// @bun
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};

// node_modules/@noble/hashes/_assert.js
var require__assert = __commonJS((exports) => {
  var number = function(n) {
    if (!Number.isSafeInteger(n) || n < 0)
      throw new Error(`Wrong positive integer: ${n}`);
  };
  var bool = function(b) {
    if (typeof b !== "boolean")
      throw new Error(`Expected boolean, not ${b}`);
  };
  var bytes = function(b, ...lengths) {
    if (!(b instanceof Uint8Array))
      throw new Error("Expected Uint8Array");
    if (lengths.length > 0 && !lengths.includes(b.length))
      throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
  };
  var hash = function(hash2) {
    if (typeof hash2 !== "function" || typeof hash2.create !== "function")
      throw new Error("Hash should be wrapped by utils.wrapConstructor");
    number(hash2.outputLen);
    number(hash2.blockLen);
  };
  var exists = function(instance, checkFinished = true) {
    if (instance.destroyed)
      throw new Error("Hash instance has been destroyed");
    if (checkFinished && instance.finished)
      throw new Error("Hash#digest() has already been called");
  };
  var output = function(out, instance) {
    bytes(out);
    const min = instance.outputLen;
    if (out.length < min) {
      throw new Error(`digestInto() expects output buffer of length at least ${min}`);
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.output = exports.exists = exports.hash = exports.bytes = exports.bool = exports.number = undefined;
  exports.number = number;
  exports.bool = bool;
  exports.bytes = bytes;
  exports.hash = hash;
  exports.exists = exists;
  exports.output = output;
  var assert = { number, bool, bytes, hash, exists, output };
  exports.default = assert;
});

// node_modules/@noble/hashes/_u64.js
var require__u64 = __commonJS((exports) => {
  var fromBig = function(n, le = false) {
    if (le)
      return { h: Number(n & U32_MASK64), l: Number(n >> _32n & U32_MASK64) };
    return { h: Number(n >> _32n & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
  };
  var split = function(lst, le = false) {
    let Ah = new Uint32Array(lst.length);
    let Al = new Uint32Array(lst.length);
    for (let i = 0;i < lst.length; i++) {
      const { h, l } = fromBig(lst[i], le);
      [Ah[i], Al[i]] = [h, l];
    }
    return [Ah, Al];
  };
  var add = function(Ah, Al, Bh, Bl) {
    const l = (Al >>> 0) + (Bl >>> 0);
    return { h: Ah + Bh + (l / 2 ** 32 | 0) | 0, l: l | 0 };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.add5L = exports.add5H = exports.add4H = exports.add4L = exports.add3H = exports.add3L = exports.add = exports.rotlBL = exports.rotlBH = exports.rotlSL = exports.rotlSH = exports.rotr32L = exports.rotr32H = exports.rotrBL = exports.rotrBH = exports.rotrSL = exports.rotrSH = exports.shrSL = exports.shrSH = exports.toBig = exports.split = exports.fromBig = undefined;
  var U32_MASK64 = BigInt(2 ** 32 - 1);
  var _32n = BigInt(32);
  exports.fromBig = fromBig;
  exports.split = split;
  var toBig = (h, l) => BigInt(h >>> 0) << _32n | BigInt(l >>> 0);
  exports.toBig = toBig;
  var shrSH = (h, _l, s) => h >>> s;
  exports.shrSH = shrSH;
  var shrSL = (h, l, s) => h << 32 - s | l >>> s;
  exports.shrSL = shrSL;
  var rotrSH = (h, l, s) => h >>> s | l << 32 - s;
  exports.rotrSH = rotrSH;
  var rotrSL = (h, l, s) => h << 32 - s | l >>> s;
  exports.rotrSL = rotrSL;
  var rotrBH = (h, l, s) => h << 64 - s | l >>> s - 32;
  exports.rotrBH = rotrBH;
  var rotrBL = (h, l, s) => h >>> s - 32 | l << 64 - s;
  exports.rotrBL = rotrBL;
  var rotr32H = (_h, l) => l;
  exports.rotr32H = rotr32H;
  var rotr32L = (h, _l) => h;
  exports.rotr32L = rotr32L;
  var rotlSH = (h, l, s) => h << s | l >>> 32 - s;
  exports.rotlSH = rotlSH;
  var rotlSL = (h, l, s) => l << s | h >>> 32 - s;
  exports.rotlSL = rotlSL;
  var rotlBH = (h, l, s) => l << s - 32 | h >>> 64 - s;
  exports.rotlBH = rotlBH;
  var rotlBL = (h, l, s) => h << s - 32 | l >>> 64 - s;
  exports.rotlBL = rotlBL;
  exports.add = add;
  var add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
  exports.add3L = add3L;
  var add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
  exports.add3H = add3H;
  var add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
  exports.add4L = add4L;
  var add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
  exports.add4H = add4H;
  var add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
  exports.add5L = add5L;
  var add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
  exports.add5H = add5H;
  var u64 = {
    fromBig,
    split,
    toBig,
    shrSH,
    shrSL,
    rotrSH,
    rotrSL,
    rotrBH,
    rotrBL,
    rotr32H,
    rotr32L,
    rotlSH,
    rotlSL,
    rotlBH,
    rotlBL,
    add,
    add3L,
    add3H,
    add4L,
    add4H,
    add5H,
    add5L
  };
  exports.default = u64;
});

// node_modules/@noble/hashes/cryptoNode.js
var require_cryptoNode = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.crypto = undefined;
  var nc = import.meta.require("crypto");
  exports.crypto = nc && typeof nc === "object" && "webcrypto" in nc ? nc.webcrypto : undefined;
});

// node_modules/@noble/hashes/utils.js
var require_utils = __commonJS((exports) => {
  var bytesToHex = function(bytes) {
    if (!u8a(bytes))
      throw new Error("Uint8Array expected");
    let hex = "";
    for (let i = 0;i < bytes.length; i++) {
      hex += hexes[bytes[i]];
    }
    return hex;
  };
  var hexToBytes = function(hex) {
    if (typeof hex !== "string")
      throw new Error("hex string expected, got " + typeof hex);
    const len = hex.length;
    if (len % 2)
      throw new Error("padded hex string expected, got unpadded hex of length " + len);
    const array = new Uint8Array(len / 2);
    for (let i = 0;i < array.length; i++) {
      const j = i * 2;
      const hexByte = hex.slice(j, j + 2);
      const byte = Number.parseInt(hexByte, 16);
      if (Number.isNaN(byte) || byte < 0)
        throw new Error("Invalid byte sequence");
      array[i] = byte;
    }
    return array;
  };
  async function asyncLoop(iters, tick, cb) {
    let ts = Date.now();
    for (let i = 0;i < iters; i++) {
      cb(i);
      const diff = Date.now() - ts;
      if (diff >= 0 && diff < tick)
        continue;
      await (0, exports.nextTick)();
      ts += diff;
    }
  }
  var utf8ToBytes = function(str) {
    if (typeof str !== "string")
      throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
    return new Uint8Array(new TextEncoder().encode(str));
  };
  var toBytes = function(data) {
    if (typeof data === "string")
      data = utf8ToBytes(data);
    if (!u8a(data))
      throw new Error(`expected Uint8Array, got ${typeof data}`);
    return data;
  };
  var concatBytes = function(...arrays) {
    const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));
    let pad = 0;
    arrays.forEach((a) => {
      if (!u8a(a))
        throw new Error("Uint8Array expected");
      r.set(a, pad);
      pad += a.length;
    });
    return r;
  };
  var checkOpts = function(defaults, opts) {
    if (opts !== undefined && toStr.call(opts) !== "[object Object]")
      throw new Error("Options should be object or undefined");
    const merged = Object.assign(defaults, opts);
    return merged;
  };
  var wrapConstructor = function(hashCons) {
    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
    const tmp = hashCons();
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = () => hashCons();
    return hashC;
  };
  var wrapConstructorWithOpts = function(hashCons) {
    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
    const tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (opts) => hashCons(opts);
    return hashC;
  };
  var wrapXOFConstructorWithOpts = function(hashCons) {
    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
    const tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (opts) => hashCons(opts);
    return hashC;
  };
  var randomBytes = function(bytesLength = 32) {
    if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === "function") {
      return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
    }
    throw new Error("crypto.getRandomValues must be defined");
  };
  /*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.randomBytes = exports.wrapXOFConstructorWithOpts = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.checkOpts = exports.Hash = exports.concatBytes = exports.toBytes = exports.utf8ToBytes = exports.asyncLoop = exports.nextTick = exports.hexToBytes = exports.bytesToHex = exports.isLE = exports.rotr = exports.createView = exports.u32 = exports.u8 = undefined;
  var crypto_1 = require_cryptoNode();
  var u8a = (a) => a instanceof Uint8Array;
  var u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
  exports.u8 = u8;
  var u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
  exports.u32 = u32;
  var createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
  exports.createView = createView;
  var rotr = (word, shift) => word << 32 - shift | word >>> shift;
  exports.rotr = rotr;
  exports.isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
  if (!exports.isLE)
    throw new Error("Non little-endian hardware is not supported");
  var hexes = Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
  exports.bytesToHex = bytesToHex;
  exports.hexToBytes = hexToBytes;
  var nextTick = async () => {
  };
  exports.nextTick = nextTick;
  exports.asyncLoop = asyncLoop;
  exports.utf8ToBytes = utf8ToBytes;
  exports.toBytes = toBytes;
  exports.concatBytes = concatBytes;

  class Hash {
    clone() {
      return this._cloneInto();
    }
  }
  exports.Hash = Hash;
  var toStr = {}.toString;
  exports.checkOpts = checkOpts;
  exports.wrapConstructor = wrapConstructor;
  exports.wrapConstructorWithOpts = wrapConstructorWithOpts;
  exports.wrapXOFConstructorWithOpts = wrapXOFConstructorWithOpts;
  exports.randomBytes = randomBytes;
});

// node_modules/@noble/hashes/sha3.js
var require_sha3 = __commonJS((exports) => {
  var keccakP = function(s, rounds = 24) {
    const B = new Uint32Array(5 * 2);
    for (let round = 24 - rounds;round < 24; round++) {
      for (let x = 0;x < 10; x++)
        B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
      for (let x = 0;x < 10; x += 2) {
        const idx1 = (x + 8) % 10;
        const idx0 = (x + 2) % 10;
        const B02 = B[idx0];
        const B1 = B[idx0 + 1];
        const Th = rotlH(B02, B1, 1) ^ B[idx1];
        const Tl = rotlL(B02, B1, 1) ^ B[idx1 + 1];
        for (let y = 0;y < 50; y += 10) {
          s[x + y] ^= Th;
          s[x + y + 1] ^= Tl;
        }
      }
      let curH = s[2];
      let curL = s[3];
      for (let t = 0;t < 24; t++) {
        const shift = SHA3_ROTL[t];
        const Th = rotlH(curH, curL, shift);
        const Tl = rotlL(curH, curL, shift);
        const PI = SHA3_PI[t];
        curH = s[PI];
        curL = s[PI + 1];
        s[PI] = Th;
        s[PI + 1] = Tl;
      }
      for (let y = 0;y < 50; y += 10) {
        for (let x = 0;x < 10; x++)
          B[x] = s[y + x];
        for (let x = 0;x < 10; x++)
          s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
      }
      s[0] ^= SHA3_IOTA_H[round];
      s[1] ^= SHA3_IOTA_L[round];
    }
    B.fill(0);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.shake256 = exports.shake128 = exports.keccak_512 = exports.keccak_384 = exports.keccak_256 = exports.keccak_224 = exports.sha3_512 = exports.sha3_384 = exports.sha3_256 = exports.sha3_224 = exports.Keccak = exports.keccakP = undefined;
  var _assert_js_1 = require__assert();
  var _u64_js_1 = require__u64();
  var utils_js_1 = require_utils();
  var [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [[], [], []];
  var _0n = BigInt(0);
  var _1n = BigInt(1);
  var _2n = BigInt(2);
  var _7n = BigInt(7);
  var _256n = BigInt(256);
  var _0x71n = BigInt(113);
  for (let round = 0, R = _1n, x = 1, y = 0;round < 24; round++) {
    [x, y] = [y, (2 * x + 3 * y) % 5];
    SHA3_PI.push(2 * (5 * y + x));
    SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);
    let t = _0n;
    for (let j = 0;j < 7; j++) {
      R = (R << _1n ^ (R >> _7n) * _0x71n) % _256n;
      if (R & _2n)
        t ^= _1n << (_1n << BigInt(j)) - _1n;
    }
    _SHA3_IOTA.push(t);
  }
  var [SHA3_IOTA_H, SHA3_IOTA_L] = (0, _u64_js_1.split)(_SHA3_IOTA, true);
  var rotlH = (h, l, s) => s > 32 ? (0, _u64_js_1.rotlBH)(h, l, s) : (0, _u64_js_1.rotlSH)(h, l, s);
  var rotlL = (h, l, s) => s > 32 ? (0, _u64_js_1.rotlBL)(h, l, s) : (0, _u64_js_1.rotlSL)(h, l, s);
  exports.keccakP = keccakP;

  class Keccak extends utils_js_1.Hash {
    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
      super();
      this.blockLen = blockLen;
      this.suffix = suffix;
      this.outputLen = outputLen;
      this.enableXOF = enableXOF;
      this.rounds = rounds;
      this.pos = 0;
      this.posOut = 0;
      this.finished = false;
      this.destroyed = false;
      (0, _assert_js_1.number)(outputLen);
      if (0 >= this.blockLen || this.blockLen >= 200)
        throw new Error("Sha3 supports only keccak-f1600 function");
      this.state = new Uint8Array(200);
      this.state32 = (0, utils_js_1.u32)(this.state);
    }
    keccak() {
      keccakP(this.state32, this.rounds);
      this.posOut = 0;
      this.pos = 0;
    }
    update(data) {
      (0, _assert_js_1.exists)(this);
      const { blockLen, state } = this;
      data = (0, utils_js_1.toBytes)(data);
      const len = data.length;
      for (let pos = 0;pos < len; ) {
        const take = Math.min(blockLen - this.pos, len - pos);
        for (let i = 0;i < take; i++)
          state[this.pos++] ^= data[pos++];
        if (this.pos === blockLen)
          this.keccak();
      }
      return this;
    }
    finish() {
      if (this.finished)
        return;
      this.finished = true;
      const { state, suffix, pos, blockLen } = this;
      state[pos] ^= suffix;
      if ((suffix & 128) !== 0 && pos === blockLen - 1)
        this.keccak();
      state[blockLen - 1] ^= 128;
      this.keccak();
    }
    writeInto(out) {
      (0, _assert_js_1.exists)(this, false);
      (0, _assert_js_1.bytes)(out);
      this.finish();
      const bufferOut = this.state;
      const { blockLen } = this;
      for (let pos = 0, len = out.length;pos < len; ) {
        if (this.posOut >= blockLen)
          this.keccak();
        const take = Math.min(blockLen - this.posOut, len - pos);
        out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
        this.posOut += take;
        pos += take;
      }
      return out;
    }
    xofInto(out) {
      if (!this.enableXOF)
        throw new Error("XOF is not possible for this instance");
      return this.writeInto(out);
    }
    xof(bytes) {
      (0, _assert_js_1.number)(bytes);
      return this.xofInto(new Uint8Array(bytes));
    }
    digestInto(out) {
      (0, _assert_js_1.output)(out, this);
      if (this.finished)
        throw new Error("digest() was already called");
      this.writeInto(out);
      this.destroy();
      return out;
    }
    digest() {
      return this.digestInto(new Uint8Array(this.outputLen));
    }
    destroy() {
      this.destroyed = true;
      this.state.fill(0);
    }
    _cloneInto(to) {
      const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
      to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
      to.state32.set(this.state32);
      to.pos = this.pos;
      to.posOut = this.posOut;
      to.finished = this.finished;
      to.rounds = rounds;
      to.suffix = suffix;
      to.outputLen = outputLen;
      to.enableXOF = enableXOF;
      to.destroyed = this.destroyed;
      return to;
    }
  }
  exports.Keccak = Keccak;
  var gen = (suffix, blockLen, outputLen) => (0, utils_js_1.wrapConstructor)(() => new Keccak(blockLen, suffix, outputLen));
  exports.sha3_224 = gen(6, 144, 224 / 8);
  exports.sha3_256 = gen(6, 136, 256 / 8);
  exports.sha3_384 = gen(6, 104, 384 / 8);
  exports.sha3_512 = gen(6, 72, 512 / 8);
  exports.keccak_224 = gen(1, 144, 224 / 8);
  exports.keccak_256 = gen(1, 136, 256 / 8);
  exports.keccak_384 = gen(1, 104, 384 / 8);
  exports.keccak_512 = gen(1, 72, 512 / 8);
  var genShake = (suffix, blockLen, outputLen) => (0, utils_js_1.wrapXOFConstructorWithOpts)((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true));
  exports.shake128 = genShake(31, 168, 128 / 8);
  exports.shake256 = genShake(31, 136, 256 / 8);
});

// node_modules/@paralleldrive/cuid2/src/index.js
var require_src = __commonJS((exports, module) => {
  var bufToBigInt = function(buf) {
    let bits = 8n;
    let value = 0n;
    for (const i of buf.values()) {
      const bi = BigInt(i);
      value = (value << bits) + bi;
    }
    return value;
  };
  var { sha3_512: sha3 } = require_sha3();
  var defaultLength = 24;
  var bigLength = 32;
  var createEntropy = (length = 4, random = Math.random) => {
    let entropy = "";
    while (entropy.length < length) {
      entropy = entropy + Math.floor(random() * 36).toString(36);
    }
    return entropy;
  };
  var hash = (input = "") => {
    return bufToBigInt(sha3(input)).toString(36).slice(1);
  };
  var alphabet = Array.from({ length: 26 }, (x, i) => String.fromCharCode(i + 97));
  var randomLetter = (random) => alphabet[Math.floor(random() * alphabet.length)];
  var createFingerprint = ({
    globalObj = typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : {},
    random = Math.random
  } = {}) => {
    const globals = Object.keys(globalObj).toString();
    const sourceString = globals.length ? globals + createEntropy(bigLength, random) : createEntropy(bigLength, random);
    return hash(sourceString).substring(0, bigLength);
  };
  var createCounter = (count) => () => {
    return count++;
  };
  var initialCountMax = 476782367;
  var init = ({
    random = Math.random,
    counter = createCounter(Math.floor(random() * initialCountMax)),
    length = defaultLength,
    fingerprint = createFingerprint({ random })
  } = {}) => {
    return function cuid2() {
      const firstLetter = randomLetter(random);
      const time = Date.now().toString(36);
      const count = counter().toString(36);
      const salt = createEntropy(length, random);
      const hashInput = `${time + salt + count + fingerprint}`;
      return `${firstLetter + hash(hashInput).substring(1, length)}`;
    };
  };
  var createId = init();
  var isCuid = (id, { minLength = 2, maxLength = bigLength } = {}) => {
    const length = id.length;
    const regex = /^[0-9a-z]+$/;
    try {
      if (typeof id === "string" && length >= minLength && length <= maxLength && regex.test(id))
        return true;
    } finally {
    }
    return false;
  };
  exports.getConstants = () => ({ defaultLength, bigLength });
  exports.init = init;
  exports.createId = createId;
  exports.bufToBigInt = bufToBigInt;
  exports.createCounter = createCounter;
  exports.createFingerprint = createFingerprint;
  exports.isCuid = isCuid;
});

// node_modules/resend/build/package.json
var require_package = __commonJS((exports, module) => {
  module.exports = {
    name: "resend",
    version: "2.0.0",
    description: "Node.js library for the Resend API",
    main: "build/src/index.js",
    typings: "build/src/index.d.ts",
    files: [
      "build/"
    ],
    engines: {
      node: ">=18"
    },
    packageManager: "yarn@3.6.4",
    scripts: {
      build: "tsc -p .",
      test: "jest",
      "test:watch": "jest --watch",
      lint: "eslint --fix --ext .ts ./src",
      "format:check": "prettier --check \"**/*.{ts,tsx}\"",
      format: "prettier --write .",
      prepublishOnly: "yarn run build"
    },
    repository: {
      type: "git",
      url: "git+https://github.com/resendlabs/resend-node.git"
    },
    author: "",
    license: "MIT",
    bugs: {
      url: "https://github.com/resendlabs/resend-node/issues"
    },
    homepage: "https://github.com/resendlabs/resend-node#readme",
    dependencies: {
      "@react-email/render": "0.0.9"
    },
    devDependencies: {
      "@types/jest": "29.5.7",
      "@types/node": "18.18.8",
      "@types/react": "18.2.33",
      "@typescript-eslint/eslint-plugin": "6.9.1",
      "@typescript-eslint/parser": "6.9.1",
      eslint: "8.52.0",
      jest: "29.7.0",
      "jest-fetch-mock": "3.0.3",
      prettier: "3.0.3",
      "ts-jest": "29.1.1",
      "ts-node": "10.9.1",
      typescript: "5.2.2"
    }
  };
});

// node_modules/resend/build/src/api-keys/api-keys.js
var require_api_keys = __commonJS((exports) => {
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ApiKeys = undefined;

  class ApiKeys {
    constructor(resend) {
      this.resend = resend;
    }
    create(payload, options = {}) {
      return __awaiter(this, undefined, undefined, function* () {
        const data = yield this.resend.post("/api-keys", payload, options);
        return data;
      });
    }
    list() {
      return __awaiter(this, undefined, undefined, function* () {
        const data = yield this.resend.get("/api-keys");
        return data;
      });
    }
    remove(id) {
      return __awaiter(this, undefined, undefined, function* () {
        const data = yield this.resend.delete(`/api-keys/${id}`);
        return data;
      });
    }
  }
  exports.ApiKeys = ApiKeys;
});

// node_modules/react/cjs/react.development.js
var require_react_development = __commonJS((exports, module) => {
  if (true) {
    (function() {
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error);
      }
      var ReactVersion = "18.2.0";
      var REACT_ELEMENT_TYPE = Symbol.for("react.element");
      var REACT_PORTAL_TYPE = Symbol.for("react.portal");
      var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
      var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
      var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
      var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
      var REACT_CONTEXT_TYPE = Symbol.for("react.context");
      var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
      var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
      var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
      var REACT_MEMO_TYPE = Symbol.for("react.memo");
      var REACT_LAZY_TYPE = Symbol.for("react.lazy");
      var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
      var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
      var FAUX_ITERATOR_SYMBOL = "@@iterator";
      function getIteratorFn(maybeIterable) {
        if (maybeIterable === null || typeof maybeIterable !== "object") {
          return null;
        }
        var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
        if (typeof maybeIterator === "function") {
          return maybeIterator;
        }
        return null;
      }
      var ReactCurrentDispatcher = {
        current: null
      };
      var ReactCurrentBatchConfig = {
        transition: null
      };
      var ReactCurrentActQueue = {
        current: null,
        isBatchingLegacy: false,
        didScheduleLegacyUpdate: false
      };
      var ReactCurrentOwner = {
        current: null
      };
      var ReactDebugCurrentFrame = {};
      var currentExtraStackFrame = null;
      function setExtraStackFrame(stack) {
        {
          currentExtraStackFrame = stack;
        }
      }
      {
        ReactDebugCurrentFrame.setExtraStackFrame = function(stack) {
          {
            currentExtraStackFrame = stack;
          }
        };
        ReactDebugCurrentFrame.getCurrentStack = null;
        ReactDebugCurrentFrame.getStackAddendum = function() {
          var stack = "";
          if (currentExtraStackFrame) {
            stack += currentExtraStackFrame;
          }
          var impl = ReactDebugCurrentFrame.getCurrentStack;
          if (impl) {
            stack += impl() || "";
          }
          return stack;
        };
      }
      var enableScopeAPI = false;
      var enableCacheElement = false;
      var enableTransitionTracing = false;
      var enableLegacyHidden = false;
      var enableDebugTracing = false;
      var ReactSharedInternals = {
        ReactCurrentDispatcher,
        ReactCurrentBatchConfig,
        ReactCurrentOwner
      };
      {
        ReactSharedInternals.ReactDebugCurrentFrame = ReactDebugCurrentFrame;
        ReactSharedInternals.ReactCurrentActQueue = ReactCurrentActQueue;
      }
      function warn(format) {
        {
          {
            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1;_key < _len; _key++) {
              args[_key - 1] = arguments[_key];
            }
            printWarning("warn", format, args);
          }
        }
      }
      function error(format) {
        {
          {
            for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1;_key2 < _len2; _key2++) {
              args[_key2 - 1] = arguments[_key2];
            }
            printWarning("error", format, args);
          }
        }
      }
      function printWarning(level, format, args) {
        {
          var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
          var stack = ReactDebugCurrentFrame2.getStackAddendum();
          if (stack !== "") {
            format += "%s";
            args = args.concat([stack]);
          }
          var argsWithFormat = args.map(function(item) {
            return String(item);
          });
          argsWithFormat.unshift("Warning: " + format);
          Function.prototype.apply.call(console[level], console, argsWithFormat);
        }
      }
      var didWarnStateUpdateForUnmountedComponent = {};
      function warnNoop(publicInstance, callerName) {
        {
          var _constructor = publicInstance.constructor;
          var componentName = _constructor && (_constructor.displayName || _constructor.name) || "ReactClass";
          var warningKey = componentName + "." + callerName;
          if (didWarnStateUpdateForUnmountedComponent[warningKey]) {
            return;
          }
          error("Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.", callerName, componentName);
          didWarnStateUpdateForUnmountedComponent[warningKey] = true;
        }
      }
      var ReactNoopUpdateQueue = {
        isMounted: function(publicInstance) {
          return false;
        },
        enqueueForceUpdate: function(publicInstance, callback, callerName) {
          warnNoop(publicInstance, "forceUpdate");
        },
        enqueueReplaceState: function(publicInstance, completeState, callback, callerName) {
          warnNoop(publicInstance, "replaceState");
        },
        enqueueSetState: function(publicInstance, partialState, callback, callerName) {
          warnNoop(publicInstance, "setState");
        }
      };
      var assign = Object.assign;
      var emptyObject = {};
      {
        Object.freeze(emptyObject);
      }
      function Component(props, context, updater) {
        this.props = props;
        this.context = context;
        this.refs = emptyObject;
        this.updater = updater || ReactNoopUpdateQueue;
      }
      Component.prototype.isReactComponent = {};
      Component.prototype.setState = function(partialState, callback) {
        if (typeof partialState !== "object" && typeof partialState !== "function" && partialState != null) {
          throw new Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
        }
        this.updater.enqueueSetState(this, partialState, callback, "setState");
      };
      Component.prototype.forceUpdate = function(callback) {
        this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
      };
      {
        var deprecatedAPIs = {
          isMounted: ["isMounted", "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."],
          replaceState: ["replaceState", "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."]
        };
        var defineDeprecationWarning = function(methodName, info) {
          Object.defineProperty(Component.prototype, methodName, {
            get: function() {
              warn("%s(...) is deprecated in plain JavaScript React classes. %s", info[0], info[1]);
              return;
            }
          });
        };
        for (var fnName in deprecatedAPIs) {
          if (deprecatedAPIs.hasOwnProperty(fnName)) {
            defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
          }
        }
      }
      function ComponentDummy() {
      }
      ComponentDummy.prototype = Component.prototype;
      function PureComponent(props, context, updater) {
        this.props = props;
        this.context = context;
        this.refs = emptyObject;
        this.updater = updater || ReactNoopUpdateQueue;
      }
      var pureComponentPrototype = PureComponent.prototype = new ComponentDummy;
      pureComponentPrototype.constructor = PureComponent;
      assign(pureComponentPrototype, Component.prototype);
      pureComponentPrototype.isPureReactComponent = true;
      function createRef() {
        var refObject = {
          current: null
        };
        {
          Object.seal(refObject);
        }
        return refObject;
      }
      var isArrayImpl = Array.isArray;
      function isArray(a) {
        return isArrayImpl(a);
      }
      function typeName(value) {
        {
          var hasToStringTag = typeof Symbol === "function" && Symbol.toStringTag;
          var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
          return type;
        }
      }
      function willCoercionThrow(value) {
        {
          try {
            testStringCoercion(value);
            return false;
          } catch (e) {
            return true;
          }
        }
      }
      function testStringCoercion(value) {
        return "" + value;
      }
      function checkKeyStringCoercion(value) {
        {
          if (willCoercionThrow(value)) {
            error("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value));
            return testStringCoercion(value);
          }
        }
      }
      function getWrappedName(outerType, innerType, wrapperName) {
        var displayName = outerType.displayName;
        if (displayName) {
          return displayName;
        }
        var functionName = innerType.displayName || innerType.name || "";
        return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
      }
      function getContextName(type) {
        return type.displayName || "Context";
      }
      function getComponentNameFromType(type) {
        if (type == null) {
          return null;
        }
        {
          if (typeof type.tag === "number") {
            error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.");
          }
        }
        if (typeof type === "function") {
          return type.displayName || type.name || null;
        }
        if (typeof type === "string") {
          return type;
        }
        switch (type) {
          case REACT_FRAGMENT_TYPE:
            return "Fragment";
          case REACT_PORTAL_TYPE:
            return "Portal";
          case REACT_PROFILER_TYPE:
            return "Profiler";
          case REACT_STRICT_MODE_TYPE:
            return "StrictMode";
          case REACT_SUSPENSE_TYPE:
            return "Suspense";
          case REACT_SUSPENSE_LIST_TYPE:
            return "SuspenseList";
        }
        if (typeof type === "object") {
          switch (type.$$typeof) {
            case REACT_CONTEXT_TYPE:
              var context = type;
              return getContextName(context) + ".Consumer";
            case REACT_PROVIDER_TYPE:
              var provider = type;
              return getContextName(provider._context) + ".Provider";
            case REACT_FORWARD_REF_TYPE:
              return getWrappedName(type, type.render, "ForwardRef");
            case REACT_MEMO_TYPE:
              var outerName = type.displayName || null;
              if (outerName !== null) {
                return outerName;
              }
              return getComponentNameFromType(type.type) || "Memo";
            case REACT_LAZY_TYPE: {
              var lazyComponent = type;
              var payload = lazyComponent._payload;
              var init2 = lazyComponent._init;
              try {
                return getComponentNameFromType(init2(payload));
              } catch (x) {
                return null;
              }
            }
          }
        }
        return null;
      }
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      var RESERVED_PROPS = {
        key: true,
        ref: true,
        __self: true,
        __source: true
      };
      var specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;
      {
        didWarnAboutStringRefs = {};
      }
      function hasValidRef(config) {
        {
          if (hasOwnProperty.call(config, "ref")) {
            var getter = Object.getOwnPropertyDescriptor(config, "ref").get;
            if (getter && getter.isReactWarning) {
              return false;
            }
          }
        }
        return config.ref !== undefined;
      }
      function hasValidKey(config) {
        {
          if (hasOwnProperty.call(config, "key")) {
            var getter = Object.getOwnPropertyDescriptor(config, "key").get;
            if (getter && getter.isReactWarning) {
              return false;
            }
          }
        }
        return config.key !== undefined;
      }
      function defineKeyPropWarningGetter(props, displayName) {
        var warnAboutAccessingKey = function() {
          {
            if (!specialPropKeyWarningShown) {
              specialPropKeyWarningShown = true;
              error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
            }
          }
        };
        warnAboutAccessingKey.isReactWarning = true;
        Object.defineProperty(props, "key", {
          get: warnAboutAccessingKey,
          configurable: true
        });
      }
      function defineRefPropWarningGetter(props, displayName) {
        var warnAboutAccessingRef = function() {
          {
            if (!specialPropRefWarningShown) {
              specialPropRefWarningShown = true;
              error("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
            }
          }
        };
        warnAboutAccessingRef.isReactWarning = true;
        Object.defineProperty(props, "ref", {
          get: warnAboutAccessingRef,
          configurable: true
        });
      }
      function warnIfStringRefCannotBeAutoConverted(config) {
        {
          if (typeof config.ref === "string" && ReactCurrentOwner.current && config.__self && ReactCurrentOwner.current.stateNode !== config.__self) {
            var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);
            if (!didWarnAboutStringRefs[componentName]) {
              error('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', componentName, config.ref);
              didWarnAboutStringRefs[componentName] = true;
            }
          }
        }
      }
      var ReactElement = function(type, key, ref, self2, source, owner, props) {
        var element = {
          $$typeof: REACT_ELEMENT_TYPE,
          type,
          key,
          ref,
          props,
          _owner: owner
        };
        {
          element._store = {};
          Object.defineProperty(element._store, "validated", {
            configurable: false,
            enumerable: false,
            writable: true,
            value: false
          });
          Object.defineProperty(element, "_self", {
            configurable: false,
            enumerable: false,
            writable: false,
            value: self2
          });
          Object.defineProperty(element, "_source", {
            configurable: false,
            enumerable: false,
            writable: false,
            value: source
          });
          if (Object.freeze) {
            Object.freeze(element.props);
            Object.freeze(element);
          }
        }
        return element;
      };
      function createElement(type, config, children) {
        var propName;
        var props = {};
        var key = null;
        var ref = null;
        var self2 = null;
        var source = null;
        if (config != null) {
          if (hasValidRef(config)) {
            ref = config.ref;
            {
              warnIfStringRefCannotBeAutoConverted(config);
            }
          }
          if (hasValidKey(config)) {
            {
              checkKeyStringCoercion(config.key);
            }
            key = "" + config.key;
          }
          self2 = config.__self === undefined ? null : config.__self;
          source = config.__source === undefined ? null : config.__source;
          for (propName in config) {
            if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
              props[propName] = config[propName];
            }
          }
        }
        var childrenLength = arguments.length - 2;
        if (childrenLength === 1) {
          props.children = children;
        } else if (childrenLength > 1) {
          var childArray = Array(childrenLength);
          for (var i = 0;i < childrenLength; i++) {
            childArray[i] = arguments[i + 2];
          }
          {
            if (Object.freeze) {
              Object.freeze(childArray);
            }
          }
          props.children = childArray;
        }
        if (type && type.defaultProps) {
          var defaultProps = type.defaultProps;
          for (propName in defaultProps) {
            if (props[propName] === undefined) {
              props[propName] = defaultProps[propName];
            }
          }
        }
        {
          if (key || ref) {
            var displayName = typeof type === "function" ? type.displayName || type.name || "Unknown" : type;
            if (key) {
              defineKeyPropWarningGetter(props, displayName);
            }
            if (ref) {
              defineRefPropWarningGetter(props, displayName);
            }
          }
        }
        return ReactElement(type, key, ref, self2, source, ReactCurrentOwner.current, props);
      }
      function cloneAndReplaceKey(oldElement, newKey) {
        var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
        return newElement;
      }
      function cloneElement(element, config, children) {
        if (element === null || element === undefined) {
          throw new Error("React.cloneElement(...): The argument must be a React element, but you passed " + element + ".");
        }
        var propName;
        var props = assign({}, element.props);
        var key = element.key;
        var ref = element.ref;
        var self2 = element._self;
        var source = element._source;
        var owner = element._owner;
        if (config != null) {
          if (hasValidRef(config)) {
            ref = config.ref;
            owner = ReactCurrentOwner.current;
          }
          if (hasValidKey(config)) {
            {
              checkKeyStringCoercion(config.key);
            }
            key = "" + config.key;
          }
          var defaultProps;
          if (element.type && element.type.defaultProps) {
            defaultProps = element.type.defaultProps;
          }
          for (propName in config) {
            if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
              if (config[propName] === undefined && defaultProps !== undefined) {
                props[propName] = defaultProps[propName];
              } else {
                props[propName] = config[propName];
              }
            }
          }
        }
        var childrenLength = arguments.length - 2;
        if (childrenLength === 1) {
          props.children = children;
        } else if (childrenLength > 1) {
          var childArray = Array(childrenLength);
          for (var i = 0;i < childrenLength; i++) {
            childArray[i] = arguments[i + 2];
          }
          props.children = childArray;
        }
        return ReactElement(element.type, key, ref, self2, source, owner, props);
      }
      function isValidElement(object) {
        return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
      }
      var SEPARATOR = ".";
      var SUBSEPARATOR = ":";
      function escape2(key) {
        var escapeRegex = /[=:]/g;
        var escaperLookup = {
          "=": "=0",
          ":": "=2"
        };
        var escapedString = key.replace(escapeRegex, function(match) {
          return escaperLookup[match];
        });
        return "$" + escapedString;
      }
      var didWarnAboutMaps = false;
      var userProvidedKeyEscapeRegex = /\/+/g;
      function escapeUserProvidedKey(text2) {
        return text2.replace(userProvidedKeyEscapeRegex, "$&/");
      }
      function getElementKey(element, index) {
        if (typeof element === "object" && element !== null && element.key != null) {
          {
            checkKeyStringCoercion(element.key);
          }
          return escape2("" + element.key);
        }
        return index.toString(36);
      }
      function mapIntoArray(children, array2, escapedPrefix, nameSoFar, callback) {
        var type = typeof children;
        if (type === "undefined" || type === "boolean") {
          children = null;
        }
        var invokeCallback = false;
        if (children === null) {
          invokeCallback = true;
        } else {
          switch (type) {
            case "string":
            case "number":
              invokeCallback = true;
              break;
            case "object":
              switch (children.$$typeof) {
                case REACT_ELEMENT_TYPE:
                case REACT_PORTAL_TYPE:
                  invokeCallback = true;
              }
          }
        }
        if (invokeCallback) {
          var _child = children;
          var mappedChild = callback(_child);
          var childKey = nameSoFar === "" ? SEPARATOR + getElementKey(_child, 0) : nameSoFar;
          if (isArray(mappedChild)) {
            var escapedChildKey = "";
            if (childKey != null) {
              escapedChildKey = escapeUserProvidedKey(childKey) + "/";
            }
            mapIntoArray(mappedChild, array2, escapedChildKey, "", function(c2) {
              return c2;
            });
          } else if (mappedChild != null) {
            if (isValidElement(mappedChild)) {
              {
                if (mappedChild.key && (!_child || _child.key !== mappedChild.key)) {
                  checkKeyStringCoercion(mappedChild.key);
                }
              }
              mappedChild = cloneAndReplaceKey(mappedChild, escapedPrefix + (mappedChild.key && (!_child || _child.key !== mappedChild.key) ? escapeUserProvidedKey("" + mappedChild.key) + "/" : "") + childKey);
            }
            array2.push(mappedChild);
          }
          return 1;
        }
        var child;
        var nextName;
        var subtreeCount = 0;
        var nextNamePrefix = nameSoFar === "" ? SEPARATOR : nameSoFar + SUBSEPARATOR;
        if (isArray(children)) {
          for (var i = 0;i < children.length; i++) {
            child = children[i];
            nextName = nextNamePrefix + getElementKey(child, i);
            subtreeCount += mapIntoArray(child, array2, escapedPrefix, nextName, callback);
          }
        } else {
          var iteratorFn = getIteratorFn(children);
          if (typeof iteratorFn === "function") {
            var iterableChildren = children;
            {
              if (iteratorFn === iterableChildren.entries) {
                if (!didWarnAboutMaps) {
                  warn("Using Maps as children is not supported. Use an array of keyed ReactElements instead.");
                }
                didWarnAboutMaps = true;
              }
            }
            var iterator = iteratorFn.call(iterableChildren);
            var step;
            var ii = 0;
            while (!(step = iterator.next()).done) {
              child = step.value;
              nextName = nextNamePrefix + getElementKey(child, ii++);
              subtreeCount += mapIntoArray(child, array2, escapedPrefix, nextName, callback);
            }
          } else if (type === "object") {
            var childrenString = String(children);
            throw new Error("Objects are not valid as a React child (found: " + (childrenString === "[object Object]" ? "object with keys {" + Object.keys(children).join(", ") + "}" : childrenString) + "). If you meant to render a collection of children, use an array instead.");
          }
        }
        return subtreeCount;
      }
      function mapChildren(children, func, context) {
        if (children == null) {
          return children;
        }
        var result2 = [];
        var count2 = 0;
        mapIntoArray(children, result2, "", "", function(child) {
          return func.call(context, child, count2++);
        });
        return result2;
      }
      function countChildren(children) {
        var n = 0;
        mapChildren(children, function() {
          n++;
        });
        return n;
      }
      function forEachChildren(children, forEachFunc, forEachContext) {
        mapChildren(children, function() {
          forEachFunc.apply(this, arguments);
        }, forEachContext);
      }
      function toArray(children) {
        return mapChildren(children, function(child) {
          return child;
        }) || [];
      }
      function onlyChild(children) {
        if (!isValidElement(children)) {
          throw new Error("React.Children.only expected to receive a single React element child.");
        }
        return children;
      }
      function createContext(defaultValue) {
        var context = {
          $$typeof: REACT_CONTEXT_TYPE,
          _currentValue: defaultValue,
          _currentValue2: defaultValue,
          _threadCount: 0,
          Provider: null,
          Consumer: null,
          _defaultValue: null,
          _globalName: null
        };
        context.Provider = {
          $$typeof: REACT_PROVIDER_TYPE,
          _context: context
        };
        var hasWarnedAboutUsingNestedContextConsumers = false;
        var hasWarnedAboutUsingConsumerProvider = false;
        var hasWarnedAboutDisplayNameOnConsumer = false;
        {
          var Consumer = {
            $$typeof: REACT_CONTEXT_TYPE,
            _context: context
          };
          Object.defineProperties(Consumer, {
            Provider: {
              get: function() {
                if (!hasWarnedAboutUsingConsumerProvider) {
                  hasWarnedAboutUsingConsumerProvider = true;
                  error("Rendering <Context.Consumer.Provider> is not supported and will be removed in a future major release. Did you mean to render <Context.Provider> instead?");
                }
                return context.Provider;
              },
              set: function(_Provider) {
                context.Provider = _Provider;
              }
            },
            _currentValue: {
              get: function() {
                return context._currentValue;
              },
              set: function(_currentValue) {
                context._currentValue = _currentValue;
              }
            },
            _currentValue2: {
              get: function() {
                return context._currentValue2;
              },
              set: function(_currentValue2) {
                context._currentValue2 = _currentValue2;
              }
            },
            _threadCount: {
              get: function() {
                return context._threadCount;
              },
              set: function(_threadCount) {
                context._threadCount = _threadCount;
              }
            },
            Consumer: {
              get: function() {
                if (!hasWarnedAboutUsingNestedContextConsumers) {
                  hasWarnedAboutUsingNestedContextConsumers = true;
                  error("Rendering <Context.Consumer.Consumer> is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?");
                }
                return context.Consumer;
              }
            },
            displayName: {
              get: function() {
                return context.displayName;
              },
              set: function(displayName) {
                if (!hasWarnedAboutDisplayNameOnConsumer) {
                  warn("Setting `displayName` on Context.Consumer has no effect. You should set it directly on the context with Context.displayName = '%s'.", displayName);
                  hasWarnedAboutDisplayNameOnConsumer = true;
                }
              }
            }
          });
          context.Consumer = Consumer;
        }
        {
          context._currentRenderer = null;
          context._currentRenderer2 = null;
        }
        return context;
      }
      var Uninitialized = -1;
      var Pending = 0;
      var Resolved = 1;
      var Rejected = 2;
      function lazyInitializer(payload) {
        if (payload._status === Uninitialized) {
          var ctor = payload._result;
          var thenable = ctor();
          thenable.then(function(moduleObject2) {
            if (payload._status === Pending || payload._status === Uninitialized) {
              var resolved = payload;
              resolved._status = Resolved;
              resolved._result = moduleObject2;
            }
          }, function(error2) {
            if (payload._status === Pending || payload._status === Uninitialized) {
              var rejected = payload;
              rejected._status = Rejected;
              rejected._result = error2;
            }
          });
          if (payload._status === Uninitialized) {
            var pending = payload;
            pending._status = Pending;
            pending._result = thenable;
          }
        }
        if (payload._status === Resolved) {
          var moduleObject = payload._result;
          {
            if (moduleObject === undefined) {
              error("lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))\n\nDid you accidentally put curly braces around the import?", moduleObject);
            }
          }
          {
            if (!("default" in moduleObject)) {
              error("lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))", moduleObject);
            }
          }
          return moduleObject.default;
        } else {
          throw payload._result;
        }
      }
      function lazy(ctor) {
        var payload = {
          _status: Uninitialized,
          _result: ctor
        };
        var lazyType2 = {
          $$typeof: REACT_LAZY_TYPE,
          _payload: payload,
          _init: lazyInitializer
        };
        {
          var defaultProps;
          var propTypes;
          Object.defineProperties(lazyType2, {
            defaultProps: {
              configurable: true,
              get: function() {
                return defaultProps;
              },
              set: function(newDefaultProps) {
                error("React.lazy(...): It is not supported to assign `defaultProps` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.");
                defaultProps = newDefaultProps;
                Object.defineProperty(lazyType2, "defaultProps", {
                  enumerable: true
                });
              }
            },
            propTypes: {
              configurable: true,
              get: function() {
                return propTypes;
              },
              set: function(newPropTypes) {
                error("React.lazy(...): It is not supported to assign `propTypes` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.");
                propTypes = newPropTypes;
                Object.defineProperty(lazyType2, "propTypes", {
                  enumerable: true
                });
              }
            }
          });
        }
        return lazyType2;
      }
      function forwardRef(render) {
        {
          if (render != null && render.$$typeof === REACT_MEMO_TYPE) {
            error("forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...)).");
          } else if (typeof render !== "function") {
            error("forwardRef requires a render function but was given %s.", render === null ? "null" : typeof render);
          } else {
            if (render.length !== 0 && render.length !== 2) {
              error("forwardRef render functions accept exactly two parameters: props and ref. %s", render.length === 1 ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined.");
            }
          }
          if (render != null) {
            if (render.defaultProps != null || render.propTypes != null) {
              error("forwardRef render functions do not support propTypes or defaultProps. Did you accidentally pass a React component?");
            }
          }
        }
        var elementType = {
          $$typeof: REACT_FORWARD_REF_TYPE,
          render
        };
        {
          var ownName;
          Object.defineProperty(elementType, "displayName", {
            enumerable: false,
            configurable: true,
            get: function() {
              return ownName;
            },
            set: function(name) {
              ownName = name;
              if (!render.name && !render.displayName) {
                render.displayName = name;
              }
            }
          });
        }
        return elementType;
      }
      var REACT_MODULE_REFERENCE;
      {
        REACT_MODULE_REFERENCE = Symbol.for("react.module.reference");
      }
      function isValidElementType(type) {
        if (typeof type === "string" || typeof type === "function") {
          return true;
        }
        if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {
          return true;
        }
        if (typeof type === "object" && type !== null) {
          if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== undefined) {
            return true;
          }
        }
        return false;
      }
      function memo(type, compare) {
        {
          if (!isValidElementType(type)) {
            error("memo: The first argument must be a component. Instead received: %s", type === null ? "null" : typeof type);
          }
        }
        var elementType = {
          $$typeof: REACT_MEMO_TYPE,
          type,
          compare: compare === undefined ? null : compare
        };
        {
          var ownName;
          Object.defineProperty(elementType, "displayName", {
            enumerable: false,
            configurable: true,
            get: function() {
              return ownName;
            },
            set: function(name) {
              ownName = name;
              if (!type.name && !type.displayName) {
                type.displayName = name;
              }
            }
          });
        }
        return elementType;
      }
      function resolveDispatcher() {
        var dispatcher = ReactCurrentDispatcher.current;
        {
          if (dispatcher === null) {
            error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.");
          }
        }
        return dispatcher;
      }
      function useContext(Context) {
        var dispatcher = resolveDispatcher();
        {
          if (Context._context !== undefined) {
            var realContext = Context._context;
            if (realContext.Consumer === Context) {
              error("Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be removed in a future major release. Did you mean to call useContext(Context) instead?");
            } else if (realContext.Provider === Context) {
              error("Calling useContext(Context.Provider) is not supported. Did you mean to call useContext(Context) instead?");
            }
          }
        }
        return dispatcher.useContext(Context);
      }
      function useState(initialState) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useState(initialState);
      }
      function useReducer(reducer, initialArg, init2) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useReducer(reducer, initialArg, init2);
      }
      function useRef(initialValue) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useRef(initialValue);
      }
      function useEffect(create, deps) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useEffect(create, deps);
      }
      function useInsertionEffect(create, deps) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useInsertionEffect(create, deps);
      }
      function useLayoutEffect(create, deps) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useLayoutEffect(create, deps);
      }
      function useCallback(callback, deps) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useCallback(callback, deps);
      }
      function useMemo(create, deps) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useMemo(create, deps);
      }
      function useImperativeHandle(ref, create, deps) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useImperativeHandle(ref, create, deps);
      }
      function useDebugValue(value, formatterFn) {
        {
          var dispatcher = resolveDispatcher();
          return dispatcher.useDebugValue(value, formatterFn);
        }
      }
      function useTransition() {
        var dispatcher = resolveDispatcher();
        return dispatcher.useTransition();
      }
      function useDeferredValue(value) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useDeferredValue(value);
      }
      function useId() {
        var dispatcher = resolveDispatcher();
        return dispatcher.useId();
      }
      function useSyncExternalStore(subscribe2, getSnapshot, getServerSnapshot) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useSyncExternalStore(subscribe2, getSnapshot, getServerSnapshot);
      }
      var disabledDepth = 0;
      var prevLog;
      var prevInfo;
      var prevWarn;
      var prevError;
      var prevGroup;
      var prevGroupCollapsed;
      var prevGroupEnd;
      function disabledLog() {
      }
      disabledLog.__reactDisabledLog = true;
      function disableLogs() {
        {
          if (disabledDepth === 0) {
            prevLog = console.log;
            prevInfo = console.info;
            prevWarn = console.warn;
            prevError = console.error;
            prevGroup = console.group;
            prevGroupCollapsed = console.groupCollapsed;
            prevGroupEnd = console.groupEnd;
            var props = {
              configurable: true,
              enumerable: true,
              value: disabledLog,
              writable: true
            };
            Object.defineProperties(console, {
              info: props,
              log: props,
              warn: props,
              error: props,
              group: props,
              groupCollapsed: props,
              groupEnd: props
            });
          }
          disabledDepth++;
        }
      }
      function reenableLogs() {
        {
          disabledDepth--;
          if (disabledDepth === 0) {
            var props = {
              configurable: true,
              enumerable: true,
              writable: true
            };
            Object.defineProperties(console, {
              log: assign({}, props, {
                value: prevLog
              }),
              info: assign({}, props, {
                value: prevInfo
              }),
              warn: assign({}, props, {
                value: prevWarn
              }),
              error: assign({}, props, {
                value: prevError
              }),
              group: assign({}, props, {
                value: prevGroup
              }),
              groupCollapsed: assign({}, props, {
                value: prevGroupCollapsed
              }),
              groupEnd: assign({}, props, {
                value: prevGroupEnd
              })
            });
          }
          if (disabledDepth < 0) {
            error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
          }
        }
      }
      var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;
      var prefix;
      function describeBuiltInComponentFrame(name, source, ownerFn) {
        {
          if (prefix === undefined) {
            try {
              throw Error();
            } catch (x) {
              var match = x.stack.trim().match(/\n( *(at )?)/);
              prefix = match && match[1] || "";
            }
          }
          return "\n" + prefix + name;
        }
      }
      var reentry = false;
      var componentFrameCache;
      {
        var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
        componentFrameCache = new PossiblyWeakMap;
      }
      function describeNativeComponentFrame(fn, construct) {
        if (!fn || reentry) {
          return "";
        }
        {
          var frame = componentFrameCache.get(fn);
          if (frame !== undefined) {
            return frame;
          }
        }
        var control;
        reentry = true;
        var previousPrepareStackTrace = Error.prepareStackTrace;
        Error.prepareStackTrace = undefined;
        var previousDispatcher;
        {
          previousDispatcher = ReactCurrentDispatcher$1.current;
          ReactCurrentDispatcher$1.current = null;
          disableLogs();
        }
        try {
          if (construct) {
            var Fake = function() {
              throw Error();
            };
            Object.defineProperty(Fake.prototype, "props", {
              set: function() {
                throw Error();
              }
            });
            if (typeof Reflect === "object" && Reflect.construct) {
              try {
                Reflect.construct(Fake, []);
              } catch (x) {
                control = x;
              }
              Reflect.construct(fn, [], Fake);
            } else {
              try {
                Fake.call();
              } catch (x) {
                control = x;
              }
              fn.call(Fake.prototype);
            }
          } else {
            try {
              throw Error();
            } catch (x) {
              control = x;
            }
            fn();
          }
        } catch (sample) {
          if (sample && control && typeof sample.stack === "string") {
            var sampleLines = sample.stack.split("\n");
            var controlLines = control.stack.split("\n");
            var s = sampleLines.length - 1;
            var c2 = controlLines.length - 1;
            while (s >= 1 && c2 >= 0 && sampleLines[s] !== controlLines[c2]) {
              c2--;
            }
            for (;s >= 1 && c2 >= 0; s--, c2--) {
              if (sampleLines[s] !== controlLines[c2]) {
                if (s !== 1 || c2 !== 1) {
                  do {
                    s--;
                    c2--;
                    if (c2 < 0 || sampleLines[s] !== controlLines[c2]) {
                      var _frame = "\n" + sampleLines[s].replace(" at new ", " at ");
                      if (fn.displayName && _frame.includes("<anonymous>")) {
                        _frame = _frame.replace("<anonymous>", fn.displayName);
                      }
                      {
                        if (typeof fn === "function") {
                          componentFrameCache.set(fn, _frame);
                        }
                      }
                      return _frame;
                    }
                  } while (s >= 1 && c2 >= 0);
                }
                break;
              }
            }
          }
        } finally {
          reentry = false;
          {
            ReactCurrentDispatcher$1.current = previousDispatcher;
            reenableLogs();
          }
          Error.prepareStackTrace = previousPrepareStackTrace;
        }
        var name = fn ? fn.displayName || fn.name : "";
        var syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
        {
          if (typeof fn === "function") {
            componentFrameCache.set(fn, syntheticFrame);
          }
        }
        return syntheticFrame;
      }
      function describeFunctionComponentFrame(fn, source, ownerFn) {
        {
          return describeNativeComponentFrame(fn, false);
        }
      }
      function shouldConstruct(Component2) {
        var prototype = Component2.prototype;
        return !!(prototype && prototype.isReactComponent);
      }
      function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
        if (type == null) {
          return "";
        }
        if (typeof type === "function") {
          {
            return describeNativeComponentFrame(type, shouldConstruct(type));
          }
        }
        if (typeof type === "string") {
          return describeBuiltInComponentFrame(type);
        }
        switch (type) {
          case REACT_SUSPENSE_TYPE:
            return describeBuiltInComponentFrame("Suspense");
          case REACT_SUSPENSE_LIST_TYPE:
            return describeBuiltInComponentFrame("SuspenseList");
        }
        if (typeof type === "object") {
          switch (type.$$typeof) {
            case REACT_FORWARD_REF_TYPE:
              return describeFunctionComponentFrame(type.render);
            case REACT_MEMO_TYPE:
              return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
            case REACT_LAZY_TYPE: {
              var lazyComponent = type;
              var payload = lazyComponent._payload;
              var init2 = lazyComponent._init;
              try {
                return describeUnknownElementTypeFrameInDEV(init2(payload), source, ownerFn);
              } catch (x) {
              }
            }
          }
        }
        return "";
      }
      var loggedTypeFailures = {};
      var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
      function setCurrentlyValidatingElement(element) {
        {
          if (element) {
            var owner = element._owner;
            var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
            ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
          } else {
            ReactDebugCurrentFrame$1.setExtraStackFrame(null);
          }
        }
      }
      function checkPropTypes(typeSpecs, values2, location, componentName, element) {
        {
          var has = Function.call.bind(hasOwnProperty);
          for (var typeSpecName in typeSpecs) {
            if (has(typeSpecs, typeSpecName)) {
              var error$1 = undefined;
              try {
                if (typeof typeSpecs[typeSpecName] !== "function") {
                  var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                  err.name = "Invariant Violation";
                  throw err;
                }
                error$1 = typeSpecs[typeSpecName](values2, typeSpecName, componentName, location, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
              } catch (ex) {
                error$1 = ex;
              }
              if (error$1 && !(error$1 instanceof Error)) {
                setCurrentlyValidatingElement(element);
                error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location, typeSpecName, typeof error$1);
                setCurrentlyValidatingElement(null);
              }
              if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                loggedTypeFailures[error$1.message] = true;
                setCurrentlyValidatingElement(element);
                error("Failed %s type: %s", location, error$1.message);
                setCurrentlyValidatingElement(null);
              }
            }
          }
        }
      }
      function setCurrentlyValidatingElement$1(element) {
        {
          if (element) {
            var owner = element._owner;
            var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
            setExtraStackFrame(stack);
          } else {
            setExtraStackFrame(null);
          }
        }
      }
      var propTypesMisspellWarningShown;
      {
        propTypesMisspellWarningShown = false;
      }
      function getDeclarationErrorAddendum() {
        if (ReactCurrentOwner.current) {
          var name = getComponentNameFromType(ReactCurrentOwner.current.type);
          if (name) {
            return "\n\nCheck the render method of `" + name + "`.";
          }
        }
        return "";
      }
      function getSourceInfoErrorAddendum(source) {
        if (source !== undefined) {
          var fileName = source.fileName.replace(/^.*[\\\/]/, "");
          var lineNumber = source.lineNumber;
          return "\n\nCheck your code at " + fileName + ":" + lineNumber + ".";
        }
        return "";
      }
      function getSourceInfoErrorAddendumForProps(elementProps) {
        if (elementProps !== null && elementProps !== undefined) {
          return getSourceInfoErrorAddendum(elementProps.__source);
        }
        return "";
      }
      var ownerHasKeyUseWarning = {};
      function getCurrentComponentErrorInfo(parentType) {
        var info = getDeclarationErrorAddendum();
        if (!info) {
          var parentName = typeof parentType === "string" ? parentType : parentType.displayName || parentType.name;
          if (parentName) {
            info = "\n\nCheck the top-level render call using <" + parentName + ">.";
          }
        }
        return info;
      }
      function validateExplicitKey(element, parentType) {
        if (!element._store || element._store.validated || element.key != null) {
          return;
        }
        element._store.validated = true;
        var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
        if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
          return;
        }
        ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
        var childOwner = "";
        if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
          childOwner = " It was passed a child from " + getComponentNameFromType(element._owner.type) + ".";
        }
        {
          setCurrentlyValidatingElement$1(element);
          error('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);
          setCurrentlyValidatingElement$1(null);
        }
      }
      function validateChildKeys(node, parentType) {
        if (typeof node !== "object") {
          return;
        }
        if (isArray(node)) {
          for (var i = 0;i < node.length; i++) {
            var child = node[i];
            if (isValidElement(child)) {
              validateExplicitKey(child, parentType);
            }
          }
        } else if (isValidElement(node)) {
          if (node._store) {
            node._store.validated = true;
          }
        } else if (node) {
          var iteratorFn = getIteratorFn(node);
          if (typeof iteratorFn === "function") {
            if (iteratorFn !== node.entries) {
              var iterator = iteratorFn.call(node);
              var step;
              while (!(step = iterator.next()).done) {
                if (isValidElement(step.value)) {
                  validateExplicitKey(step.value, parentType);
                }
              }
            }
          }
        }
      }
      function validatePropTypes(element) {
        {
          var type = element.type;
          if (type === null || type === undefined || typeof type === "string") {
            return;
          }
          var propTypes;
          if (typeof type === "function") {
            propTypes = type.propTypes;
          } else if (typeof type === "object" && (type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_MEMO_TYPE)) {
            propTypes = type.propTypes;
          } else {
            return;
          }
          if (propTypes) {
            var name = getComponentNameFromType(type);
            checkPropTypes(propTypes, element.props, "prop", name, element);
          } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {
            propTypesMisspellWarningShown = true;
            var _name = getComponentNameFromType(type);
            error("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", _name || "Unknown");
          }
          if (typeof type.getDefaultProps === "function" && !type.getDefaultProps.isReactClassApproved) {
            error("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
          }
        }
      }
      function validateFragmentProps(fragment2) {
        {
          var keys = Object.keys(fragment2.props);
          for (var i = 0;i < keys.length; i++) {
            var key = keys[i];
            if (key !== "children" && key !== "key") {
              setCurrentlyValidatingElement$1(fragment2);
              error("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", key);
              setCurrentlyValidatingElement$1(null);
              break;
            }
          }
          if (fragment2.ref !== null) {
            setCurrentlyValidatingElement$1(fragment2);
            error("Invalid attribute `ref` supplied to `React.Fragment`.");
            setCurrentlyValidatingElement$1(null);
          }
        }
      }
      function createElementWithValidation(type, props, children) {
        var validType = isValidElementType(type);
        if (!validType) {
          var info = "";
          if (type === undefined || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
            info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
          }
          var sourceInfo = getSourceInfoErrorAddendumForProps(props);
          if (sourceInfo) {
            info += sourceInfo;
          } else {
            info += getDeclarationErrorAddendum();
          }
          var typeString;
          if (type === null) {
            typeString = "null";
          } else if (isArray(type)) {
            typeString = "array";
          } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {
            typeString = "<" + (getComponentNameFromType(type.type) || "Unknown") + " />";
            info = " Did you accidentally export a JSX literal instead of a component?";
          } else {
            typeString = typeof type;
          }
          {
            error("React.createElement: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", typeString, info);
          }
        }
        var element = createElement.apply(this, arguments);
        if (element == null) {
          return element;
        }
        if (validType) {
          for (var i = 2;i < arguments.length; i++) {
            validateChildKeys(arguments[i], type);
          }
        }
        if (type === REACT_FRAGMENT_TYPE) {
          validateFragmentProps(element);
        } else {
          validatePropTypes(element);
        }
        return element;
      }
      var didWarnAboutDeprecatedCreateFactory = false;
      function createFactoryWithValidation(type) {
        var validatedFactory = createElementWithValidation.bind(null, type);
        validatedFactory.type = type;
        {
          if (!didWarnAboutDeprecatedCreateFactory) {
            didWarnAboutDeprecatedCreateFactory = true;
            warn("React.createFactory() is deprecated and will be removed in a future major release. Consider using JSX or use React.createElement() directly instead.");
          }
          Object.defineProperty(validatedFactory, "type", {
            enumerable: false,
            get: function() {
              warn("Factory.type is deprecated. Access the class directly before passing it to createFactory.");
              Object.defineProperty(this, "type", {
                value: type
              });
              return type;
            }
          });
        }
        return validatedFactory;
      }
      function cloneElementWithValidation(element, props, children) {
        var newElement = cloneElement.apply(this, arguments);
        for (var i = 2;i < arguments.length; i++) {
          validateChildKeys(arguments[i], newElement.type);
        }
        validatePropTypes(newElement);
        return newElement;
      }
      function startTransition(scope, options) {
        var prevTransition = ReactCurrentBatchConfig.transition;
        ReactCurrentBatchConfig.transition = {};
        var currentTransition = ReactCurrentBatchConfig.transition;
        {
          ReactCurrentBatchConfig.transition._updatedFibers = new Set;
        }
        try {
          scope();
        } finally {
          ReactCurrentBatchConfig.transition = prevTransition;
          {
            if (prevTransition === null && currentTransition._updatedFibers) {
              var updatedFibersCount = currentTransition._updatedFibers.size;
              if (updatedFibersCount > 10) {
                warn("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table.");
              }
              currentTransition._updatedFibers.clear();
            }
          }
        }
      }
      var didWarnAboutMessageChannel = false;
      var enqueueTaskImpl = null;
      function enqueueTask(task) {
        if (enqueueTaskImpl === null) {
          try {
            var requireString = ("require" + Math.random()).slice(0, 7);
            var nodeRequire = module && module[requireString];
            enqueueTaskImpl = nodeRequire.call(module, "timers").setImmediate;
          } catch (_err) {
            enqueueTaskImpl = function(callback) {
              {
                if (didWarnAboutMessageChannel === false) {
                  didWarnAboutMessageChannel = true;
                  if (typeof MessageChannel === "undefined") {
                    error("This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning.");
                  }
                }
              }
              var channel = new MessageChannel;
              channel.port1.onmessage = callback;
              channel.port2.postMessage(undefined);
            };
          }
        }
        return enqueueTaskImpl(task);
      }
      var actScopeDepth = 0;
      var didWarnNoAwaitAct = false;
      function act(callback) {
        {
          var prevActScopeDepth = actScopeDepth;
          actScopeDepth++;
          if (ReactCurrentActQueue.current === null) {
            ReactCurrentActQueue.current = [];
          }
          var prevIsBatchingLegacy = ReactCurrentActQueue.isBatchingLegacy;
          var result2;
          try {
            ReactCurrentActQueue.isBatchingLegacy = true;
            result2 = callback();
            if (!prevIsBatchingLegacy && ReactCurrentActQueue.didScheduleLegacyUpdate) {
              var queue3 = ReactCurrentActQueue.current;
              if (queue3 !== null) {
                ReactCurrentActQueue.didScheduleLegacyUpdate = false;
                flushActQueue(queue3);
              }
            }
          } catch (error2) {
            popActScope(prevActScopeDepth);
            throw error2;
          } finally {
            ReactCurrentActQueue.isBatchingLegacy = prevIsBatchingLegacy;
          }
          if (result2 !== null && typeof result2 === "object" && typeof result2.then === "function") {
            var thenableResult = result2;
            var wasAwaited = false;
            var thenable = {
              then: function(resolve, reject) {
                wasAwaited = true;
                thenableResult.then(function(returnValue2) {
                  popActScope(prevActScopeDepth);
                  if (actScopeDepth === 0) {
                    recursivelyFlushAsyncActWork(returnValue2, resolve, reject);
                  } else {
                    resolve(returnValue2);
                  }
                }, function(error2) {
                  popActScope(prevActScopeDepth);
                  reject(error2);
                });
              }
            };
            {
              if (!didWarnNoAwaitAct && typeof Promise !== "undefined") {
                Promise.resolve().then(function() {
                }).then(function() {
                  if (!wasAwaited) {
                    didWarnNoAwaitAct = true;
                    error("You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);");
                  }
                });
              }
            }
            return thenable;
          } else {
            var returnValue = result2;
            popActScope(prevActScopeDepth);
            if (actScopeDepth === 0) {
              var _queue = ReactCurrentActQueue.current;
              if (_queue !== null) {
                flushActQueue(_queue);
                ReactCurrentActQueue.current = null;
              }
              var _thenable = {
                then: function(resolve, reject) {
                  if (ReactCurrentActQueue.current === null) {
                    ReactCurrentActQueue.current = [];
                    recursivelyFlushAsyncActWork(returnValue, resolve, reject);
                  } else {
                    resolve(returnValue);
                  }
                }
              };
              return _thenable;
            } else {
              var _thenable2 = {
                then: function(resolve, reject) {
                  resolve(returnValue);
                }
              };
              return _thenable2;
            }
          }
        }
      }
      function popActScope(prevActScopeDepth) {
        {
          if (prevActScopeDepth !== actScopeDepth - 1) {
            error("You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. ");
          }
          actScopeDepth = prevActScopeDepth;
        }
      }
      function recursivelyFlushAsyncActWork(returnValue, resolve, reject) {
        {
          var queue3 = ReactCurrentActQueue.current;
          if (queue3 !== null) {
            try {
              flushActQueue(queue3);
              enqueueTask(function() {
                if (queue3.length === 0) {
                  ReactCurrentActQueue.current = null;
                  resolve(returnValue);
                } else {
                  recursivelyFlushAsyncActWork(returnValue, resolve, reject);
                }
              });
            } catch (error2) {
              reject(error2);
            }
          } else {
            resolve(returnValue);
          }
        }
      }
      var isFlushing = false;
      function flushActQueue(queue3) {
        {
          if (!isFlushing) {
            isFlushing = true;
            var i = 0;
            try {
              for (;i < queue3.length; i++) {
                var callback = queue3[i];
                do {
                  callback = callback(true);
                } while (callback !== null);
              }
              queue3.length = 0;
            } catch (error2) {
              queue3 = queue3.slice(i + 1);
              throw error2;
            } finally {
              isFlushing = false;
            }
          }
        }
      }
      var createElement$1 = createElementWithValidation;
      var cloneElement$1 = cloneElementWithValidation;
      var createFactory = createFactoryWithValidation;
      var Children = {
        map: mapChildren,
        forEach: forEachChildren,
        count: countChildren,
        toArray,
        only: onlyChild
      };
      exports.Children = Children;
      exports.Component = Component;
      exports.Fragment = REACT_FRAGMENT_TYPE;
      exports.Profiler = REACT_PROFILER_TYPE;
      exports.PureComponent = PureComponent;
      exports.StrictMode = REACT_STRICT_MODE_TYPE;
      exports.Suspense = REACT_SUSPENSE_TYPE;
      exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals;
      exports.cloneElement = cloneElement$1;
      exports.createContext = createContext;
      exports.createElement = createElement$1;
      exports.createFactory = createFactory;
      exports.createRef = createRef;
      exports.forwardRef = forwardRef;
      exports.isValidElement = isValidElement;
      exports.lazy = lazy;
      exports.memo = memo;
      exports.startTransition = startTransition;
      exports.unstable_act = act;
      exports.useCallback = useCallback;
      exports.useContext = useContext;
      exports.useDebugValue = useDebugValue;
      exports.useDeferredValue = useDeferredValue;
      exports.useEffect = useEffect;
      exports.useId = useId;
      exports.useImperativeHandle = useImperativeHandle;
      exports.useInsertionEffect = useInsertionEffect;
      exports.useLayoutEffect = useLayoutEffect;
      exports.useMemo = useMemo;
      exports.useReducer = useReducer;
      exports.useRef = useRef;
      exports.useState = useState;
      exports.useSyncExternalStore = useSyncExternalStore;
      exports.useTransition = useTransition;
      exports.version = ReactVersion;
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error);
      }
    })();
  }
});

// node_modules/react/index.js
var require_react = __commonJS((exports, module) => {
  if (false) {
  } else {
    module.exports = require_react_development();
  }
});

// node_modules/react-dom/cjs/react-dom-server-legacy.node.development.js
var require_react_dom_server_legacy_node_development = __commonJS((exports) => {
  var React = __toESM(require_react(), 1);
  if (true) {
    (function() {
      var stream = import.meta.require("stream");
      var ReactVersion = "18.2.0";
      var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
      function warn(format) {
        {
          {
            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1;_key < _len; _key++) {
              args[_key - 1] = arguments[_key];
            }
            printWarning("warn", format, args);
          }
        }
      }
      function error(format) {
        {
          {
            for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1;_key2 < _len2; _key2++) {
              args[_key2 - 1] = arguments[_key2];
            }
            printWarning("error", format, args);
          }
        }
      }
      function printWarning(level, format, args) {
        {
          var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
          var stack = ReactDebugCurrentFrame2.getStackAddendum();
          if (stack !== "") {
            format += "%s";
            args = args.concat([stack]);
          }
          var argsWithFormat = args.map(function(item) {
            return String(item);
          });
          argsWithFormat.unshift("Warning: " + format);
          Function.prototype.apply.call(console[level], console, argsWithFormat);
        }
      }
      function scheduleWork(callback) {
        callback();
      }
      function beginWriting(destination) {
      }
      function writeChunk(destination, chunk) {
        writeChunkAndReturn(destination, chunk);
      }
      function writeChunkAndReturn(destination, chunk) {
        return destination.push(chunk);
      }
      function completeWriting(destination) {
      }
      function close(destination) {
        destination.push(null);
      }
      function stringToChunk(content) {
        return content;
      }
      function stringToPrecomputedChunk(content) {
        return content;
      }
      function closeWithError(destination, error2) {
        destination.destroy(error2);
      }
      function typeName(value) {
        {
          var hasToStringTag = typeof Symbol === "function" && Symbol.toStringTag;
          var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
          return type;
        }
      }
      function willCoercionThrow(value) {
        {
          try {
            testStringCoercion(value);
            return false;
          } catch (e) {
            return true;
          }
        }
      }
      function testStringCoercion(value) {
        return "" + value;
      }
      function checkAttributeStringCoercion(value, attributeName) {
        {
          if (willCoercionThrow(value)) {
            error("The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before before using it here.", attributeName, typeName(value));
            return testStringCoercion(value);
          }
        }
      }
      function checkCSSPropertyStringCoercion(value, propName) {
        {
          if (willCoercionThrow(value)) {
            error("The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before before using it here.", propName, typeName(value));
            return testStringCoercion(value);
          }
        }
      }
      function checkHtmlStringCoercion(value) {
        {
          if (willCoercionThrow(value)) {
            error("The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value));
            return testStringCoercion(value);
          }
        }
      }
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      var RESERVED = 0;
      var STRING = 1;
      var BOOLEANISH_STRING = 2;
      var BOOLEAN = 3;
      var OVERLOADED_BOOLEAN = 4;
      var NUMERIC = 5;
      var POSITIVE_NUMERIC = 6;
      var ATTRIBUTE_NAME_START_CHAR = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
      var ATTRIBUTE_NAME_CHAR = ATTRIBUTE_NAME_START_CHAR + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
      var VALID_ATTRIBUTE_NAME_REGEX = new RegExp("^[" + ATTRIBUTE_NAME_START_CHAR + "][" + ATTRIBUTE_NAME_CHAR + "]*$");
      var illegalAttributeNameCache = {};
      var validatedAttributeNameCache = {};
      function isAttributeNameSafe(attributeName) {
        if (hasOwnProperty.call(validatedAttributeNameCache, attributeName)) {
          return true;
        }
        if (hasOwnProperty.call(illegalAttributeNameCache, attributeName)) {
          return false;
        }
        if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
          validatedAttributeNameCache[attributeName] = true;
          return true;
        }
        illegalAttributeNameCache[attributeName] = true;
        {
          error("Invalid attribute name: `%s`", attributeName);
        }
        return false;
      }
      function shouldRemoveAttributeWithWarning(name, value, propertyInfo, isCustomComponentTag) {
        if (propertyInfo !== null && propertyInfo.type === RESERVED) {
          return false;
        }
        switch (typeof value) {
          case "function":
          case "symbol":
            return true;
          case "boolean": {
            if (isCustomComponentTag) {
              return false;
            }
            if (propertyInfo !== null) {
              return !propertyInfo.acceptsBooleans;
            } else {
              var prefix2 = name.toLowerCase().slice(0, 5);
              return prefix2 !== "data-" && prefix2 !== "aria-";
            }
          }
          default:
            return false;
        }
      }
      function getPropertyInfo(name) {
        return properties.hasOwnProperty(name) ? properties[name] : null;
      }
      function PropertyInfoRecord(name, type, mustUseProperty, attributeName, attributeNamespace, sanitizeURL2, removeEmptyString) {
        this.acceptsBooleans = type === BOOLEANISH_STRING || type === BOOLEAN || type === OVERLOADED_BOOLEAN;
        this.attributeName = attributeName;
        this.attributeNamespace = attributeNamespace;
        this.mustUseProperty = mustUseProperty;
        this.propertyName = name;
        this.type = type;
        this.sanitizeURL = sanitizeURL2;
        this.removeEmptyString = removeEmptyString;
      }
      var properties = {};
      var reservedProps = [
        "children",
        "dangerouslySetInnerHTML",
        "defaultValue",
        "defaultChecked",
        "innerHTML",
        "suppressContentEditableWarning",
        "suppressHydrationWarning",
        "style"
      ];
      reservedProps.forEach(function(name) {
        properties[name] = new PropertyInfoRecord(name, RESERVED, false, name, null, false, false);
      });
      [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(_ref) {
        var name = _ref[0], attributeName = _ref[1];
        properties[name] = new PropertyInfoRecord(name, STRING, false, attributeName, null, false, false);
      });
      ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(name) {
        properties[name] = new PropertyInfoRecord(name, BOOLEANISH_STRING, false, name.toLowerCase(), null, false, false);
      });
      ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(name) {
        properties[name] = new PropertyInfoRecord(name, BOOLEANISH_STRING, false, name, null, false, false);
      });
      [
        "allowFullScreen",
        "async",
        "autoFocus",
        "autoPlay",
        "controls",
        "default",
        "defer",
        "disabled",
        "disablePictureInPicture",
        "disableRemotePlayback",
        "formNoValidate",
        "hidden",
        "loop",
        "noModule",
        "noValidate",
        "open",
        "playsInline",
        "readOnly",
        "required",
        "reversed",
        "scoped",
        "seamless",
        "itemScope"
      ].forEach(function(name) {
        properties[name] = new PropertyInfoRecord(name, BOOLEAN, false, name.toLowerCase(), null, false, false);
      });
      [
        "checked",
        "multiple",
        "muted",
        "selected"
      ].forEach(function(name) {
        properties[name] = new PropertyInfoRecord(name, BOOLEAN, true, name, null, false, false);
      });
      [
        "capture",
        "download"
      ].forEach(function(name) {
        properties[name] = new PropertyInfoRecord(name, OVERLOADED_BOOLEAN, false, name, null, false, false);
      });
      [
        "cols",
        "rows",
        "size",
        "span"
      ].forEach(function(name) {
        properties[name] = new PropertyInfoRecord(name, POSITIVE_NUMERIC, false, name, null, false, false);
      });
      ["rowSpan", "start"].forEach(function(name) {
        properties[name] = new PropertyInfoRecord(name, NUMERIC, false, name.toLowerCase(), null, false, false);
      });
      var CAMELIZE = /[\-\:]([a-z])/g;
      var capitalize = function(token) {
        return token[1].toUpperCase();
      };
      [
        "accent-height",
        "alignment-baseline",
        "arabic-form",
        "baseline-shift",
        "cap-height",
        "clip-path",
        "clip-rule",
        "color-interpolation",
        "color-interpolation-filters",
        "color-profile",
        "color-rendering",
        "dominant-baseline",
        "enable-background",
        "fill-opacity",
        "fill-rule",
        "flood-color",
        "flood-opacity",
        "font-family",
        "font-size",
        "font-size-adjust",
        "font-stretch",
        "font-style",
        "font-variant",
        "font-weight",
        "glyph-name",
        "glyph-orientation-horizontal",
        "glyph-orientation-vertical",
        "horiz-adv-x",
        "horiz-origin-x",
        "image-rendering",
        "letter-spacing",
        "lighting-color",
        "marker-end",
        "marker-mid",
        "marker-start",
        "overline-position",
        "overline-thickness",
        "paint-order",
        "panose-1",
        "pointer-events",
        "rendering-intent",
        "shape-rendering",
        "stop-color",
        "stop-opacity",
        "strikethrough-position",
        "strikethrough-thickness",
        "stroke-dasharray",
        "stroke-dashoffset",
        "stroke-linecap",
        "stroke-linejoin",
        "stroke-miterlimit",
        "stroke-opacity",
        "stroke-width",
        "text-anchor",
        "text-decoration",
        "text-rendering",
        "underline-position",
        "underline-thickness",
        "unicode-bidi",
        "unicode-range",
        "units-per-em",
        "v-alphabetic",
        "v-hanging",
        "v-ideographic",
        "v-mathematical",
        "vector-effect",
        "vert-adv-y",
        "vert-origin-x",
        "vert-origin-y",
        "word-spacing",
        "writing-mode",
        "xmlns:xlink",
        "x-height"
      ].forEach(function(attributeName) {
        var name = attributeName.replace(CAMELIZE, capitalize);
        properties[name] = new PropertyInfoRecord(name, STRING, false, attributeName, null, false, false);
      });
      [
        "xlink:actuate",
        "xlink:arcrole",
        "xlink:role",
        "xlink:show",
        "xlink:title",
        "xlink:type"
      ].forEach(function(attributeName) {
        var name = attributeName.replace(CAMELIZE, capitalize);
        properties[name] = new PropertyInfoRecord(name, STRING, false, attributeName, "http://www.w3.org/1999/xlink", false, false);
      });
      [
        "xml:base",
        "xml:lang",
        "xml:space"
      ].forEach(function(attributeName) {
        var name = attributeName.replace(CAMELIZE, capitalize);
        properties[name] = new PropertyInfoRecord(name, STRING, false, attributeName, "http://www.w3.org/XML/1998/namespace", false, false);
      });
      ["tabIndex", "crossOrigin"].forEach(function(attributeName) {
        properties[attributeName] = new PropertyInfoRecord(attributeName, STRING, false, attributeName.toLowerCase(), null, false, false);
      });
      var xlinkHref = "xlinkHref";
      properties[xlinkHref] = new PropertyInfoRecord("xlinkHref", STRING, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
      ["src", "href", "action", "formAction"].forEach(function(attributeName) {
        properties[attributeName] = new PropertyInfoRecord(attributeName, STRING, false, attributeName.toLowerCase(), null, true, true);
      });
      var isUnitlessNumber = {
        animationIterationCount: true,
        aspectRatio: true,
        borderImageOutset: true,
        borderImageSlice: true,
        borderImageWidth: true,
        boxFlex: true,
        boxFlexGroup: true,
        boxOrdinalGroup: true,
        columnCount: true,
        columns: true,
        flex: true,
        flexGrow: true,
        flexPositive: true,
        flexShrink: true,
        flexNegative: true,
        flexOrder: true,
        gridArea: true,
        gridRow: true,
        gridRowEnd: true,
        gridRowSpan: true,
        gridRowStart: true,
        gridColumn: true,
        gridColumnEnd: true,
        gridColumnSpan: true,
        gridColumnStart: true,
        fontWeight: true,
        lineClamp: true,
        lineHeight: true,
        opacity: true,
        order: true,
        orphans: true,
        tabSize: true,
        widows: true,
        zIndex: true,
        zoom: true,
        fillOpacity: true,
        floodOpacity: true,
        stopOpacity: true,
        strokeDasharray: true,
        strokeDashoffset: true,
        strokeMiterlimit: true,
        strokeOpacity: true,
        strokeWidth: true
      };
      function prefixKey(prefix2, key) {
        return prefix2 + key.charAt(0).toUpperCase() + key.substring(1);
      }
      var prefixes = ["Webkit", "ms", "Moz", "O"];
      Object.keys(isUnitlessNumber).forEach(function(prop) {
        prefixes.forEach(function(prefix2) {
          isUnitlessNumber[prefixKey(prefix2, prop)] = isUnitlessNumber[prop];
        });
      });
      var hasReadOnlyValue = {
        button: true,
        checkbox: true,
        image: true,
        hidden: true,
        radio: true,
        reset: true,
        submit: true
      };
      function checkControlledValueProps(tagName, props) {
        {
          if (!(hasReadOnlyValue[props.type] || props.onChange || props.onInput || props.readOnly || props.disabled || props.value == null)) {
            error("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`.");
          }
          if (!(props.onChange || props.readOnly || props.disabled || props.checked == null)) {
            error("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
          }
        }
      }
      function isCustomComponent(tagName, props) {
        if (tagName.indexOf("-") === -1) {
          return typeof props.is === "string";
        }
        switch (tagName) {
          case "annotation-xml":
          case "color-profile":
          case "font-face":
          case "font-face-src":
          case "font-face-uri":
          case "font-face-format":
          case "font-face-name":
          case "missing-glyph":
            return false;
          default:
            return true;
        }
      }
      var ariaProperties = {
        "aria-current": 0,
        "aria-description": 0,
        "aria-details": 0,
        "aria-disabled": 0,
        "aria-hidden": 0,
        "aria-invalid": 0,
        "aria-keyshortcuts": 0,
        "aria-label": 0,
        "aria-roledescription": 0,
        "aria-autocomplete": 0,
        "aria-checked": 0,
        "aria-expanded": 0,
        "aria-haspopup": 0,
        "aria-level": 0,
        "aria-modal": 0,
        "aria-multiline": 0,
        "aria-multiselectable": 0,
        "aria-orientation": 0,
        "aria-placeholder": 0,
        "aria-pressed": 0,
        "aria-readonly": 0,
        "aria-required": 0,
        "aria-selected": 0,
        "aria-sort": 0,
        "aria-valuemax": 0,
        "aria-valuemin": 0,
        "aria-valuenow": 0,
        "aria-valuetext": 0,
        "aria-atomic": 0,
        "aria-busy": 0,
        "aria-live": 0,
        "aria-relevant": 0,
        "aria-dropeffect": 0,
        "aria-grabbed": 0,
        "aria-activedescendant": 0,
        "aria-colcount": 0,
        "aria-colindex": 0,
        "aria-colspan": 0,
        "aria-controls": 0,
        "aria-describedby": 0,
        "aria-errormessage": 0,
        "aria-flowto": 0,
        "aria-labelledby": 0,
        "aria-owns": 0,
        "aria-posinset": 0,
        "aria-rowcount": 0,
        "aria-rowindex": 0,
        "aria-rowspan": 0,
        "aria-setsize": 0
      };
      var warnedProperties = {};
      var rARIA = new RegExp("^(aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$");
      var rARIACamel = new RegExp("^(aria)[A-Z][" + ATTRIBUTE_NAME_CHAR + "]*$");
      function validateProperty(tagName, name) {
        {
          if (hasOwnProperty.call(warnedProperties, name) && warnedProperties[name]) {
            return true;
          }
          if (rARIACamel.test(name)) {
            var ariaName = "aria-" + name.slice(4).toLowerCase();
            var correctName = ariaProperties.hasOwnProperty(ariaName) ? ariaName : null;
            if (correctName == null) {
              error("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", name);
              warnedProperties[name] = true;
              return true;
            }
            if (name !== correctName) {
              error("Invalid ARIA attribute `%s`. Did you mean `%s`?", name, correctName);
              warnedProperties[name] = true;
              return true;
            }
          }
          if (rARIA.test(name)) {
            var lowerCasedName = name.toLowerCase();
            var standardName = ariaProperties.hasOwnProperty(lowerCasedName) ? lowerCasedName : null;
            if (standardName == null) {
              warnedProperties[name] = true;
              return false;
            }
            if (name !== standardName) {
              error("Unknown ARIA attribute `%s`. Did you mean `%s`?", name, standardName);
              warnedProperties[name] = true;
              return true;
            }
          }
        }
        return true;
      }
      function warnInvalidARIAProps(type, props) {
        {
          var invalidProps = [];
          for (var key in props) {
            var isValid2 = validateProperty(type, key);
            if (!isValid2) {
              invalidProps.push(key);
            }
          }
          var unknownPropString = invalidProps.map(function(prop) {
            return "`" + prop + "`";
          }).join(", ");
          if (invalidProps.length === 1) {
            error("Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type);
          } else if (invalidProps.length > 1) {
            error("Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type);
          }
        }
      }
      function validateProperties(type, props) {
        if (isCustomComponent(type, props)) {
          return;
        }
        warnInvalidARIAProps(type, props);
      }
      var didWarnValueNull = false;
      function validateProperties$1(type, props) {
        {
          if (type !== "input" && type !== "textarea" && type !== "select") {
            return;
          }
          if (props != null && props.value === null && !didWarnValueNull) {
            didWarnValueNull = true;
            if (type === "select" && props.multiple) {
              error("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", type);
            } else {
              error("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", type);
            }
          }
        }
      }
      var possibleStandardNames = {
        accept: "accept",
        acceptcharset: "acceptCharset",
        "accept-charset": "acceptCharset",
        accesskey: "accessKey",
        action: "action",
        allowfullscreen: "allowFullScreen",
        alt: "alt",
        as: "as",
        async: "async",
        autocapitalize: "autoCapitalize",
        autocomplete: "autoComplete",
        autocorrect: "autoCorrect",
        autofocus: "autoFocus",
        autoplay: "autoPlay",
        autosave: "autoSave",
        capture: "capture",
        cellpadding: "cellPadding",
        cellspacing: "cellSpacing",
        challenge: "challenge",
        charset: "charSet",
        checked: "checked",
        children: "children",
        cite: "cite",
        class: "className",
        classid: "classID",
        classname: "className",
        cols: "cols",
        colspan: "colSpan",
        content: "content",
        contenteditable: "contentEditable",
        contextmenu: "contextMenu",
        controls: "controls",
        controlslist: "controlsList",
        coords: "coords",
        crossorigin: "crossOrigin",
        dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
        data: "data",
        datetime: "dateTime",
        default: "default",
        defaultchecked: "defaultChecked",
        defaultvalue: "defaultValue",
        defer: "defer",
        dir: "dir",
        disabled: "disabled",
        disablepictureinpicture: "disablePictureInPicture",
        disableremoteplayback: "disableRemotePlayback",
        download: "download",
        draggable: "draggable",
        enctype: "encType",
        enterkeyhint: "enterKeyHint",
        for: "htmlFor",
        form: "form",
        formmethod: "formMethod",
        formaction: "formAction",
        formenctype: "formEncType",
        formnovalidate: "formNoValidate",
        formtarget: "formTarget",
        frameborder: "frameBorder",
        headers: "headers",
        height: "height",
        hidden: "hidden",
        high: "high",
        href: "href",
        hreflang: "hrefLang",
        htmlfor: "htmlFor",
        httpequiv: "httpEquiv",
        "http-equiv": "httpEquiv",
        icon: "icon",
        id: "id",
        imagesizes: "imageSizes",
        imagesrcset: "imageSrcSet",
        innerhtml: "innerHTML",
        inputmode: "inputMode",
        integrity: "integrity",
        is: "is",
        itemid: "itemID",
        itemprop: "itemProp",
        itemref: "itemRef",
        itemscope: "itemScope",
        itemtype: "itemType",
        keyparams: "keyParams",
        keytype: "keyType",
        kind: "kind",
        label: "label",
        lang: "lang",
        list: "list",
        loop: "loop",
        low: "low",
        manifest: "manifest",
        marginwidth: "marginWidth",
        marginheight: "marginHeight",
        max: "max",
        maxlength: "maxLength",
        media: "media",
        mediagroup: "mediaGroup",
        method: "method",
        min: "min",
        minlength: "minLength",
        multiple: "multiple",
        muted: "muted",
        name: "name",
        nomodule: "noModule",
        nonce: "nonce",
        novalidate: "noValidate",
        open: "open",
        optimum: "optimum",
        pattern: "pattern",
        placeholder: "placeholder",
        playsinline: "playsInline",
        poster: "poster",
        preload: "preload",
        profile: "profile",
        radiogroup: "radioGroup",
        readonly: "readOnly",
        referrerpolicy: "referrerPolicy",
        rel: "rel",
        required: "required",
        reversed: "reversed",
        role: "role",
        rows: "rows",
        rowspan: "rowSpan",
        sandbox: "sandbox",
        scope: "scope",
        scoped: "scoped",
        scrolling: "scrolling",
        seamless: "seamless",
        selected: "selected",
        shape: "shape",
        size: "size",
        sizes: "sizes",
        span: "span",
        spellcheck: "spellCheck",
        src: "src",
        srcdoc: "srcDoc",
        srclang: "srcLang",
        srcset: "srcSet",
        start: "start",
        step: "step",
        style: "style",
        summary: "summary",
        tabindex: "tabIndex",
        target: "target",
        title: "title",
        type: "type",
        usemap: "useMap",
        value: "value",
        width: "width",
        wmode: "wmode",
        wrap: "wrap",
        about: "about",
        accentheight: "accentHeight",
        "accent-height": "accentHeight",
        accumulate: "accumulate",
        additive: "additive",
        alignmentbaseline: "alignmentBaseline",
        "alignment-baseline": "alignmentBaseline",
        allowreorder: "allowReorder",
        alphabetic: "alphabetic",
        amplitude: "amplitude",
        arabicform: "arabicForm",
        "arabic-form": "arabicForm",
        ascent: "ascent",
        attributename: "attributeName",
        attributetype: "attributeType",
        autoreverse: "autoReverse",
        azimuth: "azimuth",
        basefrequency: "baseFrequency",
        baselineshift: "baselineShift",
        "baseline-shift": "baselineShift",
        baseprofile: "baseProfile",
        bbox: "bbox",
        begin: "begin",
        bias: "bias",
        by: "by",
        calcmode: "calcMode",
        capheight: "capHeight",
        "cap-height": "capHeight",
        clip: "clip",
        clippath: "clipPath",
        "clip-path": "clipPath",
        clippathunits: "clipPathUnits",
        cliprule: "clipRule",
        "clip-rule": "clipRule",
        color: "color",
        colorinterpolation: "colorInterpolation",
        "color-interpolation": "colorInterpolation",
        colorinterpolationfilters: "colorInterpolationFilters",
        "color-interpolation-filters": "colorInterpolationFilters",
        colorprofile: "colorProfile",
        "color-profile": "colorProfile",
        colorrendering: "colorRendering",
        "color-rendering": "colorRendering",
        contentscripttype: "contentScriptType",
        contentstyletype: "contentStyleType",
        cursor: "cursor",
        cx: "cx",
        cy: "cy",
        d: "d",
        datatype: "datatype",
        decelerate: "decelerate",
        descent: "descent",
        diffuseconstant: "diffuseConstant",
        direction: "direction",
        display: "display",
        divisor: "divisor",
        dominantbaseline: "dominantBaseline",
        "dominant-baseline": "dominantBaseline",
        dur: "dur",
        dx: "dx",
        dy: "dy",
        edgemode: "edgeMode",
        elevation: "elevation",
        enablebackground: "enableBackground",
        "enable-background": "enableBackground",
        end: "end",
        exponent: "exponent",
        externalresourcesrequired: "externalResourcesRequired",
        fill: "fill",
        fillopacity: "fillOpacity",
        "fill-opacity": "fillOpacity",
        fillrule: "fillRule",
        "fill-rule": "fillRule",
        filter: "filter",
        filterres: "filterRes",
        filterunits: "filterUnits",
        floodopacity: "floodOpacity",
        "flood-opacity": "floodOpacity",
        floodcolor: "floodColor",
        "flood-color": "floodColor",
        focusable: "focusable",
        fontfamily: "fontFamily",
        "font-family": "fontFamily",
        fontsize: "fontSize",
        "font-size": "fontSize",
        fontsizeadjust: "fontSizeAdjust",
        "font-size-adjust": "fontSizeAdjust",
        fontstretch: "fontStretch",
        "font-stretch": "fontStretch",
        fontstyle: "fontStyle",
        "font-style": "fontStyle",
        fontvariant: "fontVariant",
        "font-variant": "fontVariant",
        fontweight: "fontWeight",
        "font-weight": "fontWeight",
        format: "format",
        from: "from",
        fx: "fx",
        fy: "fy",
        g1: "g1",
        g2: "g2",
        glyphname: "glyphName",
        "glyph-name": "glyphName",
        glyphorientationhorizontal: "glyphOrientationHorizontal",
        "glyph-orientation-horizontal": "glyphOrientationHorizontal",
        glyphorientationvertical: "glyphOrientationVertical",
        "glyph-orientation-vertical": "glyphOrientationVertical",
        glyphref: "glyphRef",
        gradienttransform: "gradientTransform",
        gradientunits: "gradientUnits",
        hanging: "hanging",
        horizadvx: "horizAdvX",
        "horiz-adv-x": "horizAdvX",
        horizoriginx: "horizOriginX",
        "horiz-origin-x": "horizOriginX",
        ideographic: "ideographic",
        imagerendering: "imageRendering",
        "image-rendering": "imageRendering",
        in2: "in2",
        in: "in",
        inlist: "inlist",
        intercept: "intercept",
        k1: "k1",
        k2: "k2",
        k3: "k3",
        k4: "k4",
        k: "k",
        kernelmatrix: "kernelMatrix",
        kernelunitlength: "kernelUnitLength",
        kerning: "kerning",
        keypoints: "keyPoints",
        keysplines: "keySplines",
        keytimes: "keyTimes",
        lengthadjust: "lengthAdjust",
        letterspacing: "letterSpacing",
        "letter-spacing": "letterSpacing",
        lightingcolor: "lightingColor",
        "lighting-color": "lightingColor",
        limitingconeangle: "limitingConeAngle",
        local: "local",
        markerend: "markerEnd",
        "marker-end": "markerEnd",
        markerheight: "markerHeight",
        markermid: "markerMid",
        "marker-mid": "markerMid",
        markerstart: "markerStart",
        "marker-start": "markerStart",
        markerunits: "markerUnits",
        markerwidth: "markerWidth",
        mask: "mask",
        maskcontentunits: "maskContentUnits",
        maskunits: "maskUnits",
        mathematical: "mathematical",
        mode: "mode",
        numoctaves: "numOctaves",
        offset: "offset",
        opacity: "opacity",
        operator: "operator",
        order: "order",
        orient: "orient",
        orientation: "orientation",
        origin: "origin",
        overflow: "overflow",
        overlineposition: "overlinePosition",
        "overline-position": "overlinePosition",
        overlinethickness: "overlineThickness",
        "overline-thickness": "overlineThickness",
        paintorder: "paintOrder",
        "paint-order": "paintOrder",
        panose1: "panose1",
        "panose-1": "panose1",
        pathlength: "pathLength",
        patterncontentunits: "patternContentUnits",
        patterntransform: "patternTransform",
        patternunits: "patternUnits",
        pointerevents: "pointerEvents",
        "pointer-events": "pointerEvents",
        points: "points",
        pointsatx: "pointsAtX",
        pointsaty: "pointsAtY",
        pointsatz: "pointsAtZ",
        prefix: "prefix",
        preservealpha: "preserveAlpha",
        preserveaspectratio: "preserveAspectRatio",
        primitiveunits: "primitiveUnits",
        property: "property",
        r: "r",
        radius: "radius",
        refx: "refX",
        refy: "refY",
        renderingintent: "renderingIntent",
        "rendering-intent": "renderingIntent",
        repeatcount: "repeatCount",
        repeatdur: "repeatDur",
        requiredextensions: "requiredExtensions",
        requiredfeatures: "requiredFeatures",
        resource: "resource",
        restart: "restart",
        result: "result",
        results: "results",
        rotate: "rotate",
        rx: "rx",
        ry: "ry",
        scale: "scale",
        security: "security",
        seed: "seed",
        shaperendering: "shapeRendering",
        "shape-rendering": "shapeRendering",
        slope: "slope",
        spacing: "spacing",
        specularconstant: "specularConstant",
        specularexponent: "specularExponent",
        speed: "speed",
        spreadmethod: "spreadMethod",
        startoffset: "startOffset",
        stddeviation: "stdDeviation",
        stemh: "stemh",
        stemv: "stemv",
        stitchtiles: "stitchTiles",
        stopcolor: "stopColor",
        "stop-color": "stopColor",
        stopopacity: "stopOpacity",
        "stop-opacity": "stopOpacity",
        strikethroughposition: "strikethroughPosition",
        "strikethrough-position": "strikethroughPosition",
        strikethroughthickness: "strikethroughThickness",
        "strikethrough-thickness": "strikethroughThickness",
        string: "string",
        stroke: "stroke",
        strokedasharray: "strokeDasharray",
        "stroke-dasharray": "strokeDasharray",
        strokedashoffset: "strokeDashoffset",
        "stroke-dashoffset": "strokeDashoffset",
        strokelinecap: "strokeLinecap",
        "stroke-linecap": "strokeLinecap",
        strokelinejoin: "strokeLinejoin",
        "stroke-linejoin": "strokeLinejoin",
        strokemiterlimit: "strokeMiterlimit",
        "stroke-miterlimit": "strokeMiterlimit",
        strokewidth: "strokeWidth",
        "stroke-width": "strokeWidth",
        strokeopacity: "strokeOpacity",
        "stroke-opacity": "strokeOpacity",
        suppresscontenteditablewarning: "suppressContentEditableWarning",
        suppresshydrationwarning: "suppressHydrationWarning",
        surfacescale: "surfaceScale",
        systemlanguage: "systemLanguage",
        tablevalues: "tableValues",
        targetx: "targetX",
        targety: "targetY",
        textanchor: "textAnchor",
        "text-anchor": "textAnchor",
        textdecoration: "textDecoration",
        "text-decoration": "textDecoration",
        textlength: "textLength",
        textrendering: "textRendering",
        "text-rendering": "textRendering",
        to: "to",
        transform: "transform",
        typeof: "typeof",
        u1: "u1",
        u2: "u2",
        underlineposition: "underlinePosition",
        "underline-position": "underlinePosition",
        underlinethickness: "underlineThickness",
        "underline-thickness": "underlineThickness",
        unicode: "unicode",
        unicodebidi: "unicodeBidi",
        "unicode-bidi": "unicodeBidi",
        unicoderange: "unicodeRange",
        "unicode-range": "unicodeRange",
        unitsperem: "unitsPerEm",
        "units-per-em": "unitsPerEm",
        unselectable: "unselectable",
        valphabetic: "vAlphabetic",
        "v-alphabetic": "vAlphabetic",
        values: "values",
        vectoreffect: "vectorEffect",
        "vector-effect": "vectorEffect",
        version: "version",
        vertadvy: "vertAdvY",
        "vert-adv-y": "vertAdvY",
        vertoriginx: "vertOriginX",
        "vert-origin-x": "vertOriginX",
        vertoriginy: "vertOriginY",
        "vert-origin-y": "vertOriginY",
        vhanging: "vHanging",
        "v-hanging": "vHanging",
        videographic: "vIdeographic",
        "v-ideographic": "vIdeographic",
        viewbox: "viewBox",
        viewtarget: "viewTarget",
        visibility: "visibility",
        vmathematical: "vMathematical",
        "v-mathematical": "vMathematical",
        vocab: "vocab",
        widths: "widths",
        wordspacing: "wordSpacing",
        "word-spacing": "wordSpacing",
        writingmode: "writingMode",
        "writing-mode": "writingMode",
        x1: "x1",
        x2: "x2",
        x: "x",
        xchannelselector: "xChannelSelector",
        xheight: "xHeight",
        "x-height": "xHeight",
        xlinkactuate: "xlinkActuate",
        "xlink:actuate": "xlinkActuate",
        xlinkarcrole: "xlinkArcrole",
        "xlink:arcrole": "xlinkArcrole",
        xlinkhref: "xlinkHref",
        "xlink:href": "xlinkHref",
        xlinkrole: "xlinkRole",
        "xlink:role": "xlinkRole",
        xlinkshow: "xlinkShow",
        "xlink:show": "xlinkShow",
        xlinktitle: "xlinkTitle",
        "xlink:title": "xlinkTitle",
        xlinktype: "xlinkType",
        "xlink:type": "xlinkType",
        xmlbase: "xmlBase",
        "xml:base": "xmlBase",
        xmllang: "xmlLang",
        "xml:lang": "xmlLang",
        xmlns: "xmlns",
        "xml:space": "xmlSpace",
        xmlnsxlink: "xmlnsXlink",
        "xmlns:xlink": "xmlnsXlink",
        xmlspace: "xmlSpace",
        y1: "y1",
        y2: "y2",
        y: "y",
        ychannelselector: "yChannelSelector",
        z: "z",
        zoomandpan: "zoomAndPan"
      };
      var validateProperty$1 = function() {
      };
      {
        var warnedProperties$1 = {};
        var EVENT_NAME_REGEX = /^on./;
        var INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/;
        var rARIA$1 = new RegExp("^(aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$");
        var rARIACamel$1 = new RegExp("^(aria)[A-Z][" + ATTRIBUTE_NAME_CHAR + "]*$");
        validateProperty$1 = function(tagName, name, value, eventRegistry) {
          if (hasOwnProperty.call(warnedProperties$1, name) && warnedProperties$1[name]) {
            return true;
          }
          var lowerCasedName = name.toLowerCase();
          if (lowerCasedName === "onfocusin" || lowerCasedName === "onfocusout") {
            error("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React.");
            warnedProperties$1[name] = true;
            return true;
          }
          if (eventRegistry != null) {
            var { registrationNameDependencies, possibleRegistrationNames } = eventRegistry;
            if (registrationNameDependencies.hasOwnProperty(name)) {
              return true;
            }
            var registrationName = possibleRegistrationNames.hasOwnProperty(lowerCasedName) ? possibleRegistrationNames[lowerCasedName] : null;
            if (registrationName != null) {
              error("Invalid event handler property `%s`. Did you mean `%s`?", name, registrationName);
              warnedProperties$1[name] = true;
              return true;
            }
            if (EVENT_NAME_REGEX.test(name)) {
              error("Unknown event handler property `%s`. It will be ignored.", name);
              warnedProperties$1[name] = true;
              return true;
            }
          } else if (EVENT_NAME_REGEX.test(name)) {
            if (INVALID_EVENT_NAME_REGEX.test(name)) {
              error("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", name);
            }
            warnedProperties$1[name] = true;
            return true;
          }
          if (rARIA$1.test(name) || rARIACamel$1.test(name)) {
            return true;
          }
          if (lowerCasedName === "innerhtml") {
            error("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`.");
            warnedProperties$1[name] = true;
            return true;
          }
          if (lowerCasedName === "aria") {
            error("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead.");
            warnedProperties$1[name] = true;
            return true;
          }
          if (lowerCasedName === "is" && value !== null && value !== undefined && typeof value !== "string") {
            error("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof value);
            warnedProperties$1[name] = true;
            return true;
          }
          if (typeof value === "number" && isNaN(value)) {
            error("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", name);
            warnedProperties$1[name] = true;
            return true;
          }
          var propertyInfo = getPropertyInfo(name);
          var isReserved = propertyInfo !== null && propertyInfo.type === RESERVED;
          if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
            var standardName = possibleStandardNames[lowerCasedName];
            if (standardName !== name) {
              error("Invalid DOM property `%s`. Did you mean `%s`?", name, standardName);
              warnedProperties$1[name] = true;
              return true;
            }
          } else if (!isReserved && name !== lowerCasedName) {
            error("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", name, lowerCasedName);
            warnedProperties$1[name] = true;
            return true;
          }
          if (typeof value === "boolean" && shouldRemoveAttributeWithWarning(name, value, propertyInfo, false)) {
            if (value) {
              error('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', value, name, name, value, name);
            } else {
              error('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', value, name, name, value, name, name, name);
            }
            warnedProperties$1[name] = true;
            return true;
          }
          if (isReserved) {
            return true;
          }
          if (shouldRemoveAttributeWithWarning(name, value, propertyInfo, false)) {
            warnedProperties$1[name] = true;
            return false;
          }
          if ((value === "false" || value === "true") && propertyInfo !== null && propertyInfo.type === BOOLEAN) {
            error("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", value, name, value === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', name, value);
            warnedProperties$1[name] = true;
            return true;
          }
          return true;
        };
      }
      var warnUnknownProperties = function(type, props, eventRegistry) {
        {
          var unknownProps = [];
          for (var key in props) {
            var isValid2 = validateProperty$1(type, key, props[key], eventRegistry);
            if (!isValid2) {
              unknownProps.push(key);
            }
          }
          var unknownPropString = unknownProps.map(function(prop) {
            return "`" + prop + "`";
          }).join(", ");
          if (unknownProps.length === 1) {
            error("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type);
          } else if (unknownProps.length > 1) {
            error("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type);
          }
        }
      };
      function validateProperties$2(type, props, eventRegistry) {
        if (isCustomComponent(type, props)) {
          return;
        }
        warnUnknownProperties(type, props, eventRegistry);
      }
      var warnValidStyle = function() {
      };
      {
        var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;
        var msPattern = /^-ms-/;
        var hyphenPattern = /-(.)/g;
        var badStyleValueWithSemicolonPattern = /;\s*$/;
        var warnedStyleNames = {};
        var warnedStyleValues = {};
        var warnedForNaNValue = false;
        var warnedForInfinityValue = false;
        var camelize = function(string) {
          return string.replace(hyphenPattern, function(_, character) {
            return character.toUpperCase();
          });
        };
        var warnHyphenatedStyleName = function(name) {
          if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
            return;
          }
          warnedStyleNames[name] = true;
          error("Unsupported style property %s. Did you mean %s?", name, camelize(name.replace(msPattern, "ms-")));
        };
        var warnBadVendoredStyleName = function(name) {
          if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
            return;
          }
          warnedStyleNames[name] = true;
          error("Unsupported vendor-prefixed style property %s. Did you mean %s?", name, name.charAt(0).toUpperCase() + name.slice(1));
        };
        var warnStyleValueWithSemicolon = function(name, value) {
          if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {
            return;
          }
          warnedStyleValues[value] = true;
          error(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, name, value.replace(badStyleValueWithSemicolonPattern, ""));
        };
        var warnStyleValueIsNaN = function(name, value) {
          if (warnedForNaNValue) {
            return;
          }
          warnedForNaNValue = true;
          error("`NaN` is an invalid value for the `%s` css style property.", name);
        };
        var warnStyleValueIsInfinity = function(name, value) {
          if (warnedForInfinityValue) {
            return;
          }
          warnedForInfinityValue = true;
          error("`Infinity` is an invalid value for the `%s` css style property.", name);
        };
        warnValidStyle = function(name, value) {
          if (name.indexOf("-") > -1) {
            warnHyphenatedStyleName(name);
          } else if (badVendoredStyleNamePattern.test(name)) {
            warnBadVendoredStyleName(name);
          } else if (badStyleValueWithSemicolonPattern.test(value)) {
            warnStyleValueWithSemicolon(name, value);
          }
          if (typeof value === "number") {
            if (isNaN(value)) {
              warnStyleValueIsNaN(name, value);
            } else if (!isFinite(value)) {
              warnStyleValueIsInfinity(name, value);
            }
          }
        };
      }
      var warnValidStyle$1 = warnValidStyle;
      var matchHtmlRegExp = /["'&<>]/;
      function escapeHtml(string) {
        {
          checkHtmlStringCoercion(string);
        }
        var str = "" + string;
        var match = matchHtmlRegExp.exec(str);
        if (!match) {
          return str;
        }
        var escape2;
        var html = "";
        var index;
        var lastIndex = 0;
        for (index = match.index;index < str.length; index++) {
          switch (str.charCodeAt(index)) {
            case 34:
              escape2 = "&quot;";
              break;
            case 38:
              escape2 = "&amp;";
              break;
            case 39:
              escape2 = "&#x27;";
              break;
            case 60:
              escape2 = "&lt;";
              break;
            case 62:
              escape2 = "&gt;";
              break;
            default:
              continue;
          }
          if (lastIndex !== index) {
            html += str.substring(lastIndex, index);
          }
          lastIndex = index + 1;
          html += escape2;
        }
        return lastIndex !== index ? html + str.substring(lastIndex, index) : html;
      }
      function escapeTextForBrowser(text2) {
        if (typeof text2 === "boolean" || typeof text2 === "number") {
          return "" + text2;
        }
        return escapeHtml(text2);
      }
      var uppercasePattern = /([A-Z])/g;
      var msPattern$1 = /^ms-/;
      function hyphenateStyleName(name) {
        return name.replace(uppercasePattern, "-$1").toLowerCase().replace(msPattern$1, "-ms-");
      }
      var isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i;
      var didWarn = false;
      function sanitizeURL(url) {
        {
          if (!didWarn && isJavaScriptProtocol.test(url)) {
            didWarn = true;
            error("A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(url));
          }
        }
      }
      var isArrayImpl = Array.isArray;
      function isArray(a) {
        return isArrayImpl(a);
      }
      var startInlineScript = stringToPrecomputedChunk("<script>");
      var endInlineScript = stringToPrecomputedChunk("</script>");
      var startScriptSrc = stringToPrecomputedChunk('<script src="');
      var startModuleSrc = stringToPrecomputedChunk('<script type="module" src="');
      var endAsyncScript = stringToPrecomputedChunk('" async=""></script>');
      function escapeBootstrapScriptContent(scriptText) {
        {
          checkHtmlStringCoercion(scriptText);
        }
        return ("" + scriptText).replace(scriptRegex, scriptReplacer);
      }
      var scriptRegex = /(<\/|<)(s)(cript)/gi;
      var scriptReplacer = function(match, prefix2, s, suffix) {
        return "" + prefix2 + (s === "s" ? "\\u0073" : "\\u0053") + suffix;
      };
      function createResponseState(identifierPrefix, nonce, bootstrapScriptContent, bootstrapScripts, bootstrapModules) {
        var idPrefix = identifierPrefix === undefined ? "" : identifierPrefix;
        var inlineScriptWithNonce = nonce === undefined ? startInlineScript : stringToPrecomputedChunk('<script nonce="' + escapeTextForBrowser(nonce) + '">');
        var bootstrapChunks = [];
        if (bootstrapScriptContent !== undefined) {
          bootstrapChunks.push(inlineScriptWithNonce, stringToChunk(escapeBootstrapScriptContent(bootstrapScriptContent)), endInlineScript);
        }
        if (bootstrapScripts !== undefined) {
          for (var i = 0;i < bootstrapScripts.length; i++) {
            bootstrapChunks.push(startScriptSrc, stringToChunk(escapeTextForBrowser(bootstrapScripts[i])), endAsyncScript);
          }
        }
        if (bootstrapModules !== undefined) {
          for (var _i = 0;_i < bootstrapModules.length; _i++) {
            bootstrapChunks.push(startModuleSrc, stringToChunk(escapeTextForBrowser(bootstrapModules[_i])), endAsyncScript);
          }
        }
        return {
          bootstrapChunks,
          startInlineScript: inlineScriptWithNonce,
          placeholderPrefix: stringToPrecomputedChunk(idPrefix + "P:"),
          segmentPrefix: stringToPrecomputedChunk(idPrefix + "S:"),
          boundaryPrefix: idPrefix + "B:",
          idPrefix,
          nextSuspenseID: 0,
          sentCompleteSegmentFunction: false,
          sentCompleteBoundaryFunction: false,
          sentClientRenderFunction: false
        };
      }
      var ROOT_HTML_MODE = 0;
      var HTML_MODE = 1;
      var SVG_MODE = 2;
      var MATHML_MODE = 3;
      var HTML_TABLE_MODE = 4;
      var HTML_TABLE_BODY_MODE = 5;
      var HTML_TABLE_ROW_MODE = 6;
      var HTML_COLGROUP_MODE = 7;
      function createFormatContext(insertionMode, selectedValue) {
        return {
          insertionMode,
          selectedValue
        };
      }
      function getChildFormatContext(parentContext, type, props) {
        switch (type) {
          case "select":
            return createFormatContext(HTML_MODE, props.value != null ? props.value : props.defaultValue);
          case "svg":
            return createFormatContext(SVG_MODE, null);
          case "math":
            return createFormatContext(MATHML_MODE, null);
          case "foreignObject":
            return createFormatContext(HTML_MODE, null);
          case "table":
            return createFormatContext(HTML_TABLE_MODE, null);
          case "thead":
          case "tbody":
          case "tfoot":
            return createFormatContext(HTML_TABLE_BODY_MODE, null);
          case "colgroup":
            return createFormatContext(HTML_COLGROUP_MODE, null);
          case "tr":
            return createFormatContext(HTML_TABLE_ROW_MODE, null);
        }
        if (parentContext.insertionMode >= HTML_TABLE_MODE) {
          return createFormatContext(HTML_MODE, null);
        }
        if (parentContext.insertionMode === ROOT_HTML_MODE) {
          return createFormatContext(HTML_MODE, null);
        }
        return parentContext;
      }
      var UNINITIALIZED_SUSPENSE_BOUNDARY_ID = null;
      function assignSuspenseBoundaryID(responseState) {
        var generatedID = responseState.nextSuspenseID++;
        return stringToPrecomputedChunk(responseState.boundaryPrefix + generatedID.toString(16));
      }
      function makeId(responseState, treeId, localId) {
        var idPrefix = responseState.idPrefix;
        var id = ":" + idPrefix + "R" + treeId;
        if (localId > 0) {
          id += "H" + localId.toString(32);
        }
        return id + ":";
      }
      function encodeHTMLTextNode(text2) {
        return escapeTextForBrowser(text2);
      }
      var textSeparator = stringToPrecomputedChunk("<!-- -->");
      function pushTextInstance(target, text2, responseState, textEmbedded) {
        if (text2 === "") {
          return textEmbedded;
        }
        if (textEmbedded) {
          target.push(textSeparator);
        }
        target.push(stringToChunk(encodeHTMLTextNode(text2)));
        return true;
      }
      function pushSegmentFinale(target, responseState, lastPushedText, textEmbedded) {
        if (lastPushedText && textEmbedded) {
          target.push(textSeparator);
        }
      }
      var styleNameCache = new Map;
      function processStyleName(styleName) {
        var chunk = styleNameCache.get(styleName);
        if (chunk !== undefined) {
          return chunk;
        }
        var result2 = stringToPrecomputedChunk(escapeTextForBrowser(hyphenateStyleName(styleName)));
        styleNameCache.set(styleName, result2);
        return result2;
      }
      var styleAttributeStart = stringToPrecomputedChunk(' style="');
      var styleAssign = stringToPrecomputedChunk(":");
      var styleSeparator = stringToPrecomputedChunk(";");
      function pushStyle(target, responseState, style) {
        if (typeof style !== "object") {
          throw new Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
        }
        var isFirst = true;
        for (var styleName in style) {
          if (!hasOwnProperty.call(style, styleName)) {
            continue;
          }
          var styleValue = style[styleName];
          if (styleValue == null || typeof styleValue === "boolean" || styleValue === "") {
            continue;
          }
          var nameChunk = undefined;
          var valueChunk = undefined;
          var isCustomProperty = styleName.indexOf("--") === 0;
          if (isCustomProperty) {
            nameChunk = stringToChunk(escapeTextForBrowser(styleName));
            {
              checkCSSPropertyStringCoercion(styleValue, styleName);
            }
            valueChunk = stringToChunk(escapeTextForBrowser(("" + styleValue).trim()));
          } else {
            {
              warnValidStyle$1(styleName, styleValue);
            }
            nameChunk = processStyleName(styleName);
            if (typeof styleValue === "number") {
              if (styleValue !== 0 && !hasOwnProperty.call(isUnitlessNumber, styleName)) {
                valueChunk = stringToChunk(styleValue + "px");
              } else {
                valueChunk = stringToChunk("" + styleValue);
              }
            } else {
              {
                checkCSSPropertyStringCoercion(styleValue, styleName);
              }
              valueChunk = stringToChunk(escapeTextForBrowser(("" + styleValue).trim()));
            }
          }
          if (isFirst) {
            isFirst = false;
            target.push(styleAttributeStart, nameChunk, styleAssign, valueChunk);
          } else {
            target.push(styleSeparator, nameChunk, styleAssign, valueChunk);
          }
        }
        if (!isFirst) {
          target.push(attributeEnd);
        }
      }
      var attributeSeparator = stringToPrecomputedChunk(" ");
      var attributeAssign = stringToPrecomputedChunk('="');
      var attributeEnd = stringToPrecomputedChunk('"');
      var attributeEmptyString = stringToPrecomputedChunk('=""');
      function pushAttribute(target, responseState, name, value) {
        switch (name) {
          case "style": {
            pushStyle(target, responseState, value);
            return;
          }
          case "defaultValue":
          case "defaultChecked":
          case "innerHTML":
          case "suppressContentEditableWarning":
          case "suppressHydrationWarning":
            return;
        }
        if (name.length > 2 && (name[0] === "o" || name[0] === "O") && (name[1] === "n" || name[1] === "N")) {
          return;
        }
        var propertyInfo = getPropertyInfo(name);
        if (propertyInfo !== null) {
          switch (typeof value) {
            case "function":
            case "symbol":
              return;
            case "boolean": {
              if (!propertyInfo.acceptsBooleans) {
                return;
              }
            }
          }
          var attributeName = propertyInfo.attributeName;
          var attributeNameChunk = stringToChunk(attributeName);
          switch (propertyInfo.type) {
            case BOOLEAN:
              if (value) {
                target.push(attributeSeparator, attributeNameChunk, attributeEmptyString);
              }
              return;
            case OVERLOADED_BOOLEAN:
              if (value === true) {
                target.push(attributeSeparator, attributeNameChunk, attributeEmptyString);
              } else if (value === false)
                ;
              else {
                target.push(attributeSeparator, attributeNameChunk, attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);
              }
              return;
            case NUMERIC:
              if (!isNaN(value)) {
                target.push(attributeSeparator, attributeNameChunk, attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);
              }
              break;
            case POSITIVE_NUMERIC:
              if (!isNaN(value) && value >= 1) {
                target.push(attributeSeparator, attributeNameChunk, attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);
              }
              break;
            default:
              if (propertyInfo.sanitizeURL) {
                {
                  checkAttributeStringCoercion(value, attributeName);
                }
                value = "" + value;
                sanitizeURL(value);
              }
              target.push(attributeSeparator, attributeNameChunk, attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);
          }
        } else if (isAttributeNameSafe(name)) {
          switch (typeof value) {
            case "function":
            case "symbol":
              return;
            case "boolean": {
              var prefix2 = name.toLowerCase().slice(0, 5);
              if (prefix2 !== "data-" && prefix2 !== "aria-") {
                return;
              }
            }
          }
          target.push(attributeSeparator, stringToChunk(name), attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);
        }
      }
      var endOfStartTag = stringToPrecomputedChunk(">");
      var endOfStartTagSelfClosing = stringToPrecomputedChunk("/>");
      function pushInnerHTML(target, innerHTML, children) {
        if (innerHTML != null) {
          if (children != null) {
            throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
          }
          if (typeof innerHTML !== "object" || !("__html" in innerHTML)) {
            throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
          }
          var html = innerHTML.__html;
          if (html !== null && html !== undefined) {
            {
              checkHtmlStringCoercion(html);
            }
            target.push(stringToChunk("" + html));
          }
        }
      }
      var didWarnDefaultInputValue = false;
      var didWarnDefaultChecked = false;
      var didWarnDefaultSelectValue = false;
      var didWarnDefaultTextareaValue = false;
      var didWarnInvalidOptionChildren = false;
      var didWarnInvalidOptionInnerHTML = false;
      var didWarnSelectedSetOnOption = false;
      function checkSelectProp(props, propName) {
        {
          var value = props[propName];
          if (value != null) {
            var array2 = isArray(value);
            if (props.multiple && !array2) {
              error("The `%s` prop supplied to <select> must be an array if `multiple` is true.", propName);
            } else if (!props.multiple && array2) {
              error("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.", propName);
            }
          }
        }
      }
      function pushStartSelect(target, props, responseState) {
        {
          checkControlledValueProps("select", props);
          checkSelectProp(props, "value");
          checkSelectProp(props, "defaultValue");
          if (props.value !== undefined && props.defaultValue !== undefined && !didWarnDefaultSelectValue) {
            error("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components");
            didWarnDefaultSelectValue = true;
          }
        }
        target.push(startChunkForTag("select"));
        var children = null;
        var innerHTML = null;
        for (var propKey in props) {
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null) {
              continue;
            }
            switch (propKey) {
              case "children":
                children = propValue;
                break;
              case "dangerouslySetInnerHTML":
                innerHTML = propValue;
                break;
              case "defaultValue":
              case "value":
                break;
              default:
                pushAttribute(target, responseState, propKey, propValue);
                break;
            }
          }
        }
        target.push(endOfStartTag);
        pushInnerHTML(target, innerHTML, children);
        return children;
      }
      function flattenOptionChildren(children) {
        var content = "";
        React.Children.forEach(children, function(child) {
          if (child == null) {
            return;
          }
          content += child;
          {
            if (!didWarnInvalidOptionChildren && typeof child !== "string" && typeof child !== "number") {
              didWarnInvalidOptionChildren = true;
              error("Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.");
            }
          }
        });
        return content;
      }
      var selectedMarkerAttribute = stringToPrecomputedChunk(' selected=""');
      function pushStartOption(target, props, responseState, formatContext) {
        var selectedValue = formatContext.selectedValue;
        target.push(startChunkForTag("option"));
        var children = null;
        var value = null;
        var selected = null;
        var innerHTML = null;
        for (var propKey in props) {
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null) {
              continue;
            }
            switch (propKey) {
              case "children":
                children = propValue;
                break;
              case "selected":
                selected = propValue;
                {
                  if (!didWarnSelectedSetOnOption) {
                    error("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>.");
                    didWarnSelectedSetOnOption = true;
                  }
                }
                break;
              case "dangerouslySetInnerHTML":
                innerHTML = propValue;
                break;
              case "value":
                value = propValue;
              default:
                pushAttribute(target, responseState, propKey, propValue);
                break;
            }
          }
        }
        if (selectedValue != null) {
          var stringValue;
          if (value !== null) {
            {
              checkAttributeStringCoercion(value, "value");
            }
            stringValue = "" + value;
          } else {
            {
              if (innerHTML !== null) {
                if (!didWarnInvalidOptionInnerHTML) {
                  didWarnInvalidOptionInnerHTML = true;
                  error("Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected.");
                }
              }
            }
            stringValue = flattenOptionChildren(children);
          }
          if (isArray(selectedValue)) {
            for (var i = 0;i < selectedValue.length; i++) {
              {
                checkAttributeStringCoercion(selectedValue[i], "value");
              }
              var v = "" + selectedValue[i];
              if (v === stringValue) {
                target.push(selectedMarkerAttribute);
                break;
              }
            }
          } else {
            {
              checkAttributeStringCoercion(selectedValue, "select.value");
            }
            if ("" + selectedValue === stringValue) {
              target.push(selectedMarkerAttribute);
            }
          }
        } else if (selected) {
          target.push(selectedMarkerAttribute);
        }
        target.push(endOfStartTag);
        pushInnerHTML(target, innerHTML, children);
        return children;
      }
      function pushInput(target, props, responseState) {
        {
          checkControlledValueProps("input", props);
          if (props.checked !== undefined && props.defaultChecked !== undefined && !didWarnDefaultChecked) {
            error("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", "A component", props.type);
            didWarnDefaultChecked = true;
          }
          if (props.value !== undefined && props.defaultValue !== undefined && !didWarnDefaultInputValue) {
            error("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", "A component", props.type);
            didWarnDefaultInputValue = true;
          }
        }
        target.push(startChunkForTag("input"));
        var value = null;
        var defaultValue = null;
        var checked = null;
        var defaultChecked = null;
        for (var propKey in props) {
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null) {
              continue;
            }
            switch (propKey) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw new Error("input is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
              case "defaultChecked":
                defaultChecked = propValue;
                break;
              case "defaultValue":
                defaultValue = propValue;
                break;
              case "checked":
                checked = propValue;
                break;
              case "value":
                value = propValue;
                break;
              default:
                pushAttribute(target, responseState, propKey, propValue);
                break;
            }
          }
        }
        if (checked !== null) {
          pushAttribute(target, responseState, "checked", checked);
        } else if (defaultChecked !== null) {
          pushAttribute(target, responseState, "checked", defaultChecked);
        }
        if (value !== null) {
          pushAttribute(target, responseState, "value", value);
        } else if (defaultValue !== null) {
          pushAttribute(target, responseState, "value", defaultValue);
        }
        target.push(endOfStartTagSelfClosing);
        return null;
      }
      function pushStartTextArea(target, props, responseState) {
        {
          checkControlledValueProps("textarea", props);
          if (props.value !== undefined && props.defaultValue !== undefined && !didWarnDefaultTextareaValue) {
            error("Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components");
            didWarnDefaultTextareaValue = true;
          }
        }
        target.push(startChunkForTag("textarea"));
        var value = null;
        var defaultValue = null;
        var children = null;
        for (var propKey in props) {
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null) {
              continue;
            }
            switch (propKey) {
              case "children":
                children = propValue;
                break;
              case "value":
                value = propValue;
                break;
              case "defaultValue":
                defaultValue = propValue;
                break;
              case "dangerouslySetInnerHTML":
                throw new Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
              default:
                pushAttribute(target, responseState, propKey, propValue);
                break;
            }
          }
        }
        if (value === null && defaultValue !== null) {
          value = defaultValue;
        }
        target.push(endOfStartTag);
        if (children != null) {
          {
            error("Use the `defaultValue` or `value` props instead of setting children on <textarea>.");
          }
          if (value != null) {
            throw new Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
          }
          if (isArray(children)) {
            if (children.length > 1) {
              throw new Error("<textarea> can only have at most one child.");
            }
            {
              checkHtmlStringCoercion(children[0]);
            }
            value = "" + children[0];
          }
          {
            checkHtmlStringCoercion(children);
          }
          value = "" + children;
        }
        if (typeof value === "string" && value[0] === "\n") {
          target.push(leadingNewline);
        }
        if (value !== null) {
          {
            checkAttributeStringCoercion(value, "value");
          }
          target.push(stringToChunk(encodeHTMLTextNode("" + value)));
        }
        return null;
      }
      function pushSelfClosing(target, props, tag, responseState) {
        target.push(startChunkForTag(tag));
        for (var propKey in props) {
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null) {
              continue;
            }
            switch (propKey) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw new Error(tag + " is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
              default:
                pushAttribute(target, responseState, propKey, propValue);
                break;
            }
          }
        }
        target.push(endOfStartTagSelfClosing);
        return null;
      }
      function pushStartMenuItem(target, props, responseState) {
        target.push(startChunkForTag("menuitem"));
        for (var propKey in props) {
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null) {
              continue;
            }
            switch (propKey) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw new Error("menuitems cannot have `children` nor `dangerouslySetInnerHTML`.");
              default:
                pushAttribute(target, responseState, propKey, propValue);
                break;
            }
          }
        }
        target.push(endOfStartTag);
        return null;
      }
      function pushStartTitle(target, props, responseState) {
        target.push(startChunkForTag("title"));
        var children = null;
        for (var propKey in props) {
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null) {
              continue;
            }
            switch (propKey) {
              case "children":
                children = propValue;
                break;
              case "dangerouslySetInnerHTML":
                throw new Error("`dangerouslySetInnerHTML` does not make sense on <title>.");
              default:
                pushAttribute(target, responseState, propKey, propValue);
                break;
            }
          }
        }
        target.push(endOfStartTag);
        {
          var child = Array.isArray(children) && children.length < 2 ? children[0] || null : children;
          if (Array.isArray(children) && children.length > 1) {
            error("A title element received an array with more than 1 element as children. In browsers title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering");
          } else if (child != null && child.$$typeof != null) {
            error("A title element received a React element for children. In the browser title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering");
          } else if (child != null && typeof child !== "string" && typeof child !== "number") {
            error("A title element received a value that was not a string or number for children. In the browser title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering");
          }
        }
        return children;
      }
      function pushStartGenericElement(target, props, tag, responseState) {
        target.push(startChunkForTag(tag));
        var children = null;
        var innerHTML = null;
        for (var propKey in props) {
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null) {
              continue;
            }
            switch (propKey) {
              case "children":
                children = propValue;
                break;
              case "dangerouslySetInnerHTML":
                innerHTML = propValue;
                break;
              default:
                pushAttribute(target, responseState, propKey, propValue);
                break;
            }
          }
        }
        target.push(endOfStartTag);
        pushInnerHTML(target, innerHTML, children);
        if (typeof children === "string") {
          target.push(stringToChunk(encodeHTMLTextNode(children)));
          return null;
        }
        return children;
      }
      function pushStartCustomElement(target, props, tag, responseState) {
        target.push(startChunkForTag(tag));
        var children = null;
        var innerHTML = null;
        for (var propKey in props) {
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null) {
              continue;
            }
            switch (propKey) {
              case "children":
                children = propValue;
                break;
              case "dangerouslySetInnerHTML":
                innerHTML = propValue;
                break;
              case "style":
                pushStyle(target, responseState, propValue);
                break;
              case "suppressContentEditableWarning":
              case "suppressHydrationWarning":
                break;
              default:
                if (isAttributeNameSafe(propKey) && typeof propValue !== "function" && typeof propValue !== "symbol") {
                  target.push(attributeSeparator, stringToChunk(propKey), attributeAssign, stringToChunk(escapeTextForBrowser(propValue)), attributeEnd);
                }
                break;
            }
          }
        }
        target.push(endOfStartTag);
        pushInnerHTML(target, innerHTML, children);
        return children;
      }
      var leadingNewline = stringToPrecomputedChunk("\n");
      function pushStartPreformattedElement(target, props, tag, responseState) {
        target.push(startChunkForTag(tag));
        var children = null;
        var innerHTML = null;
        for (var propKey in props) {
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null) {
              continue;
            }
            switch (propKey) {
              case "children":
                children = propValue;
                break;
              case "dangerouslySetInnerHTML":
                innerHTML = propValue;
                break;
              default:
                pushAttribute(target, responseState, propKey, propValue);
                break;
            }
          }
        }
        target.push(endOfStartTag);
        if (innerHTML != null) {
          if (children != null) {
            throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
          }
          if (typeof innerHTML !== "object" || !("__html" in innerHTML)) {
            throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
          }
          var html = innerHTML.__html;
          if (html !== null && html !== undefined) {
            if (typeof html === "string" && html.length > 0 && html[0] === "\n") {
              target.push(leadingNewline, stringToChunk(html));
            } else {
              {
                checkHtmlStringCoercion(html);
              }
              target.push(stringToChunk("" + html));
            }
          }
        }
        if (typeof children === "string" && children[0] === "\n") {
          target.push(leadingNewline);
        }
        return children;
      }
      var VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/;
      var validatedTagCache = new Map;
      function startChunkForTag(tag) {
        var tagStartChunk = validatedTagCache.get(tag);
        if (tagStartChunk === undefined) {
          if (!VALID_TAG_REGEX.test(tag)) {
            throw new Error("Invalid tag: " + tag);
          }
          tagStartChunk = stringToPrecomputedChunk("<" + tag);
          validatedTagCache.set(tag, tagStartChunk);
        }
        return tagStartChunk;
      }
      var DOCTYPE = stringToPrecomputedChunk("<!DOCTYPE html>");
      function pushStartInstance(target, type, props, responseState, formatContext) {
        {
          validateProperties(type, props);
          validateProperties$1(type, props);
          validateProperties$2(type, props, null);
          if (!props.suppressContentEditableWarning && props.contentEditable && props.children != null) {
            error("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional.");
          }
          if (formatContext.insertionMode !== SVG_MODE && formatContext.insertionMode !== MATHML_MODE) {
            if (type.indexOf("-") === -1 && typeof props.is !== "string" && type.toLowerCase() !== type) {
              error("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", type);
            }
          }
        }
        switch (type) {
          case "select":
            return pushStartSelect(target, props, responseState);
          case "option":
            return pushStartOption(target, props, responseState, formatContext);
          case "textarea":
            return pushStartTextArea(target, props, responseState);
          case "input":
            return pushInput(target, props, responseState);
          case "menuitem":
            return pushStartMenuItem(target, props, responseState);
          case "title":
            return pushStartTitle(target, props, responseState);
          case "listing":
          case "pre": {
            return pushStartPreformattedElement(target, props, type, responseState);
          }
          case "area":
          case "base":
          case "br":
          case "col":
          case "embed":
          case "hr":
          case "img":
          case "keygen":
          case "link":
          case "meta":
          case "param":
          case "source":
          case "track":
          case "wbr": {
            return pushSelfClosing(target, props, type, responseState);
          }
          case "annotation-xml":
          case "color-profile":
          case "font-face":
          case "font-face-src":
          case "font-face-uri":
          case "font-face-format":
          case "font-face-name":
          case "missing-glyph": {
            return pushStartGenericElement(target, props, type, responseState);
          }
          case "html": {
            if (formatContext.insertionMode === ROOT_HTML_MODE) {
              target.push(DOCTYPE);
            }
            return pushStartGenericElement(target, props, type, responseState);
          }
          default: {
            if (type.indexOf("-") === -1 && typeof props.is !== "string") {
              return pushStartGenericElement(target, props, type, responseState);
            } else {
              return pushStartCustomElement(target, props, type, responseState);
            }
          }
        }
      }
      var endTag1 = stringToPrecomputedChunk("</");
      var endTag2 = stringToPrecomputedChunk(">");
      function pushEndInstance(target, type, props) {
        switch (type) {
          case "area":
          case "base":
          case "br":
          case "col":
          case "embed":
          case "hr":
          case "img":
          case "input":
          case "keygen":
          case "link":
          case "meta":
          case "param":
          case "source":
          case "track":
          case "wbr": {
            break;
          }
          default: {
            target.push(endTag1, stringToChunk(type), endTag2);
          }
        }
      }
      function writeCompletedRoot(destination, responseState) {
        var bootstrapChunks = responseState.bootstrapChunks;
        var i = 0;
        for (;i < bootstrapChunks.length - 1; i++) {
          writeChunk(destination, bootstrapChunks[i]);
        }
        if (i < bootstrapChunks.length) {
          return writeChunkAndReturn(destination, bootstrapChunks[i]);
        }
        return true;
      }
      var placeholder1 = stringToPrecomputedChunk('<template id="');
      var placeholder2 = stringToPrecomputedChunk('"></template>');
      function writePlaceholder(destination, responseState, id) {
        writeChunk(destination, placeholder1);
        writeChunk(destination, responseState.placeholderPrefix);
        var formattedID = stringToChunk(id.toString(16));
        writeChunk(destination, formattedID);
        return writeChunkAndReturn(destination, placeholder2);
      }
      var startCompletedSuspenseBoundary = stringToPrecomputedChunk("<!--$-->");
      var startPendingSuspenseBoundary1 = stringToPrecomputedChunk('<!--$?--><template id="');
      var startPendingSuspenseBoundary2 = stringToPrecomputedChunk('"></template>');
      var startClientRenderedSuspenseBoundary = stringToPrecomputedChunk("<!--$!-->");
      var endSuspenseBoundary = stringToPrecomputedChunk("<!--/$-->");
      var clientRenderedSuspenseBoundaryError1 = stringToPrecomputedChunk("<template");
      var clientRenderedSuspenseBoundaryErrorAttrInterstitial = stringToPrecomputedChunk('"');
      var clientRenderedSuspenseBoundaryError1A = stringToPrecomputedChunk(' data-dgst="');
      var clientRenderedSuspenseBoundaryError1B = stringToPrecomputedChunk(' data-msg="');
      var clientRenderedSuspenseBoundaryError1C = stringToPrecomputedChunk(' data-stck="');
      var clientRenderedSuspenseBoundaryError2 = stringToPrecomputedChunk("></template>");
      function writeStartCompletedSuspenseBoundary(destination, responseState) {
        return writeChunkAndReturn(destination, startCompletedSuspenseBoundary);
      }
      function writeStartPendingSuspenseBoundary(destination, responseState, id) {
        writeChunk(destination, startPendingSuspenseBoundary1);
        if (id === null) {
          throw new Error("An ID must have been assigned before we can complete the boundary.");
        }
        writeChunk(destination, id);
        return writeChunkAndReturn(destination, startPendingSuspenseBoundary2);
      }
      function writeStartClientRenderedSuspenseBoundary(destination, responseState, errorDigest, errorMesssage, errorComponentStack) {
        var result2;
        result2 = writeChunkAndReturn(destination, startClientRenderedSuspenseBoundary);
        writeChunk(destination, clientRenderedSuspenseBoundaryError1);
        if (errorDigest) {
          writeChunk(destination, clientRenderedSuspenseBoundaryError1A);
          writeChunk(destination, stringToChunk(escapeTextForBrowser(errorDigest)));
          writeChunk(destination, clientRenderedSuspenseBoundaryErrorAttrInterstitial);
        }
        {
          if (errorMesssage) {
            writeChunk(destination, clientRenderedSuspenseBoundaryError1B);
            writeChunk(destination, stringToChunk(escapeTextForBrowser(errorMesssage)));
            writeChunk(destination, clientRenderedSuspenseBoundaryErrorAttrInterstitial);
          }
          if (errorComponentStack) {
            writeChunk(destination, clientRenderedSuspenseBoundaryError1C);
            writeChunk(destination, stringToChunk(escapeTextForBrowser(errorComponentStack)));
            writeChunk(destination, clientRenderedSuspenseBoundaryErrorAttrInterstitial);
          }
        }
        result2 = writeChunkAndReturn(destination, clientRenderedSuspenseBoundaryError2);
        return result2;
      }
      function writeEndCompletedSuspenseBoundary(destination, responseState) {
        return writeChunkAndReturn(destination, endSuspenseBoundary);
      }
      function writeEndPendingSuspenseBoundary(destination, responseState) {
        return writeChunkAndReturn(destination, endSuspenseBoundary);
      }
      function writeEndClientRenderedSuspenseBoundary(destination, responseState) {
        return writeChunkAndReturn(destination, endSuspenseBoundary);
      }
      var startSegmentHTML = stringToPrecomputedChunk('<div hidden id="');
      var startSegmentHTML2 = stringToPrecomputedChunk('">');
      var endSegmentHTML = stringToPrecomputedChunk("</div>");
      var startSegmentSVG = stringToPrecomputedChunk('<svg aria-hidden="true" style="display:none" id="');
      var startSegmentSVG2 = stringToPrecomputedChunk('">');
      var endSegmentSVG = stringToPrecomputedChunk("</svg>");
      var startSegmentMathML = stringToPrecomputedChunk('<math aria-hidden="true" style="display:none" id="');
      var startSegmentMathML2 = stringToPrecomputedChunk('">');
      var endSegmentMathML = stringToPrecomputedChunk("</math>");
      var startSegmentTable = stringToPrecomputedChunk('<table hidden id="');
      var startSegmentTable2 = stringToPrecomputedChunk('">');
      var endSegmentTable = stringToPrecomputedChunk("</table>");
      var startSegmentTableBody = stringToPrecomputedChunk('<table hidden><tbody id="');
      var startSegmentTableBody2 = stringToPrecomputedChunk('">');
      var endSegmentTableBody = stringToPrecomputedChunk("</tbody></table>");
      var startSegmentTableRow = stringToPrecomputedChunk('<table hidden><tr id="');
      var startSegmentTableRow2 = stringToPrecomputedChunk('">');
      var endSegmentTableRow = stringToPrecomputedChunk("</tr></table>");
      var startSegmentColGroup = stringToPrecomputedChunk('<table hidden><colgroup id="');
      var startSegmentColGroup2 = stringToPrecomputedChunk('">');
      var endSegmentColGroup = stringToPrecomputedChunk("</colgroup></table>");
      function writeStartSegment(destination, responseState, formatContext, id) {
        switch (formatContext.insertionMode) {
          case ROOT_HTML_MODE:
          case HTML_MODE: {
            writeChunk(destination, startSegmentHTML);
            writeChunk(destination, responseState.segmentPrefix);
            writeChunk(destination, stringToChunk(id.toString(16)));
            return writeChunkAndReturn(destination, startSegmentHTML2);
          }
          case SVG_MODE: {
            writeChunk(destination, startSegmentSVG);
            writeChunk(destination, responseState.segmentPrefix);
            writeChunk(destination, stringToChunk(id.toString(16)));
            return writeChunkAndReturn(destination, startSegmentSVG2);
          }
          case MATHML_MODE: {
            writeChunk(destination, startSegmentMathML);
            writeChunk(destination, responseState.segmentPrefix);
            writeChunk(destination, stringToChunk(id.toString(16)));
            return writeChunkAndReturn(destination, startSegmentMathML2);
          }
          case HTML_TABLE_MODE: {
            writeChunk(destination, startSegmentTable);
            writeChunk(destination, responseState.segmentPrefix);
            writeChunk(destination, stringToChunk(id.toString(16)));
            return writeChunkAndReturn(destination, startSegmentTable2);
          }
          case HTML_TABLE_BODY_MODE: {
            writeChunk(destination, startSegmentTableBody);
            writeChunk(destination, responseState.segmentPrefix);
            writeChunk(destination, stringToChunk(id.toString(16)));
            return writeChunkAndReturn(destination, startSegmentTableBody2);
          }
          case HTML_TABLE_ROW_MODE: {
            writeChunk(destination, startSegmentTableRow);
            writeChunk(destination, responseState.segmentPrefix);
            writeChunk(destination, stringToChunk(id.toString(16)));
            return writeChunkAndReturn(destination, startSegmentTableRow2);
          }
          case HTML_COLGROUP_MODE: {
            writeChunk(destination, startSegmentColGroup);
            writeChunk(destination, responseState.segmentPrefix);
            writeChunk(destination, stringToChunk(id.toString(16)));
            return writeChunkAndReturn(destination, startSegmentColGroup2);
          }
          default: {
            throw new Error("Unknown insertion mode. This is a bug in React.");
          }
        }
      }
      function writeEndSegment(destination, formatContext) {
        switch (formatContext.insertionMode) {
          case ROOT_HTML_MODE:
          case HTML_MODE: {
            return writeChunkAndReturn(destination, endSegmentHTML);
          }
          case SVG_MODE: {
            return writeChunkAndReturn(destination, endSegmentSVG);
          }
          case MATHML_MODE: {
            return writeChunkAndReturn(destination, endSegmentMathML);
          }
          case HTML_TABLE_MODE: {
            return writeChunkAndReturn(destination, endSegmentTable);
          }
          case HTML_TABLE_BODY_MODE: {
            return writeChunkAndReturn(destination, endSegmentTableBody);
          }
          case HTML_TABLE_ROW_MODE: {
            return writeChunkAndReturn(destination, endSegmentTableRow);
          }
          case HTML_COLGROUP_MODE: {
            return writeChunkAndReturn(destination, endSegmentColGroup);
          }
          default: {
            throw new Error("Unknown insertion mode. This is a bug in React.");
          }
        }
      }
      var completeSegmentFunction = "function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)}";
      var completeBoundaryFunction = 'function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==d&&"$?"!==d&&"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&&a._reactRetry()}}';
      var clientRenderFunction = 'function $RX(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())}';
      var completeSegmentScript1Full = stringToPrecomputedChunk(completeSegmentFunction + ';$RS("');
      var completeSegmentScript1Partial = stringToPrecomputedChunk('$RS("');
      var completeSegmentScript2 = stringToPrecomputedChunk('","');
      var completeSegmentScript3 = stringToPrecomputedChunk('")</script>');
      function writeCompletedSegmentInstruction(destination, responseState, contentSegmentID) {
        writeChunk(destination, responseState.startInlineScript);
        if (!responseState.sentCompleteSegmentFunction) {
          responseState.sentCompleteSegmentFunction = true;
          writeChunk(destination, completeSegmentScript1Full);
        } else {
          writeChunk(destination, completeSegmentScript1Partial);
        }
        writeChunk(destination, responseState.segmentPrefix);
        var formattedID = stringToChunk(contentSegmentID.toString(16));
        writeChunk(destination, formattedID);
        writeChunk(destination, completeSegmentScript2);
        writeChunk(destination, responseState.placeholderPrefix);
        writeChunk(destination, formattedID);
        return writeChunkAndReturn(destination, completeSegmentScript3);
      }
      var completeBoundaryScript1Full = stringToPrecomputedChunk(completeBoundaryFunction + ';$RC("');
      var completeBoundaryScript1Partial = stringToPrecomputedChunk('$RC("');
      var completeBoundaryScript2 = stringToPrecomputedChunk('","');
      var completeBoundaryScript3 = stringToPrecomputedChunk('")</script>');
      function writeCompletedBoundaryInstruction(destination, responseState, boundaryID, contentSegmentID) {
        writeChunk(destination, responseState.startInlineScript);
        if (!responseState.sentCompleteBoundaryFunction) {
          responseState.sentCompleteBoundaryFunction = true;
          writeChunk(destination, completeBoundaryScript1Full);
        } else {
          writeChunk(destination, completeBoundaryScript1Partial);
        }
        if (boundaryID === null) {
          throw new Error("An ID must have been assigned before we can complete the boundary.");
        }
        var formattedContentID = stringToChunk(contentSegmentID.toString(16));
        writeChunk(destination, boundaryID);
        writeChunk(destination, completeBoundaryScript2);
        writeChunk(destination, responseState.segmentPrefix);
        writeChunk(destination, formattedContentID);
        return writeChunkAndReturn(destination, completeBoundaryScript3);
      }
      var clientRenderScript1Full = stringToPrecomputedChunk(clientRenderFunction + ';$RX("');
      var clientRenderScript1Partial = stringToPrecomputedChunk('$RX("');
      var clientRenderScript1A = stringToPrecomputedChunk('"');
      var clientRenderScript2 = stringToPrecomputedChunk(")</script>");
      var clientRenderErrorScriptArgInterstitial = stringToPrecomputedChunk(",");
      function writeClientRenderBoundaryInstruction(destination, responseState, boundaryID, errorDigest, errorMessage, errorComponentStack) {
        writeChunk(destination, responseState.startInlineScript);
        if (!responseState.sentClientRenderFunction) {
          responseState.sentClientRenderFunction = true;
          writeChunk(destination, clientRenderScript1Full);
        } else {
          writeChunk(destination, clientRenderScript1Partial);
        }
        if (boundaryID === null) {
          throw new Error("An ID must have been assigned before we can complete the boundary.");
        }
        writeChunk(destination, boundaryID);
        writeChunk(destination, clientRenderScript1A);
        if (errorDigest || errorMessage || errorComponentStack) {
          writeChunk(destination, clientRenderErrorScriptArgInterstitial);
          writeChunk(destination, stringToChunk(escapeJSStringsForInstructionScripts(errorDigest || "")));
        }
        if (errorMessage || errorComponentStack) {
          writeChunk(destination, clientRenderErrorScriptArgInterstitial);
          writeChunk(destination, stringToChunk(escapeJSStringsForInstructionScripts(errorMessage || "")));
        }
        if (errorComponentStack) {
          writeChunk(destination, clientRenderErrorScriptArgInterstitial);
          writeChunk(destination, stringToChunk(escapeJSStringsForInstructionScripts(errorComponentStack)));
        }
        return writeChunkAndReturn(destination, clientRenderScript2);
      }
      var regexForJSStringsInScripts = /[<\u2028\u2029]/g;
      function escapeJSStringsForInstructionScripts(input) {
        var escaped = JSON.stringify(input);
        return escaped.replace(regexForJSStringsInScripts, function(match) {
          switch (match) {
            case "<":
              return "\\u003c";
            case "\u2028":
              return "\\u2028";
            case "\u2029":
              return "\\u2029";
            default: {
              throw new Error("escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
            }
          }
        });
      }
      function createResponseState$1(generateStaticMarkup, identifierPrefix) {
        var responseState = createResponseState(identifierPrefix, undefined);
        return {
          bootstrapChunks: responseState.bootstrapChunks,
          startInlineScript: responseState.startInlineScript,
          placeholderPrefix: responseState.placeholderPrefix,
          segmentPrefix: responseState.segmentPrefix,
          boundaryPrefix: responseState.boundaryPrefix,
          idPrefix: responseState.idPrefix,
          nextSuspenseID: responseState.nextSuspenseID,
          sentCompleteSegmentFunction: responseState.sentCompleteSegmentFunction,
          sentCompleteBoundaryFunction: responseState.sentCompleteBoundaryFunction,
          sentClientRenderFunction: responseState.sentClientRenderFunction,
          generateStaticMarkup
        };
      }
      function createRootFormatContext() {
        return {
          insertionMode: HTML_MODE,
          selectedValue: null
        };
      }
      function pushTextInstance$1(target, text2, responseState, textEmbedded) {
        if (responseState.generateStaticMarkup) {
          target.push(stringToChunk(escapeTextForBrowser(text2)));
          return false;
        } else {
          return pushTextInstance(target, text2, responseState, textEmbedded);
        }
      }
      function pushSegmentFinale$1(target, responseState, lastPushedText, textEmbedded) {
        if (responseState.generateStaticMarkup) {
          return;
        } else {
          return pushSegmentFinale(target, responseState, lastPushedText, textEmbedded);
        }
      }
      function writeStartCompletedSuspenseBoundary$1(destination, responseState) {
        if (responseState.generateStaticMarkup) {
          return true;
        }
        return writeStartCompletedSuspenseBoundary(destination);
      }
      function writeStartClientRenderedSuspenseBoundary$1(destination, responseState, errorDigest, errorMessage, errorComponentStack) {
        if (responseState.generateStaticMarkup) {
          return true;
        }
        return writeStartClientRenderedSuspenseBoundary(destination, responseState, errorDigest, errorMessage, errorComponentStack);
      }
      function writeEndCompletedSuspenseBoundary$1(destination, responseState) {
        if (responseState.generateStaticMarkup) {
          return true;
        }
        return writeEndCompletedSuspenseBoundary(destination);
      }
      function writeEndClientRenderedSuspenseBoundary$1(destination, responseState) {
        if (responseState.generateStaticMarkup) {
          return true;
        }
        return writeEndClientRenderedSuspenseBoundary(destination);
      }
      var assign = Object.assign;
      var REACT_ELEMENT_TYPE = Symbol.for("react.element");
      var REACT_PORTAL_TYPE = Symbol.for("react.portal");
      var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
      var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
      var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
      var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
      var REACT_CONTEXT_TYPE = Symbol.for("react.context");
      var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
      var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
      var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
      var REACT_MEMO_TYPE = Symbol.for("react.memo");
      var REACT_LAZY_TYPE = Symbol.for("react.lazy");
      var REACT_SCOPE_TYPE = Symbol.for("react.scope");
      var REACT_DEBUG_TRACING_MODE_TYPE = Symbol.for("react.debug_trace_mode");
      var REACT_LEGACY_HIDDEN_TYPE = Symbol.for("react.legacy_hidden");
      var REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED = Symbol.for("react.default_value");
      var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
      var FAUX_ITERATOR_SYMBOL = "@@iterator";
      function getIteratorFn(maybeIterable) {
        if (maybeIterable === null || typeof maybeIterable !== "object") {
          return null;
        }
        var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
        if (typeof maybeIterator === "function") {
          return maybeIterator;
        }
        return null;
      }
      function getWrappedName(outerType, innerType, wrapperName) {
        var displayName = outerType.displayName;
        if (displayName) {
          return displayName;
        }
        var functionName = innerType.displayName || innerType.name || "";
        return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
      }
      function getContextName(type) {
        return type.displayName || "Context";
      }
      function getComponentNameFromType(type) {
        if (type == null) {
          return null;
        }
        {
          if (typeof type.tag === "number") {
            error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.");
          }
        }
        if (typeof type === "function") {
          return type.displayName || type.name || null;
        }
        if (typeof type === "string") {
          return type;
        }
        switch (type) {
          case REACT_FRAGMENT_TYPE:
            return "Fragment";
          case REACT_PORTAL_TYPE:
            return "Portal";
          case REACT_PROFILER_TYPE:
            return "Profiler";
          case REACT_STRICT_MODE_TYPE:
            return "StrictMode";
          case REACT_SUSPENSE_TYPE:
            return "Suspense";
          case REACT_SUSPENSE_LIST_TYPE:
            return "SuspenseList";
        }
        if (typeof type === "object") {
          switch (type.$$typeof) {
            case REACT_CONTEXT_TYPE:
              var context = type;
              return getContextName(context) + ".Consumer";
            case REACT_PROVIDER_TYPE:
              var provider = type;
              return getContextName(provider._context) + ".Provider";
            case REACT_FORWARD_REF_TYPE:
              return getWrappedName(type, type.render, "ForwardRef");
            case REACT_MEMO_TYPE:
              var outerName = type.displayName || null;
              if (outerName !== null) {
                return outerName;
              }
              return getComponentNameFromType(type.type) || "Memo";
            case REACT_LAZY_TYPE: {
              var lazyComponent = type;
              var payload = lazyComponent._payload;
              var init2 = lazyComponent._init;
              try {
                return getComponentNameFromType(init2(payload));
              } catch (x) {
                return null;
              }
            }
          }
        }
        return null;
      }
      var disabledDepth = 0;
      var prevLog;
      var prevInfo;
      var prevWarn;
      var prevError;
      var prevGroup;
      var prevGroupCollapsed;
      var prevGroupEnd;
      function disabledLog() {
      }
      disabledLog.__reactDisabledLog = true;
      function disableLogs() {
        {
          if (disabledDepth === 0) {
            prevLog = console.log;
            prevInfo = console.info;
            prevWarn = console.warn;
            prevError = console.error;
            prevGroup = console.group;
            prevGroupCollapsed = console.groupCollapsed;
            prevGroupEnd = console.groupEnd;
            var props = {
              configurable: true,
              enumerable: true,
              value: disabledLog,
              writable: true
            };
            Object.defineProperties(console, {
              info: props,
              log: props,
              warn: props,
              error: props,
              group: props,
              groupCollapsed: props,
              groupEnd: props
            });
          }
          disabledDepth++;
        }
      }
      function reenableLogs() {
        {
          disabledDepth--;
          if (disabledDepth === 0) {
            var props = {
              configurable: true,
              enumerable: true,
              writable: true
            };
            Object.defineProperties(console, {
              log: assign({}, props, {
                value: prevLog
              }),
              info: assign({}, props, {
                value: prevInfo
              }),
              warn: assign({}, props, {
                value: prevWarn
              }),
              error: assign({}, props, {
                value: prevError
              }),
              group: assign({}, props, {
                value: prevGroup
              }),
              groupCollapsed: assign({}, props, {
                value: prevGroupCollapsed
              }),
              groupEnd: assign({}, props, {
                value: prevGroupEnd
              })
            });
          }
          if (disabledDepth < 0) {
            error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
          }
        }
      }
      var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
      var prefix;
      function describeBuiltInComponentFrame(name, source, ownerFn) {
        {
          if (prefix === undefined) {
            try {
              throw Error();
            } catch (x) {
              var match = x.stack.trim().match(/\n( *(at )?)/);
              prefix = match && match[1] || "";
            }
          }
          return "\n" + prefix + name;
        }
      }
      var reentry = false;
      var componentFrameCache;
      {
        var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
        componentFrameCache = new PossiblyWeakMap;
      }
      function describeNativeComponentFrame(fn, construct) {
        if (!fn || reentry) {
          return "";
        }
        {
          var frame = componentFrameCache.get(fn);
          if (frame !== undefined) {
            return frame;
          }
        }
        var control;
        reentry = true;
        var previousPrepareStackTrace = Error.prepareStackTrace;
        Error.prepareStackTrace = undefined;
        var previousDispatcher;
        {
          previousDispatcher = ReactCurrentDispatcher.current;
          ReactCurrentDispatcher.current = null;
          disableLogs();
        }
        try {
          if (construct) {
            var Fake = function() {
              throw Error();
            };
            Object.defineProperty(Fake.prototype, "props", {
              set: function() {
                throw Error();
              }
            });
            if (typeof Reflect === "object" && Reflect.construct) {
              try {
                Reflect.construct(Fake, []);
              } catch (x) {
                control = x;
              }
              Reflect.construct(fn, [], Fake);
            } else {
              try {
                Fake.call();
              } catch (x) {
                control = x;
              }
              fn.call(Fake.prototype);
            }
          } else {
            try {
              throw Error();
            } catch (x) {
              control = x;
            }
            fn();
          }
        } catch (sample) {
          if (sample && control && typeof sample.stack === "string") {
            var sampleLines = sample.stack.split("\n");
            var controlLines = control.stack.split("\n");
            var s = sampleLines.length - 1;
            var c2 = controlLines.length - 1;
            while (s >= 1 && c2 >= 0 && sampleLines[s] !== controlLines[c2]) {
              c2--;
            }
            for (;s >= 1 && c2 >= 0; s--, c2--) {
              if (sampleLines[s] !== controlLines[c2]) {
                if (s !== 1 || c2 !== 1) {
                  do {
                    s--;
                    c2--;
                    if (c2 < 0 || sampleLines[s] !== controlLines[c2]) {
                      var _frame = "\n" + sampleLines[s].replace(" at new ", " at ");
                      if (fn.displayName && _frame.includes("<anonymous>")) {
                        _frame = _frame.replace("<anonymous>", fn.displayName);
                      }
                      {
                        if (typeof fn === "function") {
                          componentFrameCache.set(fn, _frame);
                        }
                      }
                      return _frame;
                    }
                  } while (s >= 1 && c2 >= 0);
                }
                break;
              }
            }
          }
        } finally {
          reentry = false;
          {
            ReactCurrentDispatcher.current = previousDispatcher;
            reenableLogs();
          }
          Error.prepareStackTrace = previousPrepareStackTrace;
        }
        var name = fn ? fn.displayName || fn.name : "";
        var syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
        {
          if (typeof fn === "function") {
            componentFrameCache.set(fn, syntheticFrame);
          }
        }
        return syntheticFrame;
      }
      function describeClassComponentFrame(ctor, source, ownerFn) {
        {
          return describeNativeComponentFrame(ctor, true);
        }
      }
      function describeFunctionComponentFrame(fn, source, ownerFn) {
        {
          return describeNativeComponentFrame(fn, false);
        }
      }
      function shouldConstruct(Component) {
        var prototype = Component.prototype;
        return !!(prototype && prototype.isReactComponent);
      }
      function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
        if (type == null) {
          return "";
        }
        if (typeof type === "function") {
          {
            return describeNativeComponentFrame(type, shouldConstruct(type));
          }
        }
        if (typeof type === "string") {
          return describeBuiltInComponentFrame(type);
        }
        switch (type) {
          case REACT_SUSPENSE_TYPE:
            return describeBuiltInComponentFrame("Suspense");
          case REACT_SUSPENSE_LIST_TYPE:
            return describeBuiltInComponentFrame("SuspenseList");
        }
        if (typeof type === "object") {
          switch (type.$$typeof) {
            case REACT_FORWARD_REF_TYPE:
              return describeFunctionComponentFrame(type.render);
            case REACT_MEMO_TYPE:
              return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
            case REACT_LAZY_TYPE: {
              var lazyComponent = type;
              var payload = lazyComponent._payload;
              var init2 = lazyComponent._init;
              try {
                return describeUnknownElementTypeFrameInDEV(init2(payload), source, ownerFn);
              } catch (x) {
              }
            }
          }
        }
        return "";
      }
      var loggedTypeFailures = {};
      var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
      function setCurrentlyValidatingElement(element) {
        {
          if (element) {
            var owner = element._owner;
            var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
            ReactDebugCurrentFrame.setExtraStackFrame(stack);
          } else {
            ReactDebugCurrentFrame.setExtraStackFrame(null);
          }
        }
      }
      function checkPropTypes(typeSpecs, values2, location, componentName, element) {
        {
          var has = Function.call.bind(hasOwnProperty);
          for (var typeSpecName in typeSpecs) {
            if (has(typeSpecs, typeSpecName)) {
              var error$1 = undefined;
              try {
                if (typeof typeSpecs[typeSpecName] !== "function") {
                  var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                  err.name = "Invariant Violation";
                  throw err;
                }
                error$1 = typeSpecs[typeSpecName](values2, typeSpecName, componentName, location, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
              } catch (ex) {
                error$1 = ex;
              }
              if (error$1 && !(error$1 instanceof Error)) {
                setCurrentlyValidatingElement(element);
                error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location, typeSpecName, typeof error$1);
                setCurrentlyValidatingElement(null);
              }
              if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                loggedTypeFailures[error$1.message] = true;
                setCurrentlyValidatingElement(element);
                error("Failed %s type: %s", location, error$1.message);
                setCurrentlyValidatingElement(null);
              }
            }
          }
        }
      }
      var warnedAboutMissingGetChildContext;
      {
        warnedAboutMissingGetChildContext = {};
      }
      var emptyContextObject = {};
      {
        Object.freeze(emptyContextObject);
      }
      function getMaskedContext(type, unmaskedContext) {
        {
          var contextTypes = type.contextTypes;
          if (!contextTypes) {
            return emptyContextObject;
          }
          var context = {};
          for (var key in contextTypes) {
            context[key] = unmaskedContext[key];
          }
          {
            var name = getComponentNameFromType(type) || "Unknown";
            checkPropTypes(contextTypes, context, "context", name);
          }
          return context;
        }
      }
      function processChildContext(instance, type, parentContext, childContextTypes) {
        {
          if (typeof instance.getChildContext !== "function") {
            {
              var componentName = getComponentNameFromType(type) || "Unknown";
              if (!warnedAboutMissingGetChildContext[componentName]) {
                warnedAboutMissingGetChildContext[componentName] = true;
                error("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", componentName, componentName);
              }
            }
            return parentContext;
          }
          var childContext = instance.getChildContext();
          for (var contextKey in childContext) {
            if (!(contextKey in childContextTypes)) {
              throw new Error((getComponentNameFromType(type) || "Unknown") + ".getChildContext(): key \"" + contextKey + "\" is not defined in childContextTypes.");
            }
          }
          {
            var name = getComponentNameFromType(type) || "Unknown";
            checkPropTypes(childContextTypes, childContext, "child context", name);
          }
          return assign({}, parentContext, childContext);
        }
      }
      var rendererSigil;
      {
        rendererSigil = {};
      }
      var rootContextSnapshot = null;
      var currentActiveSnapshot = null;
      function popNode(prev) {
        {
          prev.context._currentValue2 = prev.parentValue;
        }
      }
      function pushNode(next) {
        {
          next.context._currentValue2 = next.value;
        }
      }
      function popToNearestCommonAncestor(prev, next) {
        if (prev === next)
          ;
        else {
          popNode(prev);
          var parentPrev = prev.parent;
          var parentNext = next.parent;
          if (parentPrev === null) {
            if (parentNext !== null) {
              throw new Error("The stacks must reach the root at the same time. This is a bug in React.");
            }
          } else {
            if (parentNext === null) {
              throw new Error("The stacks must reach the root at the same time. This is a bug in React.");
            }
            popToNearestCommonAncestor(parentPrev, parentNext);
          }
          pushNode(next);
        }
      }
      function popAllPrevious(prev) {
        popNode(prev);
        var parentPrev = prev.parent;
        if (parentPrev !== null) {
          popAllPrevious(parentPrev);
        }
      }
      function pushAllNext(next) {
        var parentNext = next.parent;
        if (parentNext !== null) {
          pushAllNext(parentNext);
        }
        pushNode(next);
      }
      function popPreviousToCommonLevel(prev, next) {
        popNode(prev);
        var parentPrev = prev.parent;
        if (parentPrev === null) {
          throw new Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
        }
        if (parentPrev.depth === next.depth) {
          popToNearestCommonAncestor(parentPrev, next);
        } else {
          popPreviousToCommonLevel(parentPrev, next);
        }
      }
      function popNextToCommonLevel(prev, next) {
        var parentNext = next.parent;
        if (parentNext === null) {
          throw new Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
        }
        if (prev.depth === parentNext.depth) {
          popToNearestCommonAncestor(prev, parentNext);
        } else {
          popNextToCommonLevel(prev, parentNext);
        }
        pushNode(next);
      }
      function switchContext(newSnapshot) {
        var prev = currentActiveSnapshot;
        var next = newSnapshot;
        if (prev !== next) {
          if (prev === null) {
            pushAllNext(next);
          } else if (next === null) {
            popAllPrevious(prev);
          } else if (prev.depth === next.depth) {
            popToNearestCommonAncestor(prev, next);
          } else if (prev.depth > next.depth) {
            popPreviousToCommonLevel(prev, next);
          } else {
            popNextToCommonLevel(prev, next);
          }
          currentActiveSnapshot = next;
        }
      }
      function pushProvider(context, nextValue) {
        var prevValue;
        {
          prevValue = context._currentValue2;
          context._currentValue2 = nextValue;
          {
            if (context._currentRenderer2 !== undefined && context._currentRenderer2 !== null && context._currentRenderer2 !== rendererSigil) {
              error("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.");
            }
            context._currentRenderer2 = rendererSigil;
          }
        }
        var prevNode = currentActiveSnapshot;
        var newNode = {
          parent: prevNode,
          depth: prevNode === null ? 0 : prevNode.depth + 1,
          context,
          parentValue: prevValue,
          value: nextValue
        };
        currentActiveSnapshot = newNode;
        return newNode;
      }
      function popProvider(context) {
        var prevSnapshot = currentActiveSnapshot;
        if (prevSnapshot === null) {
          throw new Error("Tried to pop a Context at the root of the app. This is a bug in React.");
        }
        {
          if (prevSnapshot.context !== context) {
            error("The parent context is not the expected context. This is probably a bug in React.");
          }
        }
        {
          var _value = prevSnapshot.parentValue;
          if (_value === REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED) {
            prevSnapshot.context._currentValue2 = prevSnapshot.context._defaultValue;
          } else {
            prevSnapshot.context._currentValue2 = _value;
          }
          {
            if (context._currentRenderer2 !== undefined && context._currentRenderer2 !== null && context._currentRenderer2 !== rendererSigil) {
              error("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.");
            }
            context._currentRenderer2 = rendererSigil;
          }
        }
        return currentActiveSnapshot = prevSnapshot.parent;
      }
      function getActiveContext() {
        return currentActiveSnapshot;
      }
      function readContext(context) {
        var value = context._currentValue2;
        return value;
      }
      function get(key) {
        return key._reactInternals;
      }
      function set(key, value) {
        key._reactInternals = value;
      }
      var didWarnAboutNoopUpdateForComponent = {};
      var didWarnAboutDeprecatedWillMount = {};
      var didWarnAboutUninitializedState;
      var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate;
      var didWarnAboutLegacyLifecyclesAndDerivedState;
      var didWarnAboutUndefinedDerivedState;
      var warnOnUndefinedDerivedState;
      var warnOnInvalidCallback;
      var didWarnAboutDirectlyAssigningPropsToState;
      var didWarnAboutContextTypeAndContextTypes;
      var didWarnAboutInvalidateContextType;
      {
        didWarnAboutUninitializedState = new Set;
        didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = new Set;
        didWarnAboutLegacyLifecyclesAndDerivedState = new Set;
        didWarnAboutDirectlyAssigningPropsToState = new Set;
        didWarnAboutUndefinedDerivedState = new Set;
        didWarnAboutContextTypeAndContextTypes = new Set;
        didWarnAboutInvalidateContextType = new Set;
        var didWarnOnInvalidCallback = new Set;
        warnOnInvalidCallback = function(callback, callerName) {
          if (callback === null || typeof callback === "function") {
            return;
          }
          var key = callerName + "_" + callback;
          if (!didWarnOnInvalidCallback.has(key)) {
            didWarnOnInvalidCallback.add(key);
            error("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", callerName, callback);
          }
        };
        warnOnUndefinedDerivedState = function(type, partialState) {
          if (partialState === undefined) {
            var componentName = getComponentNameFromType(type) || "Component";
            if (!didWarnAboutUndefinedDerivedState.has(componentName)) {
              didWarnAboutUndefinedDerivedState.add(componentName);
              error("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", componentName);
            }
          }
        };
      }
      function warnNoop(publicInstance, callerName) {
        {
          var _constructor = publicInstance.constructor;
          var componentName = _constructor && getComponentNameFromType(_constructor) || "ReactClass";
          var warningKey = componentName + "." + callerName;
          if (didWarnAboutNoopUpdateForComponent[warningKey]) {
            return;
          }
          error("%s(...): Can only update a mounting component. This usually means you called %s() outside componentWillMount() on the server. This is a no-op.\n\nPlease check the code for the %s component.", callerName, callerName, componentName);
          didWarnAboutNoopUpdateForComponent[warningKey] = true;
        }
      }
      var classComponentUpdater = {
        isMounted: function(inst) {
          return false;
        },
        enqueueSetState: function(inst, payload, callback) {
          var internals = get(inst);
          if (internals.queue === null) {
            warnNoop(inst, "setState");
          } else {
            internals.queue.push(payload);
            {
              if (callback !== undefined && callback !== null) {
                warnOnInvalidCallback(callback, "setState");
              }
            }
          }
        },
        enqueueReplaceState: function(inst, payload, callback) {
          var internals = get(inst);
          internals.replace = true;
          internals.queue = [payload];
          {
            if (callback !== undefined && callback !== null) {
              warnOnInvalidCallback(callback, "setState");
            }
          }
        },
        enqueueForceUpdate: function(inst, callback) {
          var internals = get(inst);
          if (internals.queue === null) {
            warnNoop(inst, "forceUpdate");
          } else {
            {
              if (callback !== undefined && callback !== null) {
                warnOnInvalidCallback(callback, "setState");
              }
            }
          }
        }
      };
      function applyDerivedStateFromProps(instance, ctor, getDerivedStateFromProps, prevState, nextProps) {
        var partialState = getDerivedStateFromProps(nextProps, prevState);
        {
          warnOnUndefinedDerivedState(ctor, partialState);
        }
        var newState = partialState === null || partialState === undefined ? prevState : assign({}, prevState, partialState);
        return newState;
      }
      function constructClassInstance(ctor, props, maskedLegacyContext) {
        var context = emptyContextObject;
        var contextType = ctor.contextType;
        {
          if ("contextType" in ctor) {
            var isValid2 = contextType === null || contextType !== undefined && contextType.$$typeof === REACT_CONTEXT_TYPE && contextType._context === undefined;
            if (!isValid2 && !didWarnAboutInvalidateContextType.has(ctor)) {
              didWarnAboutInvalidateContextType.add(ctor);
              var addendum = "";
              if (contextType === undefined) {
                addendum = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file.";
              } else if (typeof contextType !== "object") {
                addendum = " However, it is set to a " + typeof contextType + ".";
              } else if (contextType.$$typeof === REACT_PROVIDER_TYPE) {
                addendum = " Did you accidentally pass the Context.Provider instead?";
              } else if (contextType._context !== undefined) {
                addendum = " Did you accidentally pass the Context.Consumer instead?";
              } else {
                addendum = " However, it is set to an object with keys {" + Object.keys(contextType).join(", ") + "}.";
              }
              error("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", getComponentNameFromType(ctor) || "Component", addendum);
            }
          }
        }
        if (typeof contextType === "object" && contextType !== null) {
          context = readContext(contextType);
        } else {
          context = maskedLegacyContext;
        }
        var instance = new ctor(props, context);
        {
          if (typeof ctor.getDerivedStateFromProps === "function" && (instance.state === null || instance.state === undefined)) {
            var componentName = getComponentNameFromType(ctor) || "Component";
            if (!didWarnAboutUninitializedState.has(componentName)) {
              didWarnAboutUninitializedState.add(componentName);
              error("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", componentName, instance.state === null ? "null" : "undefined", componentName);
            }
          }
          if (typeof ctor.getDerivedStateFromProps === "function" || typeof instance.getSnapshotBeforeUpdate === "function") {
            var foundWillMountName = null;
            var foundWillReceivePropsName = null;
            var foundWillUpdateName = null;
            if (typeof instance.componentWillMount === "function" && instance.componentWillMount.__suppressDeprecationWarning !== true) {
              foundWillMountName = "componentWillMount";
            } else if (typeof instance.UNSAFE_componentWillMount === "function") {
              foundWillMountName = "UNSAFE_componentWillMount";
            }
            if (typeof instance.componentWillReceiveProps === "function" && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {
              foundWillReceivePropsName = "componentWillReceiveProps";
            } else if (typeof instance.UNSAFE_componentWillReceiveProps === "function") {
              foundWillReceivePropsName = "UNSAFE_componentWillReceiveProps";
            }
            if (typeof instance.componentWillUpdate === "function" && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {
              foundWillUpdateName = "componentWillUpdate";
            } else if (typeof instance.UNSAFE_componentWillUpdate === "function") {
              foundWillUpdateName = "UNSAFE_componentWillUpdate";
            }
            if (foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {
              var _componentName = getComponentNameFromType(ctor) || "Component";
              var newApiName = typeof ctor.getDerivedStateFromProps === "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
              if (!didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)) {
                didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName);
                error("Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\nThe above lifecycles should be removed. Learn more about this warning here:\nhttps://reactjs.org/link/unsafe-component-lifecycles", _componentName, newApiName, foundWillMountName !== null ? "\n  " + foundWillMountName : "", foundWillReceivePropsName !== null ? "\n  " + foundWillReceivePropsName : "", foundWillUpdateName !== null ? "\n  " + foundWillUpdateName : "");
              }
            }
          }
        }
        return instance;
      }
      function checkClassInstance(instance, ctor, newProps) {
        {
          var name = getComponentNameFromType(ctor) || "Component";
          var renderPresent = instance.render;
          if (!renderPresent) {
            if (ctor.prototype && typeof ctor.prototype.render === "function") {
              error("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", name);
            } else {
              error("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", name);
            }
          }
          if (instance.getInitialState && !instance.getInitialState.isReactClassApproved && !instance.state) {
            error("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", name);
          }
          if (instance.getDefaultProps && !instance.getDefaultProps.isReactClassApproved) {
            error("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", name);
          }
          if (instance.propTypes) {
            error("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", name);
          }
          if (instance.contextType) {
            error("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", name);
          }
          {
            if (instance.contextTypes) {
              error("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", name);
            }
            if (ctor.contextType && ctor.contextTypes && !didWarnAboutContextTypeAndContextTypes.has(ctor)) {
              didWarnAboutContextTypeAndContextTypes.add(ctor);
              error("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", name);
            }
          }
          if (typeof instance.componentShouldUpdate === "function") {
            error("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", name);
          }
          if (ctor.prototype && ctor.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate !== "undefined") {
            error("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", getComponentNameFromType(ctor) || "A pure component");
          }
          if (typeof instance.componentDidUnmount === "function") {
            error("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", name);
          }
          if (typeof instance.componentDidReceiveProps === "function") {
            error("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", name);
          }
          if (typeof instance.componentWillRecieveProps === "function") {
            error("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", name);
          }
          if (typeof instance.UNSAFE_componentWillRecieveProps === "function") {
            error("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", name);
          }
          var hasMutatedProps = instance.props !== newProps;
          if (instance.props !== undefined && hasMutatedProps) {
            error("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", name, name);
          }
          if (instance.defaultProps) {
            error("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", name, name);
          }
          if (typeof instance.getSnapshotBeforeUpdate === "function" && typeof instance.componentDidUpdate !== "function" && !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)) {
            didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);
            error("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", getComponentNameFromType(ctor));
          }
          if (typeof instance.getDerivedStateFromProps === "function") {
            error("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", name);
          }
          if (typeof instance.getDerivedStateFromError === "function") {
            error("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", name);
          }
          if (typeof ctor.getSnapshotBeforeUpdate === "function") {
            error("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", name);
          }
          var _state = instance.state;
          if (_state && (typeof _state !== "object" || isArray(_state))) {
            error("%s.state: must be set to an object or null", name);
          }
          if (typeof instance.getChildContext === "function" && typeof ctor.childContextTypes !== "object") {
            error("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", name);
          }
        }
      }
      function callComponentWillMount(type, instance) {
        var oldState = instance.state;
        if (typeof instance.componentWillMount === "function") {
          {
            if (instance.componentWillMount.__suppressDeprecationWarning !== true) {
              var componentName = getComponentNameFromType(type) || "Unknown";
              if (!didWarnAboutDeprecatedWillMount[componentName]) {
                warn("componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move code from componentWillMount to componentDidMount (preferred in most cases) or the constructor.\n\nPlease update the following components: %s", componentName);
                didWarnAboutDeprecatedWillMount[componentName] = true;
              }
            }
          }
          instance.componentWillMount();
        }
        if (typeof instance.UNSAFE_componentWillMount === "function") {
          instance.UNSAFE_componentWillMount();
        }
        if (oldState !== instance.state) {
          {
            error("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", getComponentNameFromType(type) || "Component");
          }
          classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
        }
      }
      function processUpdateQueue(internalInstance, inst, props, maskedLegacyContext) {
        if (internalInstance.queue !== null && internalInstance.queue.length > 0) {
          var oldQueue = internalInstance.queue;
          var oldReplace = internalInstance.replace;
          internalInstance.queue = null;
          internalInstance.replace = false;
          if (oldReplace && oldQueue.length === 1) {
            inst.state = oldQueue[0];
          } else {
            var nextState = oldReplace ? oldQueue[0] : inst.state;
            var dontMutate = true;
            for (var i = oldReplace ? 1 : 0;i < oldQueue.length; i++) {
              var partial = oldQueue[i];
              var partialState = typeof partial === "function" ? partial.call(inst, nextState, props, maskedLegacyContext) : partial;
              if (partialState != null) {
                if (dontMutate) {
                  dontMutate = false;
                  nextState = assign({}, nextState, partialState);
                } else {
                  assign(nextState, partialState);
                }
              }
            }
            inst.state = nextState;
          }
        } else {
          internalInstance.queue = null;
        }
      }
      function mountClassInstance(instance, ctor, newProps, maskedLegacyContext) {
        {
          checkClassInstance(instance, ctor, newProps);
        }
        var initialState = instance.state !== undefined ? instance.state : null;
        instance.updater = classComponentUpdater;
        instance.props = newProps;
        instance.state = initialState;
        var internalInstance = {
          queue: [],
          replace: false
        };
        set(instance, internalInstance);
        var contextType = ctor.contextType;
        if (typeof contextType === "object" && contextType !== null) {
          instance.context = readContext(contextType);
        } else {
          instance.context = maskedLegacyContext;
        }
        {
          if (instance.state === newProps) {
            var componentName = getComponentNameFromType(ctor) || "Component";
            if (!didWarnAboutDirectlyAssigningPropsToState.has(componentName)) {
              didWarnAboutDirectlyAssigningPropsToState.add(componentName);
              error("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", componentName);
            }
          }
        }
        var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
        if (typeof getDerivedStateFromProps === "function") {
          instance.state = applyDerivedStateFromProps(instance, ctor, getDerivedStateFromProps, initialState, newProps);
        }
        if (typeof ctor.getDerivedStateFromProps !== "function" && typeof instance.getSnapshotBeforeUpdate !== "function" && (typeof instance.UNSAFE_componentWillMount === "function" || typeof instance.componentWillMount === "function")) {
          callComponentWillMount(ctor, instance);
          processUpdateQueue(internalInstance, instance, newProps, maskedLegacyContext);
        }
      }
      var emptyTreeContext = {
        id: 1,
        overflow: ""
      };
      function getTreeId(context) {
        var overflow = context.overflow;
        var idWithLeadingBit = context.id;
        var id = idWithLeadingBit & ~getLeadingBit(idWithLeadingBit);
        return id.toString(32) + overflow;
      }
      function pushTreeContext(baseContext, totalChildren, index) {
        var baseIdWithLeadingBit = baseContext.id;
        var baseOverflow = baseContext.overflow;
        var baseLength = getBitLength(baseIdWithLeadingBit) - 1;
        var baseId = baseIdWithLeadingBit & ~(1 << baseLength);
        var slot = index + 1;
        var length = getBitLength(totalChildren) + baseLength;
        if (length > 30) {
          var numberOfOverflowBits = baseLength - baseLength % 5;
          var newOverflowBits = (1 << numberOfOverflowBits) - 1;
          var newOverflow = (baseId & newOverflowBits).toString(32);
          var restOfBaseId = baseId >> numberOfOverflowBits;
          var restOfBaseLength = baseLength - numberOfOverflowBits;
          var restOfLength = getBitLength(totalChildren) + restOfBaseLength;
          var restOfNewBits = slot << restOfBaseLength;
          var id = restOfNewBits | restOfBaseId;
          var overflow = newOverflow + baseOverflow;
          return {
            id: 1 << restOfLength | id,
            overflow
          };
        } else {
          var newBits = slot << baseLength;
          var _id = newBits | baseId;
          var _overflow = baseOverflow;
          return {
            id: 1 << length | _id,
            overflow: _overflow
          };
        }
      }
      function getBitLength(number) {
        return 32 - clz32(number);
      }
      function getLeadingBit(id) {
        return 1 << getBitLength(id) - 1;
      }
      var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback;
      var log = Math.log;
      var LN2 = Math.LN2;
      function clz32Fallback(x) {
        var asUint = x >>> 0;
        if (asUint === 0) {
          return 32;
        }
        return 31 - (log(asUint) / LN2 | 0) | 0;
      }
      function is2(x, y) {
        return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y;
      }
      var objectIs = typeof Object.is === "function" ? Object.is : is2;
      var currentlyRenderingComponent = null;
      var currentlyRenderingTask = null;
      var firstWorkInProgressHook = null;
      var workInProgressHook = null;
      var isReRender = false;
      var didScheduleRenderPhaseUpdate = false;
      var localIdCounter = 0;
      var renderPhaseUpdates = null;
      var numberOfReRenders = 0;
      var RE_RENDER_LIMIT = 25;
      var isInHookUserCodeInDev = false;
      var currentHookNameInDev;
      function resolveCurrentlyRenderingComponent() {
        if (currentlyRenderingComponent === null) {
          throw new Error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.");
        }
        {
          if (isInHookUserCodeInDev) {
            error("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks");
          }
        }
        return currentlyRenderingComponent;
      }
      function areHookInputsEqual(nextDeps, prevDeps) {
        if (prevDeps === null) {
          {
            error("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", currentHookNameInDev);
          }
          return false;
        }
        {
          if (nextDeps.length !== prevDeps.length) {
            error("The final argument passed to %s changed size between renders. The order and size of this array must remain constant.\n\nPrevious: %s\nIncoming: %s", currentHookNameInDev, "[" + nextDeps.join(", ") + "]", "[" + prevDeps.join(", ") + "]");
          }
        }
        for (var i = 0;i < prevDeps.length && i < nextDeps.length; i++) {
          if (objectIs(nextDeps[i], prevDeps[i])) {
            continue;
          }
          return false;
        }
        return true;
      }
      function createHook() {
        if (numberOfReRenders > 0) {
          throw new Error("Rendered more hooks than during the previous render");
        }
        return {
          memoizedState: null,
          queue: null,
          next: null
        };
      }
      function createWorkInProgressHook() {
        if (workInProgressHook === null) {
          if (firstWorkInProgressHook === null) {
            isReRender = false;
            firstWorkInProgressHook = workInProgressHook = createHook();
          } else {
            isReRender = true;
            workInProgressHook = firstWorkInProgressHook;
          }
        } else {
          if (workInProgressHook.next === null) {
            isReRender = false;
            workInProgressHook = workInProgressHook.next = createHook();
          } else {
            isReRender = true;
            workInProgressHook = workInProgressHook.next;
          }
        }
        return workInProgressHook;
      }
      function prepareToUseHooks(task, componentIdentity) {
        currentlyRenderingComponent = componentIdentity;
        currentlyRenderingTask = task;
        {
          isInHookUserCodeInDev = false;
        }
        localIdCounter = 0;
      }
      function finishHooks(Component, props, children, refOrContext) {
        while (didScheduleRenderPhaseUpdate) {
          didScheduleRenderPhaseUpdate = false;
          localIdCounter = 0;
          numberOfReRenders += 1;
          workInProgressHook = null;
          children = Component(props, refOrContext);
        }
        resetHooksState();
        return children;
      }
      function checkDidRenderIdHook() {
        var didRenderIdHook = localIdCounter !== 0;
        return didRenderIdHook;
      }
      function resetHooksState() {
        {
          isInHookUserCodeInDev = false;
        }
        currentlyRenderingComponent = null;
        currentlyRenderingTask = null;
        didScheduleRenderPhaseUpdate = false;
        firstWorkInProgressHook = null;
        numberOfReRenders = 0;
        renderPhaseUpdates = null;
        workInProgressHook = null;
      }
      function readContext$1(context) {
        {
          if (isInHookUserCodeInDev) {
            error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
          }
        }
        return readContext(context);
      }
      function useContext(context) {
        {
          currentHookNameInDev = "useContext";
        }
        resolveCurrentlyRenderingComponent();
        return readContext(context);
      }
      function basicStateReducer(state, action) {
        return typeof action === "function" ? action(state) : action;
      }
      function useState(initialState) {
        {
          currentHookNameInDev = "useState";
        }
        return useReducer(basicStateReducer, initialState);
      }
      function useReducer(reducer, initialArg, init2) {
        {
          if (reducer !== basicStateReducer) {
            currentHookNameInDev = "useReducer";
          }
        }
        currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
        workInProgressHook = createWorkInProgressHook();
        if (isReRender) {
          var queue3 = workInProgressHook.queue;
          var dispatch = queue3.dispatch;
          if (renderPhaseUpdates !== null) {
            var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue3);
            if (firstRenderPhaseUpdate !== undefined) {
              renderPhaseUpdates.delete(queue3);
              var newState = workInProgressHook.memoizedState;
              var update = firstRenderPhaseUpdate;
              do {
                var action = update.action;
                {
                  isInHookUserCodeInDev = true;
                }
                newState = reducer(newState, action);
                {
                  isInHookUserCodeInDev = false;
                }
                update = update.next;
              } while (update !== null);
              workInProgressHook.memoizedState = newState;
              return [newState, dispatch];
            }
          }
          return [workInProgressHook.memoizedState, dispatch];
        } else {
          {
            isInHookUserCodeInDev = true;
          }
          var initialState;
          if (reducer === basicStateReducer) {
            initialState = typeof initialArg === "function" ? initialArg() : initialArg;
          } else {
            initialState = init2 !== undefined ? init2(initialArg) : initialArg;
          }
          {
            isInHookUserCodeInDev = false;
          }
          workInProgressHook.memoizedState = initialState;
          var _queue = workInProgressHook.queue = {
            last: null,
            dispatch: null
          };
          var _dispatch = _queue.dispatch = dispatchAction.bind(null, currentlyRenderingComponent, _queue);
          return [workInProgressHook.memoizedState, _dispatch];
        }
      }
      function useMemo(nextCreate, deps) {
        currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
        workInProgressHook = createWorkInProgressHook();
        var nextDeps = deps === undefined ? null : deps;
        if (workInProgressHook !== null) {
          var prevState = workInProgressHook.memoizedState;
          if (prevState !== null) {
            if (nextDeps !== null) {
              var prevDeps = prevState[1];
              if (areHookInputsEqual(nextDeps, prevDeps)) {
                return prevState[0];
              }
            }
          }
        }
        {
          isInHookUserCodeInDev = true;
        }
        var nextValue = nextCreate();
        {
          isInHookUserCodeInDev = false;
        }
        workInProgressHook.memoizedState = [nextValue, nextDeps];
        return nextValue;
      }
      function useRef(initialValue) {
        currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
        workInProgressHook = createWorkInProgressHook();
        var previousRef = workInProgressHook.memoizedState;
        if (previousRef === null) {
          var ref = {
            current: initialValue
          };
          {
            Object.seal(ref);
          }
          workInProgressHook.memoizedState = ref;
          return ref;
        } else {
          return previousRef;
        }
      }
      function useLayoutEffect(create, inputs) {
        {
          currentHookNameInDev = "useLayoutEffect";
          error("useLayoutEffect does nothing on the server, because its effect cannot be encoded into the server renderer's output format. This will lead to a mismatch between the initial, non-hydrated UI and the intended UI. To avoid this, useLayoutEffect should only be used in components that render exclusively on the client. See https://reactjs.org/link/uselayouteffect-ssr for common fixes.");
        }
      }
      function dispatchAction(componentIdentity, queue3, action) {
        if (numberOfReRenders >= RE_RENDER_LIMIT) {
          throw new Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
        }
        if (componentIdentity === currentlyRenderingComponent) {
          didScheduleRenderPhaseUpdate = true;
          var update = {
            action,
            next: null
          };
          if (renderPhaseUpdates === null) {
            renderPhaseUpdates = new Map;
          }
          var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue3);
          if (firstRenderPhaseUpdate === undefined) {
            renderPhaseUpdates.set(queue3, update);
          } else {
            var lastRenderPhaseUpdate = firstRenderPhaseUpdate;
            while (lastRenderPhaseUpdate.next !== null) {
              lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;
            }
            lastRenderPhaseUpdate.next = update;
          }
        }
      }
      function useCallback(callback, deps) {
        return useMemo(function() {
          return callback;
        }, deps);
      }
      function useMutableSource(source, getSnapshot, subscribe2) {
        resolveCurrentlyRenderingComponent();
        return getSnapshot(source._source);
      }
      function useSyncExternalStore(subscribe2, getSnapshot, getServerSnapshot) {
        if (getServerSnapshot === undefined) {
          throw new Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
        }
        return getServerSnapshot();
      }
      function useDeferredValue(value) {
        resolveCurrentlyRenderingComponent();
        return value;
      }
      function unsupportedStartTransition() {
        throw new Error("startTransition cannot be called during server rendering.");
      }
      function useTransition() {
        resolveCurrentlyRenderingComponent();
        return [false, unsupportedStartTransition];
      }
      function useId() {
        var task = currentlyRenderingTask;
        var treeId = getTreeId(task.treeContext);
        var responseState = currentResponseState;
        if (responseState === null) {
          throw new Error("Invalid hook call. Hooks can only be called inside of the body of a function component.");
        }
        var localId = localIdCounter++;
        return makeId(responseState, treeId, localId);
      }
      function noop3() {
      }
      var Dispatcher = {
        readContext: readContext$1,
        useContext,
        useMemo,
        useReducer,
        useRef,
        useState,
        useInsertionEffect: noop3,
        useLayoutEffect,
        useCallback,
        useImperativeHandle: noop3,
        useEffect: noop3,
        useDebugValue: noop3,
        useDeferredValue,
        useTransition,
        useId,
        useMutableSource,
        useSyncExternalStore
      };
      var currentResponseState = null;
      function setCurrentResponseState(responseState) {
        currentResponseState = responseState;
      }
      function getStackByComponentStackNode(componentStack) {
        try {
          var info = "";
          var node = componentStack;
          do {
            switch (node.tag) {
              case 0:
                info += describeBuiltInComponentFrame(node.type, null, null);
                break;
              case 1:
                info += describeFunctionComponentFrame(node.type, null, null);
                break;
              case 2:
                info += describeClassComponentFrame(node.type, null, null);
                break;
            }
            node = node.parent;
          } while (node);
          return info;
        } catch (x) {
          return "\nError generating stack: " + x.message + "\n" + x.stack;
        }
      }
      var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;
      var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
      var PENDING = 0;
      var COMPLETED = 1;
      var FLUSHED = 2;
      var ABORTED = 3;
      var ERRORED = 4;
      var OPEN = 0;
      var CLOSING = 1;
      var CLOSED = 2;
      var DEFAULT_PROGRESSIVE_CHUNK_SIZE = 12800;
      function defaultErrorHandler(error2) {
        console["error"](error2);
        return null;
      }
      function noop$1() {
      }
      function createRequest(children, responseState, rootFormatContext, progressiveChunkSize, onError2, onAllReady, onShellReady, onShellError, onFatalError) {
        var pingedTasks = [];
        var abortSet = new Set;
        var request = {
          destination: null,
          responseState,
          progressiveChunkSize: progressiveChunkSize === undefined ? DEFAULT_PROGRESSIVE_CHUNK_SIZE : progressiveChunkSize,
          status: OPEN,
          fatalError: null,
          nextSegmentId: 0,
          allPendingTasks: 0,
          pendingRootTasks: 0,
          completedRootSegment: null,
          abortableTasks: abortSet,
          pingedTasks,
          clientRenderedBoundaries: [],
          completedBoundaries: [],
          partialBoundaries: [],
          onError: onError2 === undefined ? defaultErrorHandler : onError2,
          onAllReady: onAllReady === undefined ? noop$1 : onAllReady,
          onShellReady: onShellReady === undefined ? noop$1 : onShellReady,
          onShellError: onShellError === undefined ? noop$1 : onShellError,
          onFatalError: onFatalError === undefined ? noop$1 : onFatalError
        };
        var rootSegment = createPendingSegment(request, 0, null, rootFormatContext, false, false);
        rootSegment.parentFlushed = true;
        var rootTask = createTask(request, children, null, rootSegment, abortSet, emptyContextObject, rootContextSnapshot, emptyTreeContext);
        pingedTasks.push(rootTask);
        return request;
      }
      function pingTask(request, task) {
        var pingedTasks = request.pingedTasks;
        pingedTasks.push(task);
        if (pingedTasks.length === 1) {
          scheduleWork(function() {
            return performWork(request);
          });
        }
      }
      function createSuspenseBoundary(request, fallbackAbortableTasks) {
        return {
          id: UNINITIALIZED_SUSPENSE_BOUNDARY_ID,
          rootSegmentID: -1,
          parentFlushed: false,
          pendingTasks: 0,
          forceClientRender: false,
          completedSegments: [],
          byteSize: 0,
          fallbackAbortableTasks,
          errorDigest: null
        };
      }
      function createTask(request, node, blockedBoundary, blockedSegment, abortSet, legacyContext, context, treeContext) {
        request.allPendingTasks++;
        if (blockedBoundary === null) {
          request.pendingRootTasks++;
        } else {
          blockedBoundary.pendingTasks++;
        }
        var task = {
          node,
          ping: function() {
            return pingTask(request, task);
          },
          blockedBoundary,
          blockedSegment,
          abortSet,
          legacyContext,
          context,
          treeContext
        };
        {
          task.componentStack = null;
        }
        abortSet.add(task);
        return task;
      }
      function createPendingSegment(request, index, boundary, formatContext, lastPushedText, textEmbedded) {
        return {
          status: PENDING,
          id: -1,
          index,
          parentFlushed: false,
          chunks: [],
          children: [],
          formatContext,
          boundary,
          lastPushedText,
          textEmbedded
        };
      }
      var currentTaskInDEV = null;
      function getCurrentStackInDEV() {
        {
          if (currentTaskInDEV === null || currentTaskInDEV.componentStack === null) {
            return "";
          }
          return getStackByComponentStackNode(currentTaskInDEV.componentStack);
        }
      }
      function pushBuiltInComponentStackInDEV(task, type) {
        {
          task.componentStack = {
            tag: 0,
            parent: task.componentStack,
            type
          };
        }
      }
      function pushFunctionComponentStackInDEV(task, type) {
        {
          task.componentStack = {
            tag: 1,
            parent: task.componentStack,
            type
          };
        }
      }
      function pushClassComponentStackInDEV(task, type) {
        {
          task.componentStack = {
            tag: 2,
            parent: task.componentStack,
            type
          };
        }
      }
      function popComponentStackInDEV(task) {
        {
          if (task.componentStack === null) {
            error("Unexpectedly popped too many stack frames. This is a bug in React.");
          } else {
            task.componentStack = task.componentStack.parent;
          }
        }
      }
      var lastBoundaryErrorComponentStackDev = null;
      function captureBoundaryErrorDetailsDev(boundary, error2) {
        {
          var errorMessage;
          if (typeof error2 === "string") {
            errorMessage = error2;
          } else if (error2 && typeof error2.message === "string") {
            errorMessage = error2.message;
          } else {
            errorMessage = String(error2);
          }
          var errorComponentStack = lastBoundaryErrorComponentStackDev || getCurrentStackInDEV();
          lastBoundaryErrorComponentStackDev = null;
          boundary.errorMessage = errorMessage;
          boundary.errorComponentStack = errorComponentStack;
        }
      }
      function logRecoverableError(request, error2) {
        var errorDigest = request.onError(error2);
        if (errorDigest != null && typeof errorDigest !== "string") {
          throw new Error("onError returned something with a type other than \"string\". onError should return a string and may return null or undefined but must not return anything else. It received something of type \"" + typeof errorDigest + "\" instead");
        }
        return errorDigest;
      }
      function fatalError(request, error2) {
        var onShellError = request.onShellError;
        onShellError(error2);
        var onFatalError = request.onFatalError;
        onFatalError(error2);
        if (request.destination !== null) {
          request.status = CLOSED;
          closeWithError(request.destination, error2);
        } else {
          request.status = CLOSING;
          request.fatalError = error2;
        }
      }
      function renderSuspenseBoundary(request, task, props) {
        pushBuiltInComponentStackInDEV(task, "Suspense");
        var parentBoundary = task.blockedBoundary;
        var parentSegment = task.blockedSegment;
        var fallback = props.fallback;
        var content = props.children;
        var fallbackAbortSet = new Set;
        var newBoundary = createSuspenseBoundary(request, fallbackAbortSet);
        var insertionIndex = parentSegment.chunks.length;
        var boundarySegment = createPendingSegment(request, insertionIndex, newBoundary, parentSegment.formatContext, false, false);
        parentSegment.children.push(boundarySegment);
        parentSegment.lastPushedText = false;
        var contentRootSegment = createPendingSegment(request, 0, null, parentSegment.formatContext, false, false);
        contentRootSegment.parentFlushed = true;
        task.blockedBoundary = newBoundary;
        task.blockedSegment = contentRootSegment;
        try {
          renderNode(request, task, content);
          pushSegmentFinale$1(contentRootSegment.chunks, request.responseState, contentRootSegment.lastPushedText, contentRootSegment.textEmbedded);
          contentRootSegment.status = COMPLETED;
          queueCompletedSegment(newBoundary, contentRootSegment);
          if (newBoundary.pendingTasks === 0) {
            popComponentStackInDEV(task);
            return;
          }
        } catch (error2) {
          contentRootSegment.status = ERRORED;
          newBoundary.forceClientRender = true;
          newBoundary.errorDigest = logRecoverableError(request, error2);
          {
            captureBoundaryErrorDetailsDev(newBoundary, error2);
          }
        } finally {
          task.blockedBoundary = parentBoundary;
          task.blockedSegment = parentSegment;
        }
        var suspendedFallbackTask = createTask(request, fallback, parentBoundary, boundarySegment, fallbackAbortSet, task.legacyContext, task.context, task.treeContext);
        {
          suspendedFallbackTask.componentStack = task.componentStack;
        }
        request.pingedTasks.push(suspendedFallbackTask);
        popComponentStackInDEV(task);
      }
      function renderHostElement(request, task, type, props) {
        pushBuiltInComponentStackInDEV(task, type);
        var segment = task.blockedSegment;
        var children = pushStartInstance(segment.chunks, type, props, request.responseState, segment.formatContext);
        segment.lastPushedText = false;
        var prevContext = segment.formatContext;
        segment.formatContext = getChildFormatContext(prevContext, type, props);
        renderNode(request, task, children);
        segment.formatContext = prevContext;
        pushEndInstance(segment.chunks, type);
        segment.lastPushedText = false;
        popComponentStackInDEV(task);
      }
      function shouldConstruct$1(Component) {
        return Component.prototype && Component.prototype.isReactComponent;
      }
      function renderWithHooks(request, task, Component, props, secondArg) {
        var componentIdentity = {};
        prepareToUseHooks(task, componentIdentity);
        var result2 = Component(props, secondArg);
        return finishHooks(Component, props, result2, secondArg);
      }
      function finishClassComponent(request, task, instance, Component, props) {
        var nextChildren = instance.render();
        {
          if (instance.props !== props) {
            if (!didWarnAboutReassigningProps) {
              error("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", getComponentNameFromType(Component) || "a component");
            }
            didWarnAboutReassigningProps = true;
          }
        }
        {
          var childContextTypes = Component.childContextTypes;
          if (childContextTypes !== null && childContextTypes !== undefined) {
            var previousContext = task.legacyContext;
            var mergedContext = processChildContext(instance, Component, previousContext, childContextTypes);
            task.legacyContext = mergedContext;
            renderNodeDestructive(request, task, nextChildren);
            task.legacyContext = previousContext;
            return;
          }
        }
        renderNodeDestructive(request, task, nextChildren);
      }
      function renderClassComponent(request, task, Component, props) {
        pushClassComponentStackInDEV(task, Component);
        var maskedContext = getMaskedContext(Component, task.legacyContext);
        var instance = constructClassInstance(Component, props, maskedContext);
        mountClassInstance(instance, Component, props, maskedContext);
        finishClassComponent(request, task, instance, Component, props);
        popComponentStackInDEV(task);
      }
      var didWarnAboutBadClass = {};
      var didWarnAboutModulePatternComponent = {};
      var didWarnAboutContextTypeOnFunctionComponent = {};
      var didWarnAboutGetDerivedStateOnFunctionComponent = {};
      var didWarnAboutReassigningProps = false;
      var didWarnAboutGenerators = false;
      var didWarnAboutMaps = false;
      var hasWarnedAboutUsingContextAsConsumer = false;
      function renderIndeterminateComponent(request, task, Component, props) {
        var legacyContext;
        {
          legacyContext = getMaskedContext(Component, task.legacyContext);
        }
        pushFunctionComponentStackInDEV(task, Component);
        {
          if (Component.prototype && typeof Component.prototype.render === "function") {
            var componentName = getComponentNameFromType(Component) || "Unknown";
            if (!didWarnAboutBadClass[componentName]) {
              error("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", componentName, componentName);
              didWarnAboutBadClass[componentName] = true;
            }
          }
        }
        var value = renderWithHooks(request, task, Component, props, legacyContext);
        var hasId = checkDidRenderIdHook();
        {
          if (typeof value === "object" && value !== null && typeof value.render === "function" && value.$$typeof === undefined) {
            var _componentName = getComponentNameFromType(Component) || "Unknown";
            if (!didWarnAboutModulePatternComponent[_componentName]) {
              error("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", _componentName, _componentName, _componentName);
              didWarnAboutModulePatternComponent[_componentName] = true;
            }
          }
        }
        if (typeof value === "object" && value !== null && typeof value.render === "function" && value.$$typeof === undefined) {
          {
            var _componentName2 = getComponentNameFromType(Component) || "Unknown";
            if (!didWarnAboutModulePatternComponent[_componentName2]) {
              error("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", _componentName2, _componentName2, _componentName2);
              didWarnAboutModulePatternComponent[_componentName2] = true;
            }
          }
          mountClassInstance(value, Component, props, legacyContext);
          finishClassComponent(request, task, value, Component, props);
        } else {
          {
            validateFunctionComponentInDev(Component);
          }
          if (hasId) {
            var prevTreeContext = task.treeContext;
            var totalChildren = 1;
            var index = 0;
            task.treeContext = pushTreeContext(prevTreeContext, totalChildren, index);
            try {
              renderNodeDestructive(request, task, value);
            } finally {
              task.treeContext = prevTreeContext;
            }
          } else {
            renderNodeDestructive(request, task, value);
          }
        }
        popComponentStackInDEV(task);
      }
      function validateFunctionComponentInDev(Component) {
        {
          if (Component) {
            if (Component.childContextTypes) {
              error("%s(...): childContextTypes cannot be defined on a function component.", Component.displayName || Component.name || "Component");
            }
          }
          if (typeof Component.getDerivedStateFromProps === "function") {
            var _componentName3 = getComponentNameFromType(Component) || "Unknown";
            if (!didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3]) {
              error("%s: Function components do not support getDerivedStateFromProps.", _componentName3);
              didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3] = true;
            }
          }
          if (typeof Component.contextType === "object" && Component.contextType !== null) {
            var _componentName4 = getComponentNameFromType(Component) || "Unknown";
            if (!didWarnAboutContextTypeOnFunctionComponent[_componentName4]) {
              error("%s: Function components do not support contextType.", _componentName4);
              didWarnAboutContextTypeOnFunctionComponent[_componentName4] = true;
            }
          }
        }
      }
      function resolveDefaultProps(Component, baseProps) {
        if (Component && Component.defaultProps) {
          var props = assign({}, baseProps);
          var defaultProps = Component.defaultProps;
          for (var propName in defaultProps) {
            if (props[propName] === undefined) {
              props[propName] = defaultProps[propName];
            }
          }
          return props;
        }
        return baseProps;
      }
      function renderForwardRef(request, task, type, props, ref) {
        pushFunctionComponentStackInDEV(task, type.render);
        var children = renderWithHooks(request, task, type.render, props, ref);
        var hasId = checkDidRenderIdHook();
        if (hasId) {
          var prevTreeContext = task.treeContext;
          var totalChildren = 1;
          var index = 0;
          task.treeContext = pushTreeContext(prevTreeContext, totalChildren, index);
          try {
            renderNodeDestructive(request, task, children);
          } finally {
            task.treeContext = prevTreeContext;
          }
        } else {
          renderNodeDestructive(request, task, children);
        }
        popComponentStackInDEV(task);
      }
      function renderMemo(request, task, type, props, ref) {
        var innerType = type.type;
        var resolvedProps = resolveDefaultProps(innerType, props);
        renderElement(request, task, innerType, resolvedProps, ref);
      }
      function renderContextConsumer(request, task, context, props) {
        {
          if (context._context === undefined) {
            if (context !== context.Consumer) {
              if (!hasWarnedAboutUsingContextAsConsumer) {
                hasWarnedAboutUsingContextAsConsumer = true;
                error("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?");
              }
            }
          } else {
            context = context._context;
          }
        }
        var render = props.children;
        {
          if (typeof render !== "function") {
            error("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it.");
          }
        }
        var newValue = readContext(context);
        var newChildren = render(newValue);
        renderNodeDestructive(request, task, newChildren);
      }
      function renderContextProvider(request, task, type, props) {
        var context = type._context;
        var value = props.value;
        var children = props.children;
        var prevSnapshot;
        {
          prevSnapshot = task.context;
        }
        task.context = pushProvider(context, value);
        renderNodeDestructive(request, task, children);
        task.context = popProvider(context);
        {
          if (prevSnapshot !== task.context) {
            error("Popping the context provider did not return back to the original snapshot. This is a bug in React.");
          }
        }
      }
      function renderLazyComponent(request, task, lazyComponent, props, ref) {
        pushBuiltInComponentStackInDEV(task, "Lazy");
        var payload = lazyComponent._payload;
        var init2 = lazyComponent._init;
        var Component = init2(payload);
        var resolvedProps = resolveDefaultProps(Component, props);
        renderElement(request, task, Component, resolvedProps, ref);
        popComponentStackInDEV(task);
      }
      function renderElement(request, task, type, props, ref) {
        if (typeof type === "function") {
          if (shouldConstruct$1(type)) {
            renderClassComponent(request, task, type, props);
            return;
          } else {
            renderIndeterminateComponent(request, task, type, props);
            return;
          }
        }
        if (typeof type === "string") {
          renderHostElement(request, task, type, props);
          return;
        }
        switch (type) {
          case REACT_LEGACY_HIDDEN_TYPE:
          case REACT_DEBUG_TRACING_MODE_TYPE:
          case REACT_STRICT_MODE_TYPE:
          case REACT_PROFILER_TYPE:
          case REACT_FRAGMENT_TYPE: {
            renderNodeDestructive(request, task, props.children);
            return;
          }
          case REACT_SUSPENSE_LIST_TYPE: {
            pushBuiltInComponentStackInDEV(task, "SuspenseList");
            renderNodeDestructive(request, task, props.children);
            popComponentStackInDEV(task);
            return;
          }
          case REACT_SCOPE_TYPE: {
            throw new Error("ReactDOMServer does not yet support scope components.");
          }
          case REACT_SUSPENSE_TYPE: {
            {
              renderSuspenseBoundary(request, task, props);
            }
            return;
          }
        }
        if (typeof type === "object" && type !== null) {
          switch (type.$$typeof) {
            case REACT_FORWARD_REF_TYPE: {
              renderForwardRef(request, task, type, props, ref);
              return;
            }
            case REACT_MEMO_TYPE: {
              renderMemo(request, task, type, props, ref);
              return;
            }
            case REACT_PROVIDER_TYPE: {
              renderContextProvider(request, task, type, props);
              return;
            }
            case REACT_CONTEXT_TYPE: {
              renderContextConsumer(request, task, type, props);
              return;
            }
            case REACT_LAZY_TYPE: {
              renderLazyComponent(request, task, type, props);
              return;
            }
          }
        }
        var info = "";
        {
          if (type === undefined || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
            info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
          }
        }
        throw new Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) " + ("but got: " + (type == null ? type : typeof type) + "." + info));
      }
      function validateIterable(iterable, iteratorFn) {
        {
          if (typeof Symbol === "function" && iterable[Symbol.toStringTag] === "Generator") {
            if (!didWarnAboutGenerators) {
              error("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers.");
            }
            didWarnAboutGenerators = true;
          }
          if (iterable.entries === iteratorFn) {
            if (!didWarnAboutMaps) {
              error("Using Maps as children is not supported. Use an array of keyed ReactElements instead.");
            }
            didWarnAboutMaps = true;
          }
        }
      }
      function renderNodeDestructive(request, task, node) {
        {
          try {
            return renderNodeDestructiveImpl(request, task, node);
          } catch (x) {
            if (typeof x === "object" && x !== null && typeof x.then === "function")
              ;
            else {
              lastBoundaryErrorComponentStackDev = lastBoundaryErrorComponentStackDev !== null ? lastBoundaryErrorComponentStackDev : getCurrentStackInDEV();
            }
            throw x;
          }
        }
      }
      function renderNodeDestructiveImpl(request, task, node) {
        task.node = node;
        if (typeof node === "object" && node !== null) {
          switch (node.$$typeof) {
            case REACT_ELEMENT_TYPE: {
              var element = node;
              var type = element.type;
              var props = element.props;
              var ref = element.ref;
              renderElement(request, task, type, props, ref);
              return;
            }
            case REACT_PORTAL_TYPE:
              throw new Error("Portals are not currently supported by the server renderer. Render them conditionally so that they only appear on the client render.");
            case REACT_LAZY_TYPE: {
              var lazyNode = node;
              var payload = lazyNode._payload;
              var init2 = lazyNode._init;
              var resolvedNode;
              {
                try {
                  resolvedNode = init2(payload);
                } catch (x) {
                  if (typeof x === "object" && x !== null && typeof x.then === "function") {
                    pushBuiltInComponentStackInDEV(task, "Lazy");
                  }
                  throw x;
                }
              }
              renderNodeDestructive(request, task, resolvedNode);
              return;
            }
          }
          if (isArray(node)) {
            renderChildrenArray(request, task, node);
            return;
          }
          var iteratorFn = getIteratorFn(node);
          if (iteratorFn) {
            {
              validateIterable(node, iteratorFn);
            }
            var iterator = iteratorFn.call(node);
            if (iterator) {
              var step = iterator.next();
              if (!step.done) {
                var children = [];
                do {
                  children.push(step.value);
                  step = iterator.next();
                } while (!step.done);
                renderChildrenArray(request, task, children);
                return;
              }
              return;
            }
          }
          var childString = Object.prototype.toString.call(node);
          throw new Error("Objects are not valid as a React child (found: " + (childString === "[object Object]" ? "object with keys {" + Object.keys(node).join(", ") + "}" : childString) + "). If you meant to render a collection of children, use an array instead.");
        }
        if (typeof node === "string") {
          var segment = task.blockedSegment;
          segment.lastPushedText = pushTextInstance$1(task.blockedSegment.chunks, node, request.responseState, segment.lastPushedText);
          return;
        }
        if (typeof node === "number") {
          var _segment = task.blockedSegment;
          _segment.lastPushedText = pushTextInstance$1(task.blockedSegment.chunks, "" + node, request.responseState, _segment.lastPushedText);
          return;
        }
        {
          if (typeof node === "function") {
            error("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
          }
        }
      }
      function renderChildrenArray(request, task, children) {
        var totalChildren = children.length;
        for (var i = 0;i < totalChildren; i++) {
          var prevTreeContext = task.treeContext;
          task.treeContext = pushTreeContext(prevTreeContext, totalChildren, i);
          try {
            renderNode(request, task, children[i]);
          } finally {
            task.treeContext = prevTreeContext;
          }
        }
      }
      function spawnNewSuspendedTask(request, task, x) {
        var segment = task.blockedSegment;
        var insertionIndex = segment.chunks.length;
        var newSegment = createPendingSegment(request, insertionIndex, null, segment.formatContext, segment.lastPushedText, true);
        segment.children.push(newSegment);
        segment.lastPushedText = false;
        var newTask = createTask(request, task.node, task.blockedBoundary, newSegment, task.abortSet, task.legacyContext, task.context, task.treeContext);
        {
          if (task.componentStack !== null) {
            newTask.componentStack = task.componentStack.parent;
          }
        }
        var ping = newTask.ping;
        x.then(ping, ping);
      }
      function renderNode(request, task, node) {
        var previousFormatContext = task.blockedSegment.formatContext;
        var previousLegacyContext = task.legacyContext;
        var previousContext = task.context;
        var previousComponentStack = null;
        {
          previousComponentStack = task.componentStack;
        }
        try {
          return renderNodeDestructive(request, task, node);
        } catch (x) {
          resetHooksState();
          if (typeof x === "object" && x !== null && typeof x.then === "function") {
            spawnNewSuspendedTask(request, task, x);
            task.blockedSegment.formatContext = previousFormatContext;
            task.legacyContext = previousLegacyContext;
            task.context = previousContext;
            switchContext(previousContext);
            {
              task.componentStack = previousComponentStack;
            }
            return;
          } else {
            task.blockedSegment.formatContext = previousFormatContext;
            task.legacyContext = previousLegacyContext;
            task.context = previousContext;
            switchContext(previousContext);
            {
              task.componentStack = previousComponentStack;
            }
            throw x;
          }
        }
      }
      function erroredTask(request, boundary, segment, error2) {
        var errorDigest = logRecoverableError(request, error2);
        if (boundary === null) {
          fatalError(request, error2);
        } else {
          boundary.pendingTasks--;
          if (!boundary.forceClientRender) {
            boundary.forceClientRender = true;
            boundary.errorDigest = errorDigest;
            {
              captureBoundaryErrorDetailsDev(boundary, error2);
            }
            if (boundary.parentFlushed) {
              request.clientRenderedBoundaries.push(boundary);
            }
          }
        }
        request.allPendingTasks--;
        if (request.allPendingTasks === 0) {
          var onAllReady = request.onAllReady;
          onAllReady();
        }
      }
      function abortTaskSoft(task) {
        var request = this;
        var boundary = task.blockedBoundary;
        var segment = task.blockedSegment;
        segment.status = ABORTED;
        finishedTask(request, boundary, segment);
      }
      function abortTask(task, request, reason) {
        var boundary = task.blockedBoundary;
        var segment = task.blockedSegment;
        segment.status = ABORTED;
        if (boundary === null) {
          request.allPendingTasks--;
          if (request.status !== CLOSED) {
            request.status = CLOSED;
            if (request.destination !== null) {
              close(request.destination);
            }
          }
        } else {
          boundary.pendingTasks--;
          if (!boundary.forceClientRender) {
            boundary.forceClientRender = true;
            var _error = reason === undefined ? new Error("The render was aborted by the server without a reason.") : reason;
            boundary.errorDigest = request.onError(_error);
            {
              var errorPrefix = "The server did not finish this Suspense boundary: ";
              if (_error && typeof _error.message === "string") {
                _error = errorPrefix + _error.message;
              } else {
                _error = errorPrefix + String(_error);
              }
              var previousTaskInDev = currentTaskInDEV;
              currentTaskInDEV = task;
              try {
                captureBoundaryErrorDetailsDev(boundary, _error);
              } finally {
                currentTaskInDEV = previousTaskInDev;
              }
            }
            if (boundary.parentFlushed) {
              request.clientRenderedBoundaries.push(boundary);
            }
          }
          boundary.fallbackAbortableTasks.forEach(function(fallbackTask) {
            return abortTask(fallbackTask, request, reason);
          });
          boundary.fallbackAbortableTasks.clear();
          request.allPendingTasks--;
          if (request.allPendingTasks === 0) {
            var onAllReady = request.onAllReady;
            onAllReady();
          }
        }
      }
      function queueCompletedSegment(boundary, segment) {
        if (segment.chunks.length === 0 && segment.children.length === 1 && segment.children[0].boundary === null) {
          var childSegment = segment.children[0];
          childSegment.id = segment.id;
          childSegment.parentFlushed = true;
          if (childSegment.status === COMPLETED) {
            queueCompletedSegment(boundary, childSegment);
          }
        } else {
          var completedSegments = boundary.completedSegments;
          completedSegments.push(segment);
        }
      }
      function finishedTask(request, boundary, segment) {
        if (boundary === null) {
          if (segment.parentFlushed) {
            if (request.completedRootSegment !== null) {
              throw new Error("There can only be one root segment. This is a bug in React.");
            }
            request.completedRootSegment = segment;
          }
          request.pendingRootTasks--;
          if (request.pendingRootTasks === 0) {
            request.onShellError = noop$1;
            var onShellReady = request.onShellReady;
            onShellReady();
          }
        } else {
          boundary.pendingTasks--;
          if (boundary.forceClientRender)
            ;
          else if (boundary.pendingTasks === 0) {
            if (segment.parentFlushed) {
              if (segment.status === COMPLETED) {
                queueCompletedSegment(boundary, segment);
              }
            }
            if (boundary.parentFlushed) {
              request.completedBoundaries.push(boundary);
            }
            boundary.fallbackAbortableTasks.forEach(abortTaskSoft, request);
            boundary.fallbackAbortableTasks.clear();
          } else {
            if (segment.parentFlushed) {
              if (segment.status === COMPLETED) {
                queueCompletedSegment(boundary, segment);
                var completedSegments = boundary.completedSegments;
                if (completedSegments.length === 1) {
                  if (boundary.parentFlushed) {
                    request.partialBoundaries.push(boundary);
                  }
                }
              }
            }
          }
        }
        request.allPendingTasks--;
        if (request.allPendingTasks === 0) {
          var onAllReady = request.onAllReady;
          onAllReady();
        }
      }
      function retryTask(request, task) {
        var segment = task.blockedSegment;
        if (segment.status !== PENDING) {
          return;
        }
        switchContext(task.context);
        var prevTaskInDEV = null;
        {
          prevTaskInDEV = currentTaskInDEV;
          currentTaskInDEV = task;
        }
        try {
          renderNodeDestructive(request, task, task.node);
          pushSegmentFinale$1(segment.chunks, request.responseState, segment.lastPushedText, segment.textEmbedded);
          task.abortSet.delete(task);
          segment.status = COMPLETED;
          finishedTask(request, task.blockedBoundary, segment);
        } catch (x) {
          resetHooksState();
          if (typeof x === "object" && x !== null && typeof x.then === "function") {
            var ping = task.ping;
            x.then(ping, ping);
          } else {
            task.abortSet.delete(task);
            segment.status = ERRORED;
            erroredTask(request, task.blockedBoundary, segment, x);
          }
        } finally {
          {
            currentTaskInDEV = prevTaskInDEV;
          }
        }
      }
      function performWork(request) {
        if (request.status === CLOSED) {
          return;
        }
        var prevContext = getActiveContext();
        var prevDispatcher = ReactCurrentDispatcher$1.current;
        ReactCurrentDispatcher$1.current = Dispatcher;
        var prevGetCurrentStackImpl;
        {
          prevGetCurrentStackImpl = ReactDebugCurrentFrame$1.getCurrentStack;
          ReactDebugCurrentFrame$1.getCurrentStack = getCurrentStackInDEV;
        }
        var prevResponseState = currentResponseState;
        setCurrentResponseState(request.responseState);
        try {
          var pingedTasks = request.pingedTasks;
          var i;
          for (i = 0;i < pingedTasks.length; i++) {
            var task = pingedTasks[i];
            retryTask(request, task);
          }
          pingedTasks.splice(0, i);
          if (request.destination !== null) {
            flushCompletedQueues(request, request.destination);
          }
        } catch (error2) {
          logRecoverableError(request, error2);
          fatalError(request, error2);
        } finally {
          setCurrentResponseState(prevResponseState);
          ReactCurrentDispatcher$1.current = prevDispatcher;
          {
            ReactDebugCurrentFrame$1.getCurrentStack = prevGetCurrentStackImpl;
          }
          if (prevDispatcher === Dispatcher) {
            switchContext(prevContext);
          }
        }
      }
      function flushSubtree(request, destination, segment) {
        segment.parentFlushed = true;
        switch (segment.status) {
          case PENDING: {
            var segmentID = segment.id = request.nextSegmentId++;
            segment.lastPushedText = false;
            segment.textEmbedded = false;
            return writePlaceholder(destination, request.responseState, segmentID);
          }
          case COMPLETED: {
            segment.status = FLUSHED;
            var r = true;
            var chunks = segment.chunks;
            var chunkIdx = 0;
            var children = segment.children;
            for (var childIdx = 0;childIdx < children.length; childIdx++) {
              var nextChild = children[childIdx];
              for (;chunkIdx < nextChild.index; chunkIdx++) {
                writeChunk(destination, chunks[chunkIdx]);
              }
              r = flushSegment(request, destination, nextChild);
            }
            for (;chunkIdx < chunks.length - 1; chunkIdx++) {
              writeChunk(destination, chunks[chunkIdx]);
            }
            if (chunkIdx < chunks.length) {
              r = writeChunkAndReturn(destination, chunks[chunkIdx]);
            }
            return r;
          }
          default: {
            throw new Error("Aborted, errored or already flushed boundaries should not be flushed again. This is a bug in React.");
          }
        }
      }
      function flushSegment(request, destination, segment) {
        var boundary = segment.boundary;
        if (boundary === null) {
          return flushSubtree(request, destination, segment);
        }
        boundary.parentFlushed = true;
        if (boundary.forceClientRender) {
          writeStartClientRenderedSuspenseBoundary$1(destination, request.responseState, boundary.errorDigest, boundary.errorMessage, boundary.errorComponentStack);
          flushSubtree(request, destination, segment);
          return writeEndClientRenderedSuspenseBoundary$1(destination, request.responseState);
        } else if (boundary.pendingTasks > 0) {
          boundary.rootSegmentID = request.nextSegmentId++;
          if (boundary.completedSegments.length > 0) {
            request.partialBoundaries.push(boundary);
          }
          var id = boundary.id = assignSuspenseBoundaryID(request.responseState);
          writeStartPendingSuspenseBoundary(destination, request.responseState, id);
          flushSubtree(request, destination, segment);
          return writeEndPendingSuspenseBoundary(destination, request.responseState);
        } else if (boundary.byteSize > request.progressiveChunkSize) {
          boundary.rootSegmentID = request.nextSegmentId++;
          request.completedBoundaries.push(boundary);
          writeStartPendingSuspenseBoundary(destination, request.responseState, boundary.id);
          flushSubtree(request, destination, segment);
          return writeEndPendingSuspenseBoundary(destination, request.responseState);
        } else {
          writeStartCompletedSuspenseBoundary$1(destination, request.responseState);
          var completedSegments = boundary.completedSegments;
          if (completedSegments.length !== 1) {
            throw new Error("A previously unvisited boundary must have exactly one root segment. This is a bug in React.");
          }
          var contentSegment = completedSegments[0];
          flushSegment(request, destination, contentSegment);
          return writeEndCompletedSuspenseBoundary$1(destination, request.responseState);
        }
      }
      function flushClientRenderedBoundary(request, destination, boundary) {
        return writeClientRenderBoundaryInstruction(destination, request.responseState, boundary.id, boundary.errorDigest, boundary.errorMessage, boundary.errorComponentStack);
      }
      function flushSegmentContainer(request, destination, segment) {
        writeStartSegment(destination, request.responseState, segment.formatContext, segment.id);
        flushSegment(request, destination, segment);
        return writeEndSegment(destination, segment.formatContext);
      }
      function flushCompletedBoundary(request, destination, boundary) {
        var completedSegments = boundary.completedSegments;
        var i = 0;
        for (;i < completedSegments.length; i++) {
          var segment = completedSegments[i];
          flushPartiallyCompletedSegment(request, destination, boundary, segment);
        }
        completedSegments.length = 0;
        return writeCompletedBoundaryInstruction(destination, request.responseState, boundary.id, boundary.rootSegmentID);
      }
      function flushPartialBoundary(request, destination, boundary) {
        var completedSegments = boundary.completedSegments;
        var i = 0;
        for (;i < completedSegments.length; i++) {
          var segment = completedSegments[i];
          if (!flushPartiallyCompletedSegment(request, destination, boundary, segment)) {
            i++;
            completedSegments.splice(0, i);
            return false;
          }
        }
        completedSegments.splice(0, i);
        return true;
      }
      function flushPartiallyCompletedSegment(request, destination, boundary, segment) {
        if (segment.status === FLUSHED) {
          return true;
        }
        var segmentID = segment.id;
        if (segmentID === -1) {
          var rootSegmentID = segment.id = boundary.rootSegmentID;
          if (rootSegmentID === -1) {
            throw new Error("A root segment ID must have been assigned by now. This is a bug in React.");
          }
          return flushSegmentContainer(request, destination, segment);
        } else {
          flushSegmentContainer(request, destination, segment);
          return writeCompletedSegmentInstruction(destination, request.responseState, segmentID);
        }
      }
      function flushCompletedQueues(request, destination) {
        try {
          var completedRootSegment = request.completedRootSegment;
          if (completedRootSegment !== null && request.pendingRootTasks === 0) {
            flushSegment(request, destination, completedRootSegment);
            request.completedRootSegment = null;
            writeCompletedRoot(destination, request.responseState);
          }
          var clientRenderedBoundaries = request.clientRenderedBoundaries;
          var i;
          for (i = 0;i < clientRenderedBoundaries.length; i++) {
            var boundary = clientRenderedBoundaries[i];
            if (!flushClientRenderedBoundary(request, destination, boundary)) {
              request.destination = null;
              i++;
              clientRenderedBoundaries.splice(0, i);
              return;
            }
          }
          clientRenderedBoundaries.splice(0, i);
          var completedBoundaries = request.completedBoundaries;
          for (i = 0;i < completedBoundaries.length; i++) {
            var _boundary = completedBoundaries[i];
            if (!flushCompletedBoundary(request, destination, _boundary)) {
              request.destination = null;
              i++;
              completedBoundaries.splice(0, i);
              return;
            }
          }
          completedBoundaries.splice(0, i);
          completeWriting(destination);
          beginWriting(destination);
          var partialBoundaries = request.partialBoundaries;
          for (i = 0;i < partialBoundaries.length; i++) {
            var _boundary2 = partialBoundaries[i];
            if (!flushPartialBoundary(request, destination, _boundary2)) {
              request.destination = null;
              i++;
              partialBoundaries.splice(0, i);
              return;
            }
          }
          partialBoundaries.splice(0, i);
          var largeBoundaries = request.completedBoundaries;
          for (i = 0;i < largeBoundaries.length; i++) {
            var _boundary3 = largeBoundaries[i];
            if (!flushCompletedBoundary(request, destination, _boundary3)) {
              request.destination = null;
              i++;
              largeBoundaries.splice(0, i);
              return;
            }
          }
          largeBoundaries.splice(0, i);
        } finally {
          if (request.allPendingTasks === 0 && request.pingedTasks.length === 0 && request.clientRenderedBoundaries.length === 0 && request.completedBoundaries.length === 0) {
            {
              if (request.abortableTasks.size !== 0) {
                error("There was still abortable task at the root when we closed. This is a bug in React.");
              }
            }
            close(destination);
          }
        }
      }
      function startWork(request) {
        scheduleWork(function() {
          return performWork(request);
        });
      }
      function startFlowing(request, destination) {
        if (request.status === CLOSING) {
          request.status = CLOSED;
          closeWithError(destination, request.fatalError);
          return;
        }
        if (request.status === CLOSED) {
          return;
        }
        if (request.destination !== null) {
          return;
        }
        request.destination = destination;
        try {
          flushCompletedQueues(request, destination);
        } catch (error2) {
          logRecoverableError(request, error2);
          fatalError(request, error2);
        }
      }
      function abort(request, reason) {
        try {
          var abortableTasks = request.abortableTasks;
          abortableTasks.forEach(function(task) {
            return abortTask(task, request, reason);
          });
          abortableTasks.clear();
          if (request.destination !== null) {
            flushCompletedQueues(request, request.destination);
          }
        } catch (error2) {
          logRecoverableError(request, error2);
          fatalError(request, error2);
        }
      }
      function onError() {
      }
      function renderToStringImpl(children, options, generateStaticMarkup, abortReason) {
        var didFatal = false;
        var fatalError2 = null;
        var result2 = "";
        var destination = {
          push: function(chunk) {
            if (chunk !== null) {
              result2 += chunk;
            }
            return true;
          },
          destroy: function(error2) {
            didFatal = true;
            fatalError2 = error2;
          }
        };
        var readyToStream = false;
        function onShellReady() {
          readyToStream = true;
        }
        var request = createRequest(children, createResponseState$1(generateStaticMarkup, options ? options.identifierPrefix : undefined), createRootFormatContext(), Infinity, onError, undefined, onShellReady, undefined, undefined);
        startWork(request);
        abort(request, abortReason);
        startFlowing(request, destination);
        if (didFatal) {
          throw fatalError2;
        }
        if (!readyToStream) {
          throw new Error("A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition.");
        }
        return result2;
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }
      var ReactMarkupReadableStream = function(_Readable) {
        _inheritsLoose(ReactMarkupReadableStream2, _Readable);
        function ReactMarkupReadableStream2() {
          var _this;
          _this = _Readable.call(this, {}) || this;
          _this.request = null;
          _this.startedFlowing = false;
          return _this;
        }
        var _proto = ReactMarkupReadableStream2.prototype;
        _proto._destroy = function _destroy(err, callback) {
          abort(this.request);
          callback(err);
        };
        _proto._read = function _read(size2) {
          if (this.startedFlowing) {
            startFlowing(this.request, this);
          }
        };
        return ReactMarkupReadableStream2;
      }(stream.Readable);
      function onError$1() {
      }
      function renderToNodeStreamImpl(children, options, generateStaticMarkup) {
        function onAllReady() {
          destination.startedFlowing = true;
          startFlowing(request, destination);
        }
        var destination = new ReactMarkupReadableStream;
        var request = createRequest(children, createResponseState$1(false, options ? options.identifierPrefix : undefined), createRootFormatContext(), Infinity, onError$1, onAllReady, undefined, undefined);
        destination.request = request;
        startWork(request);
        return destination;
      }
      function renderToNodeStream(children, options) {
        {
          error("renderToNodeStream is deprecated. Use renderToPipeableStream instead.");
        }
        return renderToNodeStreamImpl(children, options);
      }
      function renderToStaticNodeStream(children, options) {
        return renderToNodeStreamImpl(children, options);
      }
      function renderToString(children, options) {
        return renderToStringImpl(children, options, false, 'The server used "renderToString" which does not support Suspense. If you intended for this Suspense boundary to render the fallback content on the server consider throwing an Error somewhere within the Suspense boundary. If you intended to have the server wait for the suspended component please switch to "renderToPipeableStream" which supports Suspense on the server');
      }
      function renderToStaticMarkup(children, options) {
        return renderToStringImpl(children, options, true, 'The server used "renderToStaticMarkup" which does not support Suspense. If you intended to have the server wait for the suspended component please switch to "renderToPipeableStream" which supports Suspense on the server');
      }
      exports.renderToNodeStream = renderToNodeStream;
      exports.renderToStaticMarkup = renderToStaticMarkup;
      exports.renderToStaticNodeStream = renderToStaticNodeStream;
      exports.renderToString = renderToString;
      exports.version = ReactVersion;
    })();
  }
});

// node_modules/react-dom/cjs/react-dom-server.node.development.js
var require_react_dom_server_node_development = __commonJS((exports) => {
  var React = __toESM(require_react(), 1);
  if (true) {
    (function() {
      var util2 = import.meta.require("util");
      var ReactVersion = "18.2.0";
      var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
      function warn(format) {
        {
          {
            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1;_key < _len; _key++) {
              args[_key - 1] = arguments[_key];
            }
            printWarning("warn", format, args);
          }
        }
      }
      function error(format) {
        {
          {
            for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1;_key2 < _len2; _key2++) {
              args[_key2 - 1] = arguments[_key2];
            }
            printWarning("error", format, args);
          }
        }
      }
      function printWarning(level, format, args) {
        {
          var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
          var stack = ReactDebugCurrentFrame2.getStackAddendum();
          if (stack !== "") {
            format += "%s";
            args = args.concat([stack]);
          }
          var argsWithFormat = args.map(function(item) {
            return String(item);
          });
          argsWithFormat.unshift("Warning: " + format);
          Function.prototype.apply.call(console[level], console, argsWithFormat);
        }
      }
      function scheduleWork(callback) {
        setImmediate(callback);
      }
      function flushBuffered(destination) {
        if (typeof destination.flush === "function") {
          destination.flush();
        }
      }
      var VIEW_SIZE = 2048;
      var currentView = null;
      var writtenBytes = 0;
      var destinationHasCapacity = true;
      function beginWriting(destination) {
        currentView = new Uint8Array(VIEW_SIZE);
        writtenBytes = 0;
        destinationHasCapacity = true;
      }
      function writeStringChunk(destination, stringChunk) {
        if (stringChunk.length === 0) {
          return;
        }
        if (stringChunk.length * 3 > VIEW_SIZE) {
          if (writtenBytes > 0) {
            writeToDestination(destination, currentView.subarray(0, writtenBytes));
            currentView = new Uint8Array(VIEW_SIZE);
            writtenBytes = 0;
          }
          writeToDestination(destination, textEncoder.encode(stringChunk));
          return;
        }
        var target = currentView;
        if (writtenBytes > 0) {
          target = currentView.subarray(writtenBytes);
        }
        var _textEncoder$encodeIn = textEncoder.encodeInto(stringChunk, target), read = _textEncoder$encodeIn.read, written = _textEncoder$encodeIn.written;
        writtenBytes += written;
        if (read < stringChunk.length) {
          writeToDestination(destination, currentView);
          currentView = new Uint8Array(VIEW_SIZE);
          writtenBytes = textEncoder.encodeInto(stringChunk.slice(read), currentView).written;
        }
        if (writtenBytes === VIEW_SIZE) {
          writeToDestination(destination, currentView);
          currentView = new Uint8Array(VIEW_SIZE);
          writtenBytes = 0;
        }
      }
      function writeViewChunk(destination, chunk) {
        if (chunk.byteLength === 0) {
          return;
        }
        if (chunk.byteLength > VIEW_SIZE) {
          if (writtenBytes > 0) {
            writeToDestination(destination, currentView.subarray(0, writtenBytes));
            currentView = new Uint8Array(VIEW_SIZE);
            writtenBytes = 0;
          }
          writeToDestination(destination, chunk);
          return;
        }
        var bytesToWrite = chunk;
        var allowableBytes = currentView.length - writtenBytes;
        if (allowableBytes < bytesToWrite.byteLength) {
          if (allowableBytes === 0) {
            writeToDestination(destination, currentView);
          } else {
            currentView.set(bytesToWrite.subarray(0, allowableBytes), writtenBytes);
            writtenBytes += allowableBytes;
            writeToDestination(destination, currentView);
            bytesToWrite = bytesToWrite.subarray(allowableBytes);
          }
          currentView = new Uint8Array(VIEW_SIZE);
          writtenBytes = 0;
        }
        currentView.set(bytesToWrite, writtenBytes);
        writtenBytes += bytesToWrite.byteLength;
        if (writtenBytes === VIEW_SIZE) {
          writeToDestination(destination, currentView);
          currentView = new Uint8Array(VIEW_SIZE);
          writtenBytes = 0;
        }
      }
      function writeChunk(destination, chunk) {
        if (typeof chunk === "string") {
          writeStringChunk(destination, chunk);
        } else {
          writeViewChunk(destination, chunk);
        }
      }
      function writeToDestination(destination, view) {
        var currentHasCapacity = destination.write(view);
        destinationHasCapacity = destinationHasCapacity && currentHasCapacity;
      }
      function writeChunkAndReturn(destination, chunk) {
        writeChunk(destination, chunk);
        return destinationHasCapacity;
      }
      function completeWriting(destination) {
        if (currentView && writtenBytes > 0) {
          destination.write(currentView.subarray(0, writtenBytes));
        }
        currentView = null;
        writtenBytes = 0;
        destinationHasCapacity = true;
      }
      function close(destination) {
        destination.end();
      }
      var textEncoder = new util2.TextEncoder;
      function stringToChunk(content) {
        return content;
      }
      function stringToPrecomputedChunk(content) {
        return textEncoder.encode(content);
      }
      function closeWithError(destination, error2) {
        destination.destroy(error2);
      }
      function typeName(value) {
        {
          var hasToStringTag = typeof Symbol === "function" && Symbol.toStringTag;
          var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
          return type;
        }
      }
      function willCoercionThrow(value) {
        {
          try {
            testStringCoercion(value);
            return false;
          } catch (e) {
            return true;
          }
        }
      }
      function testStringCoercion(value) {
        return "" + value;
      }
      function checkAttributeStringCoercion(value, attributeName) {
        {
          if (willCoercionThrow(value)) {
            error("The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before before using it here.", attributeName, typeName(value));
            return testStringCoercion(value);
          }
        }
      }
      function checkCSSPropertyStringCoercion(value, propName) {
        {
          if (willCoercionThrow(value)) {
            error("The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before before using it here.", propName, typeName(value));
            return testStringCoercion(value);
          }
        }
      }
      function checkHtmlStringCoercion(value) {
        {
          if (willCoercionThrow(value)) {
            error("The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value));
            return testStringCoercion(value);
          }
        }
      }
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      var RESERVED = 0;
      var STRING = 1;
      var BOOLEANISH_STRING = 2;
      var BOOLEAN = 3;
      var OVERLOADED_BOOLEAN = 4;
      var NUMERIC = 5;
      var POSITIVE_NUMERIC = 6;
      var ATTRIBUTE_NAME_START_CHAR = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
      var ATTRIBUTE_NAME_CHAR = ATTRIBUTE_NAME_START_CHAR + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
      var VALID_ATTRIBUTE_NAME_REGEX = new RegExp("^[" + ATTRIBUTE_NAME_START_CHAR + "][" + ATTRIBUTE_NAME_CHAR + "]*$");
      var illegalAttributeNameCache = {};
      var validatedAttributeNameCache = {};
      function isAttributeNameSafe(attributeName) {
        if (hasOwnProperty.call(validatedAttributeNameCache, attributeName)) {
          return true;
        }
        if (hasOwnProperty.call(illegalAttributeNameCache, attributeName)) {
          return false;
        }
        if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
          validatedAttributeNameCache[attributeName] = true;
          return true;
        }
        illegalAttributeNameCache[attributeName] = true;
        {
          error("Invalid attribute name: `%s`", attributeName);
        }
        return false;
      }
      function shouldRemoveAttributeWithWarning(name, value, propertyInfo, isCustomComponentTag) {
        if (propertyInfo !== null && propertyInfo.type === RESERVED) {
          return false;
        }
        switch (typeof value) {
          case "function":
          case "symbol":
            return true;
          case "boolean": {
            if (isCustomComponentTag) {
              return false;
            }
            if (propertyInfo !== null) {
              return !propertyInfo.acceptsBooleans;
            } else {
              var prefix2 = name.toLowerCase().slice(0, 5);
              return prefix2 !== "data-" && prefix2 !== "aria-";
            }
          }
          default:
            return false;
        }
      }
      function getPropertyInfo(name) {
        return properties.hasOwnProperty(name) ? properties[name] : null;
      }
      function PropertyInfoRecord(name, type, mustUseProperty, attributeName, attributeNamespace, sanitizeURL2, removeEmptyString) {
        this.acceptsBooleans = type === BOOLEANISH_STRING || type === BOOLEAN || type === OVERLOADED_BOOLEAN;
        this.attributeName = attributeName;
        this.attributeNamespace = attributeNamespace;
        this.mustUseProperty = mustUseProperty;
        this.propertyName = name;
        this.type = type;
        this.sanitizeURL = sanitizeURL2;
        this.removeEmptyString = removeEmptyString;
      }
      var properties = {};
      var reservedProps = [
        "children",
        "dangerouslySetInnerHTML",
        "defaultValue",
        "defaultChecked",
        "innerHTML",
        "suppressContentEditableWarning",
        "suppressHydrationWarning",
        "style"
      ];
      reservedProps.forEach(function(name) {
        properties[name] = new PropertyInfoRecord(name, RESERVED, false, name, null, false, false);
      });
      [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(_ref) {
        var name = _ref[0], attributeName = _ref[1];
        properties[name] = new PropertyInfoRecord(name, STRING, false, attributeName, null, false, false);
      });
      ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(name) {
        properties[name] = new PropertyInfoRecord(name, BOOLEANISH_STRING, false, name.toLowerCase(), null, false, false);
      });
      ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(name) {
        properties[name] = new PropertyInfoRecord(name, BOOLEANISH_STRING, false, name, null, false, false);
      });
      [
        "allowFullScreen",
        "async",
        "autoFocus",
        "autoPlay",
        "controls",
        "default",
        "defer",
        "disabled",
        "disablePictureInPicture",
        "disableRemotePlayback",
        "formNoValidate",
        "hidden",
        "loop",
        "noModule",
        "noValidate",
        "open",
        "playsInline",
        "readOnly",
        "required",
        "reversed",
        "scoped",
        "seamless",
        "itemScope"
      ].forEach(function(name) {
        properties[name] = new PropertyInfoRecord(name, BOOLEAN, false, name.toLowerCase(), null, false, false);
      });
      [
        "checked",
        "multiple",
        "muted",
        "selected"
      ].forEach(function(name) {
        properties[name] = new PropertyInfoRecord(name, BOOLEAN, true, name, null, false, false);
      });
      [
        "capture",
        "download"
      ].forEach(function(name) {
        properties[name] = new PropertyInfoRecord(name, OVERLOADED_BOOLEAN, false, name, null, false, false);
      });
      [
        "cols",
        "rows",
        "size",
        "span"
      ].forEach(function(name) {
        properties[name] = new PropertyInfoRecord(name, POSITIVE_NUMERIC, false, name, null, false, false);
      });
      ["rowSpan", "start"].forEach(function(name) {
        properties[name] = new PropertyInfoRecord(name, NUMERIC, false, name.toLowerCase(), null, false, false);
      });
      var CAMELIZE = /[\-\:]([a-z])/g;
      var capitalize = function(token) {
        return token[1].toUpperCase();
      };
      [
        "accent-height",
        "alignment-baseline",
        "arabic-form",
        "baseline-shift",
        "cap-height",
        "clip-path",
        "clip-rule",
        "color-interpolation",
        "color-interpolation-filters",
        "color-profile",
        "color-rendering",
        "dominant-baseline",
        "enable-background",
        "fill-opacity",
        "fill-rule",
        "flood-color",
        "flood-opacity",
        "font-family",
        "font-size",
        "font-size-adjust",
        "font-stretch",
        "font-style",
        "font-variant",
        "font-weight",
        "glyph-name",
        "glyph-orientation-horizontal",
        "glyph-orientation-vertical",
        "horiz-adv-x",
        "horiz-origin-x",
        "image-rendering",
        "letter-spacing",
        "lighting-color",
        "marker-end",
        "marker-mid",
        "marker-start",
        "overline-position",
        "overline-thickness",
        "paint-order",
        "panose-1",
        "pointer-events",
        "rendering-intent",
        "shape-rendering",
        "stop-color",
        "stop-opacity",
        "strikethrough-position",
        "strikethrough-thickness",
        "stroke-dasharray",
        "stroke-dashoffset",
        "stroke-linecap",
        "stroke-linejoin",
        "stroke-miterlimit",
        "stroke-opacity",
        "stroke-width",
        "text-anchor",
        "text-decoration",
        "text-rendering",
        "underline-position",
        "underline-thickness",
        "unicode-bidi",
        "unicode-range",
        "units-per-em",
        "v-alphabetic",
        "v-hanging",
        "v-ideographic",
        "v-mathematical",
        "vector-effect",
        "vert-adv-y",
        "vert-origin-x",
        "vert-origin-y",
        "word-spacing",
        "writing-mode",
        "xmlns:xlink",
        "x-height"
      ].forEach(function(attributeName) {
        var name = attributeName.replace(CAMELIZE, capitalize);
        properties[name] = new PropertyInfoRecord(name, STRING, false, attributeName, null, false, false);
      });
      [
        "xlink:actuate",
        "xlink:arcrole",
        "xlink:role",
        "xlink:show",
        "xlink:title",
        "xlink:type"
      ].forEach(function(attributeName) {
        var name = attributeName.replace(CAMELIZE, capitalize);
        properties[name] = new PropertyInfoRecord(name, STRING, false, attributeName, "http://www.w3.org/1999/xlink", false, false);
      });
      [
        "xml:base",
        "xml:lang",
        "xml:space"
      ].forEach(function(attributeName) {
        var name = attributeName.replace(CAMELIZE, capitalize);
        properties[name] = new PropertyInfoRecord(name, STRING, false, attributeName, "http://www.w3.org/XML/1998/namespace", false, false);
      });
      ["tabIndex", "crossOrigin"].forEach(function(attributeName) {
        properties[attributeName] = new PropertyInfoRecord(attributeName, STRING, false, attributeName.toLowerCase(), null, false, false);
      });
      var xlinkHref = "xlinkHref";
      properties[xlinkHref] = new PropertyInfoRecord("xlinkHref", STRING, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
      ["src", "href", "action", "formAction"].forEach(function(attributeName) {
        properties[attributeName] = new PropertyInfoRecord(attributeName, STRING, false, attributeName.toLowerCase(), null, true, true);
      });
      var isUnitlessNumber = {
        animationIterationCount: true,
        aspectRatio: true,
        borderImageOutset: true,
        borderImageSlice: true,
        borderImageWidth: true,
        boxFlex: true,
        boxFlexGroup: true,
        boxOrdinalGroup: true,
        columnCount: true,
        columns: true,
        flex: true,
        flexGrow: true,
        flexPositive: true,
        flexShrink: true,
        flexNegative: true,
        flexOrder: true,
        gridArea: true,
        gridRow: true,
        gridRowEnd: true,
        gridRowSpan: true,
        gridRowStart: true,
        gridColumn: true,
        gridColumnEnd: true,
        gridColumnSpan: true,
        gridColumnStart: true,
        fontWeight: true,
        lineClamp: true,
        lineHeight: true,
        opacity: true,
        order: true,
        orphans: true,
        tabSize: true,
        widows: true,
        zIndex: true,
        zoom: true,
        fillOpacity: true,
        floodOpacity: true,
        stopOpacity: true,
        strokeDasharray: true,
        strokeDashoffset: true,
        strokeMiterlimit: true,
        strokeOpacity: true,
        strokeWidth: true
      };
      function prefixKey(prefix2, key) {
        return prefix2 + key.charAt(0).toUpperCase() + key.substring(1);
      }
      var prefixes = ["Webkit", "ms", "Moz", "O"];
      Object.keys(isUnitlessNumber).forEach(function(prop) {
        prefixes.forEach(function(prefix2) {
          isUnitlessNumber[prefixKey(prefix2, prop)] = isUnitlessNumber[prop];
        });
      });
      var hasReadOnlyValue = {
        button: true,
        checkbox: true,
        image: true,
        hidden: true,
        radio: true,
        reset: true,
        submit: true
      };
      function checkControlledValueProps(tagName, props) {
        {
          if (!(hasReadOnlyValue[props.type] || props.onChange || props.onInput || props.readOnly || props.disabled || props.value == null)) {
            error("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`.");
          }
          if (!(props.onChange || props.readOnly || props.disabled || props.checked == null)) {
            error("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
          }
        }
      }
      function isCustomComponent(tagName, props) {
        if (tagName.indexOf("-") === -1) {
          return typeof props.is === "string";
        }
        switch (tagName) {
          case "annotation-xml":
          case "color-profile":
          case "font-face":
          case "font-face-src":
          case "font-face-uri":
          case "font-face-format":
          case "font-face-name":
          case "missing-glyph":
            return false;
          default:
            return true;
        }
      }
      var ariaProperties = {
        "aria-current": 0,
        "aria-description": 0,
        "aria-details": 0,
        "aria-disabled": 0,
        "aria-hidden": 0,
        "aria-invalid": 0,
        "aria-keyshortcuts": 0,
        "aria-label": 0,
        "aria-roledescription": 0,
        "aria-autocomplete": 0,
        "aria-checked": 0,
        "aria-expanded": 0,
        "aria-haspopup": 0,
        "aria-level": 0,
        "aria-modal": 0,
        "aria-multiline": 0,
        "aria-multiselectable": 0,
        "aria-orientation": 0,
        "aria-placeholder": 0,
        "aria-pressed": 0,
        "aria-readonly": 0,
        "aria-required": 0,
        "aria-selected": 0,
        "aria-sort": 0,
        "aria-valuemax": 0,
        "aria-valuemin": 0,
        "aria-valuenow": 0,
        "aria-valuetext": 0,
        "aria-atomic": 0,
        "aria-busy": 0,
        "aria-live": 0,
        "aria-relevant": 0,
        "aria-dropeffect": 0,
        "aria-grabbed": 0,
        "aria-activedescendant": 0,
        "aria-colcount": 0,
        "aria-colindex": 0,
        "aria-colspan": 0,
        "aria-controls": 0,
        "aria-describedby": 0,
        "aria-errormessage": 0,
        "aria-flowto": 0,
        "aria-labelledby": 0,
        "aria-owns": 0,
        "aria-posinset": 0,
        "aria-rowcount": 0,
        "aria-rowindex": 0,
        "aria-rowspan": 0,
        "aria-setsize": 0
      };
      var warnedProperties = {};
      var rARIA = new RegExp("^(aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$");
      var rARIACamel = new RegExp("^(aria)[A-Z][" + ATTRIBUTE_NAME_CHAR + "]*$");
      function validateProperty(tagName, name) {
        {
          if (hasOwnProperty.call(warnedProperties, name) && warnedProperties[name]) {
            return true;
          }
          if (rARIACamel.test(name)) {
            var ariaName = "aria-" + name.slice(4).toLowerCase();
            var correctName = ariaProperties.hasOwnProperty(ariaName) ? ariaName : null;
            if (correctName == null) {
              error("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", name);
              warnedProperties[name] = true;
              return true;
            }
            if (name !== correctName) {
              error("Invalid ARIA attribute `%s`. Did you mean `%s`?", name, correctName);
              warnedProperties[name] = true;
              return true;
            }
          }
          if (rARIA.test(name)) {
            var lowerCasedName = name.toLowerCase();
            var standardName = ariaProperties.hasOwnProperty(lowerCasedName) ? lowerCasedName : null;
            if (standardName == null) {
              warnedProperties[name] = true;
              return false;
            }
            if (name !== standardName) {
              error("Unknown ARIA attribute `%s`. Did you mean `%s`?", name, standardName);
              warnedProperties[name] = true;
              return true;
            }
          }
        }
        return true;
      }
      function warnInvalidARIAProps(type, props) {
        {
          var invalidProps = [];
          for (var key in props) {
            var isValid2 = validateProperty(type, key);
            if (!isValid2) {
              invalidProps.push(key);
            }
          }
          var unknownPropString = invalidProps.map(function(prop) {
            return "`" + prop + "`";
          }).join(", ");
          if (invalidProps.length === 1) {
            error("Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type);
          } else if (invalidProps.length > 1) {
            error("Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type);
          }
        }
      }
      function validateProperties(type, props) {
        if (isCustomComponent(type, props)) {
          return;
        }
        warnInvalidARIAProps(type, props);
      }
      var didWarnValueNull = false;
      function validateProperties$1(type, props) {
        {
          if (type !== "input" && type !== "textarea" && type !== "select") {
            return;
          }
          if (props != null && props.value === null && !didWarnValueNull) {
            didWarnValueNull = true;
            if (type === "select" && props.multiple) {
              error("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", type);
            } else {
              error("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", type);
            }
          }
        }
      }
      var possibleStandardNames = {
        accept: "accept",
        acceptcharset: "acceptCharset",
        "accept-charset": "acceptCharset",
        accesskey: "accessKey",
        action: "action",
        allowfullscreen: "allowFullScreen",
        alt: "alt",
        as: "as",
        async: "async",
        autocapitalize: "autoCapitalize",
        autocomplete: "autoComplete",
        autocorrect: "autoCorrect",
        autofocus: "autoFocus",
        autoplay: "autoPlay",
        autosave: "autoSave",
        capture: "capture",
        cellpadding: "cellPadding",
        cellspacing: "cellSpacing",
        challenge: "challenge",
        charset: "charSet",
        checked: "checked",
        children: "children",
        cite: "cite",
        class: "className",
        classid: "classID",
        classname: "className",
        cols: "cols",
        colspan: "colSpan",
        content: "content",
        contenteditable: "contentEditable",
        contextmenu: "contextMenu",
        controls: "controls",
        controlslist: "controlsList",
        coords: "coords",
        crossorigin: "crossOrigin",
        dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
        data: "data",
        datetime: "dateTime",
        default: "default",
        defaultchecked: "defaultChecked",
        defaultvalue: "defaultValue",
        defer: "defer",
        dir: "dir",
        disabled: "disabled",
        disablepictureinpicture: "disablePictureInPicture",
        disableremoteplayback: "disableRemotePlayback",
        download: "download",
        draggable: "draggable",
        enctype: "encType",
        enterkeyhint: "enterKeyHint",
        for: "htmlFor",
        form: "form",
        formmethod: "formMethod",
        formaction: "formAction",
        formenctype: "formEncType",
        formnovalidate: "formNoValidate",
        formtarget: "formTarget",
        frameborder: "frameBorder",
        headers: "headers",
        height: "height",
        hidden: "hidden",
        high: "high",
        href: "href",
        hreflang: "hrefLang",
        htmlfor: "htmlFor",
        httpequiv: "httpEquiv",
        "http-equiv": "httpEquiv",
        icon: "icon",
        id: "id",
        imagesizes: "imageSizes",
        imagesrcset: "imageSrcSet",
        innerhtml: "innerHTML",
        inputmode: "inputMode",
        integrity: "integrity",
        is: "is",
        itemid: "itemID",
        itemprop: "itemProp",
        itemref: "itemRef",
        itemscope: "itemScope",
        itemtype: "itemType",
        keyparams: "keyParams",
        keytype: "keyType",
        kind: "kind",
        label: "label",
        lang: "lang",
        list: "list",
        loop: "loop",
        low: "low",
        manifest: "manifest",
        marginwidth: "marginWidth",
        marginheight: "marginHeight",
        max: "max",
        maxlength: "maxLength",
        media: "media",
        mediagroup: "mediaGroup",
        method: "method",
        min: "min",
        minlength: "minLength",
        multiple: "multiple",
        muted: "muted",
        name: "name",
        nomodule: "noModule",
        nonce: "nonce",
        novalidate: "noValidate",
        open: "open",
        optimum: "optimum",
        pattern: "pattern",
        placeholder: "placeholder",
        playsinline: "playsInline",
        poster: "poster",
        preload: "preload",
        profile: "profile",
        radiogroup: "radioGroup",
        readonly: "readOnly",
        referrerpolicy: "referrerPolicy",
        rel: "rel",
        required: "required",
        reversed: "reversed",
        role: "role",
        rows: "rows",
        rowspan: "rowSpan",
        sandbox: "sandbox",
        scope: "scope",
        scoped: "scoped",
        scrolling: "scrolling",
        seamless: "seamless",
        selected: "selected",
        shape: "shape",
        size: "size",
        sizes: "sizes",
        span: "span",
        spellcheck: "spellCheck",
        src: "src",
        srcdoc: "srcDoc",
        srclang: "srcLang",
        srcset: "srcSet",
        start: "start",
        step: "step",
        style: "style",
        summary: "summary",
        tabindex: "tabIndex",
        target: "target",
        title: "title",
        type: "type",
        usemap: "useMap",
        value: "value",
        width: "width",
        wmode: "wmode",
        wrap: "wrap",
        about: "about",
        accentheight: "accentHeight",
        "accent-height": "accentHeight",
        accumulate: "accumulate",
        additive: "additive",
        alignmentbaseline: "alignmentBaseline",
        "alignment-baseline": "alignmentBaseline",
        allowreorder: "allowReorder",
        alphabetic: "alphabetic",
        amplitude: "amplitude",
        arabicform: "arabicForm",
        "arabic-form": "arabicForm",
        ascent: "ascent",
        attributename: "attributeName",
        attributetype: "attributeType",
        autoreverse: "autoReverse",
        azimuth: "azimuth",
        basefrequency: "baseFrequency",
        baselineshift: "baselineShift",
        "baseline-shift": "baselineShift",
        baseprofile: "baseProfile",
        bbox: "bbox",
        begin: "begin",
        bias: "bias",
        by: "by",
        calcmode: "calcMode",
        capheight: "capHeight",
        "cap-height": "capHeight",
        clip: "clip",
        clippath: "clipPath",
        "clip-path": "clipPath",
        clippathunits: "clipPathUnits",
        cliprule: "clipRule",
        "clip-rule": "clipRule",
        color: "color",
        colorinterpolation: "colorInterpolation",
        "color-interpolation": "colorInterpolation",
        colorinterpolationfilters: "colorInterpolationFilters",
        "color-interpolation-filters": "colorInterpolationFilters",
        colorprofile: "colorProfile",
        "color-profile": "colorProfile",
        colorrendering: "colorRendering",
        "color-rendering": "colorRendering",
        contentscripttype: "contentScriptType",
        contentstyletype: "contentStyleType",
        cursor: "cursor",
        cx: "cx",
        cy: "cy",
        d: "d",
        datatype: "datatype",
        decelerate: "decelerate",
        descent: "descent",
        diffuseconstant: "diffuseConstant",
        direction: "direction",
        display: "display",
        divisor: "divisor",
        dominantbaseline: "dominantBaseline",
        "dominant-baseline": "dominantBaseline",
        dur: "dur",
        dx: "dx",
        dy: "dy",
        edgemode: "edgeMode",
        elevation: "elevation",
        enablebackground: "enableBackground",
        "enable-background": "enableBackground",
        end: "end",
        exponent: "exponent",
        externalresourcesrequired: "externalResourcesRequired",
        fill: "fill",
        fillopacity: "fillOpacity",
        "fill-opacity": "fillOpacity",
        fillrule: "fillRule",
        "fill-rule": "fillRule",
        filter: "filter",
        filterres: "filterRes",
        filterunits: "filterUnits",
        floodopacity: "floodOpacity",
        "flood-opacity": "floodOpacity",
        floodcolor: "floodColor",
        "flood-color": "floodColor",
        focusable: "focusable",
        fontfamily: "fontFamily",
        "font-family": "fontFamily",
        fontsize: "fontSize",
        "font-size": "fontSize",
        fontsizeadjust: "fontSizeAdjust",
        "font-size-adjust": "fontSizeAdjust",
        fontstretch: "fontStretch",
        "font-stretch": "fontStretch",
        fontstyle: "fontStyle",
        "font-style": "fontStyle",
        fontvariant: "fontVariant",
        "font-variant": "fontVariant",
        fontweight: "fontWeight",
        "font-weight": "fontWeight",
        format: "format",
        from: "from",
        fx: "fx",
        fy: "fy",
        g1: "g1",
        g2: "g2",
        glyphname: "glyphName",
        "glyph-name": "glyphName",
        glyphorientationhorizontal: "glyphOrientationHorizontal",
        "glyph-orientation-horizontal": "glyphOrientationHorizontal",
        glyphorientationvertical: "glyphOrientationVertical",
        "glyph-orientation-vertical": "glyphOrientationVertical",
        glyphref: "glyphRef",
        gradienttransform: "gradientTransform",
        gradientunits: "gradientUnits",
        hanging: "hanging",
        horizadvx: "horizAdvX",
        "horiz-adv-x": "horizAdvX",
        horizoriginx: "horizOriginX",
        "horiz-origin-x": "horizOriginX",
        ideographic: "ideographic",
        imagerendering: "imageRendering",
        "image-rendering": "imageRendering",
        in2: "in2",
        in: "in",
        inlist: "inlist",
        intercept: "intercept",
        k1: "k1",
        k2: "k2",
        k3: "k3",
        k4: "k4",
        k: "k",
        kernelmatrix: "kernelMatrix",
        kernelunitlength: "kernelUnitLength",
        kerning: "kerning",
        keypoints: "keyPoints",
        keysplines: "keySplines",
        keytimes: "keyTimes",
        lengthadjust: "lengthAdjust",
        letterspacing: "letterSpacing",
        "letter-spacing": "letterSpacing",
        lightingcolor: "lightingColor",
        "lighting-color": "lightingColor",
        limitingconeangle: "limitingConeAngle",
        local: "local",
        markerend: "markerEnd",
        "marker-end": "markerEnd",
        markerheight: "markerHeight",
        markermid: "markerMid",
        "marker-mid": "markerMid",
        markerstart: "markerStart",
        "marker-start": "markerStart",
        markerunits: "markerUnits",
        markerwidth: "markerWidth",
        mask: "mask",
        maskcontentunits: "maskContentUnits",
        maskunits: "maskUnits",
        mathematical: "mathematical",
        mode: "mode",
        numoctaves: "numOctaves",
        offset: "offset",
        opacity: "opacity",
        operator: "operator",
        order: "order",
        orient: "orient",
        orientation: "orientation",
        origin: "origin",
        overflow: "overflow",
        overlineposition: "overlinePosition",
        "overline-position": "overlinePosition",
        overlinethickness: "overlineThickness",
        "overline-thickness": "overlineThickness",
        paintorder: "paintOrder",
        "paint-order": "paintOrder",
        panose1: "panose1",
        "panose-1": "panose1",
        pathlength: "pathLength",
        patterncontentunits: "patternContentUnits",
        patterntransform: "patternTransform",
        patternunits: "patternUnits",
        pointerevents: "pointerEvents",
        "pointer-events": "pointerEvents",
        points: "points",
        pointsatx: "pointsAtX",
        pointsaty: "pointsAtY",
        pointsatz: "pointsAtZ",
        prefix: "prefix",
        preservealpha: "preserveAlpha",
        preserveaspectratio: "preserveAspectRatio",
        primitiveunits: "primitiveUnits",
        property: "property",
        r: "r",
        radius: "radius",
        refx: "refX",
        refy: "refY",
        renderingintent: "renderingIntent",
        "rendering-intent": "renderingIntent",
        repeatcount: "repeatCount",
        repeatdur: "repeatDur",
        requiredextensions: "requiredExtensions",
        requiredfeatures: "requiredFeatures",
        resource: "resource",
        restart: "restart",
        result: "result",
        results: "results",
        rotate: "rotate",
        rx: "rx",
        ry: "ry",
        scale: "scale",
        security: "security",
        seed: "seed",
        shaperendering: "shapeRendering",
        "shape-rendering": "shapeRendering",
        slope: "slope",
        spacing: "spacing",
        specularconstant: "specularConstant",
        specularexponent: "specularExponent",
        speed: "speed",
        spreadmethod: "spreadMethod",
        startoffset: "startOffset",
        stddeviation: "stdDeviation",
        stemh: "stemh",
        stemv: "stemv",
        stitchtiles: "stitchTiles",
        stopcolor: "stopColor",
        "stop-color": "stopColor",
        stopopacity: "stopOpacity",
        "stop-opacity": "stopOpacity",
        strikethroughposition: "strikethroughPosition",
        "strikethrough-position": "strikethroughPosition",
        strikethroughthickness: "strikethroughThickness",
        "strikethrough-thickness": "strikethroughThickness",
        string: "string",
        stroke: "stroke",
        strokedasharray: "strokeDasharray",
        "stroke-dasharray": "strokeDasharray",
        strokedashoffset: "strokeDashoffset",
        "stroke-dashoffset": "strokeDashoffset",
        strokelinecap: "strokeLinecap",
        "stroke-linecap": "strokeLinecap",
        strokelinejoin: "strokeLinejoin",
        "stroke-linejoin": "strokeLinejoin",
        strokemiterlimit: "strokeMiterlimit",
        "stroke-miterlimit": "strokeMiterlimit",
        strokewidth: "strokeWidth",
        "stroke-width": "strokeWidth",
        strokeopacity: "strokeOpacity",
        "stroke-opacity": "strokeOpacity",
        suppresscontenteditablewarning: "suppressContentEditableWarning",
        suppresshydrationwarning: "suppressHydrationWarning",
        surfacescale: "surfaceScale",
        systemlanguage: "systemLanguage",
        tablevalues: "tableValues",
        targetx: "targetX",
        targety: "targetY",
        textanchor: "textAnchor",
        "text-anchor": "textAnchor",
        textdecoration: "textDecoration",
        "text-decoration": "textDecoration",
        textlength: "textLength",
        textrendering: "textRendering",
        "text-rendering": "textRendering",
        to: "to",
        transform: "transform",
        typeof: "typeof",
        u1: "u1",
        u2: "u2",
        underlineposition: "underlinePosition",
        "underline-position": "underlinePosition",
        underlinethickness: "underlineThickness",
        "underline-thickness": "underlineThickness",
        unicode: "unicode",
        unicodebidi: "unicodeBidi",
        "unicode-bidi": "unicodeBidi",
        unicoderange: "unicodeRange",
        "unicode-range": "unicodeRange",
        unitsperem: "unitsPerEm",
        "units-per-em": "unitsPerEm",
        unselectable: "unselectable",
        valphabetic: "vAlphabetic",
        "v-alphabetic": "vAlphabetic",
        values: "values",
        vectoreffect: "vectorEffect",
        "vector-effect": "vectorEffect",
        version: "version",
        vertadvy: "vertAdvY",
        "vert-adv-y": "vertAdvY",
        vertoriginx: "vertOriginX",
        "vert-origin-x": "vertOriginX",
        vertoriginy: "vertOriginY",
        "vert-origin-y": "vertOriginY",
        vhanging: "vHanging",
        "v-hanging": "vHanging",
        videographic: "vIdeographic",
        "v-ideographic": "vIdeographic",
        viewbox: "viewBox",
        viewtarget: "viewTarget",
        visibility: "visibility",
        vmathematical: "vMathematical",
        "v-mathematical": "vMathematical",
        vocab: "vocab",
        widths: "widths",
        wordspacing: "wordSpacing",
        "word-spacing": "wordSpacing",
        writingmode: "writingMode",
        "writing-mode": "writingMode",
        x1: "x1",
        x2: "x2",
        x: "x",
        xchannelselector: "xChannelSelector",
        xheight: "xHeight",
        "x-height": "xHeight",
        xlinkactuate: "xlinkActuate",
        "xlink:actuate": "xlinkActuate",
        xlinkarcrole: "xlinkArcrole",
        "xlink:arcrole": "xlinkArcrole",
        xlinkhref: "xlinkHref",
        "xlink:href": "xlinkHref",
        xlinkrole: "xlinkRole",
        "xlink:role": "xlinkRole",
        xlinkshow: "xlinkShow",
        "xlink:show": "xlinkShow",
        xlinktitle: "xlinkTitle",
        "xlink:title": "xlinkTitle",
        xlinktype: "xlinkType",
        "xlink:type": "xlinkType",
        xmlbase: "xmlBase",
        "xml:base": "xmlBase",
        xmllang: "xmlLang",
        "xml:lang": "xmlLang",
        xmlns: "xmlns",
        "xml:space": "xmlSpace",
        xmlnsxlink: "xmlnsXlink",
        "xmlns:xlink": "xmlnsXlink",
        xmlspace: "xmlSpace",
        y1: "y1",
        y2: "y2",
        y: "y",
        ychannelselector: "yChannelSelector",
        z: "z",
        zoomandpan: "zoomAndPan"
      };
      var validateProperty$1 = function() {
      };
      {
        var warnedProperties$1 = {};
        var EVENT_NAME_REGEX = /^on./;
        var INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/;
        var rARIA$1 = new RegExp("^(aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$");
        var rARIACamel$1 = new RegExp("^(aria)[A-Z][" + ATTRIBUTE_NAME_CHAR + "]*$");
        validateProperty$1 = function(tagName, name, value, eventRegistry) {
          if (hasOwnProperty.call(warnedProperties$1, name) && warnedProperties$1[name]) {
            return true;
          }
          var lowerCasedName = name.toLowerCase();
          if (lowerCasedName === "onfocusin" || lowerCasedName === "onfocusout") {
            error("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React.");
            warnedProperties$1[name] = true;
            return true;
          }
          if (eventRegistry != null) {
            var { registrationNameDependencies, possibleRegistrationNames } = eventRegistry;
            if (registrationNameDependencies.hasOwnProperty(name)) {
              return true;
            }
            var registrationName = possibleRegistrationNames.hasOwnProperty(lowerCasedName) ? possibleRegistrationNames[lowerCasedName] : null;
            if (registrationName != null) {
              error("Invalid event handler property `%s`. Did you mean `%s`?", name, registrationName);
              warnedProperties$1[name] = true;
              return true;
            }
            if (EVENT_NAME_REGEX.test(name)) {
              error("Unknown event handler property `%s`. It will be ignored.", name);
              warnedProperties$1[name] = true;
              return true;
            }
          } else if (EVENT_NAME_REGEX.test(name)) {
            if (INVALID_EVENT_NAME_REGEX.test(name)) {
              error("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", name);
            }
            warnedProperties$1[name] = true;
            return true;
          }
          if (rARIA$1.test(name) || rARIACamel$1.test(name)) {
            return true;
          }
          if (lowerCasedName === "innerhtml") {
            error("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`.");
            warnedProperties$1[name] = true;
            return true;
          }
          if (lowerCasedName === "aria") {
            error("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead.");
            warnedProperties$1[name] = true;
            return true;
          }
          if (lowerCasedName === "is" && value !== null && value !== undefined && typeof value !== "string") {
            error("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof value);
            warnedProperties$1[name] = true;
            return true;
          }
          if (typeof value === "number" && isNaN(value)) {
            error("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", name);
            warnedProperties$1[name] = true;
            return true;
          }
          var propertyInfo = getPropertyInfo(name);
          var isReserved = propertyInfo !== null && propertyInfo.type === RESERVED;
          if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
            var standardName = possibleStandardNames[lowerCasedName];
            if (standardName !== name) {
              error("Invalid DOM property `%s`. Did you mean `%s`?", name, standardName);
              warnedProperties$1[name] = true;
              return true;
            }
          } else if (!isReserved && name !== lowerCasedName) {
            error("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", name, lowerCasedName);
            warnedProperties$1[name] = true;
            return true;
          }
          if (typeof value === "boolean" && shouldRemoveAttributeWithWarning(name, value, propertyInfo, false)) {
            if (value) {
              error('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', value, name, name, value, name);
            } else {
              error('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', value, name, name, value, name, name, name);
            }
            warnedProperties$1[name] = true;
            return true;
          }
          if (isReserved) {
            return true;
          }
          if (shouldRemoveAttributeWithWarning(name, value, propertyInfo, false)) {
            warnedProperties$1[name] = true;
            return false;
          }
          if ((value === "false" || value === "true") && propertyInfo !== null && propertyInfo.type === BOOLEAN) {
            error("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", value, name, value === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', name, value);
            warnedProperties$1[name] = true;
            return true;
          }
          return true;
        };
      }
      var warnUnknownProperties = function(type, props, eventRegistry) {
        {
          var unknownProps = [];
          for (var key in props) {
            var isValid2 = validateProperty$1(type, key, props[key], eventRegistry);
            if (!isValid2) {
              unknownProps.push(key);
            }
          }
          var unknownPropString = unknownProps.map(function(prop) {
            return "`" + prop + "`";
          }).join(", ");
          if (unknownProps.length === 1) {
            error("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type);
          } else if (unknownProps.length > 1) {
            error("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type);
          }
        }
      };
      function validateProperties$2(type, props, eventRegistry) {
        if (isCustomComponent(type, props)) {
          return;
        }
        warnUnknownProperties(type, props, eventRegistry);
      }
      var warnValidStyle = function() {
      };
      {
        var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;
        var msPattern = /^-ms-/;
        var hyphenPattern = /-(.)/g;
        var badStyleValueWithSemicolonPattern = /;\s*$/;
        var warnedStyleNames = {};
        var warnedStyleValues = {};
        var warnedForNaNValue = false;
        var warnedForInfinityValue = false;
        var camelize = function(string) {
          return string.replace(hyphenPattern, function(_, character) {
            return character.toUpperCase();
          });
        };
        var warnHyphenatedStyleName = function(name) {
          if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
            return;
          }
          warnedStyleNames[name] = true;
          error("Unsupported style property %s. Did you mean %s?", name, camelize(name.replace(msPattern, "ms-")));
        };
        var warnBadVendoredStyleName = function(name) {
          if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
            return;
          }
          warnedStyleNames[name] = true;
          error("Unsupported vendor-prefixed style property %s. Did you mean %s?", name, name.charAt(0).toUpperCase() + name.slice(1));
        };
        var warnStyleValueWithSemicolon = function(name, value) {
          if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {
            return;
          }
          warnedStyleValues[value] = true;
          error(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, name, value.replace(badStyleValueWithSemicolonPattern, ""));
        };
        var warnStyleValueIsNaN = function(name, value) {
          if (warnedForNaNValue) {
            return;
          }
          warnedForNaNValue = true;
          error("`NaN` is an invalid value for the `%s` css style property.", name);
        };
        var warnStyleValueIsInfinity = function(name, value) {
          if (warnedForInfinityValue) {
            return;
          }
          warnedForInfinityValue = true;
          error("`Infinity` is an invalid value for the `%s` css style property.", name);
        };
        warnValidStyle = function(name, value) {
          if (name.indexOf("-") > -1) {
            warnHyphenatedStyleName(name);
          } else if (badVendoredStyleNamePattern.test(name)) {
            warnBadVendoredStyleName(name);
          } else if (badStyleValueWithSemicolonPattern.test(value)) {
            warnStyleValueWithSemicolon(name, value);
          }
          if (typeof value === "number") {
            if (isNaN(value)) {
              warnStyleValueIsNaN(name, value);
            } else if (!isFinite(value)) {
              warnStyleValueIsInfinity(name, value);
            }
          }
        };
      }
      var warnValidStyle$1 = warnValidStyle;
      var matchHtmlRegExp = /["'&<>]/;
      function escapeHtml(string) {
        {
          checkHtmlStringCoercion(string);
        }
        var str = "" + string;
        var match = matchHtmlRegExp.exec(str);
        if (!match) {
          return str;
        }
        var escape2;
        var html = "";
        var index;
        var lastIndex = 0;
        for (index = match.index;index < str.length; index++) {
          switch (str.charCodeAt(index)) {
            case 34:
              escape2 = "&quot;";
              break;
            case 38:
              escape2 = "&amp;";
              break;
            case 39:
              escape2 = "&#x27;";
              break;
            case 60:
              escape2 = "&lt;";
              break;
            case 62:
              escape2 = "&gt;";
              break;
            default:
              continue;
          }
          if (lastIndex !== index) {
            html += str.substring(lastIndex, index);
          }
          lastIndex = index + 1;
          html += escape2;
        }
        return lastIndex !== index ? html + str.substring(lastIndex, index) : html;
      }
      function escapeTextForBrowser(text2) {
        if (typeof text2 === "boolean" || typeof text2 === "number") {
          return "" + text2;
        }
        return escapeHtml(text2);
      }
      var uppercasePattern = /([A-Z])/g;
      var msPattern$1 = /^ms-/;
      function hyphenateStyleName(name) {
        return name.replace(uppercasePattern, "-$1").toLowerCase().replace(msPattern$1, "-ms-");
      }
      var isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i;
      var didWarn = false;
      function sanitizeURL(url) {
        {
          if (!didWarn && isJavaScriptProtocol.test(url)) {
            didWarn = true;
            error("A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(url));
          }
        }
      }
      var isArrayImpl = Array.isArray;
      function isArray(a) {
        return isArrayImpl(a);
      }
      var startInlineScript = stringToPrecomputedChunk("<script>");
      var endInlineScript = stringToPrecomputedChunk("</script>");
      var startScriptSrc = stringToPrecomputedChunk('<script src="');
      var startModuleSrc = stringToPrecomputedChunk('<script type="module" src="');
      var endAsyncScript = stringToPrecomputedChunk('" async=""></script>');
      function escapeBootstrapScriptContent(scriptText) {
        {
          checkHtmlStringCoercion(scriptText);
        }
        return ("" + scriptText).replace(scriptRegex, scriptReplacer);
      }
      var scriptRegex = /(<\/|<)(s)(cript)/gi;
      var scriptReplacer = function(match, prefix2, s, suffix) {
        return "" + prefix2 + (s === "s" ? "\\u0073" : "\\u0053") + suffix;
      };
      function createResponseState(identifierPrefix, nonce, bootstrapScriptContent, bootstrapScripts, bootstrapModules) {
        var idPrefix = identifierPrefix === undefined ? "" : identifierPrefix;
        var inlineScriptWithNonce = nonce === undefined ? startInlineScript : stringToPrecomputedChunk('<script nonce="' + escapeTextForBrowser(nonce) + '">');
        var bootstrapChunks = [];
        if (bootstrapScriptContent !== undefined) {
          bootstrapChunks.push(inlineScriptWithNonce, stringToChunk(escapeBootstrapScriptContent(bootstrapScriptContent)), endInlineScript);
        }
        if (bootstrapScripts !== undefined) {
          for (var i = 0;i < bootstrapScripts.length; i++) {
            bootstrapChunks.push(startScriptSrc, stringToChunk(escapeTextForBrowser(bootstrapScripts[i])), endAsyncScript);
          }
        }
        if (bootstrapModules !== undefined) {
          for (var _i = 0;_i < bootstrapModules.length; _i++) {
            bootstrapChunks.push(startModuleSrc, stringToChunk(escapeTextForBrowser(bootstrapModules[_i])), endAsyncScript);
          }
        }
        return {
          bootstrapChunks,
          startInlineScript: inlineScriptWithNonce,
          placeholderPrefix: stringToPrecomputedChunk(idPrefix + "P:"),
          segmentPrefix: stringToPrecomputedChunk(idPrefix + "S:"),
          boundaryPrefix: idPrefix + "B:",
          idPrefix,
          nextSuspenseID: 0,
          sentCompleteSegmentFunction: false,
          sentCompleteBoundaryFunction: false,
          sentClientRenderFunction: false
        };
      }
      var ROOT_HTML_MODE = 0;
      var HTML_MODE = 1;
      var SVG_MODE = 2;
      var MATHML_MODE = 3;
      var HTML_TABLE_MODE = 4;
      var HTML_TABLE_BODY_MODE = 5;
      var HTML_TABLE_ROW_MODE = 6;
      var HTML_COLGROUP_MODE = 7;
      function createFormatContext(insertionMode, selectedValue) {
        return {
          insertionMode,
          selectedValue
        };
      }
      function createRootFormatContext(namespaceURI) {
        var insertionMode = namespaceURI === "http://www.w3.org/2000/svg" ? SVG_MODE : namespaceURI === "http://www.w3.org/1998/Math/MathML" ? MATHML_MODE : ROOT_HTML_MODE;
        return createFormatContext(insertionMode, null);
      }
      function getChildFormatContext(parentContext, type, props) {
        switch (type) {
          case "select":
            return createFormatContext(HTML_MODE, props.value != null ? props.value : props.defaultValue);
          case "svg":
            return createFormatContext(SVG_MODE, null);
          case "math":
            return createFormatContext(MATHML_MODE, null);
          case "foreignObject":
            return createFormatContext(HTML_MODE, null);
          case "table":
            return createFormatContext(HTML_TABLE_MODE, null);
          case "thead":
          case "tbody":
          case "tfoot":
            return createFormatContext(HTML_TABLE_BODY_MODE, null);
          case "colgroup":
            return createFormatContext(HTML_COLGROUP_MODE, null);
          case "tr":
            return createFormatContext(HTML_TABLE_ROW_MODE, null);
        }
        if (parentContext.insertionMode >= HTML_TABLE_MODE) {
          return createFormatContext(HTML_MODE, null);
        }
        if (parentContext.insertionMode === ROOT_HTML_MODE) {
          return createFormatContext(HTML_MODE, null);
        }
        return parentContext;
      }
      var UNINITIALIZED_SUSPENSE_BOUNDARY_ID = null;
      function assignSuspenseBoundaryID(responseState) {
        var generatedID = responseState.nextSuspenseID++;
        return stringToPrecomputedChunk(responseState.boundaryPrefix + generatedID.toString(16));
      }
      function makeId(responseState, treeId, localId) {
        var idPrefix = responseState.idPrefix;
        var id = ":" + idPrefix + "R" + treeId;
        if (localId > 0) {
          id += "H" + localId.toString(32);
        }
        return id + ":";
      }
      function encodeHTMLTextNode(text2) {
        return escapeTextForBrowser(text2);
      }
      var textSeparator = stringToPrecomputedChunk("<!-- -->");
      function pushTextInstance(target, text2, responseState, textEmbedded) {
        if (text2 === "") {
          return textEmbedded;
        }
        if (textEmbedded) {
          target.push(textSeparator);
        }
        target.push(stringToChunk(encodeHTMLTextNode(text2)));
        return true;
      }
      function pushSegmentFinale(target, responseState, lastPushedText, textEmbedded) {
        if (lastPushedText && textEmbedded) {
          target.push(textSeparator);
        }
      }
      var styleNameCache = new Map;
      function processStyleName(styleName) {
        var chunk = styleNameCache.get(styleName);
        if (chunk !== undefined) {
          return chunk;
        }
        var result2 = stringToPrecomputedChunk(escapeTextForBrowser(hyphenateStyleName(styleName)));
        styleNameCache.set(styleName, result2);
        return result2;
      }
      var styleAttributeStart = stringToPrecomputedChunk(' style="');
      var styleAssign = stringToPrecomputedChunk(":");
      var styleSeparator = stringToPrecomputedChunk(";");
      function pushStyle(target, responseState, style) {
        if (typeof style !== "object") {
          throw new Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
        }
        var isFirst = true;
        for (var styleName in style) {
          if (!hasOwnProperty.call(style, styleName)) {
            continue;
          }
          var styleValue = style[styleName];
          if (styleValue == null || typeof styleValue === "boolean" || styleValue === "") {
            continue;
          }
          var nameChunk = undefined;
          var valueChunk = undefined;
          var isCustomProperty = styleName.indexOf("--") === 0;
          if (isCustomProperty) {
            nameChunk = stringToChunk(escapeTextForBrowser(styleName));
            {
              checkCSSPropertyStringCoercion(styleValue, styleName);
            }
            valueChunk = stringToChunk(escapeTextForBrowser(("" + styleValue).trim()));
          } else {
            {
              warnValidStyle$1(styleName, styleValue);
            }
            nameChunk = processStyleName(styleName);
            if (typeof styleValue === "number") {
              if (styleValue !== 0 && !hasOwnProperty.call(isUnitlessNumber, styleName)) {
                valueChunk = stringToChunk(styleValue + "px");
              } else {
                valueChunk = stringToChunk("" + styleValue);
              }
            } else {
              {
                checkCSSPropertyStringCoercion(styleValue, styleName);
              }
              valueChunk = stringToChunk(escapeTextForBrowser(("" + styleValue).trim()));
            }
          }
          if (isFirst) {
            isFirst = false;
            target.push(styleAttributeStart, nameChunk, styleAssign, valueChunk);
          } else {
            target.push(styleSeparator, nameChunk, styleAssign, valueChunk);
          }
        }
        if (!isFirst) {
          target.push(attributeEnd);
        }
      }
      var attributeSeparator = stringToPrecomputedChunk(" ");
      var attributeAssign = stringToPrecomputedChunk('="');
      var attributeEnd = stringToPrecomputedChunk('"');
      var attributeEmptyString = stringToPrecomputedChunk('=""');
      function pushAttribute(target, responseState, name, value) {
        switch (name) {
          case "style": {
            pushStyle(target, responseState, value);
            return;
          }
          case "defaultValue":
          case "defaultChecked":
          case "innerHTML":
          case "suppressContentEditableWarning":
          case "suppressHydrationWarning":
            return;
        }
        if (name.length > 2 && (name[0] === "o" || name[0] === "O") && (name[1] === "n" || name[1] === "N")) {
          return;
        }
        var propertyInfo = getPropertyInfo(name);
        if (propertyInfo !== null) {
          switch (typeof value) {
            case "function":
            case "symbol":
              return;
            case "boolean": {
              if (!propertyInfo.acceptsBooleans) {
                return;
              }
            }
          }
          var attributeName = propertyInfo.attributeName;
          var attributeNameChunk = stringToChunk(attributeName);
          switch (propertyInfo.type) {
            case BOOLEAN:
              if (value) {
                target.push(attributeSeparator, attributeNameChunk, attributeEmptyString);
              }
              return;
            case OVERLOADED_BOOLEAN:
              if (value === true) {
                target.push(attributeSeparator, attributeNameChunk, attributeEmptyString);
              } else if (value === false)
                ;
              else {
                target.push(attributeSeparator, attributeNameChunk, attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);
              }
              return;
            case NUMERIC:
              if (!isNaN(value)) {
                target.push(attributeSeparator, attributeNameChunk, attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);
              }
              break;
            case POSITIVE_NUMERIC:
              if (!isNaN(value) && value >= 1) {
                target.push(attributeSeparator, attributeNameChunk, attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);
              }
              break;
            default:
              if (propertyInfo.sanitizeURL) {
                {
                  checkAttributeStringCoercion(value, attributeName);
                }
                value = "" + value;
                sanitizeURL(value);
              }
              target.push(attributeSeparator, attributeNameChunk, attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);
          }
        } else if (isAttributeNameSafe(name)) {
          switch (typeof value) {
            case "function":
            case "symbol":
              return;
            case "boolean": {
              var prefix2 = name.toLowerCase().slice(0, 5);
              if (prefix2 !== "data-" && prefix2 !== "aria-") {
                return;
              }
            }
          }
          target.push(attributeSeparator, stringToChunk(name), attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);
        }
      }
      var endOfStartTag = stringToPrecomputedChunk(">");
      var endOfStartTagSelfClosing = stringToPrecomputedChunk("/>");
      function pushInnerHTML(target, innerHTML, children) {
        if (innerHTML != null) {
          if (children != null) {
            throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
          }
          if (typeof innerHTML !== "object" || !("__html" in innerHTML)) {
            throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
          }
          var html = innerHTML.__html;
          if (html !== null && html !== undefined) {
            {
              checkHtmlStringCoercion(html);
            }
            target.push(stringToChunk("" + html));
          }
        }
      }
      var didWarnDefaultInputValue = false;
      var didWarnDefaultChecked = false;
      var didWarnDefaultSelectValue = false;
      var didWarnDefaultTextareaValue = false;
      var didWarnInvalidOptionChildren = false;
      var didWarnInvalidOptionInnerHTML = false;
      var didWarnSelectedSetOnOption = false;
      function checkSelectProp(props, propName) {
        {
          var value = props[propName];
          if (value != null) {
            var array2 = isArray(value);
            if (props.multiple && !array2) {
              error("The `%s` prop supplied to <select> must be an array if `multiple` is true.", propName);
            } else if (!props.multiple && array2) {
              error("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.", propName);
            }
          }
        }
      }
      function pushStartSelect(target, props, responseState) {
        {
          checkControlledValueProps("select", props);
          checkSelectProp(props, "value");
          checkSelectProp(props, "defaultValue");
          if (props.value !== undefined && props.defaultValue !== undefined && !didWarnDefaultSelectValue) {
            error("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components");
            didWarnDefaultSelectValue = true;
          }
        }
        target.push(startChunkForTag("select"));
        var children = null;
        var innerHTML = null;
        for (var propKey in props) {
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null) {
              continue;
            }
            switch (propKey) {
              case "children":
                children = propValue;
                break;
              case "dangerouslySetInnerHTML":
                innerHTML = propValue;
                break;
              case "defaultValue":
              case "value":
                break;
              default:
                pushAttribute(target, responseState, propKey, propValue);
                break;
            }
          }
        }
        target.push(endOfStartTag);
        pushInnerHTML(target, innerHTML, children);
        return children;
      }
      function flattenOptionChildren(children) {
        var content = "";
        React.Children.forEach(children, function(child) {
          if (child == null) {
            return;
          }
          content += child;
          {
            if (!didWarnInvalidOptionChildren && typeof child !== "string" && typeof child !== "number") {
              didWarnInvalidOptionChildren = true;
              error("Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.");
            }
          }
        });
        return content;
      }
      var selectedMarkerAttribute = stringToPrecomputedChunk(' selected=""');
      function pushStartOption(target, props, responseState, formatContext) {
        var selectedValue = formatContext.selectedValue;
        target.push(startChunkForTag("option"));
        var children = null;
        var value = null;
        var selected = null;
        var innerHTML = null;
        for (var propKey in props) {
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null) {
              continue;
            }
            switch (propKey) {
              case "children":
                children = propValue;
                break;
              case "selected":
                selected = propValue;
                {
                  if (!didWarnSelectedSetOnOption) {
                    error("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>.");
                    didWarnSelectedSetOnOption = true;
                  }
                }
                break;
              case "dangerouslySetInnerHTML":
                innerHTML = propValue;
                break;
              case "value":
                value = propValue;
              default:
                pushAttribute(target, responseState, propKey, propValue);
                break;
            }
          }
        }
        if (selectedValue != null) {
          var stringValue;
          if (value !== null) {
            {
              checkAttributeStringCoercion(value, "value");
            }
            stringValue = "" + value;
          } else {
            {
              if (innerHTML !== null) {
                if (!didWarnInvalidOptionInnerHTML) {
                  didWarnInvalidOptionInnerHTML = true;
                  error("Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected.");
                }
              }
            }
            stringValue = flattenOptionChildren(children);
          }
          if (isArray(selectedValue)) {
            for (var i = 0;i < selectedValue.length; i++) {
              {
                checkAttributeStringCoercion(selectedValue[i], "value");
              }
              var v = "" + selectedValue[i];
              if (v === stringValue) {
                target.push(selectedMarkerAttribute);
                break;
              }
            }
          } else {
            {
              checkAttributeStringCoercion(selectedValue, "select.value");
            }
            if ("" + selectedValue === stringValue) {
              target.push(selectedMarkerAttribute);
            }
          }
        } else if (selected) {
          target.push(selectedMarkerAttribute);
        }
        target.push(endOfStartTag);
        pushInnerHTML(target, innerHTML, children);
        return children;
      }
      function pushInput(target, props, responseState) {
        {
          checkControlledValueProps("input", props);
          if (props.checked !== undefined && props.defaultChecked !== undefined && !didWarnDefaultChecked) {
            error("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", "A component", props.type);
            didWarnDefaultChecked = true;
          }
          if (props.value !== undefined && props.defaultValue !== undefined && !didWarnDefaultInputValue) {
            error("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", "A component", props.type);
            didWarnDefaultInputValue = true;
          }
        }
        target.push(startChunkForTag("input"));
        var value = null;
        var defaultValue = null;
        var checked = null;
        var defaultChecked = null;
        for (var propKey in props) {
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null) {
              continue;
            }
            switch (propKey) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw new Error("input is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
              case "defaultChecked":
                defaultChecked = propValue;
                break;
              case "defaultValue":
                defaultValue = propValue;
                break;
              case "checked":
                checked = propValue;
                break;
              case "value":
                value = propValue;
                break;
              default:
                pushAttribute(target, responseState, propKey, propValue);
                break;
            }
          }
        }
        if (checked !== null) {
          pushAttribute(target, responseState, "checked", checked);
        } else if (defaultChecked !== null) {
          pushAttribute(target, responseState, "checked", defaultChecked);
        }
        if (value !== null) {
          pushAttribute(target, responseState, "value", value);
        } else if (defaultValue !== null) {
          pushAttribute(target, responseState, "value", defaultValue);
        }
        target.push(endOfStartTagSelfClosing);
        return null;
      }
      function pushStartTextArea(target, props, responseState) {
        {
          checkControlledValueProps("textarea", props);
          if (props.value !== undefined && props.defaultValue !== undefined && !didWarnDefaultTextareaValue) {
            error("Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components");
            didWarnDefaultTextareaValue = true;
          }
        }
        target.push(startChunkForTag("textarea"));
        var value = null;
        var defaultValue = null;
        var children = null;
        for (var propKey in props) {
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null) {
              continue;
            }
            switch (propKey) {
              case "children":
                children = propValue;
                break;
              case "value":
                value = propValue;
                break;
              case "defaultValue":
                defaultValue = propValue;
                break;
              case "dangerouslySetInnerHTML":
                throw new Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
              default:
                pushAttribute(target, responseState, propKey, propValue);
                break;
            }
          }
        }
        if (value === null && defaultValue !== null) {
          value = defaultValue;
        }
        target.push(endOfStartTag);
        if (children != null) {
          {
            error("Use the `defaultValue` or `value` props instead of setting children on <textarea>.");
          }
          if (value != null) {
            throw new Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
          }
          if (isArray(children)) {
            if (children.length > 1) {
              throw new Error("<textarea> can only have at most one child.");
            }
            {
              checkHtmlStringCoercion(children[0]);
            }
            value = "" + children[0];
          }
          {
            checkHtmlStringCoercion(children);
          }
          value = "" + children;
        }
        if (typeof value === "string" && value[0] === "\n") {
          target.push(leadingNewline);
        }
        if (value !== null) {
          {
            checkAttributeStringCoercion(value, "value");
          }
          target.push(stringToChunk(encodeHTMLTextNode("" + value)));
        }
        return null;
      }
      function pushSelfClosing(target, props, tag, responseState) {
        target.push(startChunkForTag(tag));
        for (var propKey in props) {
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null) {
              continue;
            }
            switch (propKey) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw new Error(tag + " is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
              default:
                pushAttribute(target, responseState, propKey, propValue);
                break;
            }
          }
        }
        target.push(endOfStartTagSelfClosing);
        return null;
      }
      function pushStartMenuItem(target, props, responseState) {
        target.push(startChunkForTag("menuitem"));
        for (var propKey in props) {
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null) {
              continue;
            }
            switch (propKey) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw new Error("menuitems cannot have `children` nor `dangerouslySetInnerHTML`.");
              default:
                pushAttribute(target, responseState, propKey, propValue);
                break;
            }
          }
        }
        target.push(endOfStartTag);
        return null;
      }
      function pushStartTitle(target, props, responseState) {
        target.push(startChunkForTag("title"));
        var children = null;
        for (var propKey in props) {
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null) {
              continue;
            }
            switch (propKey) {
              case "children":
                children = propValue;
                break;
              case "dangerouslySetInnerHTML":
                throw new Error("`dangerouslySetInnerHTML` does not make sense on <title>.");
              default:
                pushAttribute(target, responseState, propKey, propValue);
                break;
            }
          }
        }
        target.push(endOfStartTag);
        {
          var child = Array.isArray(children) && children.length < 2 ? children[0] || null : children;
          if (Array.isArray(children) && children.length > 1) {
            error("A title element received an array with more than 1 element as children. In browsers title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering");
          } else if (child != null && child.$$typeof != null) {
            error("A title element received a React element for children. In the browser title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering");
          } else if (child != null && typeof child !== "string" && typeof child !== "number") {
            error("A title element received a value that was not a string or number for children. In the browser title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering");
          }
        }
        return children;
      }
      function pushStartGenericElement(target, props, tag, responseState) {
        target.push(startChunkForTag(tag));
        var children = null;
        var innerHTML = null;
        for (var propKey in props) {
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null) {
              continue;
            }
            switch (propKey) {
              case "children":
                children = propValue;
                break;
              case "dangerouslySetInnerHTML":
                innerHTML = propValue;
                break;
              default:
                pushAttribute(target, responseState, propKey, propValue);
                break;
            }
          }
        }
        target.push(endOfStartTag);
        pushInnerHTML(target, innerHTML, children);
        if (typeof children === "string") {
          target.push(stringToChunk(encodeHTMLTextNode(children)));
          return null;
        }
        return children;
      }
      function pushStartCustomElement(target, props, tag, responseState) {
        target.push(startChunkForTag(tag));
        var children = null;
        var innerHTML = null;
        for (var propKey in props) {
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null) {
              continue;
            }
            switch (propKey) {
              case "children":
                children = propValue;
                break;
              case "dangerouslySetInnerHTML":
                innerHTML = propValue;
                break;
              case "style":
                pushStyle(target, responseState, propValue);
                break;
              case "suppressContentEditableWarning":
              case "suppressHydrationWarning":
                break;
              default:
                if (isAttributeNameSafe(propKey) && typeof propValue !== "function" && typeof propValue !== "symbol") {
                  target.push(attributeSeparator, stringToChunk(propKey), attributeAssign, stringToChunk(escapeTextForBrowser(propValue)), attributeEnd);
                }
                break;
            }
          }
        }
        target.push(endOfStartTag);
        pushInnerHTML(target, innerHTML, children);
        return children;
      }
      var leadingNewline = stringToPrecomputedChunk("\n");
      function pushStartPreformattedElement(target, props, tag, responseState) {
        target.push(startChunkForTag(tag));
        var children = null;
        var innerHTML = null;
        for (var propKey in props) {
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null) {
              continue;
            }
            switch (propKey) {
              case "children":
                children = propValue;
                break;
              case "dangerouslySetInnerHTML":
                innerHTML = propValue;
                break;
              default:
                pushAttribute(target, responseState, propKey, propValue);
                break;
            }
          }
        }
        target.push(endOfStartTag);
        if (innerHTML != null) {
          if (children != null) {
            throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
          }
          if (typeof innerHTML !== "object" || !("__html" in innerHTML)) {
            throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
          }
          var html = innerHTML.__html;
          if (html !== null && html !== undefined) {
            if (typeof html === "string" && html.length > 0 && html[0] === "\n") {
              target.push(leadingNewline, stringToChunk(html));
            } else {
              {
                checkHtmlStringCoercion(html);
              }
              target.push(stringToChunk("" + html));
            }
          }
        }
        if (typeof children === "string" && children[0] === "\n") {
          target.push(leadingNewline);
        }
        return children;
      }
      var VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/;
      var validatedTagCache = new Map;
      function startChunkForTag(tag) {
        var tagStartChunk = validatedTagCache.get(tag);
        if (tagStartChunk === undefined) {
          if (!VALID_TAG_REGEX.test(tag)) {
            throw new Error("Invalid tag: " + tag);
          }
          tagStartChunk = stringToPrecomputedChunk("<" + tag);
          validatedTagCache.set(tag, tagStartChunk);
        }
        return tagStartChunk;
      }
      var DOCTYPE = stringToPrecomputedChunk("<!DOCTYPE html>");
      function pushStartInstance(target, type, props, responseState, formatContext) {
        {
          validateProperties(type, props);
          validateProperties$1(type, props);
          validateProperties$2(type, props, null);
          if (!props.suppressContentEditableWarning && props.contentEditable && props.children != null) {
            error("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional.");
          }
          if (formatContext.insertionMode !== SVG_MODE && formatContext.insertionMode !== MATHML_MODE) {
            if (type.indexOf("-") === -1 && typeof props.is !== "string" && type.toLowerCase() !== type) {
              error("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", type);
            }
          }
        }
        switch (type) {
          case "select":
            return pushStartSelect(target, props, responseState);
          case "option":
            return pushStartOption(target, props, responseState, formatContext);
          case "textarea":
            return pushStartTextArea(target, props, responseState);
          case "input":
            return pushInput(target, props, responseState);
          case "menuitem":
            return pushStartMenuItem(target, props, responseState);
          case "title":
            return pushStartTitle(target, props, responseState);
          case "listing":
          case "pre": {
            return pushStartPreformattedElement(target, props, type, responseState);
          }
          case "area":
          case "base":
          case "br":
          case "col":
          case "embed":
          case "hr":
          case "img":
          case "keygen":
          case "link":
          case "meta":
          case "param":
          case "source":
          case "track":
          case "wbr": {
            return pushSelfClosing(target, props, type, responseState);
          }
          case "annotation-xml":
          case "color-profile":
          case "font-face":
          case "font-face-src":
          case "font-face-uri":
          case "font-face-format":
          case "font-face-name":
          case "missing-glyph": {
            return pushStartGenericElement(target, props, type, responseState);
          }
          case "html": {
            if (formatContext.insertionMode === ROOT_HTML_MODE) {
              target.push(DOCTYPE);
            }
            return pushStartGenericElement(target, props, type, responseState);
          }
          default: {
            if (type.indexOf("-") === -1 && typeof props.is !== "string") {
              return pushStartGenericElement(target, props, type, responseState);
            } else {
              return pushStartCustomElement(target, props, type, responseState);
            }
          }
        }
      }
      var endTag1 = stringToPrecomputedChunk("</");
      var endTag2 = stringToPrecomputedChunk(">");
      function pushEndInstance(target, type, props) {
        switch (type) {
          case "area":
          case "base":
          case "br":
          case "col":
          case "embed":
          case "hr":
          case "img":
          case "input":
          case "keygen":
          case "link":
          case "meta":
          case "param":
          case "source":
          case "track":
          case "wbr": {
            break;
          }
          default: {
            target.push(endTag1, stringToChunk(type), endTag2);
          }
        }
      }
      function writeCompletedRoot(destination, responseState) {
        var bootstrapChunks = responseState.bootstrapChunks;
        var i = 0;
        for (;i < bootstrapChunks.length - 1; i++) {
          writeChunk(destination, bootstrapChunks[i]);
        }
        if (i < bootstrapChunks.length) {
          return writeChunkAndReturn(destination, bootstrapChunks[i]);
        }
        return true;
      }
      var placeholder1 = stringToPrecomputedChunk('<template id="');
      var placeholder2 = stringToPrecomputedChunk('"></template>');
      function writePlaceholder(destination, responseState, id) {
        writeChunk(destination, placeholder1);
        writeChunk(destination, responseState.placeholderPrefix);
        var formattedID = stringToChunk(id.toString(16));
        writeChunk(destination, formattedID);
        return writeChunkAndReturn(destination, placeholder2);
      }
      var startCompletedSuspenseBoundary = stringToPrecomputedChunk("<!--$-->");
      var startPendingSuspenseBoundary1 = stringToPrecomputedChunk('<!--$?--><template id="');
      var startPendingSuspenseBoundary2 = stringToPrecomputedChunk('"></template>');
      var startClientRenderedSuspenseBoundary = stringToPrecomputedChunk("<!--$!-->");
      var endSuspenseBoundary = stringToPrecomputedChunk("<!--/$-->");
      var clientRenderedSuspenseBoundaryError1 = stringToPrecomputedChunk("<template");
      var clientRenderedSuspenseBoundaryErrorAttrInterstitial = stringToPrecomputedChunk('"');
      var clientRenderedSuspenseBoundaryError1A = stringToPrecomputedChunk(' data-dgst="');
      var clientRenderedSuspenseBoundaryError1B = stringToPrecomputedChunk(' data-msg="');
      var clientRenderedSuspenseBoundaryError1C = stringToPrecomputedChunk(' data-stck="');
      var clientRenderedSuspenseBoundaryError2 = stringToPrecomputedChunk("></template>");
      function writeStartCompletedSuspenseBoundary(destination, responseState) {
        return writeChunkAndReturn(destination, startCompletedSuspenseBoundary);
      }
      function writeStartPendingSuspenseBoundary(destination, responseState, id) {
        writeChunk(destination, startPendingSuspenseBoundary1);
        if (id === null) {
          throw new Error("An ID must have been assigned before we can complete the boundary.");
        }
        writeChunk(destination, id);
        return writeChunkAndReturn(destination, startPendingSuspenseBoundary2);
      }
      function writeStartClientRenderedSuspenseBoundary(destination, responseState, errorDigest, errorMesssage, errorComponentStack) {
        var result2;
        result2 = writeChunkAndReturn(destination, startClientRenderedSuspenseBoundary);
        writeChunk(destination, clientRenderedSuspenseBoundaryError1);
        if (errorDigest) {
          writeChunk(destination, clientRenderedSuspenseBoundaryError1A);
          writeChunk(destination, stringToChunk(escapeTextForBrowser(errorDigest)));
          writeChunk(destination, clientRenderedSuspenseBoundaryErrorAttrInterstitial);
        }
        {
          if (errorMesssage) {
            writeChunk(destination, clientRenderedSuspenseBoundaryError1B);
            writeChunk(destination, stringToChunk(escapeTextForBrowser(errorMesssage)));
            writeChunk(destination, clientRenderedSuspenseBoundaryErrorAttrInterstitial);
          }
          if (errorComponentStack) {
            writeChunk(destination, clientRenderedSuspenseBoundaryError1C);
            writeChunk(destination, stringToChunk(escapeTextForBrowser(errorComponentStack)));
            writeChunk(destination, clientRenderedSuspenseBoundaryErrorAttrInterstitial);
          }
        }
        result2 = writeChunkAndReturn(destination, clientRenderedSuspenseBoundaryError2);
        return result2;
      }
      function writeEndCompletedSuspenseBoundary(destination, responseState) {
        return writeChunkAndReturn(destination, endSuspenseBoundary);
      }
      function writeEndPendingSuspenseBoundary(destination, responseState) {
        return writeChunkAndReturn(destination, endSuspenseBoundary);
      }
      function writeEndClientRenderedSuspenseBoundary(destination, responseState) {
        return writeChunkAndReturn(destination, endSuspenseBoundary);
      }
      var startSegmentHTML = stringToPrecomputedChunk('<div hidden id="');
      var startSegmentHTML2 = stringToPrecomputedChunk('">');
      var endSegmentHTML = stringToPrecomputedChunk("</div>");
      var startSegmentSVG = stringToPrecomputedChunk('<svg aria-hidden="true" style="display:none" id="');
      var startSegmentSVG2 = stringToPrecomputedChunk('">');
      var endSegmentSVG = stringToPrecomputedChunk("</svg>");
      var startSegmentMathML = stringToPrecomputedChunk('<math aria-hidden="true" style="display:none" id="');
      var startSegmentMathML2 = stringToPrecomputedChunk('">');
      var endSegmentMathML = stringToPrecomputedChunk("</math>");
      var startSegmentTable = stringToPrecomputedChunk('<table hidden id="');
      var startSegmentTable2 = stringToPrecomputedChunk('">');
      var endSegmentTable = stringToPrecomputedChunk("</table>");
      var startSegmentTableBody = stringToPrecomputedChunk('<table hidden><tbody id="');
      var startSegmentTableBody2 = stringToPrecomputedChunk('">');
      var endSegmentTableBody = stringToPrecomputedChunk("</tbody></table>");
      var startSegmentTableRow = stringToPrecomputedChunk('<table hidden><tr id="');
      var startSegmentTableRow2 = stringToPrecomputedChunk('">');
      var endSegmentTableRow = stringToPrecomputedChunk("</tr></table>");
      var startSegmentColGroup = stringToPrecomputedChunk('<table hidden><colgroup id="');
      var startSegmentColGroup2 = stringToPrecomputedChunk('">');
      var endSegmentColGroup = stringToPrecomputedChunk("</colgroup></table>");
      function writeStartSegment(destination, responseState, formatContext, id) {
        switch (formatContext.insertionMode) {
          case ROOT_HTML_MODE:
          case HTML_MODE: {
            writeChunk(destination, startSegmentHTML);
            writeChunk(destination, responseState.segmentPrefix);
            writeChunk(destination, stringToChunk(id.toString(16)));
            return writeChunkAndReturn(destination, startSegmentHTML2);
          }
          case SVG_MODE: {
            writeChunk(destination, startSegmentSVG);
            writeChunk(destination, responseState.segmentPrefix);
            writeChunk(destination, stringToChunk(id.toString(16)));
            return writeChunkAndReturn(destination, startSegmentSVG2);
          }
          case MATHML_MODE: {
            writeChunk(destination, startSegmentMathML);
            writeChunk(destination, responseState.segmentPrefix);
            writeChunk(destination, stringToChunk(id.toString(16)));
            return writeChunkAndReturn(destination, startSegmentMathML2);
          }
          case HTML_TABLE_MODE: {
            writeChunk(destination, startSegmentTable);
            writeChunk(destination, responseState.segmentPrefix);
            writeChunk(destination, stringToChunk(id.toString(16)));
            return writeChunkAndReturn(destination, startSegmentTable2);
          }
          case HTML_TABLE_BODY_MODE: {
            writeChunk(destination, startSegmentTableBody);
            writeChunk(destination, responseState.segmentPrefix);
            writeChunk(destination, stringToChunk(id.toString(16)));
            return writeChunkAndReturn(destination, startSegmentTableBody2);
          }
          case HTML_TABLE_ROW_MODE: {
            writeChunk(destination, startSegmentTableRow);
            writeChunk(destination, responseState.segmentPrefix);
            writeChunk(destination, stringToChunk(id.toString(16)));
            return writeChunkAndReturn(destination, startSegmentTableRow2);
          }
          case HTML_COLGROUP_MODE: {
            writeChunk(destination, startSegmentColGroup);
            writeChunk(destination, responseState.segmentPrefix);
            writeChunk(destination, stringToChunk(id.toString(16)));
            return writeChunkAndReturn(destination, startSegmentColGroup2);
          }
          default: {
            throw new Error("Unknown insertion mode. This is a bug in React.");
          }
        }
      }
      function writeEndSegment(destination, formatContext) {
        switch (formatContext.insertionMode) {
          case ROOT_HTML_MODE:
          case HTML_MODE: {
            return writeChunkAndReturn(destination, endSegmentHTML);
          }
          case SVG_MODE: {
            return writeChunkAndReturn(destination, endSegmentSVG);
          }
          case MATHML_MODE: {
            return writeChunkAndReturn(destination, endSegmentMathML);
          }
          case HTML_TABLE_MODE: {
            return writeChunkAndReturn(destination, endSegmentTable);
          }
          case HTML_TABLE_BODY_MODE: {
            return writeChunkAndReturn(destination, endSegmentTableBody);
          }
          case HTML_TABLE_ROW_MODE: {
            return writeChunkAndReturn(destination, endSegmentTableRow);
          }
          case HTML_COLGROUP_MODE: {
            return writeChunkAndReturn(destination, endSegmentColGroup);
          }
          default: {
            throw new Error("Unknown insertion mode. This is a bug in React.");
          }
        }
      }
      var completeSegmentFunction = "function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)}";
      var completeBoundaryFunction = 'function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==d&&"$?"!==d&&"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&&a._reactRetry()}}';
      var clientRenderFunction = 'function $RX(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())}';
      var completeSegmentScript1Full = stringToPrecomputedChunk(completeSegmentFunction + ';$RS("');
      var completeSegmentScript1Partial = stringToPrecomputedChunk('$RS("');
      var completeSegmentScript2 = stringToPrecomputedChunk('","');
      var completeSegmentScript3 = stringToPrecomputedChunk('")</script>');
      function writeCompletedSegmentInstruction(destination, responseState, contentSegmentID) {
        writeChunk(destination, responseState.startInlineScript);
        if (!responseState.sentCompleteSegmentFunction) {
          responseState.sentCompleteSegmentFunction = true;
          writeChunk(destination, completeSegmentScript1Full);
        } else {
          writeChunk(destination, completeSegmentScript1Partial);
        }
        writeChunk(destination, responseState.segmentPrefix);
        var formattedID = stringToChunk(contentSegmentID.toString(16));
        writeChunk(destination, formattedID);
        writeChunk(destination, completeSegmentScript2);
        writeChunk(destination, responseState.placeholderPrefix);
        writeChunk(destination, formattedID);
        return writeChunkAndReturn(destination, completeSegmentScript3);
      }
      var completeBoundaryScript1Full = stringToPrecomputedChunk(completeBoundaryFunction + ';$RC("');
      var completeBoundaryScript1Partial = stringToPrecomputedChunk('$RC("');
      var completeBoundaryScript2 = stringToPrecomputedChunk('","');
      var completeBoundaryScript3 = stringToPrecomputedChunk('")</script>');
      function writeCompletedBoundaryInstruction(destination, responseState, boundaryID, contentSegmentID) {
        writeChunk(destination, responseState.startInlineScript);
        if (!responseState.sentCompleteBoundaryFunction) {
          responseState.sentCompleteBoundaryFunction = true;
          writeChunk(destination, completeBoundaryScript1Full);
        } else {
          writeChunk(destination, completeBoundaryScript1Partial);
        }
        if (boundaryID === null) {
          throw new Error("An ID must have been assigned before we can complete the boundary.");
        }
        var formattedContentID = stringToChunk(contentSegmentID.toString(16));
        writeChunk(destination, boundaryID);
        writeChunk(destination, completeBoundaryScript2);
        writeChunk(destination, responseState.segmentPrefix);
        writeChunk(destination, formattedContentID);
        return writeChunkAndReturn(destination, completeBoundaryScript3);
      }
      var clientRenderScript1Full = stringToPrecomputedChunk(clientRenderFunction + ';$RX("');
      var clientRenderScript1Partial = stringToPrecomputedChunk('$RX("');
      var clientRenderScript1A = stringToPrecomputedChunk('"');
      var clientRenderScript2 = stringToPrecomputedChunk(")</script>");
      var clientRenderErrorScriptArgInterstitial = stringToPrecomputedChunk(",");
      function writeClientRenderBoundaryInstruction(destination, responseState, boundaryID, errorDigest, errorMessage, errorComponentStack) {
        writeChunk(destination, responseState.startInlineScript);
        if (!responseState.sentClientRenderFunction) {
          responseState.sentClientRenderFunction = true;
          writeChunk(destination, clientRenderScript1Full);
        } else {
          writeChunk(destination, clientRenderScript1Partial);
        }
        if (boundaryID === null) {
          throw new Error("An ID must have been assigned before we can complete the boundary.");
        }
        writeChunk(destination, boundaryID);
        writeChunk(destination, clientRenderScript1A);
        if (errorDigest || errorMessage || errorComponentStack) {
          writeChunk(destination, clientRenderErrorScriptArgInterstitial);
          writeChunk(destination, stringToChunk(escapeJSStringsForInstructionScripts(errorDigest || "")));
        }
        if (errorMessage || errorComponentStack) {
          writeChunk(destination, clientRenderErrorScriptArgInterstitial);
          writeChunk(destination, stringToChunk(escapeJSStringsForInstructionScripts(errorMessage || "")));
        }
        if (errorComponentStack) {
          writeChunk(destination, clientRenderErrorScriptArgInterstitial);
          writeChunk(destination, stringToChunk(escapeJSStringsForInstructionScripts(errorComponentStack)));
        }
        return writeChunkAndReturn(destination, clientRenderScript2);
      }
      var regexForJSStringsInScripts = /[<\u2028\u2029]/g;
      function escapeJSStringsForInstructionScripts(input) {
        var escaped = JSON.stringify(input);
        return escaped.replace(regexForJSStringsInScripts, function(match) {
          switch (match) {
            case "<":
              return "\\u003c";
            case "\u2028":
              return "\\u2028";
            case "\u2029":
              return "\\u2029";
            default: {
              throw new Error("escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
            }
          }
        });
      }
      var assign = Object.assign;
      var REACT_ELEMENT_TYPE = Symbol.for("react.element");
      var REACT_PORTAL_TYPE = Symbol.for("react.portal");
      var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
      var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
      var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
      var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
      var REACT_CONTEXT_TYPE = Symbol.for("react.context");
      var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
      var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
      var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
      var REACT_MEMO_TYPE = Symbol.for("react.memo");
      var REACT_LAZY_TYPE = Symbol.for("react.lazy");
      var REACT_SCOPE_TYPE = Symbol.for("react.scope");
      var REACT_DEBUG_TRACING_MODE_TYPE = Symbol.for("react.debug_trace_mode");
      var REACT_LEGACY_HIDDEN_TYPE = Symbol.for("react.legacy_hidden");
      var REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED = Symbol.for("react.default_value");
      var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
      var FAUX_ITERATOR_SYMBOL = "@@iterator";
      function getIteratorFn(maybeIterable) {
        if (maybeIterable === null || typeof maybeIterable !== "object") {
          return null;
        }
        var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
        if (typeof maybeIterator === "function") {
          return maybeIterator;
        }
        return null;
      }
      function getWrappedName(outerType, innerType, wrapperName) {
        var displayName = outerType.displayName;
        if (displayName) {
          return displayName;
        }
        var functionName = innerType.displayName || innerType.name || "";
        return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
      }
      function getContextName(type) {
        return type.displayName || "Context";
      }
      function getComponentNameFromType(type) {
        if (type == null) {
          return null;
        }
        {
          if (typeof type.tag === "number") {
            error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.");
          }
        }
        if (typeof type === "function") {
          return type.displayName || type.name || null;
        }
        if (typeof type === "string") {
          return type;
        }
        switch (type) {
          case REACT_FRAGMENT_TYPE:
            return "Fragment";
          case REACT_PORTAL_TYPE:
            return "Portal";
          case REACT_PROFILER_TYPE:
            return "Profiler";
          case REACT_STRICT_MODE_TYPE:
            return "StrictMode";
          case REACT_SUSPENSE_TYPE:
            return "Suspense";
          case REACT_SUSPENSE_LIST_TYPE:
            return "SuspenseList";
        }
        if (typeof type === "object") {
          switch (type.$$typeof) {
            case REACT_CONTEXT_TYPE:
              var context = type;
              return getContextName(context) + ".Consumer";
            case REACT_PROVIDER_TYPE:
              var provider = type;
              return getContextName(provider._context) + ".Provider";
            case REACT_FORWARD_REF_TYPE:
              return getWrappedName(type, type.render, "ForwardRef");
            case REACT_MEMO_TYPE:
              var outerName = type.displayName || null;
              if (outerName !== null) {
                return outerName;
              }
              return getComponentNameFromType(type.type) || "Memo";
            case REACT_LAZY_TYPE: {
              var lazyComponent = type;
              var payload = lazyComponent._payload;
              var init2 = lazyComponent._init;
              try {
                return getComponentNameFromType(init2(payload));
              } catch (x) {
                return null;
              }
            }
          }
        }
        return null;
      }
      var disabledDepth = 0;
      var prevLog;
      var prevInfo;
      var prevWarn;
      var prevError;
      var prevGroup;
      var prevGroupCollapsed;
      var prevGroupEnd;
      function disabledLog() {
      }
      disabledLog.__reactDisabledLog = true;
      function disableLogs() {
        {
          if (disabledDepth === 0) {
            prevLog = console.log;
            prevInfo = console.info;
            prevWarn = console.warn;
            prevError = console.error;
            prevGroup = console.group;
            prevGroupCollapsed = console.groupCollapsed;
            prevGroupEnd = console.groupEnd;
            var props = {
              configurable: true,
              enumerable: true,
              value: disabledLog,
              writable: true
            };
            Object.defineProperties(console, {
              info: props,
              log: props,
              warn: props,
              error: props,
              group: props,
              groupCollapsed: props,
              groupEnd: props
            });
          }
          disabledDepth++;
        }
      }
      function reenableLogs() {
        {
          disabledDepth--;
          if (disabledDepth === 0) {
            var props = {
              configurable: true,
              enumerable: true,
              writable: true
            };
            Object.defineProperties(console, {
              log: assign({}, props, {
                value: prevLog
              }),
              info: assign({}, props, {
                value: prevInfo
              }),
              warn: assign({}, props, {
                value: prevWarn
              }),
              error: assign({}, props, {
                value: prevError
              }),
              group: assign({}, props, {
                value: prevGroup
              }),
              groupCollapsed: assign({}, props, {
                value: prevGroupCollapsed
              }),
              groupEnd: assign({}, props, {
                value: prevGroupEnd
              })
            });
          }
          if (disabledDepth < 0) {
            error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
          }
        }
      }
      var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
      var prefix;
      function describeBuiltInComponentFrame(name, source, ownerFn) {
        {
          if (prefix === undefined) {
            try {
              throw Error();
            } catch (x) {
              var match = x.stack.trim().match(/\n( *(at )?)/);
              prefix = match && match[1] || "";
            }
          }
          return "\n" + prefix + name;
        }
      }
      var reentry = false;
      var componentFrameCache;
      {
        var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
        componentFrameCache = new PossiblyWeakMap;
      }
      function describeNativeComponentFrame(fn, construct) {
        if (!fn || reentry) {
          return "";
        }
        {
          var frame = componentFrameCache.get(fn);
          if (frame !== undefined) {
            return frame;
          }
        }
        var control;
        reentry = true;
        var previousPrepareStackTrace = Error.prepareStackTrace;
        Error.prepareStackTrace = undefined;
        var previousDispatcher;
        {
          previousDispatcher = ReactCurrentDispatcher.current;
          ReactCurrentDispatcher.current = null;
          disableLogs();
        }
        try {
          if (construct) {
            var Fake = function() {
              throw Error();
            };
            Object.defineProperty(Fake.prototype, "props", {
              set: function() {
                throw Error();
              }
            });
            if (typeof Reflect === "object" && Reflect.construct) {
              try {
                Reflect.construct(Fake, []);
              } catch (x) {
                control = x;
              }
              Reflect.construct(fn, [], Fake);
            } else {
              try {
                Fake.call();
              } catch (x) {
                control = x;
              }
              fn.call(Fake.prototype);
            }
          } else {
            try {
              throw Error();
            } catch (x) {
              control = x;
            }
            fn();
          }
        } catch (sample) {
          if (sample && control && typeof sample.stack === "string") {
            var sampleLines = sample.stack.split("\n");
            var controlLines = control.stack.split("\n");
            var s = sampleLines.length - 1;
            var c2 = controlLines.length - 1;
            while (s >= 1 && c2 >= 0 && sampleLines[s] !== controlLines[c2]) {
              c2--;
            }
            for (;s >= 1 && c2 >= 0; s--, c2--) {
              if (sampleLines[s] !== controlLines[c2]) {
                if (s !== 1 || c2 !== 1) {
                  do {
                    s--;
                    c2--;
                    if (c2 < 0 || sampleLines[s] !== controlLines[c2]) {
                      var _frame = "\n" + sampleLines[s].replace(" at new ", " at ");
                      if (fn.displayName && _frame.includes("<anonymous>")) {
                        _frame = _frame.replace("<anonymous>", fn.displayName);
                      }
                      {
                        if (typeof fn === "function") {
                          componentFrameCache.set(fn, _frame);
                        }
                      }
                      return _frame;
                    }
                  } while (s >= 1 && c2 >= 0);
                }
                break;
              }
            }
          }
        } finally {
          reentry = false;
          {
            ReactCurrentDispatcher.current = previousDispatcher;
            reenableLogs();
          }
          Error.prepareStackTrace = previousPrepareStackTrace;
        }
        var name = fn ? fn.displayName || fn.name : "";
        var syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
        {
          if (typeof fn === "function") {
            componentFrameCache.set(fn, syntheticFrame);
          }
        }
        return syntheticFrame;
      }
      function describeClassComponentFrame(ctor, source, ownerFn) {
        {
          return describeNativeComponentFrame(ctor, true);
        }
      }
      function describeFunctionComponentFrame(fn, source, ownerFn) {
        {
          return describeNativeComponentFrame(fn, false);
        }
      }
      function shouldConstruct(Component) {
        var prototype = Component.prototype;
        return !!(prototype && prototype.isReactComponent);
      }
      function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
        if (type == null) {
          return "";
        }
        if (typeof type === "function") {
          {
            return describeNativeComponentFrame(type, shouldConstruct(type));
          }
        }
        if (typeof type === "string") {
          return describeBuiltInComponentFrame(type);
        }
        switch (type) {
          case REACT_SUSPENSE_TYPE:
            return describeBuiltInComponentFrame("Suspense");
          case REACT_SUSPENSE_LIST_TYPE:
            return describeBuiltInComponentFrame("SuspenseList");
        }
        if (typeof type === "object") {
          switch (type.$$typeof) {
            case REACT_FORWARD_REF_TYPE:
              return describeFunctionComponentFrame(type.render);
            case REACT_MEMO_TYPE:
              return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
            case REACT_LAZY_TYPE: {
              var lazyComponent = type;
              var payload = lazyComponent._payload;
              var init2 = lazyComponent._init;
              try {
                return describeUnknownElementTypeFrameInDEV(init2(payload), source, ownerFn);
              } catch (x) {
              }
            }
          }
        }
        return "";
      }
      var loggedTypeFailures = {};
      var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
      function setCurrentlyValidatingElement(element) {
        {
          if (element) {
            var owner = element._owner;
            var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
            ReactDebugCurrentFrame.setExtraStackFrame(stack);
          } else {
            ReactDebugCurrentFrame.setExtraStackFrame(null);
          }
        }
      }
      function checkPropTypes(typeSpecs, values2, location, componentName, element) {
        {
          var has = Function.call.bind(hasOwnProperty);
          for (var typeSpecName in typeSpecs) {
            if (has(typeSpecs, typeSpecName)) {
              var error$1 = undefined;
              try {
                if (typeof typeSpecs[typeSpecName] !== "function") {
                  var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                  err.name = "Invariant Violation";
                  throw err;
                }
                error$1 = typeSpecs[typeSpecName](values2, typeSpecName, componentName, location, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
              } catch (ex) {
                error$1 = ex;
              }
              if (error$1 && !(error$1 instanceof Error)) {
                setCurrentlyValidatingElement(element);
                error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location, typeSpecName, typeof error$1);
                setCurrentlyValidatingElement(null);
              }
              if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                loggedTypeFailures[error$1.message] = true;
                setCurrentlyValidatingElement(element);
                error("Failed %s type: %s", location, error$1.message);
                setCurrentlyValidatingElement(null);
              }
            }
          }
        }
      }
      var warnedAboutMissingGetChildContext;
      {
        warnedAboutMissingGetChildContext = {};
      }
      var emptyContextObject = {};
      {
        Object.freeze(emptyContextObject);
      }
      function getMaskedContext(type, unmaskedContext) {
        {
          var contextTypes = type.contextTypes;
          if (!contextTypes) {
            return emptyContextObject;
          }
          var context = {};
          for (var key in contextTypes) {
            context[key] = unmaskedContext[key];
          }
          {
            var name = getComponentNameFromType(type) || "Unknown";
            checkPropTypes(contextTypes, context, "context", name);
          }
          return context;
        }
      }
      function processChildContext(instance, type, parentContext, childContextTypes) {
        {
          if (typeof instance.getChildContext !== "function") {
            {
              var componentName = getComponentNameFromType(type) || "Unknown";
              if (!warnedAboutMissingGetChildContext[componentName]) {
                warnedAboutMissingGetChildContext[componentName] = true;
                error("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", componentName, componentName);
              }
            }
            return parentContext;
          }
          var childContext = instance.getChildContext();
          for (var contextKey in childContext) {
            if (!(contextKey in childContextTypes)) {
              throw new Error((getComponentNameFromType(type) || "Unknown") + ".getChildContext(): key \"" + contextKey + "\" is not defined in childContextTypes.");
            }
          }
          {
            var name = getComponentNameFromType(type) || "Unknown";
            checkPropTypes(childContextTypes, childContext, "child context", name);
          }
          return assign({}, parentContext, childContext);
        }
      }
      var rendererSigil;
      {
        rendererSigil = {};
      }
      var rootContextSnapshot = null;
      var currentActiveSnapshot = null;
      function popNode(prev) {
        {
          prev.context._currentValue = prev.parentValue;
        }
      }
      function pushNode(next) {
        {
          next.context._currentValue = next.value;
        }
      }
      function popToNearestCommonAncestor(prev, next) {
        if (prev === next)
          ;
        else {
          popNode(prev);
          var parentPrev = prev.parent;
          var parentNext = next.parent;
          if (parentPrev === null) {
            if (parentNext !== null) {
              throw new Error("The stacks must reach the root at the same time. This is a bug in React.");
            }
          } else {
            if (parentNext === null) {
              throw new Error("The stacks must reach the root at the same time. This is a bug in React.");
            }
            popToNearestCommonAncestor(parentPrev, parentNext);
          }
          pushNode(next);
        }
      }
      function popAllPrevious(prev) {
        popNode(prev);
        var parentPrev = prev.parent;
        if (parentPrev !== null) {
          popAllPrevious(parentPrev);
        }
      }
      function pushAllNext(next) {
        var parentNext = next.parent;
        if (parentNext !== null) {
          pushAllNext(parentNext);
        }
        pushNode(next);
      }
      function popPreviousToCommonLevel(prev, next) {
        popNode(prev);
        var parentPrev = prev.parent;
        if (parentPrev === null) {
          throw new Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
        }
        if (parentPrev.depth === next.depth) {
          popToNearestCommonAncestor(parentPrev, next);
        } else {
          popPreviousToCommonLevel(parentPrev, next);
        }
      }
      function popNextToCommonLevel(prev, next) {
        var parentNext = next.parent;
        if (parentNext === null) {
          throw new Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
        }
        if (prev.depth === parentNext.depth) {
          popToNearestCommonAncestor(prev, parentNext);
        } else {
          popNextToCommonLevel(prev, parentNext);
        }
        pushNode(next);
      }
      function switchContext(newSnapshot) {
        var prev = currentActiveSnapshot;
        var next = newSnapshot;
        if (prev !== next) {
          if (prev === null) {
            pushAllNext(next);
          } else if (next === null) {
            popAllPrevious(prev);
          } else if (prev.depth === next.depth) {
            popToNearestCommonAncestor(prev, next);
          } else if (prev.depth > next.depth) {
            popPreviousToCommonLevel(prev, next);
          } else {
            popNextToCommonLevel(prev, next);
          }
          currentActiveSnapshot = next;
        }
      }
      function pushProvider(context, nextValue) {
        var prevValue;
        {
          prevValue = context._currentValue;
          context._currentValue = nextValue;
          {
            if (context._currentRenderer !== undefined && context._currentRenderer !== null && context._currentRenderer !== rendererSigil) {
              error("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.");
            }
            context._currentRenderer = rendererSigil;
          }
        }
        var prevNode = currentActiveSnapshot;
        var newNode = {
          parent: prevNode,
          depth: prevNode === null ? 0 : prevNode.depth + 1,
          context,
          parentValue: prevValue,
          value: nextValue
        };
        currentActiveSnapshot = newNode;
        return newNode;
      }
      function popProvider(context) {
        var prevSnapshot = currentActiveSnapshot;
        if (prevSnapshot === null) {
          throw new Error("Tried to pop a Context at the root of the app. This is a bug in React.");
        }
        {
          if (prevSnapshot.context !== context) {
            error("The parent context is not the expected context. This is probably a bug in React.");
          }
        }
        {
          var value = prevSnapshot.parentValue;
          if (value === REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED) {
            prevSnapshot.context._currentValue = prevSnapshot.context._defaultValue;
          } else {
            prevSnapshot.context._currentValue = value;
          }
          {
            if (context._currentRenderer !== undefined && context._currentRenderer !== null && context._currentRenderer !== rendererSigil) {
              error("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.");
            }
            context._currentRenderer = rendererSigil;
          }
        }
        return currentActiveSnapshot = prevSnapshot.parent;
      }
      function getActiveContext() {
        return currentActiveSnapshot;
      }
      function readContext(context) {
        var value = context._currentValue;
        return value;
      }
      function get(key) {
        return key._reactInternals;
      }
      function set(key, value) {
        key._reactInternals = value;
      }
      var didWarnAboutNoopUpdateForComponent = {};
      var didWarnAboutDeprecatedWillMount = {};
      var didWarnAboutUninitializedState;
      var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate;
      var didWarnAboutLegacyLifecyclesAndDerivedState;
      var didWarnAboutUndefinedDerivedState;
      var warnOnUndefinedDerivedState;
      var warnOnInvalidCallback;
      var didWarnAboutDirectlyAssigningPropsToState;
      var didWarnAboutContextTypeAndContextTypes;
      var didWarnAboutInvalidateContextType;
      {
        didWarnAboutUninitializedState = new Set;
        didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = new Set;
        didWarnAboutLegacyLifecyclesAndDerivedState = new Set;
        didWarnAboutDirectlyAssigningPropsToState = new Set;
        didWarnAboutUndefinedDerivedState = new Set;
        didWarnAboutContextTypeAndContextTypes = new Set;
        didWarnAboutInvalidateContextType = new Set;
        var didWarnOnInvalidCallback = new Set;
        warnOnInvalidCallback = function(callback, callerName) {
          if (callback === null || typeof callback === "function") {
            return;
          }
          var key = callerName + "_" + callback;
          if (!didWarnOnInvalidCallback.has(key)) {
            didWarnOnInvalidCallback.add(key);
            error("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", callerName, callback);
          }
        };
        warnOnUndefinedDerivedState = function(type, partialState) {
          if (partialState === undefined) {
            var componentName = getComponentNameFromType(type) || "Component";
            if (!didWarnAboutUndefinedDerivedState.has(componentName)) {
              didWarnAboutUndefinedDerivedState.add(componentName);
              error("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", componentName);
            }
          }
        };
      }
      function warnNoop(publicInstance, callerName) {
        {
          var _constructor = publicInstance.constructor;
          var componentName = _constructor && getComponentNameFromType(_constructor) || "ReactClass";
          var warningKey = componentName + "." + callerName;
          if (didWarnAboutNoopUpdateForComponent[warningKey]) {
            return;
          }
          error("%s(...): Can only update a mounting component. This usually means you called %s() outside componentWillMount() on the server. This is a no-op.\n\nPlease check the code for the %s component.", callerName, callerName, componentName);
          didWarnAboutNoopUpdateForComponent[warningKey] = true;
        }
      }
      var classComponentUpdater = {
        isMounted: function(inst) {
          return false;
        },
        enqueueSetState: function(inst, payload, callback) {
          var internals = get(inst);
          if (internals.queue === null) {
            warnNoop(inst, "setState");
          } else {
            internals.queue.push(payload);
            {
              if (callback !== undefined && callback !== null) {
                warnOnInvalidCallback(callback, "setState");
              }
            }
          }
        },
        enqueueReplaceState: function(inst, payload, callback) {
          var internals = get(inst);
          internals.replace = true;
          internals.queue = [payload];
          {
            if (callback !== undefined && callback !== null) {
              warnOnInvalidCallback(callback, "setState");
            }
          }
        },
        enqueueForceUpdate: function(inst, callback) {
          var internals = get(inst);
          if (internals.queue === null) {
            warnNoop(inst, "forceUpdate");
          } else {
            {
              if (callback !== undefined && callback !== null) {
                warnOnInvalidCallback(callback, "setState");
              }
            }
          }
        }
      };
      function applyDerivedStateFromProps(instance, ctor, getDerivedStateFromProps, prevState, nextProps) {
        var partialState = getDerivedStateFromProps(nextProps, prevState);
        {
          warnOnUndefinedDerivedState(ctor, partialState);
        }
        var newState = partialState === null || partialState === undefined ? prevState : assign({}, prevState, partialState);
        return newState;
      }
      function constructClassInstance(ctor, props, maskedLegacyContext) {
        var context = emptyContextObject;
        var contextType = ctor.contextType;
        {
          if ("contextType" in ctor) {
            var isValid2 = contextType === null || contextType !== undefined && contextType.$$typeof === REACT_CONTEXT_TYPE && contextType._context === undefined;
            if (!isValid2 && !didWarnAboutInvalidateContextType.has(ctor)) {
              didWarnAboutInvalidateContextType.add(ctor);
              var addendum = "";
              if (contextType === undefined) {
                addendum = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file.";
              } else if (typeof contextType !== "object") {
                addendum = " However, it is set to a " + typeof contextType + ".";
              } else if (contextType.$$typeof === REACT_PROVIDER_TYPE) {
                addendum = " Did you accidentally pass the Context.Provider instead?";
              } else if (contextType._context !== undefined) {
                addendum = " Did you accidentally pass the Context.Consumer instead?";
              } else {
                addendum = " However, it is set to an object with keys {" + Object.keys(contextType).join(", ") + "}.";
              }
              error("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", getComponentNameFromType(ctor) || "Component", addendum);
            }
          }
        }
        if (typeof contextType === "object" && contextType !== null) {
          context = readContext(contextType);
        } else {
          context = maskedLegacyContext;
        }
        var instance = new ctor(props, context);
        {
          if (typeof ctor.getDerivedStateFromProps === "function" && (instance.state === null || instance.state === undefined)) {
            var componentName = getComponentNameFromType(ctor) || "Component";
            if (!didWarnAboutUninitializedState.has(componentName)) {
              didWarnAboutUninitializedState.add(componentName);
              error("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", componentName, instance.state === null ? "null" : "undefined", componentName);
            }
          }
          if (typeof ctor.getDerivedStateFromProps === "function" || typeof instance.getSnapshotBeforeUpdate === "function") {
            var foundWillMountName = null;
            var foundWillReceivePropsName = null;
            var foundWillUpdateName = null;
            if (typeof instance.componentWillMount === "function" && instance.componentWillMount.__suppressDeprecationWarning !== true) {
              foundWillMountName = "componentWillMount";
            } else if (typeof instance.UNSAFE_componentWillMount === "function") {
              foundWillMountName = "UNSAFE_componentWillMount";
            }
            if (typeof instance.componentWillReceiveProps === "function" && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {
              foundWillReceivePropsName = "componentWillReceiveProps";
            } else if (typeof instance.UNSAFE_componentWillReceiveProps === "function") {
              foundWillReceivePropsName = "UNSAFE_componentWillReceiveProps";
            }
            if (typeof instance.componentWillUpdate === "function" && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {
              foundWillUpdateName = "componentWillUpdate";
            } else if (typeof instance.UNSAFE_componentWillUpdate === "function") {
              foundWillUpdateName = "UNSAFE_componentWillUpdate";
            }
            if (foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {
              var _componentName = getComponentNameFromType(ctor) || "Component";
              var newApiName = typeof ctor.getDerivedStateFromProps === "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
              if (!didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)) {
                didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName);
                error("Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\nThe above lifecycles should be removed. Learn more about this warning here:\nhttps://reactjs.org/link/unsafe-component-lifecycles", _componentName, newApiName, foundWillMountName !== null ? "\n  " + foundWillMountName : "", foundWillReceivePropsName !== null ? "\n  " + foundWillReceivePropsName : "", foundWillUpdateName !== null ? "\n  " + foundWillUpdateName : "");
              }
            }
          }
        }
        return instance;
      }
      function checkClassInstance(instance, ctor, newProps) {
        {
          var name = getComponentNameFromType(ctor) || "Component";
          var renderPresent = instance.render;
          if (!renderPresent) {
            if (ctor.prototype && typeof ctor.prototype.render === "function") {
              error("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", name);
            } else {
              error("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", name);
            }
          }
          if (instance.getInitialState && !instance.getInitialState.isReactClassApproved && !instance.state) {
            error("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", name);
          }
          if (instance.getDefaultProps && !instance.getDefaultProps.isReactClassApproved) {
            error("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", name);
          }
          if (instance.propTypes) {
            error("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", name);
          }
          if (instance.contextType) {
            error("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", name);
          }
          {
            if (instance.contextTypes) {
              error("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", name);
            }
            if (ctor.contextType && ctor.contextTypes && !didWarnAboutContextTypeAndContextTypes.has(ctor)) {
              didWarnAboutContextTypeAndContextTypes.add(ctor);
              error("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", name);
            }
          }
          if (typeof instance.componentShouldUpdate === "function") {
            error("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", name);
          }
          if (ctor.prototype && ctor.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate !== "undefined") {
            error("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", getComponentNameFromType(ctor) || "A pure component");
          }
          if (typeof instance.componentDidUnmount === "function") {
            error("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", name);
          }
          if (typeof instance.componentDidReceiveProps === "function") {
            error("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", name);
          }
          if (typeof instance.componentWillRecieveProps === "function") {
            error("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", name);
          }
          if (typeof instance.UNSAFE_componentWillRecieveProps === "function") {
            error("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", name);
          }
          var hasMutatedProps = instance.props !== newProps;
          if (instance.props !== undefined && hasMutatedProps) {
            error("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", name, name);
          }
          if (instance.defaultProps) {
            error("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", name, name);
          }
          if (typeof instance.getSnapshotBeforeUpdate === "function" && typeof instance.componentDidUpdate !== "function" && !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)) {
            didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);
            error("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", getComponentNameFromType(ctor));
          }
          if (typeof instance.getDerivedStateFromProps === "function") {
            error("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", name);
          }
          if (typeof instance.getDerivedStateFromError === "function") {
            error("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", name);
          }
          if (typeof ctor.getSnapshotBeforeUpdate === "function") {
            error("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", name);
          }
          var _state = instance.state;
          if (_state && (typeof _state !== "object" || isArray(_state))) {
            error("%s.state: must be set to an object or null", name);
          }
          if (typeof instance.getChildContext === "function" && typeof ctor.childContextTypes !== "object") {
            error("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", name);
          }
        }
      }
      function callComponentWillMount(type, instance) {
        var oldState = instance.state;
        if (typeof instance.componentWillMount === "function") {
          {
            if (instance.componentWillMount.__suppressDeprecationWarning !== true) {
              var componentName = getComponentNameFromType(type) || "Unknown";
              if (!didWarnAboutDeprecatedWillMount[componentName]) {
                warn("componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move code from componentWillMount to componentDidMount (preferred in most cases) or the constructor.\n\nPlease update the following components: %s", componentName);
                didWarnAboutDeprecatedWillMount[componentName] = true;
              }
            }
          }
          instance.componentWillMount();
        }
        if (typeof instance.UNSAFE_componentWillMount === "function") {
          instance.UNSAFE_componentWillMount();
        }
        if (oldState !== instance.state) {
          {
            error("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", getComponentNameFromType(type) || "Component");
          }
          classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
        }
      }
      function processUpdateQueue(internalInstance, inst, props, maskedLegacyContext) {
        if (internalInstance.queue !== null && internalInstance.queue.length > 0) {
          var oldQueue = internalInstance.queue;
          var oldReplace = internalInstance.replace;
          internalInstance.queue = null;
          internalInstance.replace = false;
          if (oldReplace && oldQueue.length === 1) {
            inst.state = oldQueue[0];
          } else {
            var nextState = oldReplace ? oldQueue[0] : inst.state;
            var dontMutate = true;
            for (var i = oldReplace ? 1 : 0;i < oldQueue.length; i++) {
              var partial = oldQueue[i];
              var partialState = typeof partial === "function" ? partial.call(inst, nextState, props, maskedLegacyContext) : partial;
              if (partialState != null) {
                if (dontMutate) {
                  dontMutate = false;
                  nextState = assign({}, nextState, partialState);
                } else {
                  assign(nextState, partialState);
                }
              }
            }
            inst.state = nextState;
          }
        } else {
          internalInstance.queue = null;
        }
      }
      function mountClassInstance(instance, ctor, newProps, maskedLegacyContext) {
        {
          checkClassInstance(instance, ctor, newProps);
        }
        var initialState = instance.state !== undefined ? instance.state : null;
        instance.updater = classComponentUpdater;
        instance.props = newProps;
        instance.state = initialState;
        var internalInstance = {
          queue: [],
          replace: false
        };
        set(instance, internalInstance);
        var contextType = ctor.contextType;
        if (typeof contextType === "object" && contextType !== null) {
          instance.context = readContext(contextType);
        } else {
          instance.context = maskedLegacyContext;
        }
        {
          if (instance.state === newProps) {
            var componentName = getComponentNameFromType(ctor) || "Component";
            if (!didWarnAboutDirectlyAssigningPropsToState.has(componentName)) {
              didWarnAboutDirectlyAssigningPropsToState.add(componentName);
              error("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", componentName);
            }
          }
        }
        var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
        if (typeof getDerivedStateFromProps === "function") {
          instance.state = applyDerivedStateFromProps(instance, ctor, getDerivedStateFromProps, initialState, newProps);
        }
        if (typeof ctor.getDerivedStateFromProps !== "function" && typeof instance.getSnapshotBeforeUpdate !== "function" && (typeof instance.UNSAFE_componentWillMount === "function" || typeof instance.componentWillMount === "function")) {
          callComponentWillMount(ctor, instance);
          processUpdateQueue(internalInstance, instance, newProps, maskedLegacyContext);
        }
      }
      var emptyTreeContext = {
        id: 1,
        overflow: ""
      };
      function getTreeId(context) {
        var overflow = context.overflow;
        var idWithLeadingBit = context.id;
        var id = idWithLeadingBit & ~getLeadingBit(idWithLeadingBit);
        return id.toString(32) + overflow;
      }
      function pushTreeContext(baseContext, totalChildren, index) {
        var baseIdWithLeadingBit = baseContext.id;
        var baseOverflow = baseContext.overflow;
        var baseLength = getBitLength(baseIdWithLeadingBit) - 1;
        var baseId = baseIdWithLeadingBit & ~(1 << baseLength);
        var slot = index + 1;
        var length = getBitLength(totalChildren) + baseLength;
        if (length > 30) {
          var numberOfOverflowBits = baseLength - baseLength % 5;
          var newOverflowBits = (1 << numberOfOverflowBits) - 1;
          var newOverflow = (baseId & newOverflowBits).toString(32);
          var restOfBaseId = baseId >> numberOfOverflowBits;
          var restOfBaseLength = baseLength - numberOfOverflowBits;
          var restOfLength = getBitLength(totalChildren) + restOfBaseLength;
          var restOfNewBits = slot << restOfBaseLength;
          var id = restOfNewBits | restOfBaseId;
          var overflow = newOverflow + baseOverflow;
          return {
            id: 1 << restOfLength | id,
            overflow
          };
        } else {
          var newBits = slot << baseLength;
          var _id = newBits | baseId;
          var _overflow = baseOverflow;
          return {
            id: 1 << length | _id,
            overflow: _overflow
          };
        }
      }
      function getBitLength(number) {
        return 32 - clz32(number);
      }
      function getLeadingBit(id) {
        return 1 << getBitLength(id) - 1;
      }
      var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback;
      var log = Math.log;
      var LN2 = Math.LN2;
      function clz32Fallback(x) {
        var asUint = x >>> 0;
        if (asUint === 0) {
          return 32;
        }
        return 31 - (log(asUint) / LN2 | 0) | 0;
      }
      function is2(x, y) {
        return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y;
      }
      var objectIs = typeof Object.is === "function" ? Object.is : is2;
      var currentlyRenderingComponent = null;
      var currentlyRenderingTask = null;
      var firstWorkInProgressHook = null;
      var workInProgressHook = null;
      var isReRender = false;
      var didScheduleRenderPhaseUpdate = false;
      var localIdCounter = 0;
      var renderPhaseUpdates = null;
      var numberOfReRenders = 0;
      var RE_RENDER_LIMIT = 25;
      var isInHookUserCodeInDev = false;
      var currentHookNameInDev;
      function resolveCurrentlyRenderingComponent() {
        if (currentlyRenderingComponent === null) {
          throw new Error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.");
        }
        {
          if (isInHookUserCodeInDev) {
            error("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks");
          }
        }
        return currentlyRenderingComponent;
      }
      function areHookInputsEqual(nextDeps, prevDeps) {
        if (prevDeps === null) {
          {
            error("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", currentHookNameInDev);
          }
          return false;
        }
        {
          if (nextDeps.length !== prevDeps.length) {
            error("The final argument passed to %s changed size between renders. The order and size of this array must remain constant.\n\nPrevious: %s\nIncoming: %s", currentHookNameInDev, "[" + nextDeps.join(", ") + "]", "[" + prevDeps.join(", ") + "]");
          }
        }
        for (var i = 0;i < prevDeps.length && i < nextDeps.length; i++) {
          if (objectIs(nextDeps[i], prevDeps[i])) {
            continue;
          }
          return false;
        }
        return true;
      }
      function createHook() {
        if (numberOfReRenders > 0) {
          throw new Error("Rendered more hooks than during the previous render");
        }
        return {
          memoizedState: null,
          queue: null,
          next: null
        };
      }
      function createWorkInProgressHook() {
        if (workInProgressHook === null) {
          if (firstWorkInProgressHook === null) {
            isReRender = false;
            firstWorkInProgressHook = workInProgressHook = createHook();
          } else {
            isReRender = true;
            workInProgressHook = firstWorkInProgressHook;
          }
        } else {
          if (workInProgressHook.next === null) {
            isReRender = false;
            workInProgressHook = workInProgressHook.next = createHook();
          } else {
            isReRender = true;
            workInProgressHook = workInProgressHook.next;
          }
        }
        return workInProgressHook;
      }
      function prepareToUseHooks(task, componentIdentity) {
        currentlyRenderingComponent = componentIdentity;
        currentlyRenderingTask = task;
        {
          isInHookUserCodeInDev = false;
        }
        localIdCounter = 0;
      }
      function finishHooks(Component, props, children, refOrContext) {
        while (didScheduleRenderPhaseUpdate) {
          didScheduleRenderPhaseUpdate = false;
          localIdCounter = 0;
          numberOfReRenders += 1;
          workInProgressHook = null;
          children = Component(props, refOrContext);
        }
        resetHooksState();
        return children;
      }
      function checkDidRenderIdHook() {
        var didRenderIdHook = localIdCounter !== 0;
        return didRenderIdHook;
      }
      function resetHooksState() {
        {
          isInHookUserCodeInDev = false;
        }
        currentlyRenderingComponent = null;
        currentlyRenderingTask = null;
        didScheduleRenderPhaseUpdate = false;
        firstWorkInProgressHook = null;
        numberOfReRenders = 0;
        renderPhaseUpdates = null;
        workInProgressHook = null;
      }
      function readContext$1(context) {
        {
          if (isInHookUserCodeInDev) {
            error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
          }
        }
        return readContext(context);
      }
      function useContext(context) {
        {
          currentHookNameInDev = "useContext";
        }
        resolveCurrentlyRenderingComponent();
        return readContext(context);
      }
      function basicStateReducer(state, action) {
        return typeof action === "function" ? action(state) : action;
      }
      function useState(initialState) {
        {
          currentHookNameInDev = "useState";
        }
        return useReducer(basicStateReducer, initialState);
      }
      function useReducer(reducer, initialArg, init2) {
        {
          if (reducer !== basicStateReducer) {
            currentHookNameInDev = "useReducer";
          }
        }
        currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
        workInProgressHook = createWorkInProgressHook();
        if (isReRender) {
          var queue3 = workInProgressHook.queue;
          var dispatch = queue3.dispatch;
          if (renderPhaseUpdates !== null) {
            var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue3);
            if (firstRenderPhaseUpdate !== undefined) {
              renderPhaseUpdates.delete(queue3);
              var newState = workInProgressHook.memoizedState;
              var update = firstRenderPhaseUpdate;
              do {
                var action = update.action;
                {
                  isInHookUserCodeInDev = true;
                }
                newState = reducer(newState, action);
                {
                  isInHookUserCodeInDev = false;
                }
                update = update.next;
              } while (update !== null);
              workInProgressHook.memoizedState = newState;
              return [newState, dispatch];
            }
          }
          return [workInProgressHook.memoizedState, dispatch];
        } else {
          {
            isInHookUserCodeInDev = true;
          }
          var initialState;
          if (reducer === basicStateReducer) {
            initialState = typeof initialArg === "function" ? initialArg() : initialArg;
          } else {
            initialState = init2 !== undefined ? init2(initialArg) : initialArg;
          }
          {
            isInHookUserCodeInDev = false;
          }
          workInProgressHook.memoizedState = initialState;
          var _queue = workInProgressHook.queue = {
            last: null,
            dispatch: null
          };
          var _dispatch = _queue.dispatch = dispatchAction.bind(null, currentlyRenderingComponent, _queue);
          return [workInProgressHook.memoizedState, _dispatch];
        }
      }
      function useMemo(nextCreate, deps) {
        currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
        workInProgressHook = createWorkInProgressHook();
        var nextDeps = deps === undefined ? null : deps;
        if (workInProgressHook !== null) {
          var prevState = workInProgressHook.memoizedState;
          if (prevState !== null) {
            if (nextDeps !== null) {
              var prevDeps = prevState[1];
              if (areHookInputsEqual(nextDeps, prevDeps)) {
                return prevState[0];
              }
            }
          }
        }
        {
          isInHookUserCodeInDev = true;
        }
        var nextValue = nextCreate();
        {
          isInHookUserCodeInDev = false;
        }
        workInProgressHook.memoizedState = [nextValue, nextDeps];
        return nextValue;
      }
      function useRef(initialValue) {
        currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
        workInProgressHook = createWorkInProgressHook();
        var previousRef = workInProgressHook.memoizedState;
        if (previousRef === null) {
          var ref = {
            current: initialValue
          };
          {
            Object.seal(ref);
          }
          workInProgressHook.memoizedState = ref;
          return ref;
        } else {
          return previousRef;
        }
      }
      function useLayoutEffect(create, inputs) {
        {
          currentHookNameInDev = "useLayoutEffect";
          error("useLayoutEffect does nothing on the server, because its effect cannot be encoded into the server renderer's output format. This will lead to a mismatch between the initial, non-hydrated UI and the intended UI. To avoid this, useLayoutEffect should only be used in components that render exclusively on the client. See https://reactjs.org/link/uselayouteffect-ssr for common fixes.");
        }
      }
      function dispatchAction(componentIdentity, queue3, action) {
        if (numberOfReRenders >= RE_RENDER_LIMIT) {
          throw new Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
        }
        if (componentIdentity === currentlyRenderingComponent) {
          didScheduleRenderPhaseUpdate = true;
          var update = {
            action,
            next: null
          };
          if (renderPhaseUpdates === null) {
            renderPhaseUpdates = new Map;
          }
          var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue3);
          if (firstRenderPhaseUpdate === undefined) {
            renderPhaseUpdates.set(queue3, update);
          } else {
            var lastRenderPhaseUpdate = firstRenderPhaseUpdate;
            while (lastRenderPhaseUpdate.next !== null) {
              lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;
            }
            lastRenderPhaseUpdate.next = update;
          }
        }
      }
      function useCallback(callback, deps) {
        return useMemo(function() {
          return callback;
        }, deps);
      }
      function useMutableSource(source, getSnapshot, subscribe2) {
        resolveCurrentlyRenderingComponent();
        return getSnapshot(source._source);
      }
      function useSyncExternalStore(subscribe2, getSnapshot, getServerSnapshot) {
        if (getServerSnapshot === undefined) {
          throw new Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
        }
        return getServerSnapshot();
      }
      function useDeferredValue(value) {
        resolveCurrentlyRenderingComponent();
        return value;
      }
      function unsupportedStartTransition() {
        throw new Error("startTransition cannot be called during server rendering.");
      }
      function useTransition() {
        resolveCurrentlyRenderingComponent();
        return [false, unsupportedStartTransition];
      }
      function useId() {
        var task = currentlyRenderingTask;
        var treeId = getTreeId(task.treeContext);
        var responseState = currentResponseState;
        if (responseState === null) {
          throw new Error("Invalid hook call. Hooks can only be called inside of the body of a function component.");
        }
        var localId = localIdCounter++;
        return makeId(responseState, treeId, localId);
      }
      function noop3() {
      }
      var Dispatcher = {
        readContext: readContext$1,
        useContext,
        useMemo,
        useReducer,
        useRef,
        useState,
        useInsertionEffect: noop3,
        useLayoutEffect,
        useCallback,
        useImperativeHandle: noop3,
        useEffect: noop3,
        useDebugValue: noop3,
        useDeferredValue,
        useTransition,
        useId,
        useMutableSource,
        useSyncExternalStore
      };
      var currentResponseState = null;
      function setCurrentResponseState(responseState) {
        currentResponseState = responseState;
      }
      function getStackByComponentStackNode(componentStack) {
        try {
          var info = "";
          var node = componentStack;
          do {
            switch (node.tag) {
              case 0:
                info += describeBuiltInComponentFrame(node.type, null, null);
                break;
              case 1:
                info += describeFunctionComponentFrame(node.type, null, null);
                break;
              case 2:
                info += describeClassComponentFrame(node.type, null, null);
                break;
            }
            node = node.parent;
          } while (node);
          return info;
        } catch (x) {
          return "\nError generating stack: " + x.message + "\n" + x.stack;
        }
      }
      var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;
      var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
      var PENDING = 0;
      var COMPLETED = 1;
      var FLUSHED = 2;
      var ABORTED = 3;
      var ERRORED = 4;
      var OPEN = 0;
      var CLOSING = 1;
      var CLOSED = 2;
      var DEFAULT_PROGRESSIVE_CHUNK_SIZE = 12800;
      function defaultErrorHandler(error2) {
        console["error"](error2);
        return null;
      }
      function noop$1() {
      }
      function createRequest(children, responseState, rootFormatContext, progressiveChunkSize, onError, onAllReady, onShellReady, onShellError, onFatalError) {
        var pingedTasks = [];
        var abortSet = new Set;
        var request = {
          destination: null,
          responseState,
          progressiveChunkSize: progressiveChunkSize === undefined ? DEFAULT_PROGRESSIVE_CHUNK_SIZE : progressiveChunkSize,
          status: OPEN,
          fatalError: null,
          nextSegmentId: 0,
          allPendingTasks: 0,
          pendingRootTasks: 0,
          completedRootSegment: null,
          abortableTasks: abortSet,
          pingedTasks,
          clientRenderedBoundaries: [],
          completedBoundaries: [],
          partialBoundaries: [],
          onError: onError === undefined ? defaultErrorHandler : onError,
          onAllReady: onAllReady === undefined ? noop$1 : onAllReady,
          onShellReady: onShellReady === undefined ? noop$1 : onShellReady,
          onShellError: onShellError === undefined ? noop$1 : onShellError,
          onFatalError: onFatalError === undefined ? noop$1 : onFatalError
        };
        var rootSegment = createPendingSegment(request, 0, null, rootFormatContext, false, false);
        rootSegment.parentFlushed = true;
        var rootTask = createTask(request, children, null, rootSegment, abortSet, emptyContextObject, rootContextSnapshot, emptyTreeContext);
        pingedTasks.push(rootTask);
        return request;
      }
      function pingTask(request, task) {
        var pingedTasks = request.pingedTasks;
        pingedTasks.push(task);
        if (pingedTasks.length === 1) {
          scheduleWork(function() {
            return performWork(request);
          });
        }
      }
      function createSuspenseBoundary(request, fallbackAbortableTasks) {
        return {
          id: UNINITIALIZED_SUSPENSE_BOUNDARY_ID,
          rootSegmentID: -1,
          parentFlushed: false,
          pendingTasks: 0,
          forceClientRender: false,
          completedSegments: [],
          byteSize: 0,
          fallbackAbortableTasks,
          errorDigest: null
        };
      }
      function createTask(request, node, blockedBoundary, blockedSegment, abortSet, legacyContext, context, treeContext) {
        request.allPendingTasks++;
        if (blockedBoundary === null) {
          request.pendingRootTasks++;
        } else {
          blockedBoundary.pendingTasks++;
        }
        var task = {
          node,
          ping: function() {
            return pingTask(request, task);
          },
          blockedBoundary,
          blockedSegment,
          abortSet,
          legacyContext,
          context,
          treeContext
        };
        {
          task.componentStack = null;
        }
        abortSet.add(task);
        return task;
      }
      function createPendingSegment(request, index, boundary, formatContext, lastPushedText, textEmbedded) {
        return {
          status: PENDING,
          id: -1,
          index,
          parentFlushed: false,
          chunks: [],
          children: [],
          formatContext,
          boundary,
          lastPushedText,
          textEmbedded
        };
      }
      var currentTaskInDEV = null;
      function getCurrentStackInDEV() {
        {
          if (currentTaskInDEV === null || currentTaskInDEV.componentStack === null) {
            return "";
          }
          return getStackByComponentStackNode(currentTaskInDEV.componentStack);
        }
      }
      function pushBuiltInComponentStackInDEV(task, type) {
        {
          task.componentStack = {
            tag: 0,
            parent: task.componentStack,
            type
          };
        }
      }
      function pushFunctionComponentStackInDEV(task, type) {
        {
          task.componentStack = {
            tag: 1,
            parent: task.componentStack,
            type
          };
        }
      }
      function pushClassComponentStackInDEV(task, type) {
        {
          task.componentStack = {
            tag: 2,
            parent: task.componentStack,
            type
          };
        }
      }
      function popComponentStackInDEV(task) {
        {
          if (task.componentStack === null) {
            error("Unexpectedly popped too many stack frames. This is a bug in React.");
          } else {
            task.componentStack = task.componentStack.parent;
          }
        }
      }
      var lastBoundaryErrorComponentStackDev = null;
      function captureBoundaryErrorDetailsDev(boundary, error2) {
        {
          var errorMessage;
          if (typeof error2 === "string") {
            errorMessage = error2;
          } else if (error2 && typeof error2.message === "string") {
            errorMessage = error2.message;
          } else {
            errorMessage = String(error2);
          }
          var errorComponentStack = lastBoundaryErrorComponentStackDev || getCurrentStackInDEV();
          lastBoundaryErrorComponentStackDev = null;
          boundary.errorMessage = errorMessage;
          boundary.errorComponentStack = errorComponentStack;
        }
      }
      function logRecoverableError(request, error2) {
        var errorDigest = request.onError(error2);
        if (errorDigest != null && typeof errorDigest !== "string") {
          throw new Error("onError returned something with a type other than \"string\". onError should return a string and may return null or undefined but must not return anything else. It received something of type \"" + typeof errorDigest + "\" instead");
        }
        return errorDigest;
      }
      function fatalError(request, error2) {
        var onShellError = request.onShellError;
        onShellError(error2);
        var onFatalError = request.onFatalError;
        onFatalError(error2);
        if (request.destination !== null) {
          request.status = CLOSED;
          closeWithError(request.destination, error2);
        } else {
          request.status = CLOSING;
          request.fatalError = error2;
        }
      }
      function renderSuspenseBoundary(request, task, props) {
        pushBuiltInComponentStackInDEV(task, "Suspense");
        var parentBoundary = task.blockedBoundary;
        var parentSegment = task.blockedSegment;
        var fallback = props.fallback;
        var content = props.children;
        var fallbackAbortSet = new Set;
        var newBoundary = createSuspenseBoundary(request, fallbackAbortSet);
        var insertionIndex = parentSegment.chunks.length;
        var boundarySegment = createPendingSegment(request, insertionIndex, newBoundary, parentSegment.formatContext, false, false);
        parentSegment.children.push(boundarySegment);
        parentSegment.lastPushedText = false;
        var contentRootSegment = createPendingSegment(request, 0, null, parentSegment.formatContext, false, false);
        contentRootSegment.parentFlushed = true;
        task.blockedBoundary = newBoundary;
        task.blockedSegment = contentRootSegment;
        try {
          renderNode(request, task, content);
          pushSegmentFinale(contentRootSegment.chunks, request.responseState, contentRootSegment.lastPushedText, contentRootSegment.textEmbedded);
          contentRootSegment.status = COMPLETED;
          queueCompletedSegment(newBoundary, contentRootSegment);
          if (newBoundary.pendingTasks === 0) {
            popComponentStackInDEV(task);
            return;
          }
        } catch (error2) {
          contentRootSegment.status = ERRORED;
          newBoundary.forceClientRender = true;
          newBoundary.errorDigest = logRecoverableError(request, error2);
          {
            captureBoundaryErrorDetailsDev(newBoundary, error2);
          }
        } finally {
          task.blockedBoundary = parentBoundary;
          task.blockedSegment = parentSegment;
        }
        var suspendedFallbackTask = createTask(request, fallback, parentBoundary, boundarySegment, fallbackAbortSet, task.legacyContext, task.context, task.treeContext);
        {
          suspendedFallbackTask.componentStack = task.componentStack;
        }
        request.pingedTasks.push(suspendedFallbackTask);
        popComponentStackInDEV(task);
      }
      function renderHostElement(request, task, type, props) {
        pushBuiltInComponentStackInDEV(task, type);
        var segment = task.blockedSegment;
        var children = pushStartInstance(segment.chunks, type, props, request.responseState, segment.formatContext);
        segment.lastPushedText = false;
        var prevContext = segment.formatContext;
        segment.formatContext = getChildFormatContext(prevContext, type, props);
        renderNode(request, task, children);
        segment.formatContext = prevContext;
        pushEndInstance(segment.chunks, type);
        segment.lastPushedText = false;
        popComponentStackInDEV(task);
      }
      function shouldConstruct$1(Component) {
        return Component.prototype && Component.prototype.isReactComponent;
      }
      function renderWithHooks(request, task, Component, props, secondArg) {
        var componentIdentity = {};
        prepareToUseHooks(task, componentIdentity);
        var result2 = Component(props, secondArg);
        return finishHooks(Component, props, result2, secondArg);
      }
      function finishClassComponent(request, task, instance, Component, props) {
        var nextChildren = instance.render();
        {
          if (instance.props !== props) {
            if (!didWarnAboutReassigningProps) {
              error("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", getComponentNameFromType(Component) || "a component");
            }
            didWarnAboutReassigningProps = true;
          }
        }
        {
          var childContextTypes = Component.childContextTypes;
          if (childContextTypes !== null && childContextTypes !== undefined) {
            var previousContext = task.legacyContext;
            var mergedContext = processChildContext(instance, Component, previousContext, childContextTypes);
            task.legacyContext = mergedContext;
            renderNodeDestructive(request, task, nextChildren);
            task.legacyContext = previousContext;
            return;
          }
        }
        renderNodeDestructive(request, task, nextChildren);
      }
      function renderClassComponent(request, task, Component, props) {
        pushClassComponentStackInDEV(task, Component);
        var maskedContext = getMaskedContext(Component, task.legacyContext);
        var instance = constructClassInstance(Component, props, maskedContext);
        mountClassInstance(instance, Component, props, maskedContext);
        finishClassComponent(request, task, instance, Component, props);
        popComponentStackInDEV(task);
      }
      var didWarnAboutBadClass = {};
      var didWarnAboutModulePatternComponent = {};
      var didWarnAboutContextTypeOnFunctionComponent = {};
      var didWarnAboutGetDerivedStateOnFunctionComponent = {};
      var didWarnAboutReassigningProps = false;
      var didWarnAboutGenerators = false;
      var didWarnAboutMaps = false;
      var hasWarnedAboutUsingContextAsConsumer = false;
      function renderIndeterminateComponent(request, task, Component, props) {
        var legacyContext;
        {
          legacyContext = getMaskedContext(Component, task.legacyContext);
        }
        pushFunctionComponentStackInDEV(task, Component);
        {
          if (Component.prototype && typeof Component.prototype.render === "function") {
            var componentName = getComponentNameFromType(Component) || "Unknown";
            if (!didWarnAboutBadClass[componentName]) {
              error("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", componentName, componentName);
              didWarnAboutBadClass[componentName] = true;
            }
          }
        }
        var value = renderWithHooks(request, task, Component, props, legacyContext);
        var hasId = checkDidRenderIdHook();
        {
          if (typeof value === "object" && value !== null && typeof value.render === "function" && value.$$typeof === undefined) {
            var _componentName = getComponentNameFromType(Component) || "Unknown";
            if (!didWarnAboutModulePatternComponent[_componentName]) {
              error("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", _componentName, _componentName, _componentName);
              didWarnAboutModulePatternComponent[_componentName] = true;
            }
          }
        }
        if (typeof value === "object" && value !== null && typeof value.render === "function" && value.$$typeof === undefined) {
          {
            var _componentName2 = getComponentNameFromType(Component) || "Unknown";
            if (!didWarnAboutModulePatternComponent[_componentName2]) {
              error("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", _componentName2, _componentName2, _componentName2);
              didWarnAboutModulePatternComponent[_componentName2] = true;
            }
          }
          mountClassInstance(value, Component, props, legacyContext);
          finishClassComponent(request, task, value, Component, props);
        } else {
          {
            validateFunctionComponentInDev(Component);
          }
          if (hasId) {
            var prevTreeContext = task.treeContext;
            var totalChildren = 1;
            var index = 0;
            task.treeContext = pushTreeContext(prevTreeContext, totalChildren, index);
            try {
              renderNodeDestructive(request, task, value);
            } finally {
              task.treeContext = prevTreeContext;
            }
          } else {
            renderNodeDestructive(request, task, value);
          }
        }
        popComponentStackInDEV(task);
      }
      function validateFunctionComponentInDev(Component) {
        {
          if (Component) {
            if (Component.childContextTypes) {
              error("%s(...): childContextTypes cannot be defined on a function component.", Component.displayName || Component.name || "Component");
            }
          }
          if (typeof Component.getDerivedStateFromProps === "function") {
            var _componentName3 = getComponentNameFromType(Component) || "Unknown";
            if (!didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3]) {
              error("%s: Function components do not support getDerivedStateFromProps.", _componentName3);
              didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3] = true;
            }
          }
          if (typeof Component.contextType === "object" && Component.contextType !== null) {
            var _componentName4 = getComponentNameFromType(Component) || "Unknown";
            if (!didWarnAboutContextTypeOnFunctionComponent[_componentName4]) {
              error("%s: Function components do not support contextType.", _componentName4);
              didWarnAboutContextTypeOnFunctionComponent[_componentName4] = true;
            }
          }
        }
      }
      function resolveDefaultProps(Component, baseProps) {
        if (Component && Component.defaultProps) {
          var props = assign({}, baseProps);
          var defaultProps = Component.defaultProps;
          for (var propName in defaultProps) {
            if (props[propName] === undefined) {
              props[propName] = defaultProps[propName];
            }
          }
          return props;
        }
        return baseProps;
      }
      function renderForwardRef(request, task, type, props, ref) {
        pushFunctionComponentStackInDEV(task, type.render);
        var children = renderWithHooks(request, task, type.render, props, ref);
        var hasId = checkDidRenderIdHook();
        if (hasId) {
          var prevTreeContext = task.treeContext;
          var totalChildren = 1;
          var index = 0;
          task.treeContext = pushTreeContext(prevTreeContext, totalChildren, index);
          try {
            renderNodeDestructive(request, task, children);
          } finally {
            task.treeContext = prevTreeContext;
          }
        } else {
          renderNodeDestructive(request, task, children);
        }
        popComponentStackInDEV(task);
      }
      function renderMemo(request, task, type, props, ref) {
        var innerType = type.type;
        var resolvedProps = resolveDefaultProps(innerType, props);
        renderElement(request, task, innerType, resolvedProps, ref);
      }
      function renderContextConsumer(request, task, context, props) {
        {
          if (context._context === undefined) {
            if (context !== context.Consumer) {
              if (!hasWarnedAboutUsingContextAsConsumer) {
                hasWarnedAboutUsingContextAsConsumer = true;
                error("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?");
              }
            }
          } else {
            context = context._context;
          }
        }
        var render = props.children;
        {
          if (typeof render !== "function") {
            error("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it.");
          }
        }
        var newValue = readContext(context);
        var newChildren = render(newValue);
        renderNodeDestructive(request, task, newChildren);
      }
      function renderContextProvider(request, task, type, props) {
        var context = type._context;
        var value = props.value;
        var children = props.children;
        var prevSnapshot;
        {
          prevSnapshot = task.context;
        }
        task.context = pushProvider(context, value);
        renderNodeDestructive(request, task, children);
        task.context = popProvider(context);
        {
          if (prevSnapshot !== task.context) {
            error("Popping the context provider did not return back to the original snapshot. This is a bug in React.");
          }
        }
      }
      function renderLazyComponent(request, task, lazyComponent, props, ref) {
        pushBuiltInComponentStackInDEV(task, "Lazy");
        var payload = lazyComponent._payload;
        var init2 = lazyComponent._init;
        var Component = init2(payload);
        var resolvedProps = resolveDefaultProps(Component, props);
        renderElement(request, task, Component, resolvedProps, ref);
        popComponentStackInDEV(task);
      }
      function renderElement(request, task, type, props, ref) {
        if (typeof type === "function") {
          if (shouldConstruct$1(type)) {
            renderClassComponent(request, task, type, props);
            return;
          } else {
            renderIndeterminateComponent(request, task, type, props);
            return;
          }
        }
        if (typeof type === "string") {
          renderHostElement(request, task, type, props);
          return;
        }
        switch (type) {
          case REACT_LEGACY_HIDDEN_TYPE:
          case REACT_DEBUG_TRACING_MODE_TYPE:
          case REACT_STRICT_MODE_TYPE:
          case REACT_PROFILER_TYPE:
          case REACT_FRAGMENT_TYPE: {
            renderNodeDestructive(request, task, props.children);
            return;
          }
          case REACT_SUSPENSE_LIST_TYPE: {
            pushBuiltInComponentStackInDEV(task, "SuspenseList");
            renderNodeDestructive(request, task, props.children);
            popComponentStackInDEV(task);
            return;
          }
          case REACT_SCOPE_TYPE: {
            throw new Error("ReactDOMServer does not yet support scope components.");
          }
          case REACT_SUSPENSE_TYPE: {
            {
              renderSuspenseBoundary(request, task, props);
            }
            return;
          }
        }
        if (typeof type === "object" && type !== null) {
          switch (type.$$typeof) {
            case REACT_FORWARD_REF_TYPE: {
              renderForwardRef(request, task, type, props, ref);
              return;
            }
            case REACT_MEMO_TYPE: {
              renderMemo(request, task, type, props, ref);
              return;
            }
            case REACT_PROVIDER_TYPE: {
              renderContextProvider(request, task, type, props);
              return;
            }
            case REACT_CONTEXT_TYPE: {
              renderContextConsumer(request, task, type, props);
              return;
            }
            case REACT_LAZY_TYPE: {
              renderLazyComponent(request, task, type, props);
              return;
            }
          }
        }
        var info = "";
        {
          if (type === undefined || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
            info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
          }
        }
        throw new Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) " + ("but got: " + (type == null ? type : typeof type) + "." + info));
      }
      function validateIterable(iterable, iteratorFn) {
        {
          if (typeof Symbol === "function" && iterable[Symbol.toStringTag] === "Generator") {
            if (!didWarnAboutGenerators) {
              error("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers.");
            }
            didWarnAboutGenerators = true;
          }
          if (iterable.entries === iteratorFn) {
            if (!didWarnAboutMaps) {
              error("Using Maps as children is not supported. Use an array of keyed ReactElements instead.");
            }
            didWarnAboutMaps = true;
          }
        }
      }
      function renderNodeDestructive(request, task, node) {
        {
          try {
            return renderNodeDestructiveImpl(request, task, node);
          } catch (x) {
            if (typeof x === "object" && x !== null && typeof x.then === "function")
              ;
            else {
              lastBoundaryErrorComponentStackDev = lastBoundaryErrorComponentStackDev !== null ? lastBoundaryErrorComponentStackDev : getCurrentStackInDEV();
            }
            throw x;
          }
        }
      }
      function renderNodeDestructiveImpl(request, task, node) {
        task.node = node;
        if (typeof node === "object" && node !== null) {
          switch (node.$$typeof) {
            case REACT_ELEMENT_TYPE: {
              var element = node;
              var type = element.type;
              var props = element.props;
              var ref = element.ref;
              renderElement(request, task, type, props, ref);
              return;
            }
            case REACT_PORTAL_TYPE:
              throw new Error("Portals are not currently supported by the server renderer. Render them conditionally so that they only appear on the client render.");
            case REACT_LAZY_TYPE: {
              var lazyNode = node;
              var payload = lazyNode._payload;
              var init2 = lazyNode._init;
              var resolvedNode;
              {
                try {
                  resolvedNode = init2(payload);
                } catch (x) {
                  if (typeof x === "object" && x !== null && typeof x.then === "function") {
                    pushBuiltInComponentStackInDEV(task, "Lazy");
                  }
                  throw x;
                }
              }
              renderNodeDestructive(request, task, resolvedNode);
              return;
            }
          }
          if (isArray(node)) {
            renderChildrenArray(request, task, node);
            return;
          }
          var iteratorFn = getIteratorFn(node);
          if (iteratorFn) {
            {
              validateIterable(node, iteratorFn);
            }
            var iterator = iteratorFn.call(node);
            if (iterator) {
              var step = iterator.next();
              if (!step.done) {
                var children = [];
                do {
                  children.push(step.value);
                  step = iterator.next();
                } while (!step.done);
                renderChildrenArray(request, task, children);
                return;
              }
              return;
            }
          }
          var childString = Object.prototype.toString.call(node);
          throw new Error("Objects are not valid as a React child (found: " + (childString === "[object Object]" ? "object with keys {" + Object.keys(node).join(", ") + "}" : childString) + "). If you meant to render a collection of children, use an array instead.");
        }
        if (typeof node === "string") {
          var segment = task.blockedSegment;
          segment.lastPushedText = pushTextInstance(task.blockedSegment.chunks, node, request.responseState, segment.lastPushedText);
          return;
        }
        if (typeof node === "number") {
          var _segment = task.blockedSegment;
          _segment.lastPushedText = pushTextInstance(task.blockedSegment.chunks, "" + node, request.responseState, _segment.lastPushedText);
          return;
        }
        {
          if (typeof node === "function") {
            error("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
          }
        }
      }
      function renderChildrenArray(request, task, children) {
        var totalChildren = children.length;
        for (var i = 0;i < totalChildren; i++) {
          var prevTreeContext = task.treeContext;
          task.treeContext = pushTreeContext(prevTreeContext, totalChildren, i);
          try {
            renderNode(request, task, children[i]);
          } finally {
            task.treeContext = prevTreeContext;
          }
        }
      }
      function spawnNewSuspendedTask(request, task, x) {
        var segment = task.blockedSegment;
        var insertionIndex = segment.chunks.length;
        var newSegment = createPendingSegment(request, insertionIndex, null, segment.formatContext, segment.lastPushedText, true);
        segment.children.push(newSegment);
        segment.lastPushedText = false;
        var newTask = createTask(request, task.node, task.blockedBoundary, newSegment, task.abortSet, task.legacyContext, task.context, task.treeContext);
        {
          if (task.componentStack !== null) {
            newTask.componentStack = task.componentStack.parent;
          }
        }
        var ping = newTask.ping;
        x.then(ping, ping);
      }
      function renderNode(request, task, node) {
        var previousFormatContext = task.blockedSegment.formatContext;
        var previousLegacyContext = task.legacyContext;
        var previousContext = task.context;
        var previousComponentStack = null;
        {
          previousComponentStack = task.componentStack;
        }
        try {
          return renderNodeDestructive(request, task, node);
        } catch (x) {
          resetHooksState();
          if (typeof x === "object" && x !== null && typeof x.then === "function") {
            spawnNewSuspendedTask(request, task, x);
            task.blockedSegment.formatContext = previousFormatContext;
            task.legacyContext = previousLegacyContext;
            task.context = previousContext;
            switchContext(previousContext);
            {
              task.componentStack = previousComponentStack;
            }
            return;
          } else {
            task.blockedSegment.formatContext = previousFormatContext;
            task.legacyContext = previousLegacyContext;
            task.context = previousContext;
            switchContext(previousContext);
            {
              task.componentStack = previousComponentStack;
            }
            throw x;
          }
        }
      }
      function erroredTask(request, boundary, segment, error2) {
        var errorDigest = logRecoverableError(request, error2);
        if (boundary === null) {
          fatalError(request, error2);
        } else {
          boundary.pendingTasks--;
          if (!boundary.forceClientRender) {
            boundary.forceClientRender = true;
            boundary.errorDigest = errorDigest;
            {
              captureBoundaryErrorDetailsDev(boundary, error2);
            }
            if (boundary.parentFlushed) {
              request.clientRenderedBoundaries.push(boundary);
            }
          }
        }
        request.allPendingTasks--;
        if (request.allPendingTasks === 0) {
          var onAllReady = request.onAllReady;
          onAllReady();
        }
      }
      function abortTaskSoft(task) {
        var request = this;
        var boundary = task.blockedBoundary;
        var segment = task.blockedSegment;
        segment.status = ABORTED;
        finishedTask(request, boundary, segment);
      }
      function abortTask(task, request, reason) {
        var boundary = task.blockedBoundary;
        var segment = task.blockedSegment;
        segment.status = ABORTED;
        if (boundary === null) {
          request.allPendingTasks--;
          if (request.status !== CLOSED) {
            request.status = CLOSED;
            if (request.destination !== null) {
              close(request.destination);
            }
          }
        } else {
          boundary.pendingTasks--;
          if (!boundary.forceClientRender) {
            boundary.forceClientRender = true;
            var _error = reason === undefined ? new Error("The render was aborted by the server without a reason.") : reason;
            boundary.errorDigest = request.onError(_error);
            {
              var errorPrefix = "The server did not finish this Suspense boundary: ";
              if (_error && typeof _error.message === "string") {
                _error = errorPrefix + _error.message;
              } else {
                _error = errorPrefix + String(_error);
              }
              var previousTaskInDev = currentTaskInDEV;
              currentTaskInDEV = task;
              try {
                captureBoundaryErrorDetailsDev(boundary, _error);
              } finally {
                currentTaskInDEV = previousTaskInDev;
              }
            }
            if (boundary.parentFlushed) {
              request.clientRenderedBoundaries.push(boundary);
            }
          }
          boundary.fallbackAbortableTasks.forEach(function(fallbackTask) {
            return abortTask(fallbackTask, request, reason);
          });
          boundary.fallbackAbortableTasks.clear();
          request.allPendingTasks--;
          if (request.allPendingTasks === 0) {
            var onAllReady = request.onAllReady;
            onAllReady();
          }
        }
      }
      function queueCompletedSegment(boundary, segment) {
        if (segment.chunks.length === 0 && segment.children.length === 1 && segment.children[0].boundary === null) {
          var childSegment = segment.children[0];
          childSegment.id = segment.id;
          childSegment.parentFlushed = true;
          if (childSegment.status === COMPLETED) {
            queueCompletedSegment(boundary, childSegment);
          }
        } else {
          var completedSegments = boundary.completedSegments;
          completedSegments.push(segment);
        }
      }
      function finishedTask(request, boundary, segment) {
        if (boundary === null) {
          if (segment.parentFlushed) {
            if (request.completedRootSegment !== null) {
              throw new Error("There can only be one root segment. This is a bug in React.");
            }
            request.completedRootSegment = segment;
          }
          request.pendingRootTasks--;
          if (request.pendingRootTasks === 0) {
            request.onShellError = noop$1;
            var onShellReady = request.onShellReady;
            onShellReady();
          }
        } else {
          boundary.pendingTasks--;
          if (boundary.forceClientRender)
            ;
          else if (boundary.pendingTasks === 0) {
            if (segment.parentFlushed) {
              if (segment.status === COMPLETED) {
                queueCompletedSegment(boundary, segment);
              }
            }
            if (boundary.parentFlushed) {
              request.completedBoundaries.push(boundary);
            }
            boundary.fallbackAbortableTasks.forEach(abortTaskSoft, request);
            boundary.fallbackAbortableTasks.clear();
          } else {
            if (segment.parentFlushed) {
              if (segment.status === COMPLETED) {
                queueCompletedSegment(boundary, segment);
                var completedSegments = boundary.completedSegments;
                if (completedSegments.length === 1) {
                  if (boundary.parentFlushed) {
                    request.partialBoundaries.push(boundary);
                  }
                }
              }
            }
          }
        }
        request.allPendingTasks--;
        if (request.allPendingTasks === 0) {
          var onAllReady = request.onAllReady;
          onAllReady();
        }
      }
      function retryTask(request, task) {
        var segment = task.blockedSegment;
        if (segment.status !== PENDING) {
          return;
        }
        switchContext(task.context);
        var prevTaskInDEV = null;
        {
          prevTaskInDEV = currentTaskInDEV;
          currentTaskInDEV = task;
        }
        try {
          renderNodeDestructive(request, task, task.node);
          pushSegmentFinale(segment.chunks, request.responseState, segment.lastPushedText, segment.textEmbedded);
          task.abortSet.delete(task);
          segment.status = COMPLETED;
          finishedTask(request, task.blockedBoundary, segment);
        } catch (x) {
          resetHooksState();
          if (typeof x === "object" && x !== null && typeof x.then === "function") {
            var ping = task.ping;
            x.then(ping, ping);
          } else {
            task.abortSet.delete(task);
            segment.status = ERRORED;
            erroredTask(request, task.blockedBoundary, segment, x);
          }
        } finally {
          {
            currentTaskInDEV = prevTaskInDEV;
          }
        }
      }
      function performWork(request) {
        if (request.status === CLOSED) {
          return;
        }
        var prevContext = getActiveContext();
        var prevDispatcher = ReactCurrentDispatcher$1.current;
        ReactCurrentDispatcher$1.current = Dispatcher;
        var prevGetCurrentStackImpl;
        {
          prevGetCurrentStackImpl = ReactDebugCurrentFrame$1.getCurrentStack;
          ReactDebugCurrentFrame$1.getCurrentStack = getCurrentStackInDEV;
        }
        var prevResponseState = currentResponseState;
        setCurrentResponseState(request.responseState);
        try {
          var pingedTasks = request.pingedTasks;
          var i;
          for (i = 0;i < pingedTasks.length; i++) {
            var task = pingedTasks[i];
            retryTask(request, task);
          }
          pingedTasks.splice(0, i);
          if (request.destination !== null) {
            flushCompletedQueues(request, request.destination);
          }
        } catch (error2) {
          logRecoverableError(request, error2);
          fatalError(request, error2);
        } finally {
          setCurrentResponseState(prevResponseState);
          ReactCurrentDispatcher$1.current = prevDispatcher;
          {
            ReactDebugCurrentFrame$1.getCurrentStack = prevGetCurrentStackImpl;
          }
          if (prevDispatcher === Dispatcher) {
            switchContext(prevContext);
          }
        }
      }
      function flushSubtree(request, destination, segment) {
        segment.parentFlushed = true;
        switch (segment.status) {
          case PENDING: {
            var segmentID = segment.id = request.nextSegmentId++;
            segment.lastPushedText = false;
            segment.textEmbedded = false;
            return writePlaceholder(destination, request.responseState, segmentID);
          }
          case COMPLETED: {
            segment.status = FLUSHED;
            var r = true;
            var chunks = segment.chunks;
            var chunkIdx = 0;
            var children = segment.children;
            for (var childIdx = 0;childIdx < children.length; childIdx++) {
              var nextChild = children[childIdx];
              for (;chunkIdx < nextChild.index; chunkIdx++) {
                writeChunk(destination, chunks[chunkIdx]);
              }
              r = flushSegment(request, destination, nextChild);
            }
            for (;chunkIdx < chunks.length - 1; chunkIdx++) {
              writeChunk(destination, chunks[chunkIdx]);
            }
            if (chunkIdx < chunks.length) {
              r = writeChunkAndReturn(destination, chunks[chunkIdx]);
            }
            return r;
          }
          default: {
            throw new Error("Aborted, errored or already flushed boundaries should not be flushed again. This is a bug in React.");
          }
        }
      }
      function flushSegment(request, destination, segment) {
        var boundary = segment.boundary;
        if (boundary === null) {
          return flushSubtree(request, destination, segment);
        }
        boundary.parentFlushed = true;
        if (boundary.forceClientRender) {
          writeStartClientRenderedSuspenseBoundary(destination, request.responseState, boundary.errorDigest, boundary.errorMessage, boundary.errorComponentStack);
          flushSubtree(request, destination, segment);
          return writeEndClientRenderedSuspenseBoundary(destination, request.responseState);
        } else if (boundary.pendingTasks > 0) {
          boundary.rootSegmentID = request.nextSegmentId++;
          if (boundary.completedSegments.length > 0) {
            request.partialBoundaries.push(boundary);
          }
          var id = boundary.id = assignSuspenseBoundaryID(request.responseState);
          writeStartPendingSuspenseBoundary(destination, request.responseState, id);
          flushSubtree(request, destination, segment);
          return writeEndPendingSuspenseBoundary(destination, request.responseState);
        } else if (boundary.byteSize > request.progressiveChunkSize) {
          boundary.rootSegmentID = request.nextSegmentId++;
          request.completedBoundaries.push(boundary);
          writeStartPendingSuspenseBoundary(destination, request.responseState, boundary.id);
          flushSubtree(request, destination, segment);
          return writeEndPendingSuspenseBoundary(destination, request.responseState);
        } else {
          writeStartCompletedSuspenseBoundary(destination, request.responseState);
          var completedSegments = boundary.completedSegments;
          if (completedSegments.length !== 1) {
            throw new Error("A previously unvisited boundary must have exactly one root segment. This is a bug in React.");
          }
          var contentSegment = completedSegments[0];
          flushSegment(request, destination, contentSegment);
          return writeEndCompletedSuspenseBoundary(destination, request.responseState);
        }
      }
      function flushClientRenderedBoundary(request, destination, boundary) {
        return writeClientRenderBoundaryInstruction(destination, request.responseState, boundary.id, boundary.errorDigest, boundary.errorMessage, boundary.errorComponentStack);
      }
      function flushSegmentContainer(request, destination, segment) {
        writeStartSegment(destination, request.responseState, segment.formatContext, segment.id);
        flushSegment(request, destination, segment);
        return writeEndSegment(destination, segment.formatContext);
      }
      function flushCompletedBoundary(request, destination, boundary) {
        var completedSegments = boundary.completedSegments;
        var i = 0;
        for (;i < completedSegments.length; i++) {
          var segment = completedSegments[i];
          flushPartiallyCompletedSegment(request, destination, boundary, segment);
        }
        completedSegments.length = 0;
        return writeCompletedBoundaryInstruction(destination, request.responseState, boundary.id, boundary.rootSegmentID);
      }
      function flushPartialBoundary(request, destination, boundary) {
        var completedSegments = boundary.completedSegments;
        var i = 0;
        for (;i < completedSegments.length; i++) {
          var segment = completedSegments[i];
          if (!flushPartiallyCompletedSegment(request, destination, boundary, segment)) {
            i++;
            completedSegments.splice(0, i);
            return false;
          }
        }
        completedSegments.splice(0, i);
        return true;
      }
      function flushPartiallyCompletedSegment(request, destination, boundary, segment) {
        if (segment.status === FLUSHED) {
          return true;
        }
        var segmentID = segment.id;
        if (segmentID === -1) {
          var rootSegmentID = segment.id = boundary.rootSegmentID;
          if (rootSegmentID === -1) {
            throw new Error("A root segment ID must have been assigned by now. This is a bug in React.");
          }
          return flushSegmentContainer(request, destination, segment);
        } else {
          flushSegmentContainer(request, destination, segment);
          return writeCompletedSegmentInstruction(destination, request.responseState, segmentID);
        }
      }
      function flushCompletedQueues(request, destination) {
        beginWriting();
        try {
          var completedRootSegment = request.completedRootSegment;
          if (completedRootSegment !== null && request.pendingRootTasks === 0) {
            flushSegment(request, destination, completedRootSegment);
            request.completedRootSegment = null;
            writeCompletedRoot(destination, request.responseState);
          }
          var clientRenderedBoundaries = request.clientRenderedBoundaries;
          var i;
          for (i = 0;i < clientRenderedBoundaries.length; i++) {
            var boundary = clientRenderedBoundaries[i];
            if (!flushClientRenderedBoundary(request, destination, boundary)) {
              request.destination = null;
              i++;
              clientRenderedBoundaries.splice(0, i);
              return;
            }
          }
          clientRenderedBoundaries.splice(0, i);
          var completedBoundaries = request.completedBoundaries;
          for (i = 0;i < completedBoundaries.length; i++) {
            var _boundary = completedBoundaries[i];
            if (!flushCompletedBoundary(request, destination, _boundary)) {
              request.destination = null;
              i++;
              completedBoundaries.splice(0, i);
              return;
            }
          }
          completedBoundaries.splice(0, i);
          completeWriting(destination);
          beginWriting(destination);
          var partialBoundaries = request.partialBoundaries;
          for (i = 0;i < partialBoundaries.length; i++) {
            var _boundary2 = partialBoundaries[i];
            if (!flushPartialBoundary(request, destination, _boundary2)) {
              request.destination = null;
              i++;
              partialBoundaries.splice(0, i);
              return;
            }
          }
          partialBoundaries.splice(0, i);
          var largeBoundaries = request.completedBoundaries;
          for (i = 0;i < largeBoundaries.length; i++) {
            var _boundary3 = largeBoundaries[i];
            if (!flushCompletedBoundary(request, destination, _boundary3)) {
              request.destination = null;
              i++;
              largeBoundaries.splice(0, i);
              return;
            }
          }
          largeBoundaries.splice(0, i);
        } finally {
          completeWriting(destination);
          flushBuffered(destination);
          if (request.allPendingTasks === 0 && request.pingedTasks.length === 0 && request.clientRenderedBoundaries.length === 0 && request.completedBoundaries.length === 0) {
            {
              if (request.abortableTasks.size !== 0) {
                error("There was still abortable task at the root when we closed. This is a bug in React.");
              }
            }
            close(destination);
          }
        }
      }
      function startWork(request) {
        scheduleWork(function() {
          return performWork(request);
        });
      }
      function startFlowing(request, destination) {
        if (request.status === CLOSING) {
          request.status = CLOSED;
          closeWithError(destination, request.fatalError);
          return;
        }
        if (request.status === CLOSED) {
          return;
        }
        if (request.destination !== null) {
          return;
        }
        request.destination = destination;
        try {
          flushCompletedQueues(request, destination);
        } catch (error2) {
          logRecoverableError(request, error2);
          fatalError(request, error2);
        }
      }
      function abort(request, reason) {
        try {
          var abortableTasks = request.abortableTasks;
          abortableTasks.forEach(function(task) {
            return abortTask(task, request, reason);
          });
          abortableTasks.clear();
          if (request.destination !== null) {
            flushCompletedQueues(request, request.destination);
          }
        } catch (error2) {
          logRecoverableError(request, error2);
          fatalError(request, error2);
        }
      }
      function createDrainHandler(destination, request) {
        return function() {
          return startFlowing(request, destination);
        };
      }
      function createAbortHandler(request, reason) {
        return function() {
          return abort(request, reason);
        };
      }
      function createRequestImpl(children, options) {
        return createRequest(children, createResponseState(options ? options.identifierPrefix : undefined, options ? options.nonce : undefined, options ? options.bootstrapScriptContent : undefined, options ? options.bootstrapScripts : undefined, options ? options.bootstrapModules : undefined), createRootFormatContext(options ? options.namespaceURI : undefined), options ? options.progressiveChunkSize : undefined, options ? options.onError : undefined, options ? options.onAllReady : undefined, options ? options.onShellReady : undefined, options ? options.onShellError : undefined, undefined);
      }
      function renderToPipeableStream(children, options) {
        var request = createRequestImpl(children, options);
        var hasStartedFlowing = false;
        startWork(request);
        return {
          pipe: function(destination) {
            if (hasStartedFlowing) {
              throw new Error("React currently only supports piping to one writable stream.");
            }
            hasStartedFlowing = true;
            startFlowing(request, destination);
            destination.on("drain", createDrainHandler(destination, request));
            destination.on("error", createAbortHandler(request, new Error("The destination stream errored while writing data.")));
            destination.on("close", createAbortHandler(request, new Error("The destination stream closed early.")));
            return destination;
          },
          abort: function(reason) {
            abort(request, reason);
          }
        };
      }
      exports.renderToPipeableStream = renderToPipeableStream;
      exports.version = ReactVersion;
    })();
  }
});

// node_modules/react-dom/server.node.js
var require_server_node = __commonJS((exports) => {
  var l;
  var s;
  if (false) {
  } else {
    l = require_react_dom_server_legacy_node_development();
    s = require_react_dom_server_node_development();
  }
  exports.version = l.version;
  exports.renderToString = l.renderToString;
  exports.renderToStaticMarkup = l.renderToStaticMarkup;
  exports.renderToNodeStream = l.renderToNodeStream;
  exports.renderToStaticNodeStream = l.renderToStaticNodeStream;
  exports.renderToPipeableStream = s.renderToPipeableStream;
});

// node_modules/domelementtype/lib/index.js
var require_lib = __commonJS((exports) => {
  var isTag = function(elem) {
    return elem.type === ElementType.Tag || elem.type === ElementType.Script || elem.type === ElementType.Style;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Doctype = exports.CDATA = exports.Tag = exports.Style = exports.Script = exports.Comment = exports.Directive = exports.Text = exports.Root = exports.isTag = exports.ElementType = undefined;
  var ElementType;
  (function(ElementType2) {
    ElementType2["Root"] = "root";
    ElementType2["Text"] = "text";
    ElementType2["Directive"] = "directive";
    ElementType2["Comment"] = "comment";
    ElementType2["Script"] = "script";
    ElementType2["Style"] = "style";
    ElementType2["Tag"] = "tag";
    ElementType2["CDATA"] = "cdata";
    ElementType2["Doctype"] = "doctype";
  })(ElementType = exports.ElementType || (exports.ElementType = {}));
  exports.isTag = isTag;
  exports.Root = ElementType.Root;
  exports.Text = ElementType.Text;
  exports.Directive = ElementType.Directive;
  exports.Comment = ElementType.Comment;
  exports.Script = ElementType.Script;
  exports.Style = ElementType.Style;
  exports.Tag = ElementType.Tag;
  exports.CDATA = ElementType.CDATA;
  exports.Doctype = ElementType.Doctype;
});

// node_modules/domhandler/lib/node.js
var require_node = __commonJS((exports) => {
  var isTag = function(node) {
    return (0, domelementtype_1.isTag)(node);
  };
  var isCDATA = function(node) {
    return node.type === domelementtype_1.ElementType.CDATA;
  };
  var isText = function(node) {
    return node.type === domelementtype_1.ElementType.Text;
  };
  var isComment = function(node) {
    return node.type === domelementtype_1.ElementType.Comment;
  };
  var isDirective = function(node) {
    return node.type === domelementtype_1.ElementType.Directive;
  };
  var isDocument = function(node) {
    return node.type === domelementtype_1.ElementType.Root;
  };
  var hasChildren = function(node) {
    return Object.prototype.hasOwnProperty.call(node, "children");
  };
  var cloneNode = function(node, recursive) {
    if (recursive === undefined) {
      recursive = false;
    }
    var result2;
    if (isText(node)) {
      result2 = new Text(node.data);
    } else if (isComment(node)) {
      result2 = new Comment(node.data);
    } else if (isTag(node)) {
      var children = recursive ? cloneChildren(node.children) : [];
      var clone_1 = new Element(node.name, __assign({}, node.attribs), children);
      children.forEach(function(child) {
        return child.parent = clone_1;
      });
      if (node.namespace != null) {
        clone_1.namespace = node.namespace;
      }
      if (node["x-attribsNamespace"]) {
        clone_1["x-attribsNamespace"] = __assign({}, node["x-attribsNamespace"]);
      }
      if (node["x-attribsPrefix"]) {
        clone_1["x-attribsPrefix"] = __assign({}, node["x-attribsPrefix"]);
      }
      result2 = clone_1;
    } else if (isCDATA(node)) {
      var children = recursive ? cloneChildren(node.children) : [];
      var clone_2 = new CDATA(children);
      children.forEach(function(child) {
        return child.parent = clone_2;
      });
      result2 = clone_2;
    } else if (isDocument(node)) {
      var children = recursive ? cloneChildren(node.children) : [];
      var clone_3 = new Document(children);
      children.forEach(function(child) {
        return child.parent = clone_3;
      });
      if (node["x-mode"]) {
        clone_3["x-mode"] = node["x-mode"];
      }
      result2 = clone_3;
    } else if (isDirective(node)) {
      var instruction = new ProcessingInstruction(node.name, node.data);
      if (node["x-name"] != null) {
        instruction["x-name"] = node["x-name"];
        instruction["x-publicId"] = node["x-publicId"];
        instruction["x-systemId"] = node["x-systemId"];
      }
      result2 = instruction;
    } else {
      throw new Error("Not implemented yet: ".concat(node.type));
    }
    result2.startIndex = node.startIndex;
    result2.endIndex = node.endIndex;
    if (node.sourceCodeLocation != null) {
      result2.sourceCodeLocation = node.sourceCodeLocation;
    }
    return result2;
  };
  var cloneChildren = function(childs) {
    var children = childs.map(function(child) {
      return cloneNode(child, true);
    });
    for (var i = 1;i < children.length; i++) {
      children[i].prev = children[i - 1];
      children[i - 1].next = children[i];
    }
    return children;
  };
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b2) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
        d2.__proto__ = b3;
      } || function(d2, b3) {
        for (var p in b3)
          if (Object.prototype.hasOwnProperty.call(b3, p))
            d2[p] = b3[p];
      };
      return extendStatics(d, b2);
    };
    return function(d, b2) {
      if (typeof b2 !== "function" && b2 !== null)
        throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
      extendStatics(d, b2);
      function __() {
        this.constructor = d;
      }
      d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __);
    };
  }();
  var __assign = exports && exports.__assign || function() {
    __assign = Object.assign || function(t) {
      for (var s, i = 1, n = arguments.length;i < n; i++) {
        s = arguments[i];
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
      }
      return t;
    };
    return __assign.apply(this, arguments);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.cloneNode = exports.hasChildren = exports.isDocument = exports.isDirective = exports.isComment = exports.isText = exports.isCDATA = exports.isTag = exports.Element = exports.Document = exports.CDATA = exports.NodeWithChildren = exports.ProcessingInstruction = exports.Comment = exports.Text = exports.DataNode = exports.Node = undefined;
  var domelementtype_1 = require_lib();
  var Node = function() {
    function Node2() {
      this.parent = null;
      this.prev = null;
      this.next = null;
      this.startIndex = null;
      this.endIndex = null;
    }
    Object.defineProperty(Node2.prototype, "parentNode", {
      get: function() {
        return this.parent;
      },
      set: function(parent) {
        this.parent = parent;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Node2.prototype, "previousSibling", {
      get: function() {
        return this.prev;
      },
      set: function(prev) {
        this.prev = prev;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Node2.prototype, "nextSibling", {
      get: function() {
        return this.next;
      },
      set: function(next) {
        this.next = next;
      },
      enumerable: false,
      configurable: true
    });
    Node2.prototype.cloneNode = function(recursive) {
      if (recursive === undefined) {
        recursive = false;
      }
      return cloneNode(this, recursive);
    };
    return Node2;
  }();
  exports.Node = Node;
  var DataNode = function(_super) {
    __extends(DataNode2, _super);
    function DataNode2(data) {
      var _this = _super.call(this) || this;
      _this.data = data;
      return _this;
    }
    Object.defineProperty(DataNode2.prototype, "nodeValue", {
      get: function() {
        return this.data;
      },
      set: function(data) {
        this.data = data;
      },
      enumerable: false,
      configurable: true
    });
    return DataNode2;
  }(Node);
  exports.DataNode = DataNode;
  var Text = function(_super) {
    __extends(Text2, _super);
    function Text2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = domelementtype_1.ElementType.Text;
      return _this;
    }
    Object.defineProperty(Text2.prototype, "nodeType", {
      get: function() {
        return 3;
      },
      enumerable: false,
      configurable: true
    });
    return Text2;
  }(DataNode);
  exports.Text = Text;
  var Comment = function(_super) {
    __extends(Comment2, _super);
    function Comment2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = domelementtype_1.ElementType.Comment;
      return _this;
    }
    Object.defineProperty(Comment2.prototype, "nodeType", {
      get: function() {
        return 8;
      },
      enumerable: false,
      configurable: true
    });
    return Comment2;
  }(DataNode);
  exports.Comment = Comment;
  var ProcessingInstruction = function(_super) {
    __extends(ProcessingInstruction2, _super);
    function ProcessingInstruction2(name, data) {
      var _this = _super.call(this, data) || this;
      _this.name = name;
      _this.type = domelementtype_1.ElementType.Directive;
      return _this;
    }
    Object.defineProperty(ProcessingInstruction2.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: false,
      configurable: true
    });
    return ProcessingInstruction2;
  }(DataNode);
  exports.ProcessingInstruction = ProcessingInstruction;
  var NodeWithChildren = function(_super) {
    __extends(NodeWithChildren2, _super);
    function NodeWithChildren2(children) {
      var _this = _super.call(this) || this;
      _this.children = children;
      return _this;
    }
    Object.defineProperty(NodeWithChildren2.prototype, "firstChild", {
      get: function() {
        var _a;
        return (_a = this.children[0]) !== null && _a !== undefined ? _a : null;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(NodeWithChildren2.prototype, "lastChild", {
      get: function() {
        return this.children.length > 0 ? this.children[this.children.length - 1] : null;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(NodeWithChildren2.prototype, "childNodes", {
      get: function() {
        return this.children;
      },
      set: function(children) {
        this.children = children;
      },
      enumerable: false,
      configurable: true
    });
    return NodeWithChildren2;
  }(Node);
  exports.NodeWithChildren = NodeWithChildren;
  var CDATA = function(_super) {
    __extends(CDATA2, _super);
    function CDATA2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = domelementtype_1.ElementType.CDATA;
      return _this;
    }
    Object.defineProperty(CDATA2.prototype, "nodeType", {
      get: function() {
        return 4;
      },
      enumerable: false,
      configurable: true
    });
    return CDATA2;
  }(NodeWithChildren);
  exports.CDATA = CDATA;
  var Document = function(_super) {
    __extends(Document2, _super);
    function Document2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = domelementtype_1.ElementType.Root;
      return _this;
    }
    Object.defineProperty(Document2.prototype, "nodeType", {
      get: function() {
        return 9;
      },
      enumerable: false,
      configurable: true
    });
    return Document2;
  }(NodeWithChildren);
  exports.Document = Document;
  var Element = function(_super) {
    __extends(Element2, _super);
    function Element2(name, attribs, children, type) {
      if (children === undefined) {
        children = [];
      }
      if (type === undefined) {
        type = name === "script" ? domelementtype_1.ElementType.Script : name === "style" ? domelementtype_1.ElementType.Style : domelementtype_1.ElementType.Tag;
      }
      var _this = _super.call(this, children) || this;
      _this.name = name;
      _this.attribs = attribs;
      _this.type = type;
      return _this;
    }
    Object.defineProperty(Element2.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Element2.prototype, "tagName", {
      get: function() {
        return this.name;
      },
      set: function(name) {
        this.name = name;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Element2.prototype, "attributes", {
      get: function() {
        var _this = this;
        return Object.keys(this.attribs).map(function(name) {
          var _a, _b;
          return {
            name,
            value: _this.attribs[name],
            namespace: (_a = _this["x-attribsNamespace"]) === null || _a === undefined ? undefined : _a[name],
            prefix: (_b = _this["x-attribsPrefix"]) === null || _b === undefined ? undefined : _b[name]
          };
        });
      },
      enumerable: false,
      configurable: true
    });
    return Element2;
  }(NodeWithChildren);
  exports.Element = Element;
  exports.isTag = isTag;
  exports.isCDATA = isCDATA;
  exports.isText = isText;
  exports.isComment = isComment;
  exports.isDirective = isDirective;
  exports.isDocument = isDocument;
  exports.hasChildren = hasChildren;
  exports.cloneNode = cloneNode;
});

// node_modules/domhandler/lib/index.js
var require_lib2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc2 = Object.getOwnPropertyDescriptor(m, k);
    if (!desc2 || ("get" in desc2 ? !m.__esModule : desc2.writable || desc2.configurable)) {
      desc2 = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o2, k2, desc2);
  } : function(o2, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o2[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DomHandler = undefined;
  var domelementtype_1 = require_lib();
  var node_js_1 = require_node();
  __exportStar(require_node(), exports);
  var defaultOpts = {
    withStartIndices: false,
    withEndIndices: false,
    xmlMode: false
  };
  var DomHandler = function() {
    function DomHandler2(callback, options, elementCB) {
      this.dom = [];
      this.root = new node_js_1.Document(this.dom);
      this.done = false;
      this.tagStack = [this.root];
      this.lastNode = null;
      this.parser = null;
      if (typeof options === "function") {
        elementCB = options;
        options = defaultOpts;
      }
      if (typeof callback === "object") {
        options = callback;
        callback = undefined;
      }
      this.callback = callback !== null && callback !== undefined ? callback : null;
      this.options = options !== null && options !== undefined ? options : defaultOpts;
      this.elementCB = elementCB !== null && elementCB !== undefined ? elementCB : null;
    }
    DomHandler2.prototype.onparserinit = function(parser) {
      this.parser = parser;
    };
    DomHandler2.prototype.onreset = function() {
      this.dom = [];
      this.root = new node_js_1.Document(this.dom);
      this.done = false;
      this.tagStack = [this.root];
      this.lastNode = null;
      this.parser = null;
    };
    DomHandler2.prototype.onend = function() {
      if (this.done)
        return;
      this.done = true;
      this.parser = null;
      this.handleCallback(null);
    };
    DomHandler2.prototype.onerror = function(error) {
      this.handleCallback(error);
    };
    DomHandler2.prototype.onclosetag = function() {
      this.lastNode = null;
      var elem = this.tagStack.pop();
      if (this.options.withEndIndices) {
        elem.endIndex = this.parser.endIndex;
      }
      if (this.elementCB)
        this.elementCB(elem);
    };
    DomHandler2.prototype.onopentag = function(name, attribs) {
      var type = this.options.xmlMode ? domelementtype_1.ElementType.Tag : undefined;
      var element = new node_js_1.Element(name, attribs, undefined, type);
      this.addNode(element);
      this.tagStack.push(element);
    };
    DomHandler2.prototype.ontext = function(data) {
      var lastNode = this.lastNode;
      if (lastNode && lastNode.type === domelementtype_1.ElementType.Text) {
        lastNode.data += data;
        if (this.options.withEndIndices) {
          lastNode.endIndex = this.parser.endIndex;
        }
      } else {
        var node = new node_js_1.Text(data);
        this.addNode(node);
        this.lastNode = node;
      }
    };
    DomHandler2.prototype.oncomment = function(data) {
      if (this.lastNode && this.lastNode.type === domelementtype_1.ElementType.Comment) {
        this.lastNode.data += data;
        return;
      }
      var node = new node_js_1.Comment(data);
      this.addNode(node);
      this.lastNode = node;
    };
    DomHandler2.prototype.oncommentend = function() {
      this.lastNode = null;
    };
    DomHandler2.prototype.oncdatastart = function() {
      var text2 = new node_js_1.Text("");
      var node = new node_js_1.CDATA([text2]);
      this.addNode(node);
      text2.parent = node;
      this.lastNode = text2;
    };
    DomHandler2.prototype.oncdataend = function() {
      this.lastNode = null;
    };
    DomHandler2.prototype.onprocessinginstruction = function(name, data) {
      var node = new node_js_1.ProcessingInstruction(name, data);
      this.addNode(node);
    };
    DomHandler2.prototype.handleCallback = function(error) {
      if (typeof this.callback === "function") {
        this.callback(error, this.dom);
      } else if (error) {
        throw error;
      }
    };
    DomHandler2.prototype.addNode = function(node) {
      var parent = this.tagStack[this.tagStack.length - 1];
      var previousSibling = parent.children[parent.children.length - 1];
      if (this.options.withStartIndices) {
        node.startIndex = this.parser.startIndex;
      }
      if (this.options.withEndIndices) {
        node.endIndex = this.parser.endIndex;
      }
      parent.children.push(node);
      if (previousSibling) {
        node.prev = previousSibling;
        previousSibling.next = node;
      }
      node.parent = parent;
      this.lastNode = null;
    };
    return DomHandler2;
  }();
  exports.DomHandler = DomHandler;
  exports.default = DomHandler;
});

// node_modules/leac/lib/leac.cjs
var require_leac = __commonJS((exports) => {
  var t = function(t2) {
    const o3 = [...t2.matchAll(e)].map((e2) => e2.index || 0);
    o3.unshift(-1);
    const s2 = n(o3, 0, o3.length);
    return (e2) => r(s2, e2);
  };
  var n = function(e2, t2, r2) {
    if (r2 - t2 == 1)
      return { offset: e2[t2], index: t2 + 1 };
    const o3 = Math.ceil((t2 + r2) / 2), s2 = n(e2, t2, o3), l2 = n(e2, o3, r2);
    return { offset: s2.offset, low: s2, high: l2 };
  };
  var r = function(e2, t2) {
    return function(e3) {
      return Object.prototype.hasOwnProperty.call(e3, "index");
    }(e2) ? { line: e2.index, column: t2 - e2.offset } : r(e2.high.offset < t2 ? e2.high : e2.low, t2);
  };
  var o2 = function(e2, t2) {
    return { ...e2, regex: s(e2, t2) };
  };
  var s = function(e2, t2) {
    if (e2.name.length === 0)
      throw new Error(`Rule #${t2} has empty name, which is not allowed.`);
    if (function(e3) {
      return Object.prototype.hasOwnProperty.call(e3, "regex");
    }(e2))
      return function(e3) {
        if (e3.global)
          throw new Error(`Regular expression /${e3.source}/${e3.flags} contains the global flag, which is not allowed.`);
        return e3.sticky ? e3 : new RegExp(e3.source, e3.flags + "y");
      }(e2.regex);
    if (function(e3) {
      return Object.prototype.hasOwnProperty.call(e3, "str");
    }(e2)) {
      if (e2.str.length === 0)
        throw new Error(`Rule #${t2} ("${e2.name}") has empty "str" property, which is not allowed.`);
      return new RegExp(l(e2.str), "y");
    }
    return new RegExp(l(e2.name), "y");
  };
  var l = function(e2) {
    return e2.replace(/[-[\]{}()*+!<=:?./\\^$|#\s,]/g, "\\$&");
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var e = /\n/g;
  exports.createLexer = function(e2, n2 = "", r2 = {}) {
    const s2 = typeof n2 != "string" ? n2 : r2, l2 = typeof n2 == "string" ? n2 : "", c2 = e2.map(o2), i = !!s2.lineNumbers;
    return function(e3, n3 = 0) {
      const r3 = i ? t(e3) : () => ({ line: 0, column: 0 });
      let o3 = n3;
      const s3 = [];
      e:
        for (;o3 < e3.length; ) {
          let t2 = false;
          for (const n4 of c2) {
            n4.regex.lastIndex = o3;
            const c3 = n4.regex.exec(e3);
            if (c3 && c3[0].length > 0) {
              if (!n4.discard) {
                const e4 = r3(o3), t3 = typeof n4.replace == "string" ? c3[0].replace(new RegExp(n4.regex.source, n4.regex.flags), n4.replace) : c3[0];
                s3.push({ state: l2, name: n4.name, text: t3, offset: o3, len: c3[0].length, line: e4.line, column: e4.column });
              }
              if (o3 = n4.regex.lastIndex, t2 = true, n4.push) {
                const t3 = n4.push(e3, o3);
                s3.push(...t3.tokens), o3 = t3.offset;
              }
              if (n4.pop)
                break e;
              break;
            }
          }
          if (!t2)
            break;
        }
      return { tokens: s3, offset: o3, complete: e3.length <= o3 };
    };
  };
});

// node_modules/peberminta/lib/util.cjs
var require_util = __commonJS((exports) => {
  var clamp = function(left, x, right) {
    return Math.max(left, Math.min(x, right));
  };
  var escapeWhitespace = function(str) {
    return str.replace(/(\t)|(\r)|(\n)/g, (m, t, r) => t ? "\\t" : r ? "\\r" : "\\n");
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.clamp = clamp;
  exports.escapeWhitespace = escapeWhitespace;
});

// node_modules/peberminta/lib/core.cjs
var require_core = __commonJS((exports) => {
  var emit = function(value) {
    return (data, i) => ({
      matched: true,
      position: i,
      value
    });
  };
  var make = function(f) {
    return (data, i) => ({
      matched: true,
      position: i,
      value: f(data, i)
    });
  };
  var action = function(f) {
    return (data, i) => {
      f(data, i);
      return {
        matched: true,
        position: i,
        value: null
      };
    };
  };
  var fail = function(data, i) {
    return { matched: false };
  };
  var error = function(message) {
    return (data, i) => {
      throw new Error(message instanceof Function ? message(data, i) : message);
    };
  };
  var token = function(onToken, onEnd) {
    return (data, i) => {
      let position = i;
      let value = undefined;
      if (i < data.tokens.length) {
        value = onToken(data.tokens[i], data, i);
        if (value !== undefined) {
          position++;
        }
      } else {
        onEnd?.(data, i);
      }
      return value === undefined ? { matched: false } : {
        matched: true,
        position,
        value
      };
    };
  };
  var any = function(data, i) {
    return i < data.tokens.length ? {
      matched: true,
      position: i + 1,
      value: data.tokens[i]
    } : { matched: false };
  };
  var satisfy = function(test) {
    return (data, i) => i < data.tokens.length && test(data.tokens[i], data, i) ? {
      matched: true,
      position: i + 1,
      value: data.tokens[i]
    } : { matched: false };
  };
  var mapInner = function(r, f) {
    return r.matched ? {
      matched: true,
      position: r.position,
      value: f(r.value, r.position)
    } : r;
  };
  var mapOuter = function(r, f) {
    return r.matched ? f(r) : r;
  };
  var map = function(p, mapper) {
    return (data, i) => mapInner(p(data, i), (v, j) => mapper(v, data, i, j));
  };
  var map1 = function(p, mapper) {
    return (data, i) => mapOuter(p(data, i), (m) => mapper(m, data, i));
  };
  var peek = function(p, f) {
    return (data, i) => {
      const r = p(data, i);
      f(r, data, i);
      return r;
    };
  };
  var option = function(p, def) {
    return (data, i) => {
      const r = p(data, i);
      return r.matched ? r : {
        matched: true,
        position: i,
        value: def
      };
    };
  };
  var not2 = function(p) {
    return (data, i) => {
      const r = p(data, i);
      return r.matched ? { matched: false } : {
        matched: true,
        position: i,
        value: true
      };
    };
  };
  var choice = function(...ps) {
    return (data, i) => {
      for (const p of ps) {
        const result2 = p(data, i);
        if (result2.matched) {
          return result2;
        }
      }
      return { matched: false };
    };
  };
  var otherwise = function(pa, pb) {
    return (data, i) => {
      const r12 = pa(data, i);
      return r12.matched ? r12 : pb(data, i);
    };
  };
  var longest = function(...ps) {
    return (data, i) => {
      let match2 = undefined;
      for (const p of ps) {
        const result2 = p(data, i);
        if (result2.matched && (!match2 || match2.position < result2.position)) {
          match2 = result2;
        }
      }
      return match2 || { matched: false };
    };
  };
  var takeWhile = function(p, test) {
    return (data, i) => {
      const values2 = [];
      let success = true;
      do {
        const r = p(data, i);
        if (r.matched && test(r.value, values2.length + 1, data, i, r.position)) {
          values2.push(r.value);
          i = r.position;
        } else {
          success = false;
        }
      } while (success);
      return {
        matched: true,
        position: i,
        value: values2
      };
    };
  };
  var takeUntil = function(p, test) {
    return takeWhile(p, (value, n, data, i, j) => !test(value, n, data, i, j));
  };
  var takeWhileP = function(pValue, pTest) {
    return takeWhile(pValue, (value, n, data, i) => pTest(data, i).matched);
  };
  var takeUntilP = function(pValue, pTest) {
    return takeWhile(pValue, (value, n, data, i) => !pTest(data, i).matched);
  };
  var many = function(p) {
    return takeWhile(p, () => true);
  };
  var many1 = function(p) {
    return ab(p, many(p), (head, tail) => [head, ...tail]);
  };
  var ab = function(pa, pb, join) {
    return (data, i) => mapOuter(pa(data, i), (ma) => mapInner(pb(data, ma.position), (vb, j) => join(ma.value, vb, data, i, j)));
  };
  var left = function(pa, pb) {
    return ab(pa, pb, (va) => va);
  };
  var right = function(pa, pb) {
    return ab(pa, pb, (va, vb) => vb);
  };
  var abc = function(pa, pb, pc, join) {
    return (data, i) => mapOuter(pa(data, i), (ma) => mapOuter(pb(data, ma.position), (mb) => mapInner(pc(data, mb.position), (vc, j) => join(ma.value, mb.value, vc, data, i, j))));
  };
  var middle = function(pa, pb, pc) {
    return abc(pa, pb, pc, (ra, rb) => rb);
  };
  var all = function(...ps) {
    return (data, i) => {
      const result2 = [];
      let position = i;
      for (const p of ps) {
        const r12 = p(data, position);
        if (r12.matched) {
          result2.push(r12.value);
          position = r12.position;
        } else {
          return { matched: false };
        }
      }
      return {
        matched: true,
        position,
        value: result2
      };
    };
  };
  var skip = function(...ps) {
    return map(all(...ps), () => null);
  };
  var flatten = function(...ps) {
    return flatten1(all(...ps));
  };
  var flatten1 = function(p) {
    return map(p, (vs) => vs.flatMap((v) => v));
  };
  var sepBy1 = function(pValue, pSep) {
    return ab(pValue, many(right(pSep, pValue)), (head, tail) => [head, ...tail]);
  };
  var sepBy = function(pValue, pSep) {
    return otherwise(sepBy1(pValue, pSep), emit([]));
  };
  var chainReduce = function(acc, f) {
    return (data, i) => {
      let loop = true;
      let acc1 = acc;
      let pos = i;
      do {
        const r = f(acc1, data, pos)(data, pos);
        if (r.matched) {
          acc1 = r.value;
          pos = r.position;
        } else {
          loop = false;
        }
      } while (loop);
      return {
        matched: true,
        position: pos,
        value: acc1
      };
    };
  };
  var reduceLeft = function(acc, p, reducer) {
    return chainReduce(acc, (acc2) => map(p, (v, data, i, j) => reducer(acc2, v, data, i, j)));
  };
  var reduceRight = function(p, acc, reducer) {
    return map(many(p), (vs, data, i, j) => vs.reduceRight((acc2, v) => reducer(v, acc2, data, i, j), acc));
  };
  var leftAssoc1 = function(pLeft, pOper) {
    return chain(pLeft, (v02) => reduceLeft(v02, pOper, (acc, f) => f(acc)));
  };
  var rightAssoc1 = function(pOper, pRight) {
    return ab(reduceRight(pOper, (y) => y, (f, acc) => (y) => f(acc(y))), pRight, (f, v) => f(v));
  };
  var leftAssoc2 = function(pLeft, pOper, pRight) {
    return chain(pLeft, (v02) => reduceLeft(v02, ab(pOper, pRight, (f, y) => [f, y]), (acc, [f, y]) => f(acc, y)));
  };
  var rightAssoc2 = function(pLeft, pOper, pRight) {
    return ab(reduceRight(ab(pLeft, pOper, (x, f) => [x, f]), (y) => y, ([x, f], acc) => (y) => f(x, acc(y))), pRight, (f, v) => f(v));
  };
  var condition = function(cond, pTrue, pFalse) {
    return (data, i) => cond(data, i) ? pTrue(data, i) : pFalse(data, i);
  };
  var decide = function(p) {
    return (data, i) => mapOuter(p(data, i), (m1) => m1.value(data, m1.position));
  };
  var chain = function(p, f) {
    return (data, i) => mapOuter(p(data, i), (m1) => f(m1.value, data, i, m1.position)(data, m1.position));
  };
  var ahead = function(p) {
    return (data, i) => mapOuter(p(data, i), (m1) => ({
      matched: true,
      position: i,
      value: m1.value
    }));
  };
  var recursive = function(f) {
    return function(data, i) {
      return f()(data, i);
    };
  };
  var start = function(data, i) {
    return i !== 0 ? { matched: false } : {
      matched: true,
      position: i,
      value: true
    };
  };
  var end = function(data, i) {
    return i < data.tokens.length ? { matched: false } : {
      matched: true,
      position: i,
      value: true
    };
  };
  var remainingTokensNumber = function(data, i) {
    return data.tokens.length - i;
  };
  var parserPosition = function(data, i, formatToken, contextTokens = 3) {
    const len = data.tokens.length;
    const lowIndex = util2.clamp(0, i - contextTokens, len - contextTokens);
    const highIndex = util2.clamp(contextTokens, i + 1 + contextTokens, len);
    const tokensSlice = data.tokens.slice(lowIndex, highIndex);
    const lines = [];
    const indexWidth = String(highIndex - 1).length + 1;
    if (i < 0) {
      lines.push(`${String(i).padStart(indexWidth)} >>`);
    }
    if (0 < lowIndex) {
      lines.push("...".padStart(indexWidth + 6));
    }
    for (let j = 0;j < tokensSlice.length; j++) {
      const index = lowIndex + j;
      lines.push(`${String(index).padStart(indexWidth)} ${index === i ? ">" : " "} ${util2.escapeWhitespace(formatToken(tokensSlice[j]))}`);
    }
    if (highIndex < len) {
      lines.push("...".padStart(indexWidth + 6));
    }
    if (len <= i) {
      lines.push(`${String(i).padStart(indexWidth)} >>`);
    }
    return lines.join("\n");
  };
  var parse2 = function(parser, tokens, options, formatToken = JSON.stringify) {
    const data = { tokens, options };
    const result2 = parser(data, 0);
    if (!result2.matched) {
      throw new Error("No match");
    }
    if (result2.position < data.tokens.length) {
      throw new Error(`Partial match. Parsing stopped at:\n${parserPosition(data, result2.position, formatToken)}`);
    }
    return result2.value;
  };
  var tryParse = function(parser, tokens, options) {
    const result2 = parser({ tokens, options }, 0);
    return result2.matched ? result2.value : undefined;
  };
  var match = function(matcher, tokens, options) {
    const result2 = matcher({ tokens, options }, 0);
    return result2.value;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var util2 = require_util();
  exports.ab = ab;
  exports.abc = abc;
  exports.action = action;
  exports.ahead = ahead;
  exports.all = all;
  exports.and = all;
  exports.any = any;
  exports.chain = chain;
  exports.chainReduce = chainReduce;
  exports.choice = choice;
  exports.condition = condition;
  exports.decide = decide;
  exports.discard = skip;
  exports.eitherOr = otherwise;
  exports.emit = emit;
  exports.end = end;
  exports.eof = end;
  exports.error = error;
  exports.fail = fail;
  exports.flatten = flatten;
  exports.flatten1 = flatten1;
  exports.left = left;
  exports.leftAssoc1 = leftAssoc1;
  exports.leftAssoc2 = leftAssoc2;
  exports.longest = longest;
  exports.lookAhead = ahead;
  exports.make = make;
  exports.many = many;
  exports.many1 = many1;
  exports.map = map;
  exports.map1 = map1;
  exports.match = match;
  exports.middle = middle;
  exports.not = not2;
  exports.of = emit;
  exports.option = option;
  exports.or = choice;
  exports.otherwise = otherwise;
  exports.parse = parse2;
  exports.parserPosition = parserPosition;
  exports.peek = peek;
  exports.recursive = recursive;
  exports.reduceLeft = reduceLeft;
  exports.reduceRight = reduceRight;
  exports.remainingTokensNumber = remainingTokensNumber;
  exports.right = right;
  exports.rightAssoc1 = rightAssoc1;
  exports.rightAssoc2 = rightAssoc2;
  exports.satisfy = satisfy;
  exports.sepBy = sepBy;
  exports.sepBy1 = sepBy1;
  exports.skip = skip;
  exports.some = many1;
  exports.start = start;
  exports.takeUntil = takeUntil;
  exports.takeUntilP = takeUntilP;
  exports.takeWhile = takeWhile;
  exports.takeWhileP = takeWhileP;
  exports.token = token;
  exports.tryParse = tryParse;
});

// node_modules/parseley/lib/parseley.cjs
var require_parseley = __commonJS((exports) => {
  var _interopNamespace = function(e) {
    if (e && e.__esModule)
      return e;
    var n = Object.create(null);
    if (e) {
      Object.keys(e).forEach(function(k) {
        if (k !== "default") {
          var d = Object.getOwnPropertyDescriptor(e, k);
          Object.defineProperty(n, k, d.get ? d : {
            enumerable: true,
            get: function() {
              return e[k];
            }
          });
        }
      });
    }
    n["default"] = e;
    return Object.freeze(n);
  };
  var sumSpec = function([a02, a12, a2], [b0, b1, b2]) {
    return [a02 + b0, a12 + b1, a2 + b2];
  };
  var sumAllSpec = function(ss) {
    return ss.reduce(sumSpec, [0, 0, 0]);
  };
  var unescape2 = function(escapedString) {
    const lexerResult = lexEscapedString(escapedString);
    const result2 = escapedString_({ tokens: lexerResult.tokens, options: undefined }, 0);
    return result2.value;
  };
  var literal = function(name2) {
    return p__namespace.token((t) => t.name === name2 ? true : undefined);
  };
  var optionallySpaced = function(parser) {
    return p__namespace.middle(optionalWhitespace_, parser, optionalWhitespace_);
  };
  var parse_ = function(parser, str) {
    if (!(typeof str === "string" || str instanceof String)) {
      throw new Error("Expected a selector string. Actual input is not a string!");
    }
    const lexerResult = lexSelector(str);
    if (!lexerResult.complete) {
      throw new Error(`The input "${str}" was only partially tokenized, stopped at offset ${lexerResult.offset}!\n` + prettyPrintPosition(str, lexerResult.offset));
    }
    const result2 = optionallySpaced(parser)({ tokens: lexerResult.tokens, options: undefined }, 0);
    if (!result2.matched) {
      throw new Error(`No match for "${str}" input!`);
    }
    if (result2.position < lexerResult.tokens.length) {
      const token = lexerResult.tokens[result2.position];
      throw new Error(`The input "${str}" was only partially parsed, stopped at offset ${token.offset}!\n` + prettyPrintPosition(str, token.offset, token.len));
    }
    return result2.value;
  };
  var prettyPrintPosition = function(str, offset, len = 1) {
    return `${str.replace(/(\t)|(\r)|(\n)/g, (m, t, r) => t ? "\u2409" : r ? "\u240D" : "\u240A")}\n${"".padEnd(offset)}${"^".repeat(len)}`;
  };
  var parse2 = function(str) {
    return parse_(listSelector_, str);
  };
  var parse1 = function(str) {
    return parse_(complexSelector_, str);
  };
  var serialize = function(selector) {
    if (!selector.type) {
      throw new Error("This is not an AST node.");
    }
    switch (selector.type) {
      case "universal":
        return _serNs(selector.namespace) + "*";
      case "tag":
        return _serNs(selector.namespace) + _serIdent(selector.name);
      case "class":
        return "." + _serIdent(selector.name);
      case "id":
        return "#" + _serIdent(selector.name);
      case "attrPresence":
        return `[${_serNs(selector.namespace)}${_serIdent(selector.name)}]`;
      case "attrValue":
        return `[${_serNs(selector.namespace)}${_serIdent(selector.name)}${selector.matcher}"${_serStr(selector.value)}"${selector.modifier ? selector.modifier : ""}]`;
      case "combinator":
        return serialize(selector.left) + selector.combinator;
      case "compound":
        return selector.list.reduce((acc, node) => {
          if (node.type === "combinator") {
            return serialize(node) + acc;
          } else {
            return acc + serialize(node);
          }
        }, "");
      case "list":
        return selector.list.map(serialize).join(",");
    }
  };
  var _serNs = function(ns) {
    return ns || ns === "" ? _serIdent(ns) + "|" : "";
  };
  var _codePoint = function(char) {
    return `\\${char.codePointAt(0).toString(16)} `;
  };
  var _serIdent = function(str) {
    return str.replace(/(^[0-9])|(^-[0-9])|(^-$)|([-0-9a-zA-Z_]|[^\x00-\x7F])|(\x00)|([\x01-\x1f]|\x7f)|([\s\S])/g, (m, d1, d2, hy, safe, nl2, ctrl, other) => d1 ? _codePoint(d1) : d2 ? "-" + _codePoint(d2.slice(1)) : hy ? "\\-" : safe ? safe : nl2 ? "\uFFFD" : ctrl ? _codePoint(ctrl) : "\\" + other);
  };
  var _serStr = function(str) {
    return str.replace(/(")|(\\)|(\x00)|([\x01-\x1f]|\x7f)/g, (m, dq, bs, nl2, ctrl) => dq ? '\\"' : bs ? "\\\\" : nl2 ? "\uFFFD" : _codePoint(ctrl));
  };
  var normalize = function(selector) {
    if (!selector.type) {
      throw new Error("This is not an AST node.");
    }
    switch (selector.type) {
      case "compound": {
        selector.list.forEach(normalize);
        selector.list.sort((a, b2) => _compareArrays(_getSelectorPriority(a), _getSelectorPriority(b2)));
        break;
      }
      case "combinator": {
        normalize(selector.left);
        break;
      }
      case "list": {
        selector.list.forEach(normalize);
        selector.list.sort((a, b2) => serialize(a) < serialize(b2) ? -1 : 1);
        break;
      }
    }
    return selector;
  };
  var _getSelectorPriority = function(selector) {
    switch (selector.type) {
      case "universal":
        return [1];
      case "tag":
        return [1];
      case "id":
        return [2];
      case "class":
        return [3, selector.name];
      case "attrPresence":
        return [4, serialize(selector)];
      case "attrValue":
        return [5, serialize(selector)];
      case "combinator":
        return [15, serialize(selector)];
    }
  };
  var compareSelectors = function(a, b2) {
    return _compareArrays(a.specificity, b2.specificity);
  };
  var compareSpecificity = function(a, b2) {
    return _compareArrays(a, b2);
  };
  var _compareArrays = function(a, b2) {
    if (!Array.isArray(a) || !Array.isArray(b2)) {
      throw new Error("Arguments must be arrays.");
    }
    const shorter = a.length < b2.length ? a.length : b2.length;
    for (let i = 0;i < shorter; i++) {
      if (a[i] === b2[i]) {
        continue;
      }
      return a[i] < b2[i] ? -1 : 1;
    }
    return a.length - b2.length;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var leac = require_leac();
  var p = require_core();
  var p__namespace = _interopNamespace(p);
  var ast = Object.freeze({
    __proto__: null
  });
  var ws = `(?:[ \\t\\r\\n\\f]*)`;
  var nl = `(?:\\n|\\r\\n|\\r|\\f)`;
  var nonascii = `[^\\x00-\\x7F]`;
  var unicode = `(?:\\\\[0-9a-f]{1,6}(?:\\r\\n|[ \\n\\r\\t\\f])?)`;
  var escape2 = `(?:\\\\[^\\n\\r\\f0-9a-f])`;
  var nmstart = `(?:[_a-z]|${nonascii}|${unicode}|${escape2})`;
  var nmchar = `(?:[_a-z0-9-]|${nonascii}|${unicode}|${escape2})`;
  var name = `(?:${nmchar}+)`;
  var ident = `(?:[-]?${nmstart}${nmchar}*)`;
  var string1 = `'([^\\n\\r\\f\\\\']|\\\\${nl}|${nonascii}|${unicode}|${escape2})*'`;
  var string2 = `"([^\\n\\r\\f\\\\"]|\\\\${nl}|${nonascii}|${unicode}|${escape2})*"`;
  var lexSelector = leac.createLexer([
    { name: "ws", regex: new RegExp(ws) },
    { name: "hash", regex: new RegExp(`#${name}`, "i") },
    { name: "ident", regex: new RegExp(ident, "i") },
    { name: "str1", regex: new RegExp(string1, "i") },
    { name: "str2", regex: new RegExp(string2, "i") },
    { name: "*" },
    { name: "." },
    { name: "," },
    { name: "[" },
    { name: "]" },
    { name: "=" },
    { name: ">" },
    { name: "|" },
    { name: "+" },
    { name: "~" },
    { name: "^" },
    { name: "$" }
  ]);
  var lexEscapedString = leac.createLexer([
    { name: "unicode", regex: new RegExp(unicode, "i") },
    { name: "escape", regex: new RegExp(escape2, "i") },
    { name: "any", regex: new RegExp("[\\s\\S]", "i") }
  ]);
  var unicodeEscapedSequence_ = p__namespace.token((t) => t.name === "unicode" ? String.fromCodePoint(parseInt(t.text.slice(1), 16)) : undefined);
  var escapedSequence_ = p__namespace.token((t) => t.name === "escape" ? t.text.slice(1) : undefined);
  var anyChar_ = p__namespace.token((t) => t.name === "any" ? t.text : undefined);
  var escapedString_ = p__namespace.map(p__namespace.many(p__namespace.or(unicodeEscapedSequence_, escapedSequence_, anyChar_)), (cs) => cs.join(""));
  var whitespace_ = p__namespace.token((t) => t.name === "ws" ? null : undefined);
  var optionalWhitespace_ = p__namespace.option(whitespace_, null);
  var identifier_ = p__namespace.token((t) => t.name === "ident" ? unescape2(t.text) : undefined);
  var hashId_ = p__namespace.token((t) => t.name === "hash" ? unescape2(t.text.slice(1)) : undefined);
  var string_ = p__namespace.token((t) => t.name.startsWith("str") ? unescape2(t.text.slice(1, -1)) : undefined);
  var namespace_ = p__namespace.left(p__namespace.option(identifier_, ""), literal("|"));
  var qualifiedName_ = p__namespace.eitherOr(p__namespace.ab(namespace_, identifier_, (ns, name2) => ({ name: name2, namespace: ns })), p__namespace.map(identifier_, (name2) => ({ name: name2, namespace: null })));
  var uniSelector_ = p__namespace.eitherOr(p__namespace.ab(namespace_, literal("*"), (ns) => ({ type: "universal", namespace: ns, specificity: [0, 0, 0] })), p__namespace.map(literal("*"), () => ({ type: "universal", namespace: null, specificity: [0, 0, 0] })));
  var tagSelector_ = p__namespace.map(qualifiedName_, ({ name: name2, namespace }) => ({
    type: "tag",
    name: name2,
    namespace,
    specificity: [0, 0, 1]
  }));
  var classSelector_ = p__namespace.ab(literal("."), identifier_, (fullstop, name2) => ({
    type: "class",
    name: name2,
    specificity: [0, 1, 0]
  }));
  var idSelector_ = p__namespace.map(hashId_, (name2) => ({
    type: "id",
    name: name2,
    specificity: [1, 0, 0]
  }));
  var attrModifier_ = p__namespace.token((t) => {
    if (t.name === "ident") {
      if (t.text === "i" || t.text === "I") {
        return "i";
      }
      if (t.text === "s" || t.text === "S") {
        return "s";
      }
    }
    return;
  });
  var attrValue_ = p__namespace.eitherOr(p__namespace.ab(string_, p__namespace.option(p__namespace.right(optionalWhitespace_, attrModifier_), null), (v, mod) => ({ value: v, modifier: mod })), p__namespace.ab(identifier_, p__namespace.option(p__namespace.right(whitespace_, attrModifier_), null), (v, mod) => ({ value: v, modifier: mod })));
  var attrMatcher_ = p__namespace.choice(p__namespace.map(literal("="), () => "="), p__namespace.ab(literal("~"), literal("="), () => "~="), p__namespace.ab(literal("|"), literal("="), () => "|="), p__namespace.ab(literal("^"), literal("="), () => "^="), p__namespace.ab(literal("$"), literal("="), () => "$="), p__namespace.ab(literal("*"), literal("="), () => "*="));
  var attrPresenceSelector_ = p__namespace.abc(literal("["), optionallySpaced(qualifiedName_), literal("]"), (lbr, { name: name2, namespace }) => ({
    type: "attrPresence",
    name: name2,
    namespace,
    specificity: [0, 1, 0]
  }));
  var attrValueSelector_ = p__namespace.middle(literal("["), p__namespace.abc(optionallySpaced(qualifiedName_), attrMatcher_, optionallySpaced(attrValue_), ({ name: name2, namespace }, matcher, { value, modifier }) => ({
    type: "attrValue",
    name: name2,
    namespace,
    matcher,
    value,
    modifier,
    specificity: [0, 1, 0]
  })), literal("]"));
  var attrSelector_ = p__namespace.eitherOr(attrPresenceSelector_, attrValueSelector_);
  var typeSelector_ = p__namespace.eitherOr(uniSelector_, tagSelector_);
  var subclassSelector_ = p__namespace.choice(idSelector_, classSelector_, attrSelector_);
  var compoundSelector_ = p__namespace.map(p__namespace.eitherOr(p__namespace.flatten(typeSelector_, p__namespace.many(subclassSelector_)), p__namespace.many1(subclassSelector_)), (ss) => {
    return {
      type: "compound",
      list: ss,
      specificity: sumAllSpec(ss.map((s) => s.specificity))
    };
  });
  var combinator_ = p__namespace.choice(p__namespace.map(literal(">"), () => ">"), p__namespace.map(literal("+"), () => "+"), p__namespace.map(literal("~"), () => "~"), p__namespace.ab(literal("|"), literal("|"), () => "||"));
  var combinatorSeparator_ = p__namespace.eitherOr(optionallySpaced(combinator_), p__namespace.map(whitespace_, () => " "));
  var complexSelector_ = p__namespace.leftAssoc2(compoundSelector_, p__namespace.map(combinatorSeparator_, (c2) => (left, right) => ({
    type: "compound",
    list: [...right.list, { type: "combinator", combinator: c2, left, specificity: left.specificity }],
    specificity: sumSpec(left.specificity, right.specificity)
  })), compoundSelector_);
  var listSelector_ = p__namespace.leftAssoc2(p__namespace.map(complexSelector_, (s) => ({ type: "list", list: [s] })), p__namespace.map(optionallySpaced(literal(",")), () => (acc, next) => ({ type: "list", list: [...acc.list, next] })), complexSelector_);
  exports.Ast = ast;
  exports.compareSelectors = compareSelectors;
  exports.compareSpecificity = compareSpecificity;
  exports.normalize = normalize;
  exports.parse = parse2;
  exports.parse1 = parse1;
  exports.serialize = serialize;
});

// node_modules/selderee/lib/selderee.cjs
var require_selderee = __commonJS((exports) => {
  var _interopNamespace = function(e) {
    if (e && e.__esModule)
      return e;
    var n = Object.create(null);
    if (e) {
      Object.keys(e).forEach(function(k) {
        if (k !== "default") {
          var d = Object.getOwnPropertyDescriptor(e, k);
          Object.defineProperty(n, k, d.get ? d : {
            enumerable: true,
            get: function() {
              return e[k];
            }
          });
        }
      });
    }
    n["default"] = e;
    return Object.freeze(n);
  };
  var treeifyArray = function(nodes, tpl = heavyLines) {
    return prefixItems(tpl, nodes.map((n) => treeifyNode(n)));
  };
  var treeifyNode = function(node) {
    switch (node.type) {
      case "terminal": {
        const vctr = node.valueContainer;
        return `\u25C1 #${vctr.index} ${JSON.stringify(vctr.specificity)} ${vctr.value}`;
      }
      case "tagName":
        return `\u25FB Tag name
${treeifyArray(node.variants, doubleLines)}`;
      case "attrValue":
        return `\u25A3 Attr value: ${node.name}\n${treeifyArray(node.matchers, doubleLines)}`;
      case "attrPresence":
        return `\u25E8 Attr presence: ${node.name}\n${treeifyArray(node.cont)}`;
      case "pushElement":
        return `\u25C9 Push element: ${node.combinator}\n${treeifyArray(node.cont, thinLines)}`;
      case "popElement":
        return `\u25CC Pop element
${treeifyArray(node.cont, thinLines)}`;
      case "variant":
        return `\u25C7 = ${node.value}\n${treeifyArray(node.cont)}`;
      case "matcher":
        return `\u25C8 ${node.matcher} "${node.value}"${node.modifier || ""}\n${treeifyArray(node.cont)}`;
    }
  };
  var prefixItems = function(tpl, items) {
    return items.map((item, i, { length }) => prefixItem(tpl, item, i === length - 1)).join("\n");
  };
  var prefixItem = function(tpl, item, tail = true) {
    const tpl1 = tpl[tail ? 1 : 0];
    return tpl1[0] + item.split("\n").join("\n" + tpl1[1]);
  };
  var toAstTerminalPairs = function(array2) {
    const len = array2.length;
    const results = new Array(len);
    for (let i = 0;i < len; i++) {
      const [selectorString, val] = array2[i];
      const ast = preprocess(parseley__namespace.parse1(selectorString));
      results[i] = {
        ast,
        terminal: {
          type: "terminal",
          valueContainer: { index: i, value: val, specificity: ast.specificity }
        }
      };
    }
    return results;
  };
  var preprocess = function(ast) {
    reduceSelectorVariants(ast);
    parseley__namespace.normalize(ast);
    return ast;
  };
  var reduceSelectorVariants = function(ast) {
    const newList = [];
    ast.list.forEach((sel) => {
      switch (sel.type) {
        case "class":
          newList.push({
            matcher: "~=",
            modifier: null,
            name: "class",
            namespace: null,
            specificity: sel.specificity,
            type: "attrValue",
            value: sel.name
          });
          break;
        case "id":
          newList.push({
            matcher: "=",
            modifier: null,
            name: "id",
            namespace: null,
            specificity: sel.specificity,
            type: "attrValue",
            value: sel.name
          });
          break;
        case "combinator":
          reduceSelectorVariants(sel.left);
          newList.push(sel);
          break;
        case "universal":
          break;
        default:
          newList.push(sel);
          break;
      }
    });
    ast.list = newList;
  };
  var weave = function(items) {
    const branches = [];
    while (items.length) {
      const topKind = findTopKey(items, (sel) => true, getSelectorKind);
      const { matches, nonmatches, empty } = breakByKind(items, topKind);
      items = nonmatches;
      if (matches.length) {
        branches.push(branchOfKind(topKind, matches));
      }
      if (empty.length) {
        branches.push(...terminate(empty));
      }
    }
    return branches;
  };
  var terminate = function(items) {
    const results = [];
    for (const item of items) {
      const terminal = item.terminal;
      if (terminal.type === "terminal") {
        results.push(terminal);
      } else {
        const { matches, rest } = partition(terminal.cont, (node) => node.type === "terminal");
        matches.forEach((node) => results.push(node));
        if (rest.length) {
          terminal.cont = rest;
          results.push(terminal);
        }
      }
    }
    return results;
  };
  var breakByKind = function(items, selectedKind) {
    const matches = [];
    const nonmatches = [];
    const empty = [];
    for (const item of items) {
      const simpsels = item.ast.list;
      if (simpsels.length) {
        const isMatch = simpsels.some((node) => getSelectorKind(node) === selectedKind);
        (isMatch ? matches : nonmatches).push(item);
      } else {
        empty.push(item);
      }
    }
    return { matches, nonmatches, empty };
  };
  var getSelectorKind = function(sel) {
    switch (sel.type) {
      case "attrPresence":
        return `attrPresence ${sel.name}`;
      case "attrValue":
        return `attrValue ${sel.name}`;
      case "combinator":
        return `combinator ${sel.combinator}`;
      default:
        return sel.type;
    }
  };
  var branchOfKind = function(kind, items) {
    if (kind === "tag") {
      return tagNameBranch(items);
    }
    if (kind.startsWith("attrValue ")) {
      return attrValueBranch(kind.substring(10), items);
    }
    if (kind.startsWith("attrPresence ")) {
      return attrPresenceBranch(kind.substring(13), items);
    }
    if (kind === "combinator >") {
      return combinatorBranch(">", items);
    }
    if (kind === "combinator +") {
      return combinatorBranch("+", items);
    }
    throw new Error(`Unsupported selector kind: ${kind}`);
  };
  var tagNameBranch = function(items) {
    const groups = spliceAndGroup(items, (x) => x.type === "tag", (x) => x.name);
    const variants = Object.entries(groups).map(([name, group]) => ({
      type: "variant",
      value: name,
      cont: weave(group.items)
    }));
    return {
      type: "tagName",
      variants
    };
  };
  var attrPresenceBranch = function(name, items) {
    for (const item of items) {
      spliceSimpleSelector(item, (x) => x.type === "attrPresence" && x.name === name);
    }
    return {
      type: "attrPresence",
      name,
      cont: weave(items)
    };
  };
  var attrValueBranch = function(name, items) {
    const groups = spliceAndGroup(items, (x) => x.type === "attrValue" && x.name === name, (x) => `${x.matcher} ${x.modifier || ""} ${x.value}`);
    const matchers = [];
    for (const group of Object.values(groups)) {
      const sel = group.oneSimpleSelector;
      const predicate = getAttrPredicate(sel);
      const continuation = weave(group.items);
      matchers.push({
        type: "matcher",
        matcher: sel.matcher,
        modifier: sel.modifier,
        value: sel.value,
        predicate,
        cont: continuation
      });
    }
    return {
      type: "attrValue",
      name,
      matchers
    };
  };
  var getAttrPredicate = function(sel) {
    if (sel.modifier === "i") {
      const expected = sel.value.toLowerCase();
      switch (sel.matcher) {
        case "=":
          return (actual) => expected === actual.toLowerCase();
        case "~=":
          return (actual) => actual.toLowerCase().split(/[ \t]+/).includes(expected);
        case "^=":
          return (actual) => actual.toLowerCase().startsWith(expected);
        case "$=":
          return (actual) => actual.toLowerCase().endsWith(expected);
        case "*=":
          return (actual) => actual.toLowerCase().includes(expected);
        case "|=":
          return (actual) => {
            const lower = actual.toLowerCase();
            return expected === lower || lower.startsWith(expected) && lower[expected.length] === "-";
          };
      }
    } else {
      const expected = sel.value;
      switch (sel.matcher) {
        case "=":
          return (actual) => expected === actual;
        case "~=":
          return (actual) => actual.split(/[ \t]+/).includes(expected);
        case "^=":
          return (actual) => actual.startsWith(expected);
        case "$=":
          return (actual) => actual.endsWith(expected);
        case "*=":
          return (actual) => actual.includes(expected);
        case "|=":
          return (actual) => expected === actual || actual.startsWith(expected) && actual[expected.length] === "-";
      }
    }
  };
  var combinatorBranch = function(combinator, items) {
    const groups = spliceAndGroup(items, (x) => x.type === "combinator" && x.combinator === combinator, (x) => parseley__namespace.serialize(x.left));
    const leftItems = [];
    for (const group of Object.values(groups)) {
      const rightCont = weave(group.items);
      const leftAst = group.oneSimpleSelector.left;
      leftItems.push({
        ast: leftAst,
        terminal: { type: "popElement", cont: rightCont }
      });
    }
    return {
      type: "pushElement",
      combinator,
      cont: weave(leftItems)
    };
  };
  var spliceAndGroup = function(items, predicate, keyCallback) {
    const groups = {};
    while (items.length) {
      const bestKey = findTopKey(items, predicate, keyCallback);
      const bestKeyPredicate = (sel) => predicate(sel) && keyCallback(sel) === bestKey;
      const hasBestKeyPredicate = (item) => item.ast.list.some(bestKeyPredicate);
      const { matches, rest } = partition1(items, hasBestKeyPredicate);
      let oneSimpleSelector = null;
      for (const item of matches) {
        const splicedNode = spliceSimpleSelector(item, bestKeyPredicate);
        if (!oneSimpleSelector) {
          oneSimpleSelector = splicedNode;
        }
      }
      if (oneSimpleSelector == null) {
        throw new Error("No simple selector is found.");
      }
      groups[bestKey] = { oneSimpleSelector, items: matches };
      items = rest;
    }
    return groups;
  };
  var spliceSimpleSelector = function(item, predicate) {
    const simpsels = item.ast.list;
    const matches = new Array(simpsels.length);
    let firstIndex = -1;
    for (let i = simpsels.length;i-- > 0; ) {
      if (predicate(simpsels[i])) {
        matches[i] = true;
        firstIndex = i;
      }
    }
    if (firstIndex == -1) {
      throw new Error(`Couldn't find the required simple selector.`);
    }
    const result2 = simpsels[firstIndex];
    item.ast.list = simpsels.filter((sel, i) => !matches[i]);
    return result2;
  };
  var findTopKey = function(items, predicate, keyCallback) {
    const candidates = {};
    for (const item of items) {
      const candidates1 = {};
      for (const node of item.ast.list.filter(predicate)) {
        candidates1[keyCallback(node)] = true;
      }
      for (const key of Object.keys(candidates1)) {
        if (candidates[key]) {
          candidates[key]++;
        } else {
          candidates[key] = 1;
        }
      }
    }
    let topKind = "";
    let topCounter = 0;
    for (const entry of Object.entries(candidates)) {
      if (entry[1] > topCounter) {
        topKind = entry[0];
        topCounter = entry[1];
      }
    }
    return topKind;
  };
  var partition = function(src, predicate) {
    const matches = [];
    const rest = [];
    for (const x of src) {
      if (predicate(x)) {
        matches.push(x);
      } else {
        rest.push(x);
      }
    }
    return { matches, rest };
  };
  var partition1 = function(src, predicate) {
    const matches = [];
    const rest = [];
    for (const x of src) {
      if (predicate(x)) {
        matches.push(x);
      } else {
        rest.push(x);
      }
    }
    return { matches, rest };
  };
  var comparatorPreferFirst = function(acc, next) {
    const diff = parseley.compareSpecificity(next.specificity, acc.specificity);
    return diff > 0 || diff === 0 && next.index < acc.index;
  };
  var comparatorPreferLast = function(acc, next) {
    const diff = parseley.compareSpecificity(next.specificity, acc.specificity);
    return diff > 0 || diff === 0 && next.index > acc.index;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var parseley = require_parseley();
  var parseley__namespace = _interopNamespace(parseley);
  var Ast = Object.freeze({
    __proto__: null
  });
  var Types = Object.freeze({
    __proto__: null
  });
  var treeify = (nodes) => `\u25BD
` + treeifyArray(nodes, thinLines);
  var thinLines = [["\u251C\u2500", "\u2502 "], ["\u2514\u2500", "  "]];
  var heavyLines = [["\u2520\u2500", "\u2503 "], ["\u2516\u2500", "  "]];
  var doubleLines = [["\u255F\u2500", "\u2551 "], ["\u2559\u2500", "  "]];
  var TreeifyBuilder = Object.freeze({
    __proto__: null,
    treeify
  });

  class DecisionTree {
    constructor(input) {
      this.branches = weave(toAstTerminalPairs(input));
    }
    build(builder) {
      return builder(this.branches);
    }
  }

  class Picker {
    constructor(f) {
      this.f = f;
    }
    pickAll(el) {
      return this.f(el);
    }
    pick1(el, preferFirst = false) {
      const results = this.f(el);
      const len = results.length;
      if (len === 0) {
        return null;
      }
      if (len === 1) {
        return results[0].value;
      }
      const comparator = preferFirst ? comparatorPreferFirst : comparatorPreferLast;
      let result2 = results[0];
      for (let i = 1;i < len; i++) {
        const next = results[i];
        if (comparator(result2, next)) {
          result2 = next;
        }
      }
      return result2.value;
    }
  }
  exports.Ast = Ast;
  exports.DecisionTree = DecisionTree;
  exports.Picker = Picker;
  exports.Treeify = TreeifyBuilder;
  exports.Types = Types;
});

// node_modules/@selderee/plugin-htmlparser2/lib/hp2-builder.cjs
var require_hp2_builder = __commonJS((exports) => {
  var hp2Builder = function(nodes) {
    return new selderee.Picker(handleArray(nodes));
  };
  var handleArray = function(nodes) {
    const matchers = nodes.map(handleNode);
    return (el, ...tail) => matchers.flatMap((m) => m(el, ...tail));
  };
  var handleNode = function(node) {
    switch (node.type) {
      case "terminal": {
        const result2 = [node.valueContainer];
        return (el, ...tail) => result2;
      }
      case "tagName":
        return handleTagName(node);
      case "attrValue":
        return handleAttrValueName(node);
      case "attrPresence":
        return handleAttrPresenceName(node);
      case "pushElement":
        return handlePushElementNode(node);
      case "popElement":
        return handlePopElementNode(node);
    }
  };
  var handleTagName = function(node) {
    const variants = {};
    for (const variant of node.variants) {
      variants[variant.value] = handleArray(variant.cont);
    }
    return (el, ...tail) => {
      const continuation = variants[el.name];
      return continuation ? continuation(el, ...tail) : [];
    };
  };
  var handleAttrPresenceName = function(node) {
    const attrName = node.name;
    const continuation = handleArray(node.cont);
    return (el, ...tail) => Object.prototype.hasOwnProperty.call(el.attribs, attrName) ? continuation(el, ...tail) : [];
  };
  var handleAttrValueName = function(node) {
    const callbacks = [];
    for (const matcher of node.matchers) {
      const predicate = matcher.predicate;
      const continuation = handleArray(matcher.cont);
      callbacks.push((attr, el, ...tail) => predicate(attr) ? continuation(el, ...tail) : []);
    }
    const attrName = node.name;
    return (el, ...tail) => {
      const attr = el.attribs[attrName];
      return attr || attr === "" ? callbacks.flatMap((cb) => cb(attr, el, ...tail)) : [];
    };
  };
  var handlePushElementNode = function(node) {
    const continuation = handleArray(node.cont);
    const leftElementGetter = node.combinator === "+" ? getPrecedingElement : getParentElement;
    return (el, ...tail) => {
      const next = leftElementGetter(el);
      if (next === null) {
        return [];
      }
      return continuation(next, el, ...tail);
    };
  };
  var handlePopElementNode = function(node) {
    const continuation = handleArray(node.cont);
    return (el, next, ...tail) => continuation(next, ...tail);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var domhandler = require_lib2();
  var selderee = require_selderee();
  var getPrecedingElement = (el) => {
    const prev = el.prev;
    if (prev === null) {
      return null;
    }
    return domhandler.isTag(prev) ? prev : getPrecedingElement(prev);
  };
  var getParentElement = (el) => {
    const parent = el.parent;
    return parent && domhandler.isTag(parent) ? parent : null;
  };
  exports.hp2Builder = hp2Builder;
});

// node_modules/entities/lib/generated/decode-data-html.js
var require_decode_data_html = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = new Uint16Array('\u1D41<\xD5\u0131\u028A\u049D\u057B\u05D0\u0675\u06DE\u07A2\u07D6\u080F\u0A4A\u0A91\u0DA1\u0E6D\u0F09\u0F26\u10CA\u1228\u12E1\u1415\u149D\u14C3\u14DF\u1525\0\0\0\0\0\0\u156B\u16CD\u198D\u1C12\u1DDD\u1F7E\u2060\u21B0\u228D\u23C0\u23FB\u2442\u2824\u2912\u2D08\u2E48\u2FCE\u3016\u32BA\u3639\u37AC\u38FE\u3A28\u3A71\u3AE0\u3B2E\u0800EMabcfglmnoprstu\\bfms\x7F\x84\x8B\x90\x95\x98\xA6\xB3\xB9\xC8\xCFlig\u803B\xC6\u40C6P\u803B&\u4026cute\u803B\xC1\u40C1reve;\u4102\u0100iyx}rc\u803B\xC2\u40C2;\u4410r;\uC000\uD835\uDD04rave\u803B\xC0\u40C0pha;\u4391acr;\u4100d;\u6A53\u0100gp\x9D\xA1on;\u4104f;\uC000\uD835\uDD38plyFunction;\u6061ing\u803B\xC5\u40C5\u0100cs\xBE\xC3r;\uC000\uD835\uDC9Cign;\u6254ilde\u803B\xC3\u40C3ml\u803B\xC4\u40C4\u0400aceforsu\xE5\xFB\xFE\u0117\u011C\u0122\u0127\u012A\u0100cr\xEA\xF2kslash;\u6216\u0176\xF6\xF8;\u6AE7ed;\u6306y;\u4411\u0180crt\u0105\u010B\u0114ause;\u6235noullis;\u612Ca;\u4392r;\uC000\uD835\uDD05pf;\uC000\uD835\uDD39eve;\u42D8c\xF2\u0113mpeq;\u624E\u0700HOacdefhilorsu\u014D\u0151\u0156\u0180\u019E\u01A2\u01B5\u01B7\u01BA\u01DC\u0215\u0273\u0278\u027Ecy;\u4427PY\u803B\xA9\u40A9\u0180cpy\u015D\u0162\u017Aute;\u4106\u0100;i\u0167\u0168\u62D2talDifferentialD;\u6145leys;\u612D\u0200aeio\u0189\u018E\u0194\u0198ron;\u410Cdil\u803B\xC7\u40C7rc;\u4108nint;\u6230ot;\u410A\u0100dn\u01A7\u01ADilla;\u40B8terDot;\u40B7\xF2\u017Fi;\u43A7rcle\u0200DMPT\u01C7\u01CB\u01D1\u01D6ot;\u6299inus;\u6296lus;\u6295imes;\u6297o\u0100cs\u01E2\u01F8kwiseContourIntegral;\u6232eCurly\u0100DQ\u0203\u020FoubleQuote;\u601Duote;\u6019\u0200lnpu\u021E\u0228\u0247\u0255on\u0100;e\u0225\u0226\u6237;\u6A74\u0180git\u022F\u0236\u023Aruent;\u6261nt;\u622FourIntegral;\u622E\u0100fr\u024C\u024E;\u6102oduct;\u6210nterClockwiseContourIntegral;\u6233oss;\u6A2Fcr;\uC000\uD835\uDC9Ep\u0100;C\u0284\u0285\u62D3ap;\u624D\u0580DJSZacefios\u02A0\u02AC\u02B0\u02B4\u02B8\u02CB\u02D7\u02E1\u02E6\u0333\u048D\u0100;o\u0179\u02A5trahd;\u6911cy;\u4402cy;\u4405cy;\u440F\u0180grs\u02BF\u02C4\u02C7ger;\u6021r;\u61A1hv;\u6AE4\u0100ay\u02D0\u02D5ron;\u410E;\u4414l\u0100;t\u02DD\u02DE\u6207a;\u4394r;\uC000\uD835\uDD07\u0100af\u02EB\u0327\u0100cm\u02F0\u0322ritical\u0200ADGT\u0300\u0306\u0316\u031Ccute;\u40B4o\u0174\u030B\u030D;\u42D9bleAcute;\u42DDrave;\u4060ilde;\u42DCond;\u62C4ferentialD;\u6146\u0470\u033D\0\0\0\u0342\u0354\0\u0405f;\uC000\uD835\uDD3B\u0180;DE\u0348\u0349\u034D\u40A8ot;\u60DCqual;\u6250ble\u0300CDLRUV\u0363\u0372\u0382\u03CF\u03E2\u03F8ontourIntegra\xEC\u0239o\u0274\u0379\0\0\u037B\xBB\u0349nArrow;\u61D3\u0100eo\u0387\u03A4ft\u0180ART\u0390\u0396\u03A1rrow;\u61D0ightArrow;\u61D4e\xE5\u02CAng\u0100LR\u03AB\u03C4eft\u0100AR\u03B3\u03B9rrow;\u67F8ightArrow;\u67FAightArrow;\u67F9ight\u0100AT\u03D8\u03DErrow;\u61D2ee;\u62A8p\u0241\u03E9\0\0\u03EFrrow;\u61D1ownArrow;\u61D5erticalBar;\u6225n\u0300ABLRTa\u0412\u042A\u0430\u045E\u047F\u037Crrow\u0180;BU\u041D\u041E\u0422\u6193ar;\u6913pArrow;\u61F5reve;\u4311eft\u02D2\u043A\0\u0446\0\u0450ightVector;\u6950eeVector;\u695Eector\u0100;B\u0459\u045A\u61BDar;\u6956ight\u01D4\u0467\0\u0471eeVector;\u695Fector\u0100;B\u047A\u047B\u61C1ar;\u6957ee\u0100;A\u0486\u0487\u62A4rrow;\u61A7\u0100ct\u0492\u0497r;\uC000\uD835\uDC9Frok;\u4110\u0800NTacdfglmopqstux\u04BD\u04C0\u04C4\u04CB\u04DE\u04E2\u04E7\u04EE\u04F5\u0521\u052F\u0536\u0552\u055D\u0560\u0565G;\u414AH\u803B\xD0\u40D0cute\u803B\xC9\u40C9\u0180aiy\u04D2\u04D7\u04DCron;\u411Arc\u803B\xCA\u40CA;\u442Dot;\u4116r;\uC000\uD835\uDD08rave\u803B\xC8\u40C8ement;\u6208\u0100ap\u04FA\u04FEcr;\u4112ty\u0253\u0506\0\0\u0512mallSquare;\u65FBerySmallSquare;\u65AB\u0100gp\u0526\u052Aon;\u4118f;\uC000\uD835\uDD3Csilon;\u4395u\u0100ai\u053C\u0549l\u0100;T\u0542\u0543\u6A75ilde;\u6242librium;\u61CC\u0100ci\u0557\u055Ar;\u6130m;\u6A73a;\u4397ml\u803B\xCB\u40CB\u0100ip\u056A\u056Fsts;\u6203onentialE;\u6147\u0280cfios\u0585\u0588\u058D\u05B2\u05CCy;\u4424r;\uC000\uD835\uDD09lled\u0253\u0597\0\0\u05A3mallSquare;\u65FCerySmallSquare;\u65AA\u0370\u05BA\0\u05BF\0\0\u05C4f;\uC000\uD835\uDD3DAll;\u6200riertrf;\u6131c\xF2\u05CB\u0600JTabcdfgorst\u05E8\u05EC\u05EF\u05FA\u0600\u0612\u0616\u061B\u061D\u0623\u066C\u0672cy;\u4403\u803B>\u403Emma\u0100;d\u05F7\u05F8\u4393;\u43DCreve;\u411E\u0180eiy\u0607\u060C\u0610dil;\u4122rc;\u411C;\u4413ot;\u4120r;\uC000\uD835\uDD0A;\u62D9pf;\uC000\uD835\uDD3Eeater\u0300EFGLST\u0635\u0644\u064E\u0656\u065B\u0666qual\u0100;L\u063E\u063F\u6265ess;\u62DBullEqual;\u6267reater;\u6AA2ess;\u6277lantEqual;\u6A7Eilde;\u6273cr;\uC000\uD835\uDCA2;\u626B\u0400Aacfiosu\u0685\u068B\u0696\u069B\u069E\u06AA\u06BE\u06CARDcy;\u442A\u0100ct\u0690\u0694ek;\u42C7;\u405Eirc;\u4124r;\u610ClbertSpace;\u610B\u01F0\u06AF\0\u06B2f;\u610DizontalLine;\u6500\u0100ct\u06C3\u06C5\xF2\u06A9rok;\u4126mp\u0144\u06D0\u06D8ownHum\xF0\u012Fqual;\u624F\u0700EJOacdfgmnostu\u06FA\u06FE\u0703\u0707\u070E\u071A\u071E\u0721\u0728\u0744\u0778\u078B\u078F\u0795cy;\u4415lig;\u4132cy;\u4401cute\u803B\xCD\u40CD\u0100iy\u0713\u0718rc\u803B\xCE\u40CE;\u4418ot;\u4130r;\u6111rave\u803B\xCC\u40CC\u0180;ap\u0720\u072F\u073F\u0100cg\u0734\u0737r;\u412AinaryI;\u6148lie\xF3\u03DD\u01F4\u0749\0\u0762\u0100;e\u074D\u074E\u622C\u0100gr\u0753\u0758ral;\u622Bsection;\u62C2isible\u0100CT\u076C\u0772omma;\u6063imes;\u6062\u0180gpt\u077F\u0783\u0788on;\u412Ef;\uC000\uD835\uDD40a;\u4399cr;\u6110ilde;\u4128\u01EB\u079A\0\u079Ecy;\u4406l\u803B\xCF\u40CF\u0280cfosu\u07AC\u07B7\u07BC\u07C2\u07D0\u0100iy\u07B1\u07B5rc;\u4134;\u4419r;\uC000\uD835\uDD0Dpf;\uC000\uD835\uDD41\u01E3\u07C7\0\u07CCr;\uC000\uD835\uDCA5rcy;\u4408kcy;\u4404\u0380HJacfos\u07E4\u07E8\u07EC\u07F1\u07FD\u0802\u0808cy;\u4425cy;\u440Cppa;\u439A\u0100ey\u07F6\u07FBdil;\u4136;\u441Ar;\uC000\uD835\uDD0Epf;\uC000\uD835\uDD42cr;\uC000\uD835\uDCA6\u0580JTaceflmost\u0825\u0829\u082C\u0850\u0863\u09B3\u09B8\u09C7\u09CD\u0A37\u0A47cy;\u4409\u803B<\u403C\u0280cmnpr\u0837\u083C\u0841\u0844\u084Dute;\u4139bda;\u439Bg;\u67EAlacetrf;\u6112r;\u619E\u0180aey\u0857\u085C\u0861ron;\u413Ddil;\u413B;\u441B\u0100fs\u0868\u0970t\u0500ACDFRTUVar\u087E\u08A9\u08B1\u08E0\u08E6\u08FC\u092F\u095B\u0390\u096A\u0100nr\u0883\u088FgleBracket;\u67E8row\u0180;BR\u0899\u089A\u089E\u6190ar;\u61E4ightArrow;\u61C6eiling;\u6308o\u01F5\u08B7\0\u08C3bleBracket;\u67E6n\u01D4\u08C8\0\u08D2eeVector;\u6961ector\u0100;B\u08DB\u08DC\u61C3ar;\u6959loor;\u630Aight\u0100AV\u08EF\u08F5rrow;\u6194ector;\u694E\u0100er\u0901\u0917e\u0180;AV\u0909\u090A\u0910\u62A3rrow;\u61A4ector;\u695Aiangle\u0180;BE\u0924\u0925\u0929\u62B2ar;\u69CFqual;\u62B4p\u0180DTV\u0937\u0942\u094CownVector;\u6951eeVector;\u6960ector\u0100;B\u0956\u0957\u61BFar;\u6958ector\u0100;B\u0965\u0966\u61BCar;\u6952ight\xE1\u039Cs\u0300EFGLST\u097E\u098B\u0995\u099D\u09A2\u09ADqualGreater;\u62DAullEqual;\u6266reater;\u6276ess;\u6AA1lantEqual;\u6A7Dilde;\u6272r;\uC000\uD835\uDD0F\u0100;e\u09BD\u09BE\u62D8ftarrow;\u61DAidot;\u413F\u0180npw\u09D4\u0A16\u0A1Bg\u0200LRlr\u09DE\u09F7\u0A02\u0A10eft\u0100AR\u09E6\u09ECrrow;\u67F5ightArrow;\u67F7ightArrow;\u67F6eft\u0100ar\u03B3\u0A0Aight\xE1\u03BFight\xE1\u03CAf;\uC000\uD835\uDD43er\u0100LR\u0A22\u0A2CeftArrow;\u6199ightArrow;\u6198\u0180cht\u0A3E\u0A40\u0A42\xF2\u084C;\u61B0rok;\u4141;\u626A\u0400acefiosu\u0A5A\u0A5D\u0A60\u0A77\u0A7C\u0A85\u0A8B\u0A8Ep;\u6905y;\u441C\u0100dl\u0A65\u0A6FiumSpace;\u605Flintrf;\u6133r;\uC000\uD835\uDD10nusPlus;\u6213pf;\uC000\uD835\uDD44c\xF2\u0A76;\u439C\u0480Jacefostu\u0AA3\u0AA7\u0AAD\u0AC0\u0B14\u0B19\u0D91\u0D97\u0D9Ecy;\u440Acute;\u4143\u0180aey\u0AB4\u0AB9\u0ABEron;\u4147dil;\u4145;\u441D\u0180gsw\u0AC7\u0AF0\u0B0Eative\u0180MTV\u0AD3\u0ADF\u0AE8ediumSpace;\u600Bhi\u0100cn\u0AE6\u0AD8\xEB\u0AD9eryThi\xEE\u0AD9ted\u0100GL\u0AF8\u0B06reaterGreate\xF2\u0673essLes\xF3\u0A48Line;\u400Ar;\uC000\uD835\uDD11\u0200Bnpt\u0B22\u0B28\u0B37\u0B3Areak;\u6060BreakingSpace;\u40A0f;\u6115\u0680;CDEGHLNPRSTV\u0B55\u0B56\u0B6A\u0B7C\u0BA1\u0BEB\u0C04\u0C5E\u0C84\u0CA6\u0CD8\u0D61\u0D85\u6AEC\u0100ou\u0B5B\u0B64ngruent;\u6262pCap;\u626DoubleVerticalBar;\u6226\u0180lqx\u0B83\u0B8A\u0B9Bement;\u6209ual\u0100;T\u0B92\u0B93\u6260ilde;\uC000\u2242\u0338ists;\u6204reater\u0380;EFGLST\u0BB6\u0BB7\u0BBD\u0BC9\u0BD3\u0BD8\u0BE5\u626Fqual;\u6271ullEqual;\uC000\u2267\u0338reater;\uC000\u226B\u0338ess;\u6279lantEqual;\uC000\u2A7E\u0338ilde;\u6275ump\u0144\u0BF2\u0BFDownHump;\uC000\u224E\u0338qual;\uC000\u224F\u0338e\u0100fs\u0C0A\u0C27tTriangle\u0180;BE\u0C1A\u0C1B\u0C21\u62EAar;\uC000\u29CF\u0338qual;\u62ECs\u0300;EGLST\u0C35\u0C36\u0C3C\u0C44\u0C4B\u0C58\u626Equal;\u6270reater;\u6278ess;\uC000\u226A\u0338lantEqual;\uC000\u2A7D\u0338ilde;\u6274ested\u0100GL\u0C68\u0C79reaterGreater;\uC000\u2AA2\u0338essLess;\uC000\u2AA1\u0338recedes\u0180;ES\u0C92\u0C93\u0C9B\u6280qual;\uC000\u2AAF\u0338lantEqual;\u62E0\u0100ei\u0CAB\u0CB9verseElement;\u620CghtTriangle\u0180;BE\u0CCB\u0CCC\u0CD2\u62EBar;\uC000\u29D0\u0338qual;\u62ED\u0100qu\u0CDD\u0D0CuareSu\u0100bp\u0CE8\u0CF9set\u0100;E\u0CF0\u0CF3\uC000\u228F\u0338qual;\u62E2erset\u0100;E\u0D03\u0D06\uC000\u2290\u0338qual;\u62E3\u0180bcp\u0D13\u0D24\u0D4Eset\u0100;E\u0D1B\u0D1E\uC000\u2282\u20D2qual;\u6288ceeds\u0200;EST\u0D32\u0D33\u0D3B\u0D46\u6281qual;\uC000\u2AB0\u0338lantEqual;\u62E1ilde;\uC000\u227F\u0338erset\u0100;E\u0D58\u0D5B\uC000\u2283\u20D2qual;\u6289ilde\u0200;EFT\u0D6E\u0D6F\u0D75\u0D7F\u6241qual;\u6244ullEqual;\u6247ilde;\u6249erticalBar;\u6224cr;\uC000\uD835\uDCA9ilde\u803B\xD1\u40D1;\u439D\u0700Eacdfgmoprstuv\u0DBD\u0DC2\u0DC9\u0DD5\u0DDB\u0DE0\u0DE7\u0DFC\u0E02\u0E20\u0E22\u0E32\u0E3F\u0E44lig;\u4152cute\u803B\xD3\u40D3\u0100iy\u0DCE\u0DD3rc\u803B\xD4\u40D4;\u441Eblac;\u4150r;\uC000\uD835\uDD12rave\u803B\xD2\u40D2\u0180aei\u0DEE\u0DF2\u0DF6cr;\u414Cga;\u43A9cron;\u439Fpf;\uC000\uD835\uDD46enCurly\u0100DQ\u0E0E\u0E1AoubleQuote;\u601Cuote;\u6018;\u6A54\u0100cl\u0E27\u0E2Cr;\uC000\uD835\uDCAAash\u803B\xD8\u40D8i\u016C\u0E37\u0E3Cde\u803B\xD5\u40D5es;\u6A37ml\u803B\xD6\u40D6er\u0100BP\u0E4B\u0E60\u0100ar\u0E50\u0E53r;\u603Eac\u0100ek\u0E5A\u0E5C;\u63DEet;\u63B4arenthesis;\u63DC\u0480acfhilors\u0E7F\u0E87\u0E8A\u0E8F\u0E92\u0E94\u0E9D\u0EB0\u0EFCrtialD;\u6202y;\u441Fr;\uC000\uD835\uDD13i;\u43A6;\u43A0usMinus;\u40B1\u0100ip\u0EA2\u0EADncareplan\xE5\u069Df;\u6119\u0200;eio\u0EB9\u0EBA\u0EE0\u0EE4\u6ABBcedes\u0200;EST\u0EC8\u0EC9\u0ECF\u0EDA\u627Aqual;\u6AAFlantEqual;\u627Cilde;\u627Eme;\u6033\u0100dp\u0EE9\u0EEEuct;\u620Fortion\u0100;a\u0225\u0EF9l;\u621D\u0100ci\u0F01\u0F06r;\uC000\uD835\uDCAB;\u43A8\u0200Ufos\u0F11\u0F16\u0F1B\u0F1FOT\u803B"\u4022r;\uC000\uD835\uDD14pf;\u611Acr;\uC000\uD835\uDCAC\u0600BEacefhiorsu\u0F3E\u0F43\u0F47\u0F60\u0F73\u0FA7\u0FAA\u0FAD\u1096\u10A9\u10B4\u10BEarr;\u6910G\u803B\xAE\u40AE\u0180cnr\u0F4E\u0F53\u0F56ute;\u4154g;\u67EBr\u0100;t\u0F5C\u0F5D\u61A0l;\u6916\u0180aey\u0F67\u0F6C\u0F71ron;\u4158dil;\u4156;\u4420\u0100;v\u0F78\u0F79\u611Cerse\u0100EU\u0F82\u0F99\u0100lq\u0F87\u0F8Eement;\u620Builibrium;\u61CBpEquilibrium;\u696Fr\xBB\u0F79o;\u43A1ght\u0400ACDFTUVa\u0FC1\u0FEB\u0FF3\u1022\u1028\u105B\u1087\u03D8\u0100nr\u0FC6\u0FD2gleBracket;\u67E9row\u0180;BL\u0FDC\u0FDD\u0FE1\u6192ar;\u61E5eftArrow;\u61C4eiling;\u6309o\u01F5\u0FF9\0\u1005bleBracket;\u67E7n\u01D4\u100A\0\u1014eeVector;\u695Dector\u0100;B\u101D\u101E\u61C2ar;\u6955loor;\u630B\u0100er\u102D\u1043e\u0180;AV\u1035\u1036\u103C\u62A2rrow;\u61A6ector;\u695Biangle\u0180;BE\u1050\u1051\u1055\u62B3ar;\u69D0qual;\u62B5p\u0180DTV\u1063\u106E\u1078ownVector;\u694FeeVector;\u695Cector\u0100;B\u1082\u1083\u61BEar;\u6954ector\u0100;B\u1091\u1092\u61C0ar;\u6953\u0100pu\u109B\u109Ef;\u611DndImplies;\u6970ightarrow;\u61DB\u0100ch\u10B9\u10BCr;\u611B;\u61B1leDelayed;\u69F4\u0680HOacfhimoqstu\u10E4\u10F1\u10F7\u10FD\u1119\u111E\u1151\u1156\u1161\u1167\u11B5\u11BB\u11BF\u0100Cc\u10E9\u10EEHcy;\u4429y;\u4428FTcy;\u442Ccute;\u415A\u0280;aeiy\u1108\u1109\u110E\u1113\u1117\u6ABCron;\u4160dil;\u415Erc;\u415C;\u4421r;\uC000\uD835\uDD16ort\u0200DLRU\u112A\u1134\u113E\u1149ownArrow\xBB\u041EeftArrow\xBB\u089AightArrow\xBB\u0FDDpArrow;\u6191gma;\u43A3allCircle;\u6218pf;\uC000\uD835\uDD4A\u0272\u116D\0\0\u1170t;\u621Aare\u0200;ISU\u117B\u117C\u1189\u11AF\u65A1ntersection;\u6293u\u0100bp\u118F\u119Eset\u0100;E\u1197\u1198\u628Fqual;\u6291erset\u0100;E\u11A8\u11A9\u6290qual;\u6292nion;\u6294cr;\uC000\uD835\uDCAEar;\u62C6\u0200bcmp\u11C8\u11DB\u1209\u120B\u0100;s\u11CD\u11CE\u62D0et\u0100;E\u11CD\u11D5qual;\u6286\u0100ch\u11E0\u1205eeds\u0200;EST\u11ED\u11EE\u11F4\u11FF\u627Bqual;\u6AB0lantEqual;\u627Dilde;\u627FTh\xE1\u0F8C;\u6211\u0180;es\u1212\u1213\u1223\u62D1rset\u0100;E\u121C\u121D\u6283qual;\u6287et\xBB\u1213\u0580HRSacfhiors\u123E\u1244\u1249\u1255\u125E\u1271\u1276\u129F\u12C2\u12C8\u12D1ORN\u803B\xDE\u40DEADE;\u6122\u0100Hc\u124E\u1252cy;\u440By;\u4426\u0100bu\u125A\u125C;\u4009;\u43A4\u0180aey\u1265\u126A\u126Fron;\u4164dil;\u4162;\u4422r;\uC000\uD835\uDD17\u0100ei\u127B\u1289\u01F2\u1280\0\u1287efore;\u6234a;\u4398\u0100cn\u128E\u1298kSpace;\uC000\u205F\u200ASpace;\u6009lde\u0200;EFT\u12AB\u12AC\u12B2\u12BC\u623Cqual;\u6243ullEqual;\u6245ilde;\u6248pf;\uC000\uD835\uDD4BipleDot;\u60DB\u0100ct\u12D6\u12DBr;\uC000\uD835\uDCAFrok;\u4166\u0AE1\u12F7\u130E\u131A\u1326\0\u132C\u1331\0\0\0\0\0\u1338\u133D\u1377\u1385\0\u13FF\u1404\u140A\u1410\u0100cr\u12FB\u1301ute\u803B\xDA\u40DAr\u0100;o\u1307\u1308\u619Fcir;\u6949r\u01E3\u1313\0\u1316y;\u440Eve;\u416C\u0100iy\u131E\u1323rc\u803B\xDB\u40DB;\u4423blac;\u4170r;\uC000\uD835\uDD18rave\u803B\xD9\u40D9acr;\u416A\u0100di\u1341\u1369er\u0100BP\u1348\u135D\u0100ar\u134D\u1350r;\u405Fac\u0100ek\u1357\u1359;\u63DFet;\u63B5arenthesis;\u63DDon\u0100;P\u1370\u1371\u62C3lus;\u628E\u0100gp\u137B\u137Fon;\u4172f;\uC000\uD835\uDD4C\u0400ADETadps\u1395\u13AE\u13B8\u13C4\u03E8\u13D2\u13D7\u13F3rrow\u0180;BD\u1150\u13A0\u13A4ar;\u6912ownArrow;\u61C5ownArrow;\u6195quilibrium;\u696Eee\u0100;A\u13CB\u13CC\u62A5rrow;\u61A5own\xE1\u03F3er\u0100LR\u13DE\u13E8eftArrow;\u6196ightArrow;\u6197i\u0100;l\u13F9\u13FA\u43D2on;\u43A5ing;\u416Ecr;\uC000\uD835\uDCB0ilde;\u4168ml\u803B\xDC\u40DC\u0480Dbcdefosv\u1427\u142C\u1430\u1433\u143E\u1485\u148A\u1490\u1496ash;\u62ABar;\u6AEBy;\u4412ash\u0100;l\u143B\u143C\u62A9;\u6AE6\u0100er\u1443\u1445;\u62C1\u0180bty\u144C\u1450\u147Aar;\u6016\u0100;i\u144F\u1455cal\u0200BLST\u1461\u1465\u146A\u1474ar;\u6223ine;\u407Ceparator;\u6758ilde;\u6240ThinSpace;\u600Ar;\uC000\uD835\uDD19pf;\uC000\uD835\uDD4Dcr;\uC000\uD835\uDCB1dash;\u62AA\u0280cefos\u14A7\u14AC\u14B1\u14B6\u14BCirc;\u4174dge;\u62C0r;\uC000\uD835\uDD1Apf;\uC000\uD835\uDD4Ecr;\uC000\uD835\uDCB2\u0200fios\u14CB\u14D0\u14D2\u14D8r;\uC000\uD835\uDD1B;\u439Epf;\uC000\uD835\uDD4Fcr;\uC000\uD835\uDCB3\u0480AIUacfosu\u14F1\u14F5\u14F9\u14FD\u1504\u150F\u1514\u151A\u1520cy;\u442Fcy;\u4407cy;\u442Ecute\u803B\xDD\u40DD\u0100iy\u1509\u150Drc;\u4176;\u442Br;\uC000\uD835\uDD1Cpf;\uC000\uD835\uDD50cr;\uC000\uD835\uDCB4ml;\u4178\u0400Hacdefos\u1535\u1539\u153F\u154B\u154F\u155D\u1560\u1564cy;\u4416cute;\u4179\u0100ay\u1544\u1549ron;\u417D;\u4417ot;\u417B\u01F2\u1554\0\u155BoWidt\xE8\u0AD9a;\u4396r;\u6128pf;\u6124cr;\uC000\uD835\uDCB5\u0BE1\u1583\u158A\u1590\0\u15B0\u15B6\u15BF\0\0\0\0\u15C6\u15DB\u15EB\u165F\u166D\0\u1695\u169B\u16B2\u16B9\0\u16BEcute\u803B\xE1\u40E1reve;\u4103\u0300;Ediuy\u159C\u159D\u15A1\u15A3\u15A8\u15AD\u623E;\uC000\u223E\u0333;\u623Frc\u803B\xE2\u40E2te\u80BB\xB4\u0306;\u4430lig\u803B\xE6\u40E6\u0100;r\xB2\u15BA;\uC000\uD835\uDD1Erave\u803B\xE0\u40E0\u0100ep\u15CA\u15D6\u0100fp\u15CF\u15D4sym;\u6135\xE8\u15D3ha;\u43B1\u0100ap\u15DFc\u0100cl\u15E4\u15E7r;\u4101g;\u6A3F\u0264\u15F0\0\0\u160A\u0280;adsv\u15FA\u15FB\u15FF\u1601\u1607\u6227nd;\u6A55;\u6A5Clope;\u6A58;\u6A5A\u0380;elmrsz\u1618\u1619\u161B\u161E\u163F\u164F\u1659\u6220;\u69A4e\xBB\u1619sd\u0100;a\u1625\u1626\u6221\u0461\u1630\u1632\u1634\u1636\u1638\u163A\u163C\u163E;\u69A8;\u69A9;\u69AA;\u69AB;\u69AC;\u69AD;\u69AE;\u69AFt\u0100;v\u1645\u1646\u621Fb\u0100;d\u164C\u164D\u62BE;\u699D\u0100pt\u1654\u1657h;\u6222\xBB\xB9arr;\u637C\u0100gp\u1663\u1667on;\u4105f;\uC000\uD835\uDD52\u0380;Eaeiop\u12C1\u167B\u167D\u1682\u1684\u1687\u168A;\u6A70cir;\u6A6F;\u624Ad;\u624Bs;\u4027rox\u0100;e\u12C1\u1692\xF1\u1683ing\u803B\xE5\u40E5\u0180cty\u16A1\u16A6\u16A8r;\uC000\uD835\uDCB6;\u402Amp\u0100;e\u12C1\u16AF\xF1\u0288ilde\u803B\xE3\u40E3ml\u803B\xE4\u40E4\u0100ci\u16C2\u16C8onin\xF4\u0272nt;\u6A11\u0800Nabcdefiklnoprsu\u16ED\u16F1\u1730\u173C\u1743\u1748\u1778\u177D\u17E0\u17E6\u1839\u1850\u170D\u193D\u1948\u1970ot;\u6AED\u0100cr\u16F6\u171Ek\u0200ceps\u1700\u1705\u170D\u1713ong;\u624Cpsilon;\u43F6rime;\u6035im\u0100;e\u171A\u171B\u623Dq;\u62CD\u0176\u1722\u1726ee;\u62BDed\u0100;g\u172C\u172D\u6305e\xBB\u172Drk\u0100;t\u135C\u1737brk;\u63B6\u0100oy\u1701\u1741;\u4431quo;\u601E\u0280cmprt\u1753\u175B\u1761\u1764\u1768aus\u0100;e\u010A\u0109ptyv;\u69B0s\xE9\u170Cno\xF5\u0113\u0180ahw\u176F\u1771\u1773;\u43B2;\u6136een;\u626Cr;\uC000\uD835\uDD1Fg\u0380costuvw\u178D\u179D\u17B3\u17C1\u17D5\u17DB\u17DE\u0180aiu\u1794\u1796\u179A\xF0\u0760rc;\u65EFp\xBB\u1371\u0180dpt\u17A4\u17A8\u17ADot;\u6A00lus;\u6A01imes;\u6A02\u0271\u17B9\0\0\u17BEcup;\u6A06ar;\u6605riangle\u0100du\u17CD\u17D2own;\u65BDp;\u65B3plus;\u6A04e\xE5\u1444\xE5\u14ADarow;\u690D\u0180ako\u17ED\u1826\u1835\u0100cn\u17F2\u1823k\u0180lst\u17FA\u05AB\u1802ozenge;\u69EBriangle\u0200;dlr\u1812\u1813\u1818\u181D\u65B4own;\u65BEeft;\u65C2ight;\u65B8k;\u6423\u01B1\u182B\0\u1833\u01B2\u182F\0\u1831;\u6592;\u65914;\u6593ck;\u6588\u0100eo\u183E\u184D\u0100;q\u1843\u1846\uC000=\u20E5uiv;\uC000\u2261\u20E5t;\u6310\u0200ptwx\u1859\u185E\u1867\u186Cf;\uC000\uD835\uDD53\u0100;t\u13CB\u1863om\xBB\u13CCtie;\u62C8\u0600DHUVbdhmptuv\u1885\u1896\u18AA\u18BB\u18D7\u18DB\u18EC\u18FF\u1905\u190A\u1910\u1921\u0200LRlr\u188E\u1890\u1892\u1894;\u6557;\u6554;\u6556;\u6553\u0280;DUdu\u18A1\u18A2\u18A4\u18A6\u18A8\u6550;\u6566;\u6569;\u6564;\u6567\u0200LRlr\u18B3\u18B5\u18B7\u18B9;\u655D;\u655A;\u655C;\u6559\u0380;HLRhlr\u18CA\u18CB\u18CD\u18CF\u18D1\u18D3\u18D5\u6551;\u656C;\u6563;\u6560;\u656B;\u6562;\u655Fox;\u69C9\u0200LRlr\u18E4\u18E6\u18E8\u18EA;\u6555;\u6552;\u6510;\u650C\u0280;DUdu\u06BD\u18F7\u18F9\u18FB\u18FD;\u6565;\u6568;\u652C;\u6534inus;\u629Flus;\u629Eimes;\u62A0\u0200LRlr\u1919\u191B\u191D\u191F;\u655B;\u6558;\u6518;\u6514\u0380;HLRhlr\u1930\u1931\u1933\u1935\u1937\u1939\u193B\u6502;\u656A;\u6561;\u655E;\u653C;\u6524;\u651C\u0100ev\u0123\u1942bar\u803B\xA6\u40A6\u0200ceio\u1951\u1956\u195A\u1960r;\uC000\uD835\uDCB7mi;\u604Fm\u0100;e\u171A\u171Cl\u0180;bh\u1968\u1969\u196B\u405C;\u69C5sub;\u67C8\u016C\u1974\u197El\u0100;e\u1979\u197A\u6022t\xBB\u197Ap\u0180;Ee\u012F\u1985\u1987;\u6AAE\u0100;q\u06DC\u06DB\u0CE1\u19A7\0\u19E8\u1A11\u1A15\u1A32\0\u1A37\u1A50\0\0\u1AB4\0\0\u1AC1\0\0\u1B21\u1B2E\u1B4D\u1B52\0\u1BFD\0\u1C0C\u0180cpr\u19AD\u19B2\u19DDute;\u4107\u0300;abcds\u19BF\u19C0\u19C4\u19CA\u19D5\u19D9\u6229nd;\u6A44rcup;\u6A49\u0100au\u19CF\u19D2p;\u6A4Bp;\u6A47ot;\u6A40;\uC000\u2229\uFE00\u0100eo\u19E2\u19E5t;\u6041\xEE\u0693\u0200aeiu\u19F0\u19FB\u1A01\u1A05\u01F0\u19F5\0\u19F8s;\u6A4Don;\u410Ddil\u803B\xE7\u40E7rc;\u4109ps\u0100;s\u1A0C\u1A0D\u6A4Cm;\u6A50ot;\u410B\u0180dmn\u1A1B\u1A20\u1A26il\u80BB\xB8\u01ADptyv;\u69B2t\u8100\xA2;e\u1A2D\u1A2E\u40A2r\xE4\u01B2r;\uC000\uD835\uDD20\u0180cei\u1A3D\u1A40\u1A4Dy;\u4447ck\u0100;m\u1A47\u1A48\u6713ark\xBB\u1A48;\u43C7r\u0380;Ecefms\u1A5F\u1A60\u1A62\u1A6B\u1AA4\u1AAA\u1AAE\u65CB;\u69C3\u0180;el\u1A69\u1A6A\u1A6D\u42C6q;\u6257e\u0261\u1A74\0\0\u1A88rrow\u0100lr\u1A7C\u1A81eft;\u61BAight;\u61BB\u0280RSacd\u1A92\u1A94\u1A96\u1A9A\u1A9F\xBB\u0F47;\u64C8st;\u629Birc;\u629Aash;\u629Dnint;\u6A10id;\u6AEFcir;\u69C2ubs\u0100;u\u1ABB\u1ABC\u6663it\xBB\u1ABC\u02EC\u1AC7\u1AD4\u1AFA\0\u1B0Aon\u0100;e\u1ACD\u1ACE\u403A\u0100;q\xC7\xC6\u026D\u1AD9\0\0\u1AE2a\u0100;t\u1ADE\u1ADF\u402C;\u4040\u0180;fl\u1AE8\u1AE9\u1AEB\u6201\xEE\u1160e\u0100mx\u1AF1\u1AF6ent\xBB\u1AE9e\xF3\u024D\u01E7\u1AFE\0\u1B07\u0100;d\u12BB\u1B02ot;\u6A6Dn\xF4\u0246\u0180fry\u1B10\u1B14\u1B17;\uC000\uD835\uDD54o\xE4\u0254\u8100\xA9;s\u0155\u1B1Dr;\u6117\u0100ao\u1B25\u1B29rr;\u61B5ss;\u6717\u0100cu\u1B32\u1B37r;\uC000\uD835\uDCB8\u0100bp\u1B3C\u1B44\u0100;e\u1B41\u1B42\u6ACF;\u6AD1\u0100;e\u1B49\u1B4A\u6AD0;\u6AD2dot;\u62EF\u0380delprvw\u1B60\u1B6C\u1B77\u1B82\u1BAC\u1BD4\u1BF9arr\u0100lr\u1B68\u1B6A;\u6938;\u6935\u0270\u1B72\0\0\u1B75r;\u62DEc;\u62DFarr\u0100;p\u1B7F\u1B80\u61B6;\u693D\u0300;bcdos\u1B8F\u1B90\u1B96\u1BA1\u1BA5\u1BA8\u622Arcap;\u6A48\u0100au\u1B9B\u1B9Ep;\u6A46p;\u6A4Aot;\u628Dr;\u6A45;\uC000\u222A\uFE00\u0200alrv\u1BB5\u1BBF\u1BDE\u1BE3rr\u0100;m\u1BBC\u1BBD\u61B7;\u693Cy\u0180evw\u1BC7\u1BD4\u1BD8q\u0270\u1BCE\0\0\u1BD2re\xE3\u1B73u\xE3\u1B75ee;\u62CEedge;\u62CFen\u803B\xA4\u40A4earrow\u0100lr\u1BEE\u1BF3eft\xBB\u1B80ight\xBB\u1BBDe\xE4\u1BDD\u0100ci\u1C01\u1C07onin\xF4\u01F7nt;\u6231lcty;\u632D\u0980AHabcdefhijlorstuwz\u1C38\u1C3B\u1C3F\u1C5D\u1C69\u1C75\u1C8A\u1C9E\u1CAC\u1CB7\u1CFB\u1CFF\u1D0D\u1D7B\u1D91\u1DAB\u1DBB\u1DC6\u1DCDr\xF2\u0381ar;\u6965\u0200glrs\u1C48\u1C4D\u1C52\u1C54ger;\u6020eth;\u6138\xF2\u1133h\u0100;v\u1C5A\u1C5B\u6010\xBB\u090A\u016B\u1C61\u1C67arow;\u690Fa\xE3\u0315\u0100ay\u1C6E\u1C73ron;\u410F;\u4434\u0180;ao\u0332\u1C7C\u1C84\u0100gr\u02BF\u1C81r;\u61CAtseq;\u6A77\u0180glm\u1C91\u1C94\u1C98\u803B\xB0\u40B0ta;\u43B4ptyv;\u69B1\u0100ir\u1CA3\u1CA8sht;\u697F;\uC000\uD835\uDD21ar\u0100lr\u1CB3\u1CB5\xBB\u08DC\xBB\u101E\u0280aegsv\u1CC2\u0378\u1CD6\u1CDC\u1CE0m\u0180;os\u0326\u1CCA\u1CD4nd\u0100;s\u0326\u1CD1uit;\u6666amma;\u43DDin;\u62F2\u0180;io\u1CE7\u1CE8\u1CF8\u40F7de\u8100\xF7;o\u1CE7\u1CF0ntimes;\u62C7n\xF8\u1CF7cy;\u4452c\u026F\u1D06\0\0\u1D0Arn;\u631Eop;\u630D\u0280lptuw\u1D18\u1D1D\u1D22\u1D49\u1D55lar;\u4024f;\uC000\uD835\uDD55\u0280;emps\u030B\u1D2D\u1D37\u1D3D\u1D42q\u0100;d\u0352\u1D33ot;\u6251inus;\u6238lus;\u6214quare;\u62A1blebarwedg\xE5\xFAn\u0180adh\u112E\u1D5D\u1D67ownarrow\xF3\u1C83arpoon\u0100lr\u1D72\u1D76ef\xF4\u1CB4igh\xF4\u1CB6\u0162\u1D7F\u1D85karo\xF7\u0F42\u026F\u1D8A\0\0\u1D8Ern;\u631Fop;\u630C\u0180cot\u1D98\u1DA3\u1DA6\u0100ry\u1D9D\u1DA1;\uC000\uD835\uDCB9;\u4455l;\u69F6rok;\u4111\u0100dr\u1DB0\u1DB4ot;\u62F1i\u0100;f\u1DBA\u1816\u65BF\u0100ah\u1DC0\u1DC3r\xF2\u0429a\xF2\u0FA6angle;\u69A6\u0100ci\u1DD2\u1DD5y;\u445Fgrarr;\u67FF\u0900Dacdefglmnopqrstux\u1E01\u1E09\u1E19\u1E38\u0578\u1E3C\u1E49\u1E61\u1E7E\u1EA5\u1EAF\u1EBD\u1EE1\u1F2A\u1F37\u1F44\u1F4E\u1F5A\u0100Do\u1E06\u1D34o\xF4\u1C89\u0100cs\u1E0E\u1E14ute\u803B\xE9\u40E9ter;\u6A6E\u0200aioy\u1E22\u1E27\u1E31\u1E36ron;\u411Br\u0100;c\u1E2D\u1E2E\u6256\u803B\xEA\u40EAlon;\u6255;\u444Dot;\u4117\u0100Dr\u1E41\u1E45ot;\u6252;\uC000\uD835\uDD22\u0180;rs\u1E50\u1E51\u1E57\u6A9Aave\u803B\xE8\u40E8\u0100;d\u1E5C\u1E5D\u6A96ot;\u6A98\u0200;ils\u1E6A\u1E6B\u1E72\u1E74\u6A99nters;\u63E7;\u6113\u0100;d\u1E79\u1E7A\u6A95ot;\u6A97\u0180aps\u1E85\u1E89\u1E97cr;\u4113ty\u0180;sv\u1E92\u1E93\u1E95\u6205et\xBB\u1E93p\u01001;\u1E9D\u1EA4\u0133\u1EA1\u1EA3;\u6004;\u6005\u6003\u0100gs\u1EAA\u1EAC;\u414Bp;\u6002\u0100gp\u1EB4\u1EB8on;\u4119f;\uC000\uD835\uDD56\u0180als\u1EC4\u1ECE\u1ED2r\u0100;s\u1ECA\u1ECB\u62D5l;\u69E3us;\u6A71i\u0180;lv\u1EDA\u1EDB\u1EDF\u43B5on\xBB\u1EDB;\u43F5\u0200csuv\u1EEA\u1EF3\u1F0B\u1F23\u0100io\u1EEF\u1E31rc\xBB\u1E2E\u0269\u1EF9\0\0\u1EFB\xED\u0548ant\u0100gl\u1F02\u1F06tr\xBB\u1E5Dess\xBB\u1E7A\u0180aei\u1F12\u1F16\u1F1Als;\u403Dst;\u625Fv\u0100;D\u0235\u1F20D;\u6A78parsl;\u69E5\u0100Da\u1F2F\u1F33ot;\u6253rr;\u6971\u0180cdi\u1F3E\u1F41\u1EF8r;\u612Fo\xF4\u0352\u0100ah\u1F49\u1F4B;\u43B7\u803B\xF0\u40F0\u0100mr\u1F53\u1F57l\u803B\xEB\u40EBo;\u60AC\u0180cip\u1F61\u1F64\u1F67l;\u4021s\xF4\u056E\u0100eo\u1F6C\u1F74ctatio\xEE\u0559nential\xE5\u0579\u09E1\u1F92\0\u1F9E\0\u1FA1\u1FA7\0\0\u1FC6\u1FCC\0\u1FD3\0\u1FE6\u1FEA\u2000\0\u2008\u205Allingdotse\xF1\u1E44y;\u4444male;\u6640\u0180ilr\u1FAD\u1FB3\u1FC1lig;\u8000\uFB03\u0269\u1FB9\0\0\u1FBDg;\u8000\uFB00ig;\u8000\uFB04;\uC000\uD835\uDD23lig;\u8000\uFB01lig;\uC000fj\u0180alt\u1FD9\u1FDC\u1FE1t;\u666Dig;\u8000\uFB02ns;\u65B1of;\u4192\u01F0\u1FEE\0\u1FF3f;\uC000\uD835\uDD57\u0100ak\u05BF\u1FF7\u0100;v\u1FFC\u1FFD\u62D4;\u6AD9artint;\u6A0D\u0100ao\u200C\u2055\u0100cs\u2011\u2052\u03B1\u201A\u2030\u2038\u2045\u2048\0\u2050\u03B2\u2022\u2025\u2027\u202A\u202C\0\u202E\u803B\xBD\u40BD;\u6153\u803B\xBC\u40BC;\u6155;\u6159;\u615B\u01B3\u2034\0\u2036;\u6154;\u6156\u02B4\u203E\u2041\0\0\u2043\u803B\xBE\u40BE;\u6157;\u615C5;\u6158\u01B6\u204C\0\u204E;\u615A;\u615D8;\u615El;\u6044wn;\u6322cr;\uC000\uD835\uDCBB\u0880Eabcdefgijlnorstv\u2082\u2089\u209F\u20A5\u20B0\u20B4\u20F0\u20F5\u20FA\u20FF\u2103\u2112\u2138\u0317\u213E\u2152\u219E\u0100;l\u064D\u2087;\u6A8C\u0180cmp\u2090\u2095\u209Dute;\u41F5ma\u0100;d\u209C\u1CDA\u43B3;\u6A86reve;\u411F\u0100iy\u20AA\u20AErc;\u411D;\u4433ot;\u4121\u0200;lqs\u063E\u0642\u20BD\u20C9\u0180;qs\u063E\u064C\u20C4lan\xF4\u0665\u0200;cdl\u0665\u20D2\u20D5\u20E5c;\u6AA9ot\u0100;o\u20DC\u20DD\u6A80\u0100;l\u20E2\u20E3\u6A82;\u6A84\u0100;e\u20EA\u20ED\uC000\u22DB\uFE00s;\u6A94r;\uC000\uD835\uDD24\u0100;g\u0673\u061Bmel;\u6137cy;\u4453\u0200;Eaj\u065A\u210C\u210E\u2110;\u6A92;\u6AA5;\u6AA4\u0200Eaes\u211B\u211D\u2129\u2134;\u6269p\u0100;p\u2123\u2124\u6A8Arox\xBB\u2124\u0100;q\u212E\u212F\u6A88\u0100;q\u212E\u211Bim;\u62E7pf;\uC000\uD835\uDD58\u0100ci\u2143\u2146r;\u610Am\u0180;el\u066B\u214E\u2150;\u6A8E;\u6A90\u8300>;cdlqr\u05EE\u2160\u216A\u216E\u2173\u2179\u0100ci\u2165\u2167;\u6AA7r;\u6A7Aot;\u62D7Par;\u6995uest;\u6A7C\u0280adels\u2184\u216A\u2190\u0656\u219B\u01F0\u2189\0\u218Epro\xF8\u209Er;\u6978q\u0100lq\u063F\u2196les\xF3\u2088i\xED\u066B\u0100en\u21A3\u21ADrtneqq;\uC000\u2269\uFE00\xC5\u21AA\u0500Aabcefkosy\u21C4\u21C7\u21F1\u21F5\u21FA\u2218\u221D\u222F\u2268\u227Dr\xF2\u03A0\u0200ilmr\u21D0\u21D4\u21D7\u21DBrs\xF0\u1484f\xBB\u2024il\xF4\u06A9\u0100dr\u21E0\u21E4cy;\u444A\u0180;cw\u08F4\u21EB\u21EFir;\u6948;\u61ADar;\u610Firc;\u4125\u0180alr\u2201\u220E\u2213rts\u0100;u\u2209\u220A\u6665it\xBB\u220Alip;\u6026con;\u62B9r;\uC000\uD835\uDD25s\u0100ew\u2223\u2229arow;\u6925arow;\u6926\u0280amopr\u223A\u223E\u2243\u225E\u2263rr;\u61FFtht;\u623Bk\u0100lr\u2249\u2253eftarrow;\u61A9ightarrow;\u61AAf;\uC000\uD835\uDD59bar;\u6015\u0180clt\u226F\u2274\u2278r;\uC000\uD835\uDCBDas\xE8\u21F4rok;\u4127\u0100bp\u2282\u2287ull;\u6043hen\xBB\u1C5B\u0AE1\u22A3\0\u22AA\0\u22B8\u22C5\u22CE\0\u22D5\u22F3\0\0\u22F8\u2322\u2367\u2362\u237F\0\u2386\u23AA\u23B4cute\u803B\xED\u40ED\u0180;iy\u0771\u22B0\u22B5rc\u803B\xEE\u40EE;\u4438\u0100cx\u22BC\u22BFy;\u4435cl\u803B\xA1\u40A1\u0100fr\u039F\u22C9;\uC000\uD835\uDD26rave\u803B\xEC\u40EC\u0200;ino\u073E\u22DD\u22E9\u22EE\u0100in\u22E2\u22E6nt;\u6A0Ct;\u622Dfin;\u69DCta;\u6129lig;\u4133\u0180aop\u22FE\u231A\u231D\u0180cgt\u2305\u2308\u2317r;\u412B\u0180elp\u071F\u230F\u2313in\xE5\u078Ear\xF4\u0720h;\u4131f;\u62B7ed;\u41B5\u0280;cfot\u04F4\u232C\u2331\u233D\u2341are;\u6105in\u0100;t\u2338\u2339\u621Eie;\u69DDdo\xF4\u2319\u0280;celp\u0757\u234C\u2350\u235B\u2361al;\u62BA\u0100gr\u2355\u2359er\xF3\u1563\xE3\u234Darhk;\u6A17rod;\u6A3C\u0200cgpt\u236F\u2372\u2376\u237By;\u4451on;\u412Ff;\uC000\uD835\uDD5Aa;\u43B9uest\u803B\xBF\u40BF\u0100ci\u238A\u238Fr;\uC000\uD835\uDCBEn\u0280;Edsv\u04F4\u239B\u239D\u23A1\u04F3;\u62F9ot;\u62F5\u0100;v\u23A6\u23A7\u62F4;\u62F3\u0100;i\u0777\u23AElde;\u4129\u01EB\u23B8\0\u23BCcy;\u4456l\u803B\xEF\u40EF\u0300cfmosu\u23CC\u23D7\u23DC\u23E1\u23E7\u23F5\u0100iy\u23D1\u23D5rc;\u4135;\u4439r;\uC000\uD835\uDD27ath;\u4237pf;\uC000\uD835\uDD5B\u01E3\u23EC\0\u23F1r;\uC000\uD835\uDCBFrcy;\u4458kcy;\u4454\u0400acfghjos\u240B\u2416\u2422\u2427\u242D\u2431\u2435\u243Bppa\u0100;v\u2413\u2414\u43BA;\u43F0\u0100ey\u241B\u2420dil;\u4137;\u443Ar;\uC000\uD835\uDD28reen;\u4138cy;\u4445cy;\u445Cpf;\uC000\uD835\uDD5Ccr;\uC000\uD835\uDCC0\u0B80ABEHabcdefghjlmnoprstuv\u2470\u2481\u2486\u248D\u2491\u250E\u253D\u255A\u2580\u264E\u265E\u2665\u2679\u267D\u269A\u26B2\u26D8\u275D\u2768\u278B\u27C0\u2801\u2812\u0180art\u2477\u247A\u247Cr\xF2\u09C6\xF2\u0395ail;\u691Barr;\u690E\u0100;g\u0994\u248B;\u6A8Bar;\u6962\u0963\u24A5\0\u24AA\0\u24B1\0\0\0\0\0\u24B5\u24BA\0\u24C6\u24C8\u24CD\0\u24F9ute;\u413Amptyv;\u69B4ra\xEE\u084Cbda;\u43BBg\u0180;dl\u088E\u24C1\u24C3;\u6991\xE5\u088E;\u6A85uo\u803B\xAB\u40ABr\u0400;bfhlpst\u0899\u24DE\u24E6\u24E9\u24EB\u24EE\u24F1\u24F5\u0100;f\u089D\u24E3s;\u691Fs;\u691D\xEB\u2252p;\u61ABl;\u6939im;\u6973l;\u61A2\u0180;ae\u24FF\u2500\u2504\u6AABil;\u6919\u0100;s\u2509\u250A\u6AAD;\uC000\u2AAD\uFE00\u0180abr\u2515\u2519\u251Drr;\u690Crk;\u6772\u0100ak\u2522\u252Cc\u0100ek\u2528\u252A;\u407B;\u405B\u0100es\u2531\u2533;\u698Bl\u0100du\u2539\u253B;\u698F;\u698D\u0200aeuy\u2546\u254B\u2556\u2558ron;\u413E\u0100di\u2550\u2554il;\u413C\xEC\u08B0\xE2\u2529;\u443B\u0200cqrs\u2563\u2566\u256D\u257Da;\u6936uo\u0100;r\u0E19\u1746\u0100du\u2572\u2577har;\u6967shar;\u694Bh;\u61B2\u0280;fgqs\u258B\u258C\u0989\u25F3\u25FF\u6264t\u0280ahlrt\u2598\u25A4\u25B7\u25C2\u25E8rrow\u0100;t\u0899\u25A1a\xE9\u24F6arpoon\u0100du\u25AF\u25B4own\xBB\u045Ap\xBB\u0966eftarrows;\u61C7ight\u0180ahs\u25CD\u25D6\u25DErrow\u0100;s\u08F4\u08A7arpoon\xF3\u0F98quigarro\xF7\u21F0hreetimes;\u62CB\u0180;qs\u258B\u0993\u25FAlan\xF4\u09AC\u0280;cdgs\u09AC\u260A\u260D\u261D\u2628c;\u6AA8ot\u0100;o\u2614\u2615\u6A7F\u0100;r\u261A\u261B\u6A81;\u6A83\u0100;e\u2622\u2625\uC000\u22DA\uFE00s;\u6A93\u0280adegs\u2633\u2639\u263D\u2649\u264Bppro\xF8\u24C6ot;\u62D6q\u0100gq\u2643\u2645\xF4\u0989gt\xF2\u248C\xF4\u099Bi\xED\u09B2\u0180ilr\u2655\u08E1\u265Asht;\u697C;\uC000\uD835\uDD29\u0100;E\u099C\u2663;\u6A91\u0161\u2669\u2676r\u0100du\u25B2\u266E\u0100;l\u0965\u2673;\u696Alk;\u6584cy;\u4459\u0280;acht\u0A48\u2688\u268B\u2691\u2696r\xF2\u25C1orne\xF2\u1D08ard;\u696Bri;\u65FA\u0100io\u269F\u26A4dot;\u4140ust\u0100;a\u26AC\u26AD\u63B0che\xBB\u26AD\u0200Eaes\u26BB\u26BD\u26C9\u26D4;\u6268p\u0100;p\u26C3\u26C4\u6A89rox\xBB\u26C4\u0100;q\u26CE\u26CF\u6A87\u0100;q\u26CE\u26BBim;\u62E6\u0400abnoptwz\u26E9\u26F4\u26F7\u271A\u272F\u2741\u2747\u2750\u0100nr\u26EE\u26F1g;\u67ECr;\u61FDr\xEB\u08C1g\u0180lmr\u26FF\u270D\u2714eft\u0100ar\u09E6\u2707ight\xE1\u09F2apsto;\u67FCight\xE1\u09FDparrow\u0100lr\u2725\u2729ef\xF4\u24EDight;\u61AC\u0180afl\u2736\u2739\u273Dr;\u6985;\uC000\uD835\uDD5Dus;\u6A2Dimes;\u6A34\u0161\u274B\u274Fst;\u6217\xE1\u134E\u0180;ef\u2757\u2758\u1800\u65CAnge\xBB\u2758ar\u0100;l\u2764\u2765\u4028t;\u6993\u0280achmt\u2773\u2776\u277C\u2785\u2787r\xF2\u08A8orne\xF2\u1D8Car\u0100;d\u0F98\u2783;\u696D;\u600Eri;\u62BF\u0300achiqt\u2798\u279D\u0A40\u27A2\u27AE\u27BBquo;\u6039r;\uC000\uD835\uDCC1m\u0180;eg\u09B2\u27AA\u27AC;\u6A8D;\u6A8F\u0100bu\u252A\u27B3o\u0100;r\u0E1F\u27B9;\u601Arok;\u4142\u8400<;cdhilqr\u082B\u27D2\u2639\u27DC\u27E0\u27E5\u27EA\u27F0\u0100ci\u27D7\u27D9;\u6AA6r;\u6A79re\xE5\u25F2mes;\u62C9arr;\u6976uest;\u6A7B\u0100Pi\u27F5\u27F9ar;\u6996\u0180;ef\u2800\u092D\u181B\u65C3r\u0100du\u2807\u280Dshar;\u694Ahar;\u6966\u0100en\u2817\u2821rtneqq;\uC000\u2268\uFE00\xC5\u281E\u0700Dacdefhilnopsu\u2840\u2845\u2882\u288E\u2893\u28A0\u28A5\u28A8\u28DA\u28E2\u28E4\u0A83\u28F3\u2902Dot;\u623A\u0200clpr\u284E\u2852\u2863\u287Dr\u803B\xAF\u40AF\u0100et\u2857\u2859;\u6642\u0100;e\u285E\u285F\u6720se\xBB\u285F\u0100;s\u103B\u2868to\u0200;dlu\u103B\u2873\u2877\u287Bow\xEE\u048Cef\xF4\u090F\xF0\u13D1ker;\u65AE\u0100oy\u2887\u288Cmma;\u6A29;\u443Cash;\u6014asuredangle\xBB\u1626r;\uC000\uD835\uDD2Ao;\u6127\u0180cdn\u28AF\u28B4\u28C9ro\u803B\xB5\u40B5\u0200;acd\u1464\u28BD\u28C0\u28C4s\xF4\u16A7ir;\u6AF0ot\u80BB\xB7\u01B5us\u0180;bd\u28D2\u1903\u28D3\u6212\u0100;u\u1D3C\u28D8;\u6A2A\u0163\u28DE\u28E1p;\u6ADB\xF2\u2212\xF0\u0A81\u0100dp\u28E9\u28EEels;\u62A7f;\uC000\uD835\uDD5E\u0100ct\u28F8\u28FDr;\uC000\uD835\uDCC2pos\xBB\u159D\u0180;lm\u2909\u290A\u290D\u43BCtimap;\u62B8\u0C00GLRVabcdefghijlmoprstuvw\u2942\u2953\u297E\u2989\u2998\u29DA\u29E9\u2A15\u2A1A\u2A58\u2A5D\u2A83\u2A95\u2AA4\u2AA8\u2B04\u2B07\u2B44\u2B7F\u2BAE\u2C34\u2C67\u2C7C\u2CE9\u0100gt\u2947\u294B;\uC000\u22D9\u0338\u0100;v\u2950\u0BCF\uC000\u226B\u20D2\u0180elt\u295A\u2972\u2976ft\u0100ar\u2961\u2967rrow;\u61CDightarrow;\u61CE;\uC000\u22D8\u0338\u0100;v\u297B\u0C47\uC000\u226A\u20D2ightarrow;\u61CF\u0100Dd\u298E\u2993ash;\u62AFash;\u62AE\u0280bcnpt\u29A3\u29A7\u29AC\u29B1\u29CCla\xBB\u02DEute;\u4144g;\uC000\u2220\u20D2\u0280;Eiop\u0D84\u29BC\u29C0\u29C5\u29C8;\uC000\u2A70\u0338d;\uC000\u224B\u0338s;\u4149ro\xF8\u0D84ur\u0100;a\u29D3\u29D4\u666El\u0100;s\u29D3\u0B38\u01F3\u29DF\0\u29E3p\u80BB\xA0\u0B37mp\u0100;e\u0BF9\u0C00\u0280aeouy\u29F4\u29FE\u2A03\u2A10\u2A13\u01F0\u29F9\0\u29FB;\u6A43on;\u4148dil;\u4146ng\u0100;d\u0D7E\u2A0Aot;\uC000\u2A6D\u0338p;\u6A42;\u443Dash;\u6013\u0380;Aadqsx\u0B92\u2A29\u2A2D\u2A3B\u2A41\u2A45\u2A50rr;\u61D7r\u0100hr\u2A33\u2A36k;\u6924\u0100;o\u13F2\u13F0ot;\uC000\u2250\u0338ui\xF6\u0B63\u0100ei\u2A4A\u2A4Ear;\u6928\xED\u0B98ist\u0100;s\u0BA0\u0B9Fr;\uC000\uD835\uDD2B\u0200Eest\u0BC5\u2A66\u2A79\u2A7C\u0180;qs\u0BBC\u2A6D\u0BE1\u0180;qs\u0BBC\u0BC5\u2A74lan\xF4\u0BE2i\xED\u0BEA\u0100;r\u0BB6\u2A81\xBB\u0BB7\u0180Aap\u2A8A\u2A8D\u2A91r\xF2\u2971rr;\u61AEar;\u6AF2\u0180;sv\u0F8D\u2A9C\u0F8C\u0100;d\u2AA1\u2AA2\u62FC;\u62FAcy;\u445A\u0380AEadest\u2AB7\u2ABA\u2ABE\u2AC2\u2AC5\u2AF6\u2AF9r\xF2\u2966;\uC000\u2266\u0338rr;\u619Ar;\u6025\u0200;fqs\u0C3B\u2ACE\u2AE3\u2AEFt\u0100ar\u2AD4\u2AD9rro\xF7\u2AC1ightarro\xF7\u2A90\u0180;qs\u0C3B\u2ABA\u2AEAlan\xF4\u0C55\u0100;s\u0C55\u2AF4\xBB\u0C36i\xED\u0C5D\u0100;r\u0C35\u2AFEi\u0100;e\u0C1A\u0C25i\xE4\u0D90\u0100pt\u2B0C\u2B11f;\uC000\uD835\uDD5F\u8180\xAC;in\u2B19\u2B1A\u2B36\u40ACn\u0200;Edv\u0B89\u2B24\u2B28\u2B2E;\uC000\u22F9\u0338ot;\uC000\u22F5\u0338\u01E1\u0B89\u2B33\u2B35;\u62F7;\u62F6i\u0100;v\u0CB8\u2B3C\u01E1\u0CB8\u2B41\u2B43;\u62FE;\u62FD\u0180aor\u2B4B\u2B63\u2B69r\u0200;ast\u0B7B\u2B55\u2B5A\u2B5Flle\xEC\u0B7Bl;\uC000\u2AFD\u20E5;\uC000\u2202\u0338lint;\u6A14\u0180;ce\u0C92\u2B70\u2B73u\xE5\u0CA5\u0100;c\u0C98\u2B78\u0100;e\u0C92\u2B7D\xF1\u0C98\u0200Aait\u2B88\u2B8B\u2B9D\u2BA7r\xF2\u2988rr\u0180;cw\u2B94\u2B95\u2B99\u619B;\uC000\u2933\u0338;\uC000\u219D\u0338ghtarrow\xBB\u2B95ri\u0100;e\u0CCB\u0CD6\u0380chimpqu\u2BBD\u2BCD\u2BD9\u2B04\u0B78\u2BE4\u2BEF\u0200;cer\u0D32\u2BC6\u0D37\u2BC9u\xE5\u0D45;\uC000\uD835\uDCC3ort\u026D\u2B05\0\0\u2BD6ar\xE1\u2B56m\u0100;e\u0D6E\u2BDF\u0100;q\u0D74\u0D73su\u0100bp\u2BEB\u2BED\xE5\u0CF8\xE5\u0D0B\u0180bcp\u2BF6\u2C11\u2C19\u0200;Ees\u2BFF\u2C00\u0D22\u2C04\u6284;\uC000\u2AC5\u0338et\u0100;e\u0D1B\u2C0Bq\u0100;q\u0D23\u2C00c\u0100;e\u0D32\u2C17\xF1\u0D38\u0200;Ees\u2C22\u2C23\u0D5F\u2C27\u6285;\uC000\u2AC6\u0338et\u0100;e\u0D58\u2C2Eq\u0100;q\u0D60\u2C23\u0200gilr\u2C3D\u2C3F\u2C45\u2C47\xEC\u0BD7lde\u803B\xF1\u40F1\xE7\u0C43iangle\u0100lr\u2C52\u2C5Ceft\u0100;e\u0C1A\u2C5A\xF1\u0C26ight\u0100;e\u0CCB\u2C65\xF1\u0CD7\u0100;m\u2C6C\u2C6D\u43BD\u0180;es\u2C74\u2C75\u2C79\u4023ro;\u6116p;\u6007\u0480DHadgilrs\u2C8F\u2C94\u2C99\u2C9E\u2CA3\u2CB0\u2CB6\u2CD3\u2CE3ash;\u62ADarr;\u6904p;\uC000\u224D\u20D2ash;\u62AC\u0100et\u2CA8\u2CAC;\uC000\u2265\u20D2;\uC000>\u20D2nfin;\u69DE\u0180Aet\u2CBD\u2CC1\u2CC5rr;\u6902;\uC000\u2264\u20D2\u0100;r\u2CCA\u2CCD\uC000<\u20D2ie;\uC000\u22B4\u20D2\u0100At\u2CD8\u2CDCrr;\u6903rie;\uC000\u22B5\u20D2im;\uC000\u223C\u20D2\u0180Aan\u2CF0\u2CF4\u2D02rr;\u61D6r\u0100hr\u2CFA\u2CFDk;\u6923\u0100;o\u13E7\u13E5ear;\u6927\u1253\u1A95\0\0\0\0\0\0\0\0\0\0\0\0\0\u2D2D\0\u2D38\u2D48\u2D60\u2D65\u2D72\u2D84\u1B07\0\0\u2D8D\u2DAB\0\u2DC8\u2DCE\0\u2DDC\u2E19\u2E2B\u2E3E\u2E43\u0100cs\u2D31\u1A97ute\u803B\xF3\u40F3\u0100iy\u2D3C\u2D45r\u0100;c\u1A9E\u2D42\u803B\xF4\u40F4;\u443E\u0280abios\u1AA0\u2D52\u2D57\u01C8\u2D5Alac;\u4151v;\u6A38old;\u69BClig;\u4153\u0100cr\u2D69\u2D6Dir;\u69BF;\uC000\uD835\uDD2C\u036F\u2D79\0\0\u2D7C\0\u2D82n;\u42DBave\u803B\xF2\u40F2;\u69C1\u0100bm\u2D88\u0DF4ar;\u69B5\u0200acit\u2D95\u2D98\u2DA5\u2DA8r\xF2\u1A80\u0100ir\u2D9D\u2DA0r;\u69BEoss;\u69BBn\xE5\u0E52;\u69C0\u0180aei\u2DB1\u2DB5\u2DB9cr;\u414Dga;\u43C9\u0180cdn\u2DC0\u2DC5\u01CDron;\u43BF;\u69B6pf;\uC000\uD835\uDD60\u0180ael\u2DD4\u2DD7\u01D2r;\u69B7rp;\u69B9\u0380;adiosv\u2DEA\u2DEB\u2DEE\u2E08\u2E0D\u2E10\u2E16\u6228r\xF2\u1A86\u0200;efm\u2DF7\u2DF8\u2E02\u2E05\u6A5Dr\u0100;o\u2DFE\u2DFF\u6134f\xBB\u2DFF\u803B\xAA\u40AA\u803B\xBA\u40BAgof;\u62B6r;\u6A56lope;\u6A57;\u6A5B\u0180clo\u2E1F\u2E21\u2E27\xF2\u2E01ash\u803B\xF8\u40F8l;\u6298i\u016C\u2E2F\u2E34de\u803B\xF5\u40F5es\u0100;a\u01DB\u2E3As;\u6A36ml\u803B\xF6\u40F6bar;\u633D\u0AE1\u2E5E\0\u2E7D\0\u2E80\u2E9D\0\u2EA2\u2EB9\0\0\u2ECB\u0E9C\0\u2F13\0\0\u2F2B\u2FBC\0\u2FC8r\u0200;ast\u0403\u2E67\u2E72\u0E85\u8100\xB6;l\u2E6D\u2E6E\u40B6le\xEC\u0403\u0269\u2E78\0\0\u2E7Bm;\u6AF3;\u6AFDy;\u443Fr\u0280cimpt\u2E8B\u2E8F\u2E93\u1865\u2E97nt;\u4025od;\u402Eil;\u6030enk;\u6031r;\uC000\uD835\uDD2D\u0180imo\u2EA8\u2EB0\u2EB4\u0100;v\u2EAD\u2EAE\u43C6;\u43D5ma\xF4\u0A76ne;\u660E\u0180;tv\u2EBF\u2EC0\u2EC8\u43C0chfork\xBB\u1FFD;\u43D6\u0100au\u2ECF\u2EDFn\u0100ck\u2ED5\u2EDDk\u0100;h\u21F4\u2EDB;\u610E\xF6\u21F4s\u0480;abcdemst\u2EF3\u2EF4\u1908\u2EF9\u2EFD\u2F04\u2F06\u2F0A\u2F0E\u402Bcir;\u6A23ir;\u6A22\u0100ou\u1D40\u2F02;\u6A25;\u6A72n\u80BB\xB1\u0E9Dim;\u6A26wo;\u6A27\u0180ipu\u2F19\u2F20\u2F25ntint;\u6A15f;\uC000\uD835\uDD61nd\u803B\xA3\u40A3\u0500;Eaceinosu\u0EC8\u2F3F\u2F41\u2F44\u2F47\u2F81\u2F89\u2F92\u2F7E\u2FB6;\u6AB3p;\u6AB7u\xE5\u0ED9\u0100;c\u0ECE\u2F4C\u0300;acens\u0EC8\u2F59\u2F5F\u2F66\u2F68\u2F7Eppro\xF8\u2F43urlye\xF1\u0ED9\xF1\u0ECE\u0180aes\u2F6F\u2F76\u2F7Approx;\u6AB9qq;\u6AB5im;\u62E8i\xED\u0EDFme\u0100;s\u2F88\u0EAE\u6032\u0180Eas\u2F78\u2F90\u2F7A\xF0\u2F75\u0180dfp\u0EEC\u2F99\u2FAF\u0180als\u2FA0\u2FA5\u2FAAlar;\u632Eine;\u6312urf;\u6313\u0100;t\u0EFB\u2FB4\xEF\u0EFBrel;\u62B0\u0100ci\u2FC0\u2FC5r;\uC000\uD835\uDCC5;\u43C8ncsp;\u6008\u0300fiopsu\u2FDA\u22E2\u2FDF\u2FE5\u2FEB\u2FF1r;\uC000\uD835\uDD2Epf;\uC000\uD835\uDD62rime;\u6057cr;\uC000\uD835\uDCC6\u0180aeo\u2FF8\u3009\u3013t\u0100ei\u2FFE\u3005rnion\xF3\u06B0nt;\u6A16st\u0100;e\u3010\u3011\u403F\xF1\u1F19\xF4\u0F14\u0A80ABHabcdefhilmnoprstux\u3040\u3051\u3055\u3059\u30E0\u310E\u312B\u3147\u3162\u3172\u318E\u3206\u3215\u3224\u3229\u3258\u326E\u3272\u3290\u32B0\u32B7\u0180art\u3047\u304A\u304Cr\xF2\u10B3\xF2\u03DDail;\u691Car\xF2\u1C65ar;\u6964\u0380cdenqrt\u3068\u3075\u3078\u307F\u308F\u3094\u30CC\u0100eu\u306D\u3071;\uC000\u223D\u0331te;\u4155i\xE3\u116Emptyv;\u69B3g\u0200;del\u0FD1\u3089\u308B\u308D;\u6992;\u69A5\xE5\u0FD1uo\u803B\xBB\u40BBr\u0580;abcfhlpstw\u0FDC\u30AC\u30AF\u30B7\u30B9\u30BC\u30BE\u30C0\u30C3\u30C7\u30CAp;\u6975\u0100;f\u0FE0\u30B4s;\u6920;\u6933s;\u691E\xEB\u225D\xF0\u272El;\u6945im;\u6974l;\u61A3;\u619D\u0100ai\u30D1\u30D5il;\u691Ao\u0100;n\u30DB\u30DC\u6236al\xF3\u0F1E\u0180abr\u30E7\u30EA\u30EEr\xF2\u17E5rk;\u6773\u0100ak\u30F3\u30FDc\u0100ek\u30F9\u30FB;\u407D;\u405D\u0100es\u3102\u3104;\u698Cl\u0100du\u310A\u310C;\u698E;\u6990\u0200aeuy\u3117\u311C\u3127\u3129ron;\u4159\u0100di\u3121\u3125il;\u4157\xEC\u0FF2\xE2\u30FA;\u4440\u0200clqs\u3134\u3137\u313D\u3144a;\u6937dhar;\u6969uo\u0100;r\u020E\u020Dh;\u61B3\u0180acg\u314E\u315F\u0F44l\u0200;ips\u0F78\u3158\u315B\u109Cn\xE5\u10BBar\xF4\u0FA9t;\u65AD\u0180ilr\u3169\u1023\u316Esht;\u697D;\uC000\uD835\uDD2F\u0100ao\u3177\u3186r\u0100du\u317D\u317F\xBB\u047B\u0100;l\u1091\u3184;\u696C\u0100;v\u318B\u318C\u43C1;\u43F1\u0180gns\u3195\u31F9\u31FCht\u0300ahlrst\u31A4\u31B0\u31C2\u31D8\u31E4\u31EErrow\u0100;t\u0FDC\u31ADa\xE9\u30C8arpoon\u0100du\u31BB\u31BFow\xEE\u317Ep\xBB\u1092eft\u0100ah\u31CA\u31D0rrow\xF3\u0FEAarpoon\xF3\u0551ightarrows;\u61C9quigarro\xF7\u30CBhreetimes;\u62CCg;\u42DAingdotse\xF1\u1F32\u0180ahm\u320D\u3210\u3213r\xF2\u0FEAa\xF2\u0551;\u600Foust\u0100;a\u321E\u321F\u63B1che\xBB\u321Fmid;\u6AEE\u0200abpt\u3232\u323D\u3240\u3252\u0100nr\u3237\u323Ag;\u67EDr;\u61FEr\xEB\u1003\u0180afl\u3247\u324A\u324Er;\u6986;\uC000\uD835\uDD63us;\u6A2Eimes;\u6A35\u0100ap\u325D\u3267r\u0100;g\u3263\u3264\u4029t;\u6994olint;\u6A12ar\xF2\u31E3\u0200achq\u327B\u3280\u10BC\u3285quo;\u603Ar;\uC000\uD835\uDCC7\u0100bu\u30FB\u328Ao\u0100;r\u0214\u0213\u0180hir\u3297\u329B\u32A0re\xE5\u31F8mes;\u62CAi\u0200;efl\u32AA\u1059\u1821\u32AB\u65B9tri;\u69CEluhar;\u6968;\u611E\u0D61\u32D5\u32DB\u32DF\u332C\u3338\u3371\0\u337A\u33A4\0\0\u33EC\u33F0\0\u3428\u3448\u345A\u34AD\u34B1\u34CA\u34F1\0\u3616\0\0\u3633cute;\u415Bqu\xEF\u27BA\u0500;Eaceinpsy\u11ED\u32F3\u32F5\u32FF\u3302\u330B\u330F\u331F\u3326\u3329;\u6AB4\u01F0\u32FA\0\u32FC;\u6AB8on;\u4161u\xE5\u11FE\u0100;d\u11F3\u3307il;\u415Frc;\u415D\u0180Eas\u3316\u3318\u331B;\u6AB6p;\u6ABAim;\u62E9olint;\u6A13i\xED\u1204;\u4441ot\u0180;be\u3334\u1D47\u3335\u62C5;\u6A66\u0380Aacmstx\u3346\u334A\u3357\u335B\u335E\u3363\u336Drr;\u61D8r\u0100hr\u3350\u3352\xEB\u2228\u0100;o\u0A36\u0A34t\u803B\xA7\u40A7i;\u403Bwar;\u6929m\u0100in\u3369\xF0nu\xF3\xF1t;\u6736r\u0100;o\u3376\u2055\uC000\uD835\uDD30\u0200acoy\u3382\u3386\u3391\u33A0rp;\u666F\u0100hy\u338B\u338Fcy;\u4449;\u4448rt\u026D\u3399\0\0\u339Ci\xE4\u1464ara\xEC\u2E6F\u803B\xAD\u40AD\u0100gm\u33A8\u33B4ma\u0180;fv\u33B1\u33B2\u33B2\u43C3;\u43C2\u0400;deglnpr\u12AB\u33C5\u33C9\u33CE\u33D6\u33DE\u33E1\u33E6ot;\u6A6A\u0100;q\u12B1\u12B0\u0100;E\u33D3\u33D4\u6A9E;\u6AA0\u0100;E\u33DB\u33DC\u6A9D;\u6A9Fe;\u6246lus;\u6A24arr;\u6972ar\xF2\u113D\u0200aeit\u33F8\u3408\u340F\u3417\u0100ls\u33FD\u3404lsetm\xE9\u336Ahp;\u6A33parsl;\u69E4\u0100dl\u1463\u3414e;\u6323\u0100;e\u341C\u341D\u6AAA\u0100;s\u3422\u3423\u6AAC;\uC000\u2AAC\uFE00\u0180flp\u342E\u3433\u3442tcy;\u444C\u0100;b\u3438\u3439\u402F\u0100;a\u343E\u343F\u69C4r;\u633Ff;\uC000\uD835\uDD64a\u0100dr\u344D\u0402es\u0100;u\u3454\u3455\u6660it\xBB\u3455\u0180csu\u3460\u3479\u349F\u0100au\u3465\u346Fp\u0100;s\u1188\u346B;\uC000\u2293\uFE00p\u0100;s\u11B4\u3475;\uC000\u2294\uFE00u\u0100bp\u347F\u348F\u0180;es\u1197\u119C\u3486et\u0100;e\u1197\u348D\xF1\u119D\u0180;es\u11A8\u11AD\u3496et\u0100;e\u11A8\u349D\xF1\u11AE\u0180;af\u117B\u34A6\u05B0r\u0165\u34AB\u05B1\xBB\u117Car\xF2\u1148\u0200cemt\u34B9\u34BE\u34C2\u34C5r;\uC000\uD835\uDCC8tm\xEE\xF1i\xEC\u3415ar\xE6\u11BE\u0100ar\u34CE\u34D5r\u0100;f\u34D4\u17BF\u6606\u0100an\u34DA\u34EDight\u0100ep\u34E3\u34EApsilo\xEE\u1EE0h\xE9\u2EAFs\xBB\u2852\u0280bcmnp\u34FB\u355E\u1209\u358B\u358E\u0480;Edemnprs\u350E\u350F\u3511\u3515\u351E\u3523\u352C\u3531\u3536\u6282;\u6AC5ot;\u6ABD\u0100;d\u11DA\u351Aot;\u6AC3ult;\u6AC1\u0100Ee\u3528\u352A;\u6ACB;\u628Alus;\u6ABFarr;\u6979\u0180eiu\u353D\u3552\u3555t\u0180;en\u350E\u3545\u354Bq\u0100;q\u11DA\u350Feq\u0100;q\u352B\u3528m;\u6AC7\u0100bp\u355A\u355C;\u6AD5;\u6AD3c\u0300;acens\u11ED\u356C\u3572\u3579\u357B\u3326ppro\xF8\u32FAurlye\xF1\u11FE\xF1\u11F3\u0180aes\u3582\u3588\u331Bppro\xF8\u331Aq\xF1\u3317g;\u666A\u0680123;Edehlmnps\u35A9\u35AC\u35AF\u121C\u35B2\u35B4\u35C0\u35C9\u35D5\u35DA\u35DF\u35E8\u35ED\u803B\xB9\u40B9\u803B\xB2\u40B2\u803B\xB3\u40B3;\u6AC6\u0100os\u35B9\u35BCt;\u6ABEub;\u6AD8\u0100;d\u1222\u35C5ot;\u6AC4s\u0100ou\u35CF\u35D2l;\u67C9b;\u6AD7arr;\u697Bult;\u6AC2\u0100Ee\u35E4\u35E6;\u6ACC;\u628Blus;\u6AC0\u0180eiu\u35F4\u3609\u360Ct\u0180;en\u121C\u35FC\u3602q\u0100;q\u1222\u35B2eq\u0100;q\u35E7\u35E4m;\u6AC8\u0100bp\u3611\u3613;\u6AD4;\u6AD6\u0180Aan\u361C\u3620\u362Drr;\u61D9r\u0100hr\u3626\u3628\xEB\u222E\u0100;o\u0A2B\u0A29war;\u692Alig\u803B\xDF\u40DF\u0BE1\u3651\u365D\u3660\u12CE\u3673\u3679\0\u367E\u36C2\0\0\0\0\0\u36DB\u3703\0\u3709\u376C\0\0\0\u3787\u0272\u3656\0\0\u365Bget;\u6316;\u43C4r\xEB\u0E5F\u0180aey\u3666\u366B\u3670ron;\u4165dil;\u4163;\u4442lrec;\u6315r;\uC000\uD835\uDD31\u0200eiko\u3686\u369D\u36B5\u36BC\u01F2\u368B\0\u3691e\u01004f\u1284\u1281a\u0180;sv\u3698\u3699\u369B\u43B8ym;\u43D1\u0100cn\u36A2\u36B2k\u0100as\u36A8\u36AEppro\xF8\u12C1im\xBB\u12ACs\xF0\u129E\u0100as\u36BA\u36AE\xF0\u12C1rn\u803B\xFE\u40FE\u01EC\u031F\u36C6\u22E7es\u8180\xD7;bd\u36CF\u36D0\u36D8\u40D7\u0100;a\u190F\u36D5r;\u6A31;\u6A30\u0180eps\u36E1\u36E3\u3700\xE1\u2A4D\u0200;bcf\u0486\u36EC\u36F0\u36F4ot;\u6336ir;\u6AF1\u0100;o\u36F9\u36FC\uC000\uD835\uDD65rk;\u6ADA\xE1\u3362rime;\u6034\u0180aip\u370F\u3712\u3764d\xE5\u1248\u0380adempst\u3721\u374D\u3740\u3751\u3757\u375C\u375Fngle\u0280;dlqr\u3730\u3731\u3736\u3740\u3742\u65B5own\xBB\u1DBBeft\u0100;e\u2800\u373E\xF1\u092E;\u625Cight\u0100;e\u32AA\u374B\xF1\u105Aot;\u65ECinus;\u6A3Alus;\u6A39b;\u69CDime;\u6A3Bezium;\u63E2\u0180cht\u3772\u377D\u3781\u0100ry\u3777\u377B;\uC000\uD835\uDCC9;\u4446cy;\u445Brok;\u4167\u0100io\u378B\u378Ex\xF4\u1777head\u0100lr\u3797\u37A0eftarro\xF7\u084Fightarrow\xBB\u0F5D\u0900AHabcdfghlmoprstuw\u37D0\u37D3\u37D7\u37E4\u37F0\u37FC\u380E\u381C\u3823\u3834\u3851\u385D\u386B\u38A9\u38CC\u38D2\u38EA\u38F6r\xF2\u03EDar;\u6963\u0100cr\u37DC\u37E2ute\u803B\xFA\u40FA\xF2\u1150r\u01E3\u37EA\0\u37EDy;\u445Eve;\u416D\u0100iy\u37F5\u37FArc\u803B\xFB\u40FB;\u4443\u0180abh\u3803\u3806\u380Br\xF2\u13ADlac;\u4171a\xF2\u13C3\u0100ir\u3813\u3818sht;\u697E;\uC000\uD835\uDD32rave\u803B\xF9\u40F9\u0161\u3827\u3831r\u0100lr\u382C\u382E\xBB\u0957\xBB\u1083lk;\u6580\u0100ct\u3839\u384D\u026F\u383F\0\0\u384Arn\u0100;e\u3845\u3846\u631Cr\xBB\u3846op;\u630Fri;\u65F8\u0100al\u3856\u385Acr;\u416B\u80BB\xA8\u0349\u0100gp\u3862\u3866on;\u4173f;\uC000\uD835\uDD66\u0300adhlsu\u114B\u3878\u387D\u1372\u3891\u38A0own\xE1\u13B3arpoon\u0100lr\u3888\u388Cef\xF4\u382Digh\xF4\u382Fi\u0180;hl\u3899\u389A\u389C\u43C5\xBB\u13FAon\xBB\u389Aparrows;\u61C8\u0180cit\u38B0\u38C4\u38C8\u026F\u38B6\0\0\u38C1rn\u0100;e\u38BC\u38BD\u631Dr\xBB\u38BDop;\u630Eng;\u416Fri;\u65F9cr;\uC000\uD835\uDCCA\u0180dir\u38D9\u38DD\u38E2ot;\u62F0lde;\u4169i\u0100;f\u3730\u38E8\xBB\u1813\u0100am\u38EF\u38F2r\xF2\u38A8l\u803B\xFC\u40FCangle;\u69A7\u0780ABDacdeflnoprsz\u391C\u391F\u3929\u392D\u39B5\u39B8\u39BD\u39DF\u39E4\u39E8\u39F3\u39F9\u39FD\u3A01\u3A20r\xF2\u03F7ar\u0100;v\u3926\u3927\u6AE8;\u6AE9as\xE8\u03E1\u0100nr\u3932\u3937grt;\u699C\u0380eknprst\u34E3\u3946\u394B\u3952\u395D\u3964\u3996app\xE1\u2415othin\xE7\u1E96\u0180hir\u34EB\u2EC8\u3959op\xF4\u2FB5\u0100;h\u13B7\u3962\xEF\u318D\u0100iu\u3969\u396Dgm\xE1\u33B3\u0100bp\u3972\u3984setneq\u0100;q\u397D\u3980\uC000\u228A\uFE00;\uC000\u2ACB\uFE00setneq\u0100;q\u398F\u3992\uC000\u228B\uFE00;\uC000\u2ACC\uFE00\u0100hr\u399B\u399Fet\xE1\u369Ciangle\u0100lr\u39AA\u39AFeft\xBB\u0925ight\xBB\u1051y;\u4432ash\xBB\u1036\u0180elr\u39C4\u39D2\u39D7\u0180;be\u2DEA\u39CB\u39CFar;\u62BBq;\u625Alip;\u62EE\u0100bt\u39DC\u1468a\xF2\u1469r;\uC000\uD835\uDD33tr\xE9\u39AEsu\u0100bp\u39EF\u39F1\xBB\u0D1C\xBB\u0D59pf;\uC000\uD835\uDD67ro\xF0\u0EFBtr\xE9\u39B4\u0100cu\u3A06\u3A0Br;\uC000\uD835\uDCCB\u0100bp\u3A10\u3A18n\u0100Ee\u3980\u3A16\xBB\u397En\u0100Ee\u3992\u3A1E\xBB\u3990igzag;\u699A\u0380cefoprs\u3A36\u3A3B\u3A56\u3A5B\u3A54\u3A61\u3A6Airc;\u4175\u0100di\u3A40\u3A51\u0100bg\u3A45\u3A49ar;\u6A5Fe\u0100;q\u15FA\u3A4F;\u6259erp;\u6118r;\uC000\uD835\uDD34pf;\uC000\uD835\uDD68\u0100;e\u1479\u3A66at\xE8\u1479cr;\uC000\uD835\uDCCC\u0AE3\u178E\u3A87\0\u3A8B\0\u3A90\u3A9B\0\0\u3A9D\u3AA8\u3AAB\u3AAF\0\0\u3AC3\u3ACE\0\u3AD8\u17DC\u17DFtr\xE9\u17D1r;\uC000\uD835\uDD35\u0100Aa\u3A94\u3A97r\xF2\u03C3r\xF2\u09F6;\u43BE\u0100Aa\u3AA1\u3AA4r\xF2\u03B8r\xF2\u09EBa\xF0\u2713is;\u62FB\u0180dpt\u17A4\u3AB5\u3ABE\u0100fl\u3ABA\u17A9;\uC000\uD835\uDD69im\xE5\u17B2\u0100Aa\u3AC7\u3ACAr\xF2\u03CEr\xF2\u0A01\u0100cq\u3AD2\u17B8r;\uC000\uD835\uDCCD\u0100pt\u17D6\u3ADCr\xE9\u17D4\u0400acefiosu\u3AF0\u3AFD\u3B08\u3B0C\u3B11\u3B15\u3B1B\u3B21c\u0100uy\u3AF6\u3AFBte\u803B\xFD\u40FD;\u444F\u0100iy\u3B02\u3B06rc;\u4177;\u444Bn\u803B\xA5\u40A5r;\uC000\uD835\uDD36cy;\u4457pf;\uC000\uD835\uDD6Acr;\uC000\uD835\uDCCE\u0100cm\u3B26\u3B29y;\u444El\u803B\xFF\u40FF\u0500acdefhiosw\u3B42\u3B48\u3B54\u3B58\u3B64\u3B69\u3B6D\u3B74\u3B7A\u3B80cute;\u417A\u0100ay\u3B4D\u3B52ron;\u417E;\u4437ot;\u417C\u0100et\u3B5D\u3B61tr\xE6\u155Fa;\u43B6r;\uC000\uD835\uDD37cy;\u4436grarr;\u61DDpf;\uC000\uD835\uDD6Bcr;\uC000\uD835\uDCCF\u0100jn\u3B85\u3B87;\u600Dj;\u600C'.split("").map(function(c2) {
    return c2.charCodeAt(0);
  }));
});

// node_modules/entities/lib/generated/decode-data-xml.js
var require_decode_data_xml = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = new Uint16Array("\u0200aglq\t\x15\x18\x1B\u026D\x0F\0\0\x12p;\u4026os;\u4027t;\u403Et;\u403Cuot;\u4022".split("").map(function(c2) {
    return c2.charCodeAt(0);
  }));
});

// node_modules/entities/lib/decode_codepoint.js
var require_decode_codepoint = __commonJS((exports) => {
  var replaceCodePoint = function(codePoint) {
    var _a2;
    if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
      return 65533;
    }
    return (_a2 = decodeMap.get(codePoint)) !== null && _a2 !== undefined ? _a2 : codePoint;
  };
  var decodeCodePoint = function(codePoint) {
    return (0, exports.fromCodePoint)(replaceCodePoint(codePoint));
  };
  var _a;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.replaceCodePoint = exports.fromCodePoint = undefined;
  var decodeMap = new Map([
    [0, 65533],
    [128, 8364],
    [130, 8218],
    [131, 402],
    [132, 8222],
    [133, 8230],
    [134, 8224],
    [135, 8225],
    [136, 710],
    [137, 8240],
    [138, 352],
    [139, 8249],
    [140, 338],
    [142, 381],
    [145, 8216],
    [146, 8217],
    [147, 8220],
    [148, 8221],
    [149, 8226],
    [150, 8211],
    [151, 8212],
    [152, 732],
    [153, 8482],
    [154, 353],
    [155, 8250],
    [156, 339],
    [158, 382],
    [159, 376]
  ]);
  exports.fromCodePoint = (_a = String.fromCodePoint) !== null && _a !== undefined ? _a : function(codePoint) {
    var output = "";
    if (codePoint > 65535) {
      codePoint -= 65536;
      output += String.fromCharCode(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    output += String.fromCharCode(codePoint);
    return output;
  };
  exports.replaceCodePoint = replaceCodePoint;
  exports.default = decodeCodePoint;
});

// node_modules/entities/lib/decode.js
var require_decode = __commonJS((exports) => {
  var isNumber = function(code) {
    return code >= CharCodes.ZERO && code <= CharCodes.NINE;
  };
  var isHexadecimalCharacter = function(code) {
    return code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_F || code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_F;
  };
  var isAsciiAlphaNumeric = function(code) {
    return code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_Z || code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_Z || isNumber(code);
  };
  var isEntityInAttributeInvalidEnd = function(code) {
    return code === CharCodes.EQUALS || isAsciiAlphaNumeric(code);
  };
  var getDecoder = function(decodeTree) {
    var ret = "";
    var decoder = new EntityDecoder(decodeTree, function(str) {
      return ret += (0, decode_codepoint_js_1.fromCodePoint)(str);
    });
    return function decodeWithTrie(str, decodeMode) {
      var lastIndex = 0;
      var offset = 0;
      while ((offset = str.indexOf("&", offset)) >= 0) {
        ret += str.slice(lastIndex, offset);
        decoder.startEntity(decodeMode);
        var len = decoder.write(str, offset + 1);
        if (len < 0) {
          lastIndex = offset + decoder.end();
          break;
        }
        lastIndex = offset + len;
        offset = len === 0 ? lastIndex + 1 : lastIndex;
      }
      var result2 = ret + str.slice(lastIndex);
      ret = "";
      return result2;
    };
  };
  var determineBranch = function(decodeTree, current, nodeIdx, char) {
    var branchCount = (current & BinTrieFlags.BRANCH_LENGTH) >> 7;
    var jumpOffset = current & BinTrieFlags.JUMP_TABLE;
    if (branchCount === 0) {
      return jumpOffset !== 0 && char === jumpOffset ? nodeIdx : -1;
    }
    if (jumpOffset) {
      var value = char - jumpOffset;
      return value < 0 || value >= branchCount ? -1 : decodeTree[nodeIdx + value] - 1;
    }
    var lo = nodeIdx;
    var hi = lo + branchCount - 1;
    while (lo <= hi) {
      var mid = lo + hi >>> 1;
      var midVal = decodeTree[mid];
      if (midVal < char) {
        lo = mid + 1;
      } else if (midVal > char) {
        hi = mid - 1;
      } else {
        return decodeTree[mid + branchCount];
      }
    }
    return -1;
  };
  var decodeHTML = function(str, mode) {
    if (mode === undefined) {
      mode = DecodingMode.Legacy;
    }
    return htmlDecoder(str, mode);
  };
  var decodeHTMLAttribute = function(str) {
    return htmlDecoder(str, DecodingMode.Attribute);
  };
  var decodeHTMLStrict = function(str) {
    return htmlDecoder(str, DecodingMode.Strict);
  };
  var decodeXML = function(str) {
    return xmlDecoder(str, DecodingMode.Strict);
  };
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc2 = Object.getOwnPropertyDescriptor(m, k);
    if (!desc2 || ("get" in desc2 ? !m.__esModule : desc2.writable || desc2.configurable)) {
      desc2 = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o2, k2, desc2);
  } : function(o2, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o2[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v) {
    Object.defineProperty(o2, "default", { enumerable: true, value: v });
  } : function(o2, v) {
    o2["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result2 = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result2, mod, k);
    }
    __setModuleDefault(result2, mod);
    return result2;
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.decodeXML = exports.decodeHTMLStrict = exports.decodeHTMLAttribute = exports.decodeHTML = exports.determineBranch = exports.EntityDecoder = exports.DecodingMode = exports.BinTrieFlags = exports.fromCodePoint = exports.replaceCodePoint = exports.decodeCodePoint = exports.xmlDecodeTree = exports.htmlDecodeTree = undefined;
  var decode_data_html_js_1 = __importDefault(require_decode_data_html());
  exports.htmlDecodeTree = decode_data_html_js_1.default;
  var decode_data_xml_js_1 = __importDefault(require_decode_data_xml());
  exports.xmlDecodeTree = decode_data_xml_js_1.default;
  var decode_codepoint_js_1 = __importStar(require_decode_codepoint());
  exports.decodeCodePoint = decode_codepoint_js_1.default;
  var decode_codepoint_js_2 = require_decode_codepoint();
  Object.defineProperty(exports, "replaceCodePoint", { enumerable: true, get: function() {
    return decode_codepoint_js_2.replaceCodePoint;
  } });
  Object.defineProperty(exports, "fromCodePoint", { enumerable: true, get: function() {
    return decode_codepoint_js_2.fromCodePoint;
  } });
  var CharCodes;
  (function(CharCodes2) {
    CharCodes2[CharCodes2["NUM"] = 35] = "NUM";
    CharCodes2[CharCodes2["SEMI"] = 59] = "SEMI";
    CharCodes2[CharCodes2["EQUALS"] = 61] = "EQUALS";
    CharCodes2[CharCodes2["ZERO"] = 48] = "ZERO";
    CharCodes2[CharCodes2["NINE"] = 57] = "NINE";
    CharCodes2[CharCodes2["LOWER_A"] = 97] = "LOWER_A";
    CharCodes2[CharCodes2["LOWER_F"] = 102] = "LOWER_F";
    CharCodes2[CharCodes2["LOWER_X"] = 120] = "LOWER_X";
    CharCodes2[CharCodes2["LOWER_Z"] = 122] = "LOWER_Z";
    CharCodes2[CharCodes2["UPPER_A"] = 65] = "UPPER_A";
    CharCodes2[CharCodes2["UPPER_F"] = 70] = "UPPER_F";
    CharCodes2[CharCodes2["UPPER_Z"] = 90] = "UPPER_Z";
  })(CharCodes || (CharCodes = {}));
  var TO_LOWER_BIT = 32;
  var BinTrieFlags;
  (function(BinTrieFlags2) {
    BinTrieFlags2[BinTrieFlags2["VALUE_LENGTH"] = 49152] = "VALUE_LENGTH";
    BinTrieFlags2[BinTrieFlags2["BRANCH_LENGTH"] = 16256] = "BRANCH_LENGTH";
    BinTrieFlags2[BinTrieFlags2["JUMP_TABLE"] = 127] = "JUMP_TABLE";
  })(BinTrieFlags = exports.BinTrieFlags || (exports.BinTrieFlags = {}));
  var EntityDecoderState;
  (function(EntityDecoderState2) {
    EntityDecoderState2[EntityDecoderState2["EntityStart"] = 0] = "EntityStart";
    EntityDecoderState2[EntityDecoderState2["NumericStart"] = 1] = "NumericStart";
    EntityDecoderState2[EntityDecoderState2["NumericDecimal"] = 2] = "NumericDecimal";
    EntityDecoderState2[EntityDecoderState2["NumericHex"] = 3] = "NumericHex";
    EntityDecoderState2[EntityDecoderState2["NamedEntity"] = 4] = "NamedEntity";
  })(EntityDecoderState || (EntityDecoderState = {}));
  var DecodingMode;
  (function(DecodingMode2) {
    DecodingMode2[DecodingMode2["Legacy"] = 0] = "Legacy";
    DecodingMode2[DecodingMode2["Strict"] = 1] = "Strict";
    DecodingMode2[DecodingMode2["Attribute"] = 2] = "Attribute";
  })(DecodingMode = exports.DecodingMode || (exports.DecodingMode = {}));
  var EntityDecoder = function() {
    function EntityDecoder2(decodeTree, emitCodePoint, errors6) {
      this.decodeTree = decodeTree;
      this.emitCodePoint = emitCodePoint;
      this.errors = errors6;
      this.state = EntityDecoderState.EntityStart;
      this.consumed = 1;
      this.result = 0;
      this.treeIndex = 0;
      this.excess = 1;
      this.decodeMode = DecodingMode.Strict;
    }
    EntityDecoder2.prototype.startEntity = function(decodeMode) {
      this.decodeMode = decodeMode;
      this.state = EntityDecoderState.EntityStart;
      this.result = 0;
      this.treeIndex = 0;
      this.excess = 1;
      this.consumed = 1;
    };
    EntityDecoder2.prototype.write = function(str, offset) {
      switch (this.state) {
        case EntityDecoderState.EntityStart: {
          if (str.charCodeAt(offset) === CharCodes.NUM) {
            this.state = EntityDecoderState.NumericStart;
            this.consumed += 1;
            return this.stateNumericStart(str, offset + 1);
          }
          this.state = EntityDecoderState.NamedEntity;
          return this.stateNamedEntity(str, offset);
        }
        case EntityDecoderState.NumericStart: {
          return this.stateNumericStart(str, offset);
        }
        case EntityDecoderState.NumericDecimal: {
          return this.stateNumericDecimal(str, offset);
        }
        case EntityDecoderState.NumericHex: {
          return this.stateNumericHex(str, offset);
        }
        case EntityDecoderState.NamedEntity: {
          return this.stateNamedEntity(str, offset);
        }
      }
    };
    EntityDecoder2.prototype.stateNumericStart = function(str, offset) {
      if (offset >= str.length) {
        return -1;
      }
      if ((str.charCodeAt(offset) | TO_LOWER_BIT) === CharCodes.LOWER_X) {
        this.state = EntityDecoderState.NumericHex;
        this.consumed += 1;
        return this.stateNumericHex(str, offset + 1);
      }
      this.state = EntityDecoderState.NumericDecimal;
      return this.stateNumericDecimal(str, offset);
    };
    EntityDecoder2.prototype.addToNumericResult = function(str, start, end, base) {
      if (start !== end) {
        var digitCount = end - start;
        this.result = this.result * Math.pow(base, digitCount) + parseInt(str.substr(start, digitCount), base);
        this.consumed += digitCount;
      }
    };
    EntityDecoder2.prototype.stateNumericHex = function(str, offset) {
      var startIdx = offset;
      while (offset < str.length) {
        var char = str.charCodeAt(offset);
        if (isNumber(char) || isHexadecimalCharacter(char)) {
          offset += 1;
        } else {
          this.addToNumericResult(str, startIdx, offset, 16);
          return this.emitNumericEntity(char, 3);
        }
      }
      this.addToNumericResult(str, startIdx, offset, 16);
      return -1;
    };
    EntityDecoder2.prototype.stateNumericDecimal = function(str, offset) {
      var startIdx = offset;
      while (offset < str.length) {
        var char = str.charCodeAt(offset);
        if (isNumber(char)) {
          offset += 1;
        } else {
          this.addToNumericResult(str, startIdx, offset, 10);
          return this.emitNumericEntity(char, 2);
        }
      }
      this.addToNumericResult(str, startIdx, offset, 10);
      return -1;
    };
    EntityDecoder2.prototype.emitNumericEntity = function(lastCp, expectedLength) {
      var _a;
      if (this.consumed <= expectedLength) {
        (_a = this.errors) === null || _a === undefined || _a.absenceOfDigitsInNumericCharacterReference(this.consumed);
        return 0;
      }
      if (lastCp === CharCodes.SEMI) {
        this.consumed += 1;
      } else if (this.decodeMode === DecodingMode.Strict) {
        return 0;
      }
      this.emitCodePoint((0, decode_codepoint_js_1.replaceCodePoint)(this.result), this.consumed);
      if (this.errors) {
        if (lastCp !== CharCodes.SEMI) {
          this.errors.missingSemicolonAfterCharacterReference();
        }
        this.errors.validateNumericCharacterReference(this.result);
      }
      return this.consumed;
    };
    EntityDecoder2.prototype.stateNamedEntity = function(str, offset) {
      var decodeTree = this.decodeTree;
      var current = decodeTree[this.treeIndex];
      var valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
      for (;offset < str.length; offset++, this.excess++) {
        var char = str.charCodeAt(offset);
        this.treeIndex = determineBranch(decodeTree, current, this.treeIndex + Math.max(1, valueLength), char);
        if (this.treeIndex < 0) {
          return this.result === 0 || this.decodeMode === DecodingMode.Attribute && (valueLength === 0 || isEntityInAttributeInvalidEnd(char)) ? 0 : this.emitNotTerminatedNamedEntity();
        }
        current = decodeTree[this.treeIndex];
        valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
        if (valueLength !== 0) {
          if (char === CharCodes.SEMI) {
            return this.emitNamedEntityData(this.treeIndex, valueLength, this.consumed + this.excess);
          }
          if (this.decodeMode !== DecodingMode.Strict) {
            this.result = this.treeIndex;
            this.consumed += this.excess;
            this.excess = 0;
          }
        }
      }
      return -1;
    };
    EntityDecoder2.prototype.emitNotTerminatedNamedEntity = function() {
      var _a;
      var _b = this, result2 = _b.result, decodeTree = _b.decodeTree;
      var valueLength = (decodeTree[result2] & BinTrieFlags.VALUE_LENGTH) >> 14;
      this.emitNamedEntityData(result2, valueLength, this.consumed);
      (_a = this.errors) === null || _a === undefined || _a.missingSemicolonAfterCharacterReference();
      return this.consumed;
    };
    EntityDecoder2.prototype.emitNamedEntityData = function(result2, valueLength, consumed) {
      var decodeTree = this.decodeTree;
      this.emitCodePoint(valueLength === 1 ? decodeTree[result2] & ~BinTrieFlags.VALUE_LENGTH : decodeTree[result2 + 1], consumed);
      if (valueLength === 3) {
        this.emitCodePoint(decodeTree[result2 + 2], consumed);
      }
      return consumed;
    };
    EntityDecoder2.prototype.end = function() {
      var _a;
      switch (this.state) {
        case EntityDecoderState.NamedEntity: {
          return this.result !== 0 && (this.decodeMode !== DecodingMode.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
        }
        case EntityDecoderState.NumericDecimal: {
          return this.emitNumericEntity(0, 2);
        }
        case EntityDecoderState.NumericHex: {
          return this.emitNumericEntity(0, 3);
        }
        case EntityDecoderState.NumericStart: {
          (_a = this.errors) === null || _a === undefined || _a.absenceOfDigitsInNumericCharacterReference(this.consumed);
          return 0;
        }
        case EntityDecoderState.EntityStart: {
          return 0;
        }
      }
    };
    return EntityDecoder2;
  }();
  exports.EntityDecoder = EntityDecoder;
  exports.determineBranch = determineBranch;
  var htmlDecoder = getDecoder(decode_data_html_js_1.default);
  var xmlDecoder = getDecoder(decode_data_xml_js_1.default);
  exports.decodeHTML = decodeHTML;
  exports.decodeHTMLAttribute = decodeHTMLAttribute;
  exports.decodeHTMLStrict = decodeHTMLStrict;
  exports.decodeXML = decodeXML;
});

// node_modules/htmlparser2/lib/Tokenizer.js
var require_Tokenizer = __commonJS((exports) => {
  var isWhitespace = function(c2) {
    return c2 === CharCodes.Space || c2 === CharCodes.NewLine || c2 === CharCodes.Tab || c2 === CharCodes.FormFeed || c2 === CharCodes.CarriageReturn;
  };
  var isEndOfTagSection = function(c2) {
    return c2 === CharCodes.Slash || c2 === CharCodes.Gt || isWhitespace(c2);
  };
  var isNumber = function(c2) {
    return c2 >= CharCodes.Zero && c2 <= CharCodes.Nine;
  };
  var isASCIIAlpha = function(c2) {
    return c2 >= CharCodes.LowerA && c2 <= CharCodes.LowerZ || c2 >= CharCodes.UpperA && c2 <= CharCodes.UpperZ;
  };
  var isHexDigit = function(c2) {
    return c2 >= CharCodes.UpperA && c2 <= CharCodes.UpperF || c2 >= CharCodes.LowerA && c2 <= CharCodes.LowerF;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.QuoteType = undefined;
  var decode_js_1 = require_decode();
  var CharCodes;
  (function(CharCodes2) {
    CharCodes2[CharCodes2["Tab"] = 9] = "Tab";
    CharCodes2[CharCodes2["NewLine"] = 10] = "NewLine";
    CharCodes2[CharCodes2["FormFeed"] = 12] = "FormFeed";
    CharCodes2[CharCodes2["CarriageReturn"] = 13] = "CarriageReturn";
    CharCodes2[CharCodes2["Space"] = 32] = "Space";
    CharCodes2[CharCodes2["ExclamationMark"] = 33] = "ExclamationMark";
    CharCodes2[CharCodes2["Number"] = 35] = "Number";
    CharCodes2[CharCodes2["Amp"] = 38] = "Amp";
    CharCodes2[CharCodes2["SingleQuote"] = 39] = "SingleQuote";
    CharCodes2[CharCodes2["DoubleQuote"] = 34] = "DoubleQuote";
    CharCodes2[CharCodes2["Dash"] = 45] = "Dash";
    CharCodes2[CharCodes2["Slash"] = 47] = "Slash";
    CharCodes2[CharCodes2["Zero"] = 48] = "Zero";
    CharCodes2[CharCodes2["Nine"] = 57] = "Nine";
    CharCodes2[CharCodes2["Semi"] = 59] = "Semi";
    CharCodes2[CharCodes2["Lt"] = 60] = "Lt";
    CharCodes2[CharCodes2["Eq"] = 61] = "Eq";
    CharCodes2[CharCodes2["Gt"] = 62] = "Gt";
    CharCodes2[CharCodes2["Questionmark"] = 63] = "Questionmark";
    CharCodes2[CharCodes2["UpperA"] = 65] = "UpperA";
    CharCodes2[CharCodes2["LowerA"] = 97] = "LowerA";
    CharCodes2[CharCodes2["UpperF"] = 70] = "UpperF";
    CharCodes2[CharCodes2["LowerF"] = 102] = "LowerF";
    CharCodes2[CharCodes2["UpperZ"] = 90] = "UpperZ";
    CharCodes2[CharCodes2["LowerZ"] = 122] = "LowerZ";
    CharCodes2[CharCodes2["LowerX"] = 120] = "LowerX";
    CharCodes2[CharCodes2["OpeningSquareBracket"] = 91] = "OpeningSquareBracket";
  })(CharCodes || (CharCodes = {}));
  var State;
  (function(State2) {
    State2[State2["Text"] = 1] = "Text";
    State2[State2["BeforeTagName"] = 2] = "BeforeTagName";
    State2[State2["InTagName"] = 3] = "InTagName";
    State2[State2["InSelfClosingTag"] = 4] = "InSelfClosingTag";
    State2[State2["BeforeClosingTagName"] = 5] = "BeforeClosingTagName";
    State2[State2["InClosingTagName"] = 6] = "InClosingTagName";
    State2[State2["AfterClosingTagName"] = 7] = "AfterClosingTagName";
    State2[State2["BeforeAttributeName"] = 8] = "BeforeAttributeName";
    State2[State2["InAttributeName"] = 9] = "InAttributeName";
    State2[State2["AfterAttributeName"] = 10] = "AfterAttributeName";
    State2[State2["BeforeAttributeValue"] = 11] = "BeforeAttributeValue";
    State2[State2["InAttributeValueDq"] = 12] = "InAttributeValueDq";
    State2[State2["InAttributeValueSq"] = 13] = "InAttributeValueSq";
    State2[State2["InAttributeValueNq"] = 14] = "InAttributeValueNq";
    State2[State2["BeforeDeclaration"] = 15] = "BeforeDeclaration";
    State2[State2["InDeclaration"] = 16] = "InDeclaration";
    State2[State2["InProcessingInstruction"] = 17] = "InProcessingInstruction";
    State2[State2["BeforeComment"] = 18] = "BeforeComment";
    State2[State2["CDATASequence"] = 19] = "CDATASequence";
    State2[State2["InSpecialComment"] = 20] = "InSpecialComment";
    State2[State2["InCommentLike"] = 21] = "InCommentLike";
    State2[State2["BeforeSpecialS"] = 22] = "BeforeSpecialS";
    State2[State2["SpecialStartSequence"] = 23] = "SpecialStartSequence";
    State2[State2["InSpecialTag"] = 24] = "InSpecialTag";
    State2[State2["BeforeEntity"] = 25] = "BeforeEntity";
    State2[State2["BeforeNumericEntity"] = 26] = "BeforeNumericEntity";
    State2[State2["InNamedEntity"] = 27] = "InNamedEntity";
    State2[State2["InNumericEntity"] = 28] = "InNumericEntity";
    State2[State2["InHexEntity"] = 29] = "InHexEntity";
  })(State || (State = {}));
  var QuoteType;
  (function(QuoteType2) {
    QuoteType2[QuoteType2["NoValue"] = 0] = "NoValue";
    QuoteType2[QuoteType2["Unquoted"] = 1] = "Unquoted";
    QuoteType2[QuoteType2["Single"] = 2] = "Single";
    QuoteType2[QuoteType2["Double"] = 3] = "Double";
  })(QuoteType = exports.QuoteType || (exports.QuoteType = {}));
  var Sequences = {
    Cdata: new Uint8Array([67, 68, 65, 84, 65, 91]),
    CdataEnd: new Uint8Array([93, 93, 62]),
    CommentEnd: new Uint8Array([45, 45, 62]),
    ScriptEnd: new Uint8Array([60, 47, 115, 99, 114, 105, 112, 116]),
    StyleEnd: new Uint8Array([60, 47, 115, 116, 121, 108, 101]),
    TitleEnd: new Uint8Array([60, 47, 116, 105, 116, 108, 101])
  };
  var Tokenizer = function() {
    function Tokenizer2(_a, cbs) {
      var _b = _a.xmlMode, xmlMode = _b === undefined ? false : _b, _c = _a.decodeEntities, decodeEntities = _c === undefined ? true : _c;
      this.cbs = cbs;
      this.state = State.Text;
      this.buffer = "";
      this.sectionStart = 0;
      this.index = 0;
      this.baseState = State.Text;
      this.isSpecial = false;
      this.running = true;
      this.offset = 0;
      this.currentSequence = undefined;
      this.sequenceIndex = 0;
      this.trieIndex = 0;
      this.trieCurrent = 0;
      this.entityResult = 0;
      this.entityExcess = 0;
      this.xmlMode = xmlMode;
      this.decodeEntities = decodeEntities;
      this.entityTrie = xmlMode ? decode_js_1.xmlDecodeTree : decode_js_1.htmlDecodeTree;
    }
    Tokenizer2.prototype.reset = function() {
      this.state = State.Text;
      this.buffer = "";
      this.sectionStart = 0;
      this.index = 0;
      this.baseState = State.Text;
      this.currentSequence = undefined;
      this.running = true;
      this.offset = 0;
    };
    Tokenizer2.prototype.write = function(chunk) {
      this.offset += this.buffer.length;
      this.buffer = chunk;
      this.parse();
    };
    Tokenizer2.prototype.end = function() {
      if (this.running)
        this.finish();
    };
    Tokenizer2.prototype.pause = function() {
      this.running = false;
    };
    Tokenizer2.prototype.resume = function() {
      this.running = true;
      if (this.index < this.buffer.length + this.offset) {
        this.parse();
      }
    };
    Tokenizer2.prototype.getIndex = function() {
      return this.index;
    };
    Tokenizer2.prototype.getSectionStart = function() {
      return this.sectionStart;
    };
    Tokenizer2.prototype.stateText = function(c2) {
      if (c2 === CharCodes.Lt || !this.decodeEntities && this.fastForwardTo(CharCodes.Lt)) {
        if (this.index > this.sectionStart) {
          this.cbs.ontext(this.sectionStart, this.index);
        }
        this.state = State.BeforeTagName;
        this.sectionStart = this.index;
      } else if (this.decodeEntities && c2 === CharCodes.Amp) {
        this.state = State.BeforeEntity;
      }
    };
    Tokenizer2.prototype.stateSpecialStartSequence = function(c2) {
      var isEnd = this.sequenceIndex === this.currentSequence.length;
      var isMatch = isEnd ? isEndOfTagSection(c2) : (c2 | 32) === this.currentSequence[this.sequenceIndex];
      if (!isMatch) {
        this.isSpecial = false;
      } else if (!isEnd) {
        this.sequenceIndex++;
        return;
      }
      this.sequenceIndex = 0;
      this.state = State.InTagName;
      this.stateInTagName(c2);
    };
    Tokenizer2.prototype.stateInSpecialTag = function(c2) {
      if (this.sequenceIndex === this.currentSequence.length) {
        if (c2 === CharCodes.Gt || isWhitespace(c2)) {
          var endOfText = this.index - this.currentSequence.length;
          if (this.sectionStart < endOfText) {
            var actualIndex = this.index;
            this.index = endOfText;
            this.cbs.ontext(this.sectionStart, endOfText);
            this.index = actualIndex;
          }
          this.isSpecial = false;
          this.sectionStart = endOfText + 2;
          this.stateInClosingTagName(c2);
          return;
        }
        this.sequenceIndex = 0;
      }
      if ((c2 | 32) === this.currentSequence[this.sequenceIndex]) {
        this.sequenceIndex += 1;
      } else if (this.sequenceIndex === 0) {
        if (this.currentSequence === Sequences.TitleEnd) {
          if (this.decodeEntities && c2 === CharCodes.Amp) {
            this.state = State.BeforeEntity;
          }
        } else if (this.fastForwardTo(CharCodes.Lt)) {
          this.sequenceIndex = 1;
        }
      } else {
        this.sequenceIndex = Number(c2 === CharCodes.Lt);
      }
    };
    Tokenizer2.prototype.stateCDATASequence = function(c2) {
      if (c2 === Sequences.Cdata[this.sequenceIndex]) {
        if (++this.sequenceIndex === Sequences.Cdata.length) {
          this.state = State.InCommentLike;
          this.currentSequence = Sequences.CdataEnd;
          this.sequenceIndex = 0;
          this.sectionStart = this.index + 1;
        }
      } else {
        this.sequenceIndex = 0;
        this.state = State.InDeclaration;
        this.stateInDeclaration(c2);
      }
    };
    Tokenizer2.prototype.fastForwardTo = function(c2) {
      while (++this.index < this.buffer.length + this.offset) {
        if (this.buffer.charCodeAt(this.index - this.offset) === c2) {
          return true;
        }
      }
      this.index = this.buffer.length + this.offset - 1;
      return false;
    };
    Tokenizer2.prototype.stateInCommentLike = function(c2) {
      if (c2 === this.currentSequence[this.sequenceIndex]) {
        if (++this.sequenceIndex === this.currentSequence.length) {
          if (this.currentSequence === Sequences.CdataEnd) {
            this.cbs.oncdata(this.sectionStart, this.index, 2);
          } else {
            this.cbs.oncomment(this.sectionStart, this.index, 2);
          }
          this.sequenceIndex = 0;
          this.sectionStart = this.index + 1;
          this.state = State.Text;
        }
      } else if (this.sequenceIndex === 0) {
        if (this.fastForwardTo(this.currentSequence[0])) {
          this.sequenceIndex = 1;
        }
      } else if (c2 !== this.currentSequence[this.sequenceIndex - 1]) {
        this.sequenceIndex = 0;
      }
    };
    Tokenizer2.prototype.isTagStartChar = function(c2) {
      return this.xmlMode ? !isEndOfTagSection(c2) : isASCIIAlpha(c2);
    };
    Tokenizer2.prototype.startSpecial = function(sequence, offset) {
      this.isSpecial = true;
      this.currentSequence = sequence;
      this.sequenceIndex = offset;
      this.state = State.SpecialStartSequence;
    };
    Tokenizer2.prototype.stateBeforeTagName = function(c2) {
      if (c2 === CharCodes.ExclamationMark) {
        this.state = State.BeforeDeclaration;
        this.sectionStart = this.index + 1;
      } else if (c2 === CharCodes.Questionmark) {
        this.state = State.InProcessingInstruction;
        this.sectionStart = this.index + 1;
      } else if (this.isTagStartChar(c2)) {
        var lower = c2 | 32;
        this.sectionStart = this.index;
        if (!this.xmlMode && lower === Sequences.TitleEnd[2]) {
          this.startSpecial(Sequences.TitleEnd, 3);
        } else {
          this.state = !this.xmlMode && lower === Sequences.ScriptEnd[2] ? State.BeforeSpecialS : State.InTagName;
        }
      } else if (c2 === CharCodes.Slash) {
        this.state = State.BeforeClosingTagName;
      } else {
        this.state = State.Text;
        this.stateText(c2);
      }
    };
    Tokenizer2.prototype.stateInTagName = function(c2) {
      if (isEndOfTagSection(c2)) {
        this.cbs.onopentagname(this.sectionStart, this.index);
        this.sectionStart = -1;
        this.state = State.BeforeAttributeName;
        this.stateBeforeAttributeName(c2);
      }
    };
    Tokenizer2.prototype.stateBeforeClosingTagName = function(c2) {
      if (isWhitespace(c2)) {
      } else if (c2 === CharCodes.Gt) {
        this.state = State.Text;
      } else {
        this.state = this.isTagStartChar(c2) ? State.InClosingTagName : State.InSpecialComment;
        this.sectionStart = this.index;
      }
    };
    Tokenizer2.prototype.stateInClosingTagName = function(c2) {
      if (c2 === CharCodes.Gt || isWhitespace(c2)) {
        this.cbs.onclosetag(this.sectionStart, this.index);
        this.sectionStart = -1;
        this.state = State.AfterClosingTagName;
        this.stateAfterClosingTagName(c2);
      }
    };
    Tokenizer2.prototype.stateAfterClosingTagName = function(c2) {
      if (c2 === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
        this.state = State.Text;
        this.baseState = State.Text;
        this.sectionStart = this.index + 1;
      }
    };
    Tokenizer2.prototype.stateBeforeAttributeName = function(c2) {
      if (c2 === CharCodes.Gt) {
        this.cbs.onopentagend(this.index);
        if (this.isSpecial) {
          this.state = State.InSpecialTag;
          this.sequenceIndex = 0;
        } else {
          this.state = State.Text;
        }
        this.baseState = this.state;
        this.sectionStart = this.index + 1;
      } else if (c2 === CharCodes.Slash) {
        this.state = State.InSelfClosingTag;
      } else if (!isWhitespace(c2)) {
        this.state = State.InAttributeName;
        this.sectionStart = this.index;
      }
    };
    Tokenizer2.prototype.stateInSelfClosingTag = function(c2) {
      if (c2 === CharCodes.Gt) {
        this.cbs.onselfclosingtag(this.index);
        this.state = State.Text;
        this.baseState = State.Text;
        this.sectionStart = this.index + 1;
        this.isSpecial = false;
      } else if (!isWhitespace(c2)) {
        this.state = State.BeforeAttributeName;
        this.stateBeforeAttributeName(c2);
      }
    };
    Tokenizer2.prototype.stateInAttributeName = function(c2) {
      if (c2 === CharCodes.Eq || isEndOfTagSection(c2)) {
        this.cbs.onattribname(this.sectionStart, this.index);
        this.sectionStart = -1;
        this.state = State.AfterAttributeName;
        this.stateAfterAttributeName(c2);
      }
    };
    Tokenizer2.prototype.stateAfterAttributeName = function(c2) {
      if (c2 === CharCodes.Eq) {
        this.state = State.BeforeAttributeValue;
      } else if (c2 === CharCodes.Slash || c2 === CharCodes.Gt) {
        this.cbs.onattribend(QuoteType.NoValue, this.index);
        this.state = State.BeforeAttributeName;
        this.stateBeforeAttributeName(c2);
      } else if (!isWhitespace(c2)) {
        this.cbs.onattribend(QuoteType.NoValue, this.index);
        this.state = State.InAttributeName;
        this.sectionStart = this.index;
      }
    };
    Tokenizer2.prototype.stateBeforeAttributeValue = function(c2) {
      if (c2 === CharCodes.DoubleQuote) {
        this.state = State.InAttributeValueDq;
        this.sectionStart = this.index + 1;
      } else if (c2 === CharCodes.SingleQuote) {
        this.state = State.InAttributeValueSq;
        this.sectionStart = this.index + 1;
      } else if (!isWhitespace(c2)) {
        this.sectionStart = this.index;
        this.state = State.InAttributeValueNq;
        this.stateInAttributeValueNoQuotes(c2);
      }
    };
    Tokenizer2.prototype.handleInAttributeValue = function(c2, quote) {
      if (c2 === quote || !this.decodeEntities && this.fastForwardTo(quote)) {
        this.cbs.onattribdata(this.sectionStart, this.index);
        this.sectionStart = -1;
        this.cbs.onattribend(quote === CharCodes.DoubleQuote ? QuoteType.Double : QuoteType.Single, this.index);
        this.state = State.BeforeAttributeName;
      } else if (this.decodeEntities && c2 === CharCodes.Amp) {
        this.baseState = this.state;
        this.state = State.BeforeEntity;
      }
    };
    Tokenizer2.prototype.stateInAttributeValueDoubleQuotes = function(c2) {
      this.handleInAttributeValue(c2, CharCodes.DoubleQuote);
    };
    Tokenizer2.prototype.stateInAttributeValueSingleQuotes = function(c2) {
      this.handleInAttributeValue(c2, CharCodes.SingleQuote);
    };
    Tokenizer2.prototype.stateInAttributeValueNoQuotes = function(c2) {
      if (isWhitespace(c2) || c2 === CharCodes.Gt) {
        this.cbs.onattribdata(this.sectionStart, this.index);
        this.sectionStart = -1;
        this.cbs.onattribend(QuoteType.Unquoted, this.index);
        this.state = State.BeforeAttributeName;
        this.stateBeforeAttributeName(c2);
      } else if (this.decodeEntities && c2 === CharCodes.Amp) {
        this.baseState = this.state;
        this.state = State.BeforeEntity;
      }
    };
    Tokenizer2.prototype.stateBeforeDeclaration = function(c2) {
      if (c2 === CharCodes.OpeningSquareBracket) {
        this.state = State.CDATASequence;
        this.sequenceIndex = 0;
      } else {
        this.state = c2 === CharCodes.Dash ? State.BeforeComment : State.InDeclaration;
      }
    };
    Tokenizer2.prototype.stateInDeclaration = function(c2) {
      if (c2 === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
        this.cbs.ondeclaration(this.sectionStart, this.index);
        this.state = State.Text;
        this.sectionStart = this.index + 1;
      }
    };
    Tokenizer2.prototype.stateInProcessingInstruction = function(c2) {
      if (c2 === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
        this.cbs.onprocessinginstruction(this.sectionStart, this.index);
        this.state = State.Text;
        this.sectionStart = this.index + 1;
      }
    };
    Tokenizer2.prototype.stateBeforeComment = function(c2) {
      if (c2 === CharCodes.Dash) {
        this.state = State.InCommentLike;
        this.currentSequence = Sequences.CommentEnd;
        this.sequenceIndex = 2;
        this.sectionStart = this.index + 1;
      } else {
        this.state = State.InDeclaration;
      }
    };
    Tokenizer2.prototype.stateInSpecialComment = function(c2) {
      if (c2 === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
        this.cbs.oncomment(this.sectionStart, this.index, 0);
        this.state = State.Text;
        this.sectionStart = this.index + 1;
      }
    };
    Tokenizer2.prototype.stateBeforeSpecialS = function(c2) {
      var lower = c2 | 32;
      if (lower === Sequences.ScriptEnd[3]) {
        this.startSpecial(Sequences.ScriptEnd, 4);
      } else if (lower === Sequences.StyleEnd[3]) {
        this.startSpecial(Sequences.StyleEnd, 4);
      } else {
        this.state = State.InTagName;
        this.stateInTagName(c2);
      }
    };
    Tokenizer2.prototype.stateBeforeEntity = function(c2) {
      this.entityExcess = 1;
      this.entityResult = 0;
      if (c2 === CharCodes.Number) {
        this.state = State.BeforeNumericEntity;
      } else if (c2 === CharCodes.Amp) {
      } else {
        this.trieIndex = 0;
        this.trieCurrent = this.entityTrie[0];
        this.state = State.InNamedEntity;
        this.stateInNamedEntity(c2);
      }
    };
    Tokenizer2.prototype.stateInNamedEntity = function(c2) {
      this.entityExcess += 1;
      this.trieIndex = (0, decode_js_1.determineBranch)(this.entityTrie, this.trieCurrent, this.trieIndex + 1, c2);
      if (this.trieIndex < 0) {
        this.emitNamedEntity();
        this.index--;
        return;
      }
      this.trieCurrent = this.entityTrie[this.trieIndex];
      var masked = this.trieCurrent & decode_js_1.BinTrieFlags.VALUE_LENGTH;
      if (masked) {
        var valueLength = (masked >> 14) - 1;
        if (!this.allowLegacyEntity() && c2 !== CharCodes.Semi) {
          this.trieIndex += valueLength;
        } else {
          var entityStart = this.index - this.entityExcess + 1;
          if (entityStart > this.sectionStart) {
            this.emitPartial(this.sectionStart, entityStart);
          }
          this.entityResult = this.trieIndex;
          this.trieIndex += valueLength;
          this.entityExcess = 0;
          this.sectionStart = this.index + 1;
          if (valueLength === 0) {
            this.emitNamedEntity();
          }
        }
      }
    };
    Tokenizer2.prototype.emitNamedEntity = function() {
      this.state = this.baseState;
      if (this.entityResult === 0) {
        return;
      }
      var valueLength = (this.entityTrie[this.entityResult] & decode_js_1.BinTrieFlags.VALUE_LENGTH) >> 14;
      switch (valueLength) {
        case 1: {
          this.emitCodePoint(this.entityTrie[this.entityResult] & ~decode_js_1.BinTrieFlags.VALUE_LENGTH);
          break;
        }
        case 2: {
          this.emitCodePoint(this.entityTrie[this.entityResult + 1]);
          break;
        }
        case 3: {
          this.emitCodePoint(this.entityTrie[this.entityResult + 1]);
          this.emitCodePoint(this.entityTrie[this.entityResult + 2]);
        }
      }
    };
    Tokenizer2.prototype.stateBeforeNumericEntity = function(c2) {
      if ((c2 | 32) === CharCodes.LowerX) {
        this.entityExcess++;
        this.state = State.InHexEntity;
      } else {
        this.state = State.InNumericEntity;
        this.stateInNumericEntity(c2);
      }
    };
    Tokenizer2.prototype.emitNumericEntity = function(strict) {
      var entityStart = this.index - this.entityExcess - 1;
      var numberStart = entityStart + 2 + Number(this.state === State.InHexEntity);
      if (numberStart !== this.index) {
        if (entityStart > this.sectionStart) {
          this.emitPartial(this.sectionStart, entityStart);
        }
        this.sectionStart = this.index + Number(strict);
        this.emitCodePoint((0, decode_js_1.replaceCodePoint)(this.entityResult));
      }
      this.state = this.baseState;
    };
    Tokenizer2.prototype.stateInNumericEntity = function(c2) {
      if (c2 === CharCodes.Semi) {
        this.emitNumericEntity(true);
      } else if (isNumber(c2)) {
        this.entityResult = this.entityResult * 10 + (c2 - CharCodes.Zero);
        this.entityExcess++;
      } else {
        if (this.allowLegacyEntity()) {
          this.emitNumericEntity(false);
        } else {
          this.state = this.baseState;
        }
        this.index--;
      }
    };
    Tokenizer2.prototype.stateInHexEntity = function(c2) {
      if (c2 === CharCodes.Semi) {
        this.emitNumericEntity(true);
      } else if (isNumber(c2)) {
        this.entityResult = this.entityResult * 16 + (c2 - CharCodes.Zero);
        this.entityExcess++;
      } else if (isHexDigit(c2)) {
        this.entityResult = this.entityResult * 16 + ((c2 | 32) - CharCodes.LowerA + 10);
        this.entityExcess++;
      } else {
        if (this.allowLegacyEntity()) {
          this.emitNumericEntity(false);
        } else {
          this.state = this.baseState;
        }
        this.index--;
      }
    };
    Tokenizer2.prototype.allowLegacyEntity = function() {
      return !this.xmlMode && (this.baseState === State.Text || this.baseState === State.InSpecialTag);
    };
    Tokenizer2.prototype.cleanup = function() {
      if (this.running && this.sectionStart !== this.index) {
        if (this.state === State.Text || this.state === State.InSpecialTag && this.sequenceIndex === 0) {
          this.cbs.ontext(this.sectionStart, this.index);
          this.sectionStart = this.index;
        } else if (this.state === State.InAttributeValueDq || this.state === State.InAttributeValueSq || this.state === State.InAttributeValueNq) {
          this.cbs.onattribdata(this.sectionStart, this.index);
          this.sectionStart = this.index;
        }
      }
    };
    Tokenizer2.prototype.shouldContinue = function() {
      return this.index < this.buffer.length + this.offset && this.running;
    };
    Tokenizer2.prototype.parse = function() {
      while (this.shouldContinue()) {
        var c2 = this.buffer.charCodeAt(this.index - this.offset);
        switch (this.state) {
          case State.Text: {
            this.stateText(c2);
            break;
          }
          case State.SpecialStartSequence: {
            this.stateSpecialStartSequence(c2);
            break;
          }
          case State.InSpecialTag: {
            this.stateInSpecialTag(c2);
            break;
          }
          case State.CDATASequence: {
            this.stateCDATASequence(c2);
            break;
          }
          case State.InAttributeValueDq: {
            this.stateInAttributeValueDoubleQuotes(c2);
            break;
          }
          case State.InAttributeName: {
            this.stateInAttributeName(c2);
            break;
          }
          case State.InCommentLike: {
            this.stateInCommentLike(c2);
            break;
          }
          case State.InSpecialComment: {
            this.stateInSpecialComment(c2);
            break;
          }
          case State.BeforeAttributeName: {
            this.stateBeforeAttributeName(c2);
            break;
          }
          case State.InTagName: {
            this.stateInTagName(c2);
            break;
          }
          case State.InClosingTagName: {
            this.stateInClosingTagName(c2);
            break;
          }
          case State.BeforeTagName: {
            this.stateBeforeTagName(c2);
            break;
          }
          case State.AfterAttributeName: {
            this.stateAfterAttributeName(c2);
            break;
          }
          case State.InAttributeValueSq: {
            this.stateInAttributeValueSingleQuotes(c2);
            break;
          }
          case State.BeforeAttributeValue: {
            this.stateBeforeAttributeValue(c2);
            break;
          }
          case State.BeforeClosingTagName: {
            this.stateBeforeClosingTagName(c2);
            break;
          }
          case State.AfterClosingTagName: {
            this.stateAfterClosingTagName(c2);
            break;
          }
          case State.BeforeSpecialS: {
            this.stateBeforeSpecialS(c2);
            break;
          }
          case State.InAttributeValueNq: {
            this.stateInAttributeValueNoQuotes(c2);
            break;
          }
          case State.InSelfClosingTag: {
            this.stateInSelfClosingTag(c2);
            break;
          }
          case State.InDeclaration: {
            this.stateInDeclaration(c2);
            break;
          }
          case State.BeforeDeclaration: {
            this.stateBeforeDeclaration(c2);
            break;
          }
          case State.BeforeComment: {
            this.stateBeforeComment(c2);
            break;
          }
          case State.InProcessingInstruction: {
            this.stateInProcessingInstruction(c2);
            break;
          }
          case State.InNamedEntity: {
            this.stateInNamedEntity(c2);
            break;
          }
          case State.BeforeEntity: {
            this.stateBeforeEntity(c2);
            break;
          }
          case State.InHexEntity: {
            this.stateInHexEntity(c2);
            break;
          }
          case State.InNumericEntity: {
            this.stateInNumericEntity(c2);
            break;
          }
          default: {
            this.stateBeforeNumericEntity(c2);
          }
        }
        this.index++;
      }
      this.cleanup();
    };
    Tokenizer2.prototype.finish = function() {
      if (this.state === State.InNamedEntity) {
        this.emitNamedEntity();
      }
      if (this.sectionStart < this.index) {
        this.handleTrailingData();
      }
      this.cbs.onend();
    };
    Tokenizer2.prototype.handleTrailingData = function() {
      var endIndex = this.buffer.length + this.offset;
      if (this.state === State.InCommentLike) {
        if (this.currentSequence === Sequences.CdataEnd) {
          this.cbs.oncdata(this.sectionStart, endIndex, 0);
        } else {
          this.cbs.oncomment(this.sectionStart, endIndex, 0);
        }
      } else if (this.state === State.InNumericEntity && this.allowLegacyEntity()) {
        this.emitNumericEntity(false);
      } else if (this.state === State.InHexEntity && this.allowLegacyEntity()) {
        this.emitNumericEntity(false);
      } else if (this.state === State.InTagName || this.state === State.BeforeAttributeName || this.state === State.BeforeAttributeValue || this.state === State.AfterAttributeName || this.state === State.InAttributeName || this.state === State.InAttributeValueSq || this.state === State.InAttributeValueDq || this.state === State.InAttributeValueNq || this.state === State.InClosingTagName) {
      } else {
        this.cbs.ontext(this.sectionStart, endIndex);
      }
    };
    Tokenizer2.prototype.emitPartial = function(start, endIndex) {
      if (this.baseState !== State.Text && this.baseState !== State.InSpecialTag) {
        this.cbs.onattribdata(start, endIndex);
      } else {
        this.cbs.ontext(start, endIndex);
      }
    };
    Tokenizer2.prototype.emitCodePoint = function(cp) {
      if (this.baseState !== State.Text && this.baseState !== State.InSpecialTag) {
        this.cbs.onattribentity(cp);
      } else {
        this.cbs.ontextentity(cp);
      }
    };
    return Tokenizer2;
  }();
  exports.default = Tokenizer;
});

// node_modules/htmlparser2/lib/Parser.js
var require_Parser = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc2 = Object.getOwnPropertyDescriptor(m, k);
    if (!desc2 || ("get" in desc2 ? !m.__esModule : desc2.writable || desc2.configurable)) {
      desc2 = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o2, k2, desc2);
  } : function(o2, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o2[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v) {
    Object.defineProperty(o2, "default", { enumerable: true, value: v });
  } : function(o2, v) {
    o2["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result2 = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result2, mod, k);
    }
    __setModuleDefault(result2, mod);
    return result2;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Parser = undefined;
  var Tokenizer_js_1 = __importStar(require_Tokenizer());
  var decode_js_1 = require_decode();
  var formTags = new Set([
    "input",
    "option",
    "optgroup",
    "select",
    "button",
    "datalist",
    "textarea"
  ]);
  var pTag = new Set(["p"]);
  var tableSectionTags = new Set(["thead", "tbody"]);
  var ddtTags = new Set(["dd", "dt"]);
  var rtpTags = new Set(["rt", "rp"]);
  var openImpliesClose = new Map([
    ["tr", new Set(["tr", "th", "td"])],
    ["th", new Set(["th"])],
    ["td", new Set(["thead", "th", "td"])],
    ["body", new Set(["head", "link", "script"])],
    ["li", new Set(["li"])],
    ["p", pTag],
    ["h1", pTag],
    ["h2", pTag],
    ["h3", pTag],
    ["h4", pTag],
    ["h5", pTag],
    ["h6", pTag],
    ["select", formTags],
    ["input", formTags],
    ["output", formTags],
    ["button", formTags],
    ["datalist", formTags],
    ["textarea", formTags],
    ["option", new Set(["option"])],
    ["optgroup", new Set(["optgroup", "option"])],
    ["dd", ddtTags],
    ["dt", ddtTags],
    ["address", pTag],
    ["article", pTag],
    ["aside", pTag],
    ["blockquote", pTag],
    ["details", pTag],
    ["div", pTag],
    ["dl", pTag],
    ["fieldset", pTag],
    ["figcaption", pTag],
    ["figure", pTag],
    ["footer", pTag],
    ["form", pTag],
    ["header", pTag],
    ["hr", pTag],
    ["main", pTag],
    ["nav", pTag],
    ["ol", pTag],
    ["pre", pTag],
    ["section", pTag],
    ["table", pTag],
    ["ul", pTag],
    ["rt", rtpTags],
    ["rp", rtpTags],
    ["tbody", tableSectionTags],
    ["tfoot", tableSectionTags]
  ]);
  var voidElements = new Set([
    "area",
    "base",
    "basefont",
    "br",
    "col",
    "command",
    "embed",
    "frame",
    "hr",
    "img",
    "input",
    "isindex",
    "keygen",
    "link",
    "meta",
    "param",
    "source",
    "track",
    "wbr"
  ]);
  var foreignContextElements = new Set(["math", "svg"]);
  var htmlIntegrationElements = new Set([
    "mi",
    "mo",
    "mn",
    "ms",
    "mtext",
    "annotation-xml",
    "foreignobject",
    "desc",
    "title"
  ]);
  var reNameEnd = /\s|\//;
  var Parser = function() {
    function Parser2(cbs, options) {
      if (options === undefined) {
        options = {};
      }
      var _a, _b, _c, _d, _e;
      this.options = options;
      this.startIndex = 0;
      this.endIndex = 0;
      this.openTagStart = 0;
      this.tagname = "";
      this.attribname = "";
      this.attribvalue = "";
      this.attribs = null;
      this.stack = [];
      this.foreignContext = [];
      this.buffers = [];
      this.bufferOffset = 0;
      this.writeIndex = 0;
      this.ended = false;
      this.cbs = cbs !== null && cbs !== undefined ? cbs : {};
      this.lowerCaseTagNames = (_a = options.lowerCaseTags) !== null && _a !== undefined ? _a : !options.xmlMode;
      this.lowerCaseAttributeNames = (_b = options.lowerCaseAttributeNames) !== null && _b !== undefined ? _b : !options.xmlMode;
      this.tokenizer = new ((_c = options.Tokenizer) !== null && _c !== undefined ? _c : Tokenizer_js_1.default)(this.options, this);
      (_e = (_d = this.cbs).onparserinit) === null || _e === undefined || _e.call(_d, this);
    }
    Parser2.prototype.ontext = function(start, endIndex) {
      var _a, _b;
      var data = this.getSlice(start, endIndex);
      this.endIndex = endIndex - 1;
      (_b = (_a = this.cbs).ontext) === null || _b === undefined || _b.call(_a, data);
      this.startIndex = endIndex;
    };
    Parser2.prototype.ontextentity = function(cp) {
      var _a, _b;
      var index = this.tokenizer.getSectionStart();
      this.endIndex = index - 1;
      (_b = (_a = this.cbs).ontext) === null || _b === undefined || _b.call(_a, (0, decode_js_1.fromCodePoint)(cp));
      this.startIndex = index;
    };
    Parser2.prototype.isVoidElement = function(name) {
      return !this.options.xmlMode && voidElements.has(name);
    };
    Parser2.prototype.onopentagname = function(start, endIndex) {
      this.endIndex = endIndex;
      var name = this.getSlice(start, endIndex);
      if (this.lowerCaseTagNames) {
        name = name.toLowerCase();
      }
      this.emitOpenTag(name);
    };
    Parser2.prototype.emitOpenTag = function(name) {
      var _a, _b, _c, _d;
      this.openTagStart = this.startIndex;
      this.tagname = name;
      var impliesClose = !this.options.xmlMode && openImpliesClose.get(name);
      if (impliesClose) {
        while (this.stack.length > 0 && impliesClose.has(this.stack[this.stack.length - 1])) {
          var element = this.stack.pop();
          (_b = (_a = this.cbs).onclosetag) === null || _b === undefined || _b.call(_a, element, true);
        }
      }
      if (!this.isVoidElement(name)) {
        this.stack.push(name);
        if (foreignContextElements.has(name)) {
          this.foreignContext.push(true);
        } else if (htmlIntegrationElements.has(name)) {
          this.foreignContext.push(false);
        }
      }
      (_d = (_c = this.cbs).onopentagname) === null || _d === undefined || _d.call(_c, name);
      if (this.cbs.onopentag)
        this.attribs = {};
    };
    Parser2.prototype.endOpenTag = function(isImplied) {
      var _a, _b;
      this.startIndex = this.openTagStart;
      if (this.attribs) {
        (_b = (_a = this.cbs).onopentag) === null || _b === undefined || _b.call(_a, this.tagname, this.attribs, isImplied);
        this.attribs = null;
      }
      if (this.cbs.onclosetag && this.isVoidElement(this.tagname)) {
        this.cbs.onclosetag(this.tagname, true);
      }
      this.tagname = "";
    };
    Parser2.prototype.onopentagend = function(endIndex) {
      this.endIndex = endIndex;
      this.endOpenTag(false);
      this.startIndex = endIndex + 1;
    };
    Parser2.prototype.onclosetag = function(start, endIndex) {
      var _a, _b, _c, _d, _e, _f;
      this.endIndex = endIndex;
      var name = this.getSlice(start, endIndex);
      if (this.lowerCaseTagNames) {
        name = name.toLowerCase();
      }
      if (foreignContextElements.has(name) || htmlIntegrationElements.has(name)) {
        this.foreignContext.pop();
      }
      if (!this.isVoidElement(name)) {
        var pos = this.stack.lastIndexOf(name);
        if (pos !== -1) {
          if (this.cbs.onclosetag) {
            var count2 = this.stack.length - pos;
            while (count2--) {
              this.cbs.onclosetag(this.stack.pop(), count2 !== 0);
            }
          } else
            this.stack.length = pos;
        } else if (!this.options.xmlMode && name === "p") {
          this.emitOpenTag("p");
          this.closeCurrentTag(true);
        }
      } else if (!this.options.xmlMode && name === "br") {
        (_b = (_a = this.cbs).onopentagname) === null || _b === undefined || _b.call(_a, "br");
        (_d = (_c = this.cbs).onopentag) === null || _d === undefined || _d.call(_c, "br", {}, true);
        (_f = (_e = this.cbs).onclosetag) === null || _f === undefined || _f.call(_e, "br", false);
      }
      this.startIndex = endIndex + 1;
    };
    Parser2.prototype.onselfclosingtag = function(endIndex) {
      this.endIndex = endIndex;
      if (this.options.xmlMode || this.options.recognizeSelfClosing || this.foreignContext[this.foreignContext.length - 1]) {
        this.closeCurrentTag(false);
        this.startIndex = endIndex + 1;
      } else {
        this.onopentagend(endIndex);
      }
    };
    Parser2.prototype.closeCurrentTag = function(isOpenImplied) {
      var _a, _b;
      var name = this.tagname;
      this.endOpenTag(isOpenImplied);
      if (this.stack[this.stack.length - 1] === name) {
        (_b = (_a = this.cbs).onclosetag) === null || _b === undefined || _b.call(_a, name, !isOpenImplied);
        this.stack.pop();
      }
    };
    Parser2.prototype.onattribname = function(start, endIndex) {
      this.startIndex = start;
      var name = this.getSlice(start, endIndex);
      this.attribname = this.lowerCaseAttributeNames ? name.toLowerCase() : name;
    };
    Parser2.prototype.onattribdata = function(start, endIndex) {
      this.attribvalue += this.getSlice(start, endIndex);
    };
    Parser2.prototype.onattribentity = function(cp) {
      this.attribvalue += (0, decode_js_1.fromCodePoint)(cp);
    };
    Parser2.prototype.onattribend = function(quote, endIndex) {
      var _a, _b;
      this.endIndex = endIndex;
      (_b = (_a = this.cbs).onattribute) === null || _b === undefined || _b.call(_a, this.attribname, this.attribvalue, quote === Tokenizer_js_1.QuoteType.Double ? '"' : quote === Tokenizer_js_1.QuoteType.Single ? "'" : quote === Tokenizer_js_1.QuoteType.NoValue ? undefined : null);
      if (this.attribs && !Object.prototype.hasOwnProperty.call(this.attribs, this.attribname)) {
        this.attribs[this.attribname] = this.attribvalue;
      }
      this.attribvalue = "";
    };
    Parser2.prototype.getInstructionName = function(value) {
      var index = value.search(reNameEnd);
      var name = index < 0 ? value : value.substr(0, index);
      if (this.lowerCaseTagNames) {
        name = name.toLowerCase();
      }
      return name;
    };
    Parser2.prototype.ondeclaration = function(start, endIndex) {
      this.endIndex = endIndex;
      var value = this.getSlice(start, endIndex);
      if (this.cbs.onprocessinginstruction) {
        var name = this.getInstructionName(value);
        this.cbs.onprocessinginstruction("!".concat(name), "!".concat(value));
      }
      this.startIndex = endIndex + 1;
    };
    Parser2.prototype.onprocessinginstruction = function(start, endIndex) {
      this.endIndex = endIndex;
      var value = this.getSlice(start, endIndex);
      if (this.cbs.onprocessinginstruction) {
        var name = this.getInstructionName(value);
        this.cbs.onprocessinginstruction("?".concat(name), "?".concat(value));
      }
      this.startIndex = endIndex + 1;
    };
    Parser2.prototype.oncomment = function(start, endIndex, offset) {
      var _a, _b, _c, _d;
      this.endIndex = endIndex;
      (_b = (_a = this.cbs).oncomment) === null || _b === undefined || _b.call(_a, this.getSlice(start, endIndex - offset));
      (_d = (_c = this.cbs).oncommentend) === null || _d === undefined || _d.call(_c);
      this.startIndex = endIndex + 1;
    };
    Parser2.prototype.oncdata = function(start, endIndex, offset) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      this.endIndex = endIndex;
      var value = this.getSlice(start, endIndex - offset);
      if (this.options.xmlMode || this.options.recognizeCDATA) {
        (_b = (_a = this.cbs).oncdatastart) === null || _b === undefined || _b.call(_a);
        (_d = (_c = this.cbs).ontext) === null || _d === undefined || _d.call(_c, value);
        (_f = (_e = this.cbs).oncdataend) === null || _f === undefined || _f.call(_e);
      } else {
        (_h = (_g = this.cbs).oncomment) === null || _h === undefined || _h.call(_g, "[CDATA[".concat(value, "]]"));
        (_k = (_j = this.cbs).oncommentend) === null || _k === undefined || _k.call(_j);
      }
      this.startIndex = endIndex + 1;
    };
    Parser2.prototype.onend = function() {
      var _a, _b;
      if (this.cbs.onclosetag) {
        this.endIndex = this.startIndex;
        for (var index = this.stack.length;index > 0; this.cbs.onclosetag(this.stack[--index], true))
          ;
      }
      (_b = (_a = this.cbs).onend) === null || _b === undefined || _b.call(_a);
    };
    Parser2.prototype.reset = function() {
      var _a, _b, _c, _d;
      (_b = (_a = this.cbs).onreset) === null || _b === undefined || _b.call(_a);
      this.tokenizer.reset();
      this.tagname = "";
      this.attribname = "";
      this.attribs = null;
      this.stack.length = 0;
      this.startIndex = 0;
      this.endIndex = 0;
      (_d = (_c = this.cbs).onparserinit) === null || _d === undefined || _d.call(_c, this);
      this.buffers.length = 0;
      this.bufferOffset = 0;
      this.writeIndex = 0;
      this.ended = false;
    };
    Parser2.prototype.parseComplete = function(data) {
      this.reset();
      this.end(data);
    };
    Parser2.prototype.getSlice = function(start, end) {
      while (start - this.bufferOffset >= this.buffers[0].length) {
        this.shiftBuffer();
      }
      var slice = this.buffers[0].slice(start - this.bufferOffset, end - this.bufferOffset);
      while (end - this.bufferOffset > this.buffers[0].length) {
        this.shiftBuffer();
        slice += this.buffers[0].slice(0, end - this.bufferOffset);
      }
      return slice;
    };
    Parser2.prototype.shiftBuffer = function() {
      this.bufferOffset += this.buffers[0].length;
      this.writeIndex--;
      this.buffers.shift();
    };
    Parser2.prototype.write = function(chunk) {
      var _a, _b;
      if (this.ended) {
        (_b = (_a = this.cbs).onerror) === null || _b === undefined || _b.call(_a, new Error(".write() after done!"));
        return;
      }
      this.buffers.push(chunk);
      if (this.tokenizer.running) {
        this.tokenizer.write(chunk);
        this.writeIndex++;
      }
    };
    Parser2.prototype.end = function(chunk) {
      var _a, _b;
      if (this.ended) {
        (_b = (_a = this.cbs).onerror) === null || _b === undefined || _b.call(_a, new Error(".end() after done!"));
        return;
      }
      if (chunk)
        this.write(chunk);
      this.ended = true;
      this.tokenizer.end();
    };
    Parser2.prototype.pause = function() {
      this.tokenizer.pause();
    };
    Parser2.prototype.resume = function() {
      this.tokenizer.resume();
      while (this.tokenizer.running && this.writeIndex < this.buffers.length) {
        this.tokenizer.write(this.buffers[this.writeIndex++]);
      }
      if (this.ended)
        this.tokenizer.end();
    };
    Parser2.prototype.parseChunk = function(chunk) {
      this.write(chunk);
    };
    Parser2.prototype.done = function(chunk) {
      this.end(chunk);
    };
    return Parser2;
  }();
  exports.Parser = Parser;
});

// node_modules/entities/lib/generated/encode-html.js
var require_encode_html = __commonJS((exports) => {
  var restoreDiff = function(arr) {
    for (var i = 1;i < arr.length; i++) {
      arr[i][0] += arr[i - 1][0] + 1;
    }
    return arr;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = new Map(restoreDiff([[9, "&Tab;"], [0, "&NewLine;"], [22, "&excl;"], [0, "&quot;"], [0, "&num;"], [0, "&dollar;"], [0, "&percnt;"], [0, "&amp;"], [0, "&apos;"], [0, "&lpar;"], [0, "&rpar;"], [0, "&ast;"], [0, "&plus;"], [0, "&comma;"], [1, "&period;"], [0, "&sol;"], [10, "&colon;"], [0, "&semi;"], [0, { v: "&lt;", n: 8402, o: "&nvlt;" }], [0, { v: "&equals;", n: 8421, o: "&bne;" }], [0, { v: "&gt;", n: 8402, o: "&nvgt;" }], [0, "&quest;"], [0, "&commat;"], [26, "&lbrack;"], [0, "&bsol;"], [0, "&rbrack;"], [0, "&Hat;"], [0, "&lowbar;"], [0, "&DiacriticalGrave;"], [5, { n: 106, o: "&fjlig;" }], [20, "&lbrace;"], [0, "&verbar;"], [0, "&rbrace;"], [34, "&nbsp;"], [0, "&iexcl;"], [0, "&cent;"], [0, "&pound;"], [0, "&curren;"], [0, "&yen;"], [0, "&brvbar;"], [0, "&sect;"], [0, "&die;"], [0, "&copy;"], [0, "&ordf;"], [0, "&laquo;"], [0, "&not;"], [0, "&shy;"], [0, "&circledR;"], [0, "&macr;"], [0, "&deg;"], [0, "&PlusMinus;"], [0, "&sup2;"], [0, "&sup3;"], [0, "&acute;"], [0, "&micro;"], [0, "&para;"], [0, "&centerdot;"], [0, "&cedil;"], [0, "&sup1;"], [0, "&ordm;"], [0, "&raquo;"], [0, "&frac14;"], [0, "&frac12;"], [0, "&frac34;"], [0, "&iquest;"], [0, "&Agrave;"], [0, "&Aacute;"], [0, "&Acirc;"], [0, "&Atilde;"], [0, "&Auml;"], [0, "&angst;"], [0, "&AElig;"], [0, "&Ccedil;"], [0, "&Egrave;"], [0, "&Eacute;"], [0, "&Ecirc;"], [0, "&Euml;"], [0, "&Igrave;"], [0, "&Iacute;"], [0, "&Icirc;"], [0, "&Iuml;"], [0, "&ETH;"], [0, "&Ntilde;"], [0, "&Ograve;"], [0, "&Oacute;"], [0, "&Ocirc;"], [0, "&Otilde;"], [0, "&Ouml;"], [0, "&times;"], [0, "&Oslash;"], [0, "&Ugrave;"], [0, "&Uacute;"], [0, "&Ucirc;"], [0, "&Uuml;"], [0, "&Yacute;"], [0, "&THORN;"], [0, "&szlig;"], [0, "&agrave;"], [0, "&aacute;"], [0, "&acirc;"], [0, "&atilde;"], [0, "&auml;"], [0, "&aring;"], [0, "&aelig;"], [0, "&ccedil;"], [0, "&egrave;"], [0, "&eacute;"], [0, "&ecirc;"], [0, "&euml;"], [0, "&igrave;"], [0, "&iacute;"], [0, "&icirc;"], [0, "&iuml;"], [0, "&eth;"], [0, "&ntilde;"], [0, "&ograve;"], [0, "&oacute;"], [0, "&ocirc;"], [0, "&otilde;"], [0, "&ouml;"], [0, "&div;"], [0, "&oslash;"], [0, "&ugrave;"], [0, "&uacute;"], [0, "&ucirc;"], [0, "&uuml;"], [0, "&yacute;"], [0, "&thorn;"], [0, "&yuml;"], [0, "&Amacr;"], [0, "&amacr;"], [0, "&Abreve;"], [0, "&abreve;"], [0, "&Aogon;"], [0, "&aogon;"], [0, "&Cacute;"], [0, "&cacute;"], [0, "&Ccirc;"], [0, "&ccirc;"], [0, "&Cdot;"], [0, "&cdot;"], [0, "&Ccaron;"], [0, "&ccaron;"], [0, "&Dcaron;"], [0, "&dcaron;"], [0, "&Dstrok;"], [0, "&dstrok;"], [0, "&Emacr;"], [0, "&emacr;"], [2, "&Edot;"], [0, "&edot;"], [0, "&Eogon;"], [0, "&eogon;"], [0, "&Ecaron;"], [0, "&ecaron;"], [0, "&Gcirc;"], [0, "&gcirc;"], [0, "&Gbreve;"], [0, "&gbreve;"], [0, "&Gdot;"], [0, "&gdot;"], [0, "&Gcedil;"], [1, "&Hcirc;"], [0, "&hcirc;"], [0, "&Hstrok;"], [0, "&hstrok;"], [0, "&Itilde;"], [0, "&itilde;"], [0, "&Imacr;"], [0, "&imacr;"], [2, "&Iogon;"], [0, "&iogon;"], [0, "&Idot;"], [0, "&imath;"], [0, "&IJlig;"], [0, "&ijlig;"], [0, "&Jcirc;"], [0, "&jcirc;"], [0, "&Kcedil;"], [0, "&kcedil;"], [0, "&kgreen;"], [0, "&Lacute;"], [0, "&lacute;"], [0, "&Lcedil;"], [0, "&lcedil;"], [0, "&Lcaron;"], [0, "&lcaron;"], [0, "&Lmidot;"], [0, "&lmidot;"], [0, "&Lstrok;"], [0, "&lstrok;"], [0, "&Nacute;"], [0, "&nacute;"], [0, "&Ncedil;"], [0, "&ncedil;"], [0, "&Ncaron;"], [0, "&ncaron;"], [0, "&napos;"], [0, "&ENG;"], [0, "&eng;"], [0, "&Omacr;"], [0, "&omacr;"], [2, "&Odblac;"], [0, "&odblac;"], [0, "&OElig;"], [0, "&oelig;"], [0, "&Racute;"], [0, "&racute;"], [0, "&Rcedil;"], [0, "&rcedil;"], [0, "&Rcaron;"], [0, "&rcaron;"], [0, "&Sacute;"], [0, "&sacute;"], [0, "&Scirc;"], [0, "&scirc;"], [0, "&Scedil;"], [0, "&scedil;"], [0, "&Scaron;"], [0, "&scaron;"], [0, "&Tcedil;"], [0, "&tcedil;"], [0, "&Tcaron;"], [0, "&tcaron;"], [0, "&Tstrok;"], [0, "&tstrok;"], [0, "&Utilde;"], [0, "&utilde;"], [0, "&Umacr;"], [0, "&umacr;"], [0, "&Ubreve;"], [0, "&ubreve;"], [0, "&Uring;"], [0, "&uring;"], [0, "&Udblac;"], [0, "&udblac;"], [0, "&Uogon;"], [0, "&uogon;"], [0, "&Wcirc;"], [0, "&wcirc;"], [0, "&Ycirc;"], [0, "&ycirc;"], [0, "&Yuml;"], [0, "&Zacute;"], [0, "&zacute;"], [0, "&Zdot;"], [0, "&zdot;"], [0, "&Zcaron;"], [0, "&zcaron;"], [19, "&fnof;"], [34, "&imped;"], [63, "&gacute;"], [65, "&jmath;"], [142, "&circ;"], [0, "&caron;"], [16, "&breve;"], [0, "&DiacriticalDot;"], [0, "&ring;"], [0, "&ogon;"], [0, "&DiacriticalTilde;"], [0, "&dblac;"], [51, "&DownBreve;"], [127, "&Alpha;"], [0, "&Beta;"], [0, "&Gamma;"], [0, "&Delta;"], [0, "&Epsilon;"], [0, "&Zeta;"], [0, "&Eta;"], [0, "&Theta;"], [0, "&Iota;"], [0, "&Kappa;"], [0, "&Lambda;"], [0, "&Mu;"], [0, "&Nu;"], [0, "&Xi;"], [0, "&Omicron;"], [0, "&Pi;"], [0, "&Rho;"], [1, "&Sigma;"], [0, "&Tau;"], [0, "&Upsilon;"], [0, "&Phi;"], [0, "&Chi;"], [0, "&Psi;"], [0, "&ohm;"], [7, "&alpha;"], [0, "&beta;"], [0, "&gamma;"], [0, "&delta;"], [0, "&epsi;"], [0, "&zeta;"], [0, "&eta;"], [0, "&theta;"], [0, "&iota;"], [0, "&kappa;"], [0, "&lambda;"], [0, "&mu;"], [0, "&nu;"], [0, "&xi;"], [0, "&omicron;"], [0, "&pi;"], [0, "&rho;"], [0, "&sigmaf;"], [0, "&sigma;"], [0, "&tau;"], [0, "&upsi;"], [0, "&phi;"], [0, "&chi;"], [0, "&psi;"], [0, "&omega;"], [7, "&thetasym;"], [0, "&Upsi;"], [2, "&phiv;"], [0, "&piv;"], [5, "&Gammad;"], [0, "&digamma;"], [18, "&kappav;"], [0, "&rhov;"], [3, "&epsiv;"], [0, "&backepsilon;"], [10, "&IOcy;"], [0, "&DJcy;"], [0, "&GJcy;"], [0, "&Jukcy;"], [0, "&DScy;"], [0, "&Iukcy;"], [0, "&YIcy;"], [0, "&Jsercy;"], [0, "&LJcy;"], [0, "&NJcy;"], [0, "&TSHcy;"], [0, "&KJcy;"], [1, "&Ubrcy;"], [0, "&DZcy;"], [0, "&Acy;"], [0, "&Bcy;"], [0, "&Vcy;"], [0, "&Gcy;"], [0, "&Dcy;"], [0, "&IEcy;"], [0, "&ZHcy;"], [0, "&Zcy;"], [0, "&Icy;"], [0, "&Jcy;"], [0, "&Kcy;"], [0, "&Lcy;"], [0, "&Mcy;"], [0, "&Ncy;"], [0, "&Ocy;"], [0, "&Pcy;"], [0, "&Rcy;"], [0, "&Scy;"], [0, "&Tcy;"], [0, "&Ucy;"], [0, "&Fcy;"], [0, "&KHcy;"], [0, "&TScy;"], [0, "&CHcy;"], [0, "&SHcy;"], [0, "&SHCHcy;"], [0, "&HARDcy;"], [0, "&Ycy;"], [0, "&SOFTcy;"], [0, "&Ecy;"], [0, "&YUcy;"], [0, "&YAcy;"], [0, "&acy;"], [0, "&bcy;"], [0, "&vcy;"], [0, "&gcy;"], [0, "&dcy;"], [0, "&iecy;"], [0, "&zhcy;"], [0, "&zcy;"], [0, "&icy;"], [0, "&jcy;"], [0, "&kcy;"], [0, "&lcy;"], [0, "&mcy;"], [0, "&ncy;"], [0, "&ocy;"], [0, "&pcy;"], [0, "&rcy;"], [0, "&scy;"], [0, "&tcy;"], [0, "&ucy;"], [0, "&fcy;"], [0, "&khcy;"], [0, "&tscy;"], [0, "&chcy;"], [0, "&shcy;"], [0, "&shchcy;"], [0, "&hardcy;"], [0, "&ycy;"], [0, "&softcy;"], [0, "&ecy;"], [0, "&yucy;"], [0, "&yacy;"], [1, "&iocy;"], [0, "&djcy;"], [0, "&gjcy;"], [0, "&jukcy;"], [0, "&dscy;"], [0, "&iukcy;"], [0, "&yicy;"], [0, "&jsercy;"], [0, "&ljcy;"], [0, "&njcy;"], [0, "&tshcy;"], [0, "&kjcy;"], [1, "&ubrcy;"], [0, "&dzcy;"], [7074, "&ensp;"], [0, "&emsp;"], [0, "&emsp13;"], [0, "&emsp14;"], [1, "&numsp;"], [0, "&puncsp;"], [0, "&ThinSpace;"], [0, "&hairsp;"], [0, "&NegativeMediumSpace;"], [0, "&zwnj;"], [0, "&zwj;"], [0, "&lrm;"], [0, "&rlm;"], [0, "&dash;"], [2, "&ndash;"], [0, "&mdash;"], [0, "&horbar;"], [0, "&Verbar;"], [1, "&lsquo;"], [0, "&CloseCurlyQuote;"], [0, "&lsquor;"], [1, "&ldquo;"], [0, "&CloseCurlyDoubleQuote;"], [0, "&bdquo;"], [1, "&dagger;"], [0, "&Dagger;"], [0, "&bull;"], [2, "&nldr;"], [0, "&hellip;"], [9, "&permil;"], [0, "&pertenk;"], [0, "&prime;"], [0, "&Prime;"], [0, "&tprime;"], [0, "&backprime;"], [3, "&lsaquo;"], [0, "&rsaquo;"], [3, "&oline;"], [2, "&caret;"], [1, "&hybull;"], [0, "&frasl;"], [10, "&bsemi;"], [7, "&qprime;"], [7, { v: "&MediumSpace;", n: 8202, o: "&ThickSpace;" }], [0, "&NoBreak;"], [0, "&af;"], [0, "&InvisibleTimes;"], [0, "&ic;"], [72, "&euro;"], [46, "&tdot;"], [0, "&DotDot;"], [37, "&complexes;"], [2, "&incare;"], [4, "&gscr;"], [0, "&hamilt;"], [0, "&Hfr;"], [0, "&Hopf;"], [0, "&planckh;"], [0, "&hbar;"], [0, "&imagline;"], [0, "&Ifr;"], [0, "&lagran;"], [0, "&ell;"], [1, "&naturals;"], [0, "&numero;"], [0, "&copysr;"], [0, "&weierp;"], [0, "&Popf;"], [0, "&Qopf;"], [0, "&realine;"], [0, "&real;"], [0, "&reals;"], [0, "&rx;"], [3, "&trade;"], [1, "&integers;"], [2, "&mho;"], [0, "&zeetrf;"], [0, "&iiota;"], [2, "&bernou;"], [0, "&Cayleys;"], [1, "&escr;"], [0, "&Escr;"], [0, "&Fouriertrf;"], [1, "&Mellintrf;"], [0, "&order;"], [0, "&alefsym;"], [0, "&beth;"], [0, "&gimel;"], [0, "&daleth;"], [12, "&CapitalDifferentialD;"], [0, "&dd;"], [0, "&ee;"], [0, "&ii;"], [10, "&frac13;"], [0, "&frac23;"], [0, "&frac15;"], [0, "&frac25;"], [0, "&frac35;"], [0, "&frac45;"], [0, "&frac16;"], [0, "&frac56;"], [0, "&frac18;"], [0, "&frac38;"], [0, "&frac58;"], [0, "&frac78;"], [49, "&larr;"], [0, "&ShortUpArrow;"], [0, "&rarr;"], [0, "&darr;"], [0, "&harr;"], [0, "&updownarrow;"], [0, "&nwarr;"], [0, "&nearr;"], [0, "&LowerRightArrow;"], [0, "&LowerLeftArrow;"], [0, "&nlarr;"], [0, "&nrarr;"], [1, { v: "&rarrw;", n: 824, o: "&nrarrw;" }], [0, "&Larr;"], [0, "&Uarr;"], [0, "&Rarr;"], [0, "&Darr;"], [0, "&larrtl;"], [0, "&rarrtl;"], [0, "&LeftTeeArrow;"], [0, "&mapstoup;"], [0, "&map;"], [0, "&DownTeeArrow;"], [1, "&hookleftarrow;"], [0, "&hookrightarrow;"], [0, "&larrlp;"], [0, "&looparrowright;"], [0, "&harrw;"], [0, "&nharr;"], [1, "&lsh;"], [0, "&rsh;"], [0, "&ldsh;"], [0, "&rdsh;"], [1, "&crarr;"], [0, "&cularr;"], [0, "&curarr;"], [2, "&circlearrowleft;"], [0, "&circlearrowright;"], [0, "&leftharpoonup;"], [0, "&DownLeftVector;"], [0, "&RightUpVector;"], [0, "&LeftUpVector;"], [0, "&rharu;"], [0, "&DownRightVector;"], [0, "&dharr;"], [0, "&dharl;"], [0, "&RightArrowLeftArrow;"], [0, "&udarr;"], [0, "&LeftArrowRightArrow;"], [0, "&leftleftarrows;"], [0, "&upuparrows;"], [0, "&rightrightarrows;"], [0, "&ddarr;"], [0, "&leftrightharpoons;"], [0, "&Equilibrium;"], [0, "&nlArr;"], [0, "&nhArr;"], [0, "&nrArr;"], [0, "&DoubleLeftArrow;"], [0, "&DoubleUpArrow;"], [0, "&DoubleRightArrow;"], [0, "&dArr;"], [0, "&DoubleLeftRightArrow;"], [0, "&DoubleUpDownArrow;"], [0, "&nwArr;"], [0, "&neArr;"], [0, "&seArr;"], [0, "&swArr;"], [0, "&lAarr;"], [0, "&rAarr;"], [1, "&zigrarr;"], [6, "&larrb;"], [0, "&rarrb;"], [15, "&DownArrowUpArrow;"], [7, "&loarr;"], [0, "&roarr;"], [0, "&hoarr;"], [0, "&forall;"], [0, "&comp;"], [0, { v: "&part;", n: 824, o: "&npart;" }], [0, "&exist;"], [0, "&nexist;"], [0, "&empty;"], [1, "&Del;"], [0, "&Element;"], [0, "&NotElement;"], [1, "&ni;"], [0, "&notni;"], [2, "&prod;"], [0, "&coprod;"], [0, "&sum;"], [0, "&minus;"], [0, "&MinusPlus;"], [0, "&dotplus;"], [1, "&Backslash;"], [0, "&lowast;"], [0, "&compfn;"], [1, "&radic;"], [2, "&prop;"], [0, "&infin;"], [0, "&angrt;"], [0, { v: "&ang;", n: 8402, o: "&nang;" }], [0, "&angmsd;"], [0, "&angsph;"], [0, "&mid;"], [0, "&nmid;"], [0, "&DoubleVerticalBar;"], [0, "&NotDoubleVerticalBar;"], [0, "&and;"], [0, "&or;"], [0, { v: "&cap;", n: 65024, o: "&caps;" }], [0, { v: "&cup;", n: 65024, o: "&cups;" }], [0, "&int;"], [0, "&Int;"], [0, "&iiint;"], [0, "&conint;"], [0, "&Conint;"], [0, "&Cconint;"], [0, "&cwint;"], [0, "&ClockwiseContourIntegral;"], [0, "&awconint;"], [0, "&there4;"], [0, "&becaus;"], [0, "&ratio;"], [0, "&Colon;"], [0, "&dotminus;"], [1, "&mDDot;"], [0, "&homtht;"], [0, { v: "&sim;", n: 8402, o: "&nvsim;" }], [0, { v: "&backsim;", n: 817, o: "&race;" }], [0, { v: "&ac;", n: 819, o: "&acE;" }], [0, "&acd;"], [0, "&VerticalTilde;"], [0, "&NotTilde;"], [0, { v: "&eqsim;", n: 824, o: "&nesim;" }], [0, "&sime;"], [0, "&NotTildeEqual;"], [0, "&cong;"], [0, "&simne;"], [0, "&ncong;"], [0, "&ap;"], [0, "&nap;"], [0, "&ape;"], [0, { v: "&apid;", n: 824, o: "&napid;" }], [0, "&backcong;"], [0, { v: "&asympeq;", n: 8402, o: "&nvap;" }], [0, { v: "&bump;", n: 824, o: "&nbump;" }], [0, { v: "&bumpe;", n: 824, o: "&nbumpe;" }], [0, { v: "&doteq;", n: 824, o: "&nedot;" }], [0, "&doteqdot;"], [0, "&efDot;"], [0, "&erDot;"], [0, "&Assign;"], [0, "&ecolon;"], [0, "&ecir;"], [0, "&circeq;"], [1, "&wedgeq;"], [0, "&veeeq;"], [1, "&triangleq;"], [2, "&equest;"], [0, "&ne;"], [0, { v: "&Congruent;", n: 8421, o: "&bnequiv;" }], [0, "&nequiv;"], [1, { v: "&le;", n: 8402, o: "&nvle;" }], [0, { v: "&ge;", n: 8402, o: "&nvge;" }], [0, { v: "&lE;", n: 824, o: "&nlE;" }], [0, { v: "&gE;", n: 824, o: "&ngE;" }], [0, { v: "&lnE;", n: 65024, o: "&lvertneqq;" }], [0, { v: "&gnE;", n: 65024, o: "&gvertneqq;" }], [0, { v: "&ll;", n: new Map(restoreDiff([[824, "&nLtv;"], [7577, "&nLt;"]])) }], [0, { v: "&gg;", n: new Map(restoreDiff([[824, "&nGtv;"], [7577, "&nGt;"]])) }], [0, "&between;"], [0, "&NotCupCap;"], [0, "&nless;"], [0, "&ngt;"], [0, "&nle;"], [0, "&nge;"], [0, "&lesssim;"], [0, "&GreaterTilde;"], [0, "&nlsim;"], [0, "&ngsim;"], [0, "&LessGreater;"], [0, "&gl;"], [0, "&NotLessGreater;"], [0, "&NotGreaterLess;"], [0, "&pr;"], [0, "&sc;"], [0, "&prcue;"], [0, "&sccue;"], [0, "&PrecedesTilde;"], [0, { v: "&scsim;", n: 824, o: "&NotSucceedsTilde;" }], [0, "&NotPrecedes;"], [0, "&NotSucceeds;"], [0, { v: "&sub;", n: 8402, o: "&NotSubset;" }], [0, { v: "&sup;", n: 8402, o: "&NotSuperset;" }], [0, "&nsub;"], [0, "&nsup;"], [0, "&sube;"], [0, "&supe;"], [0, "&NotSubsetEqual;"], [0, "&NotSupersetEqual;"], [0, { v: "&subne;", n: 65024, o: "&varsubsetneq;" }], [0, { v: "&supne;", n: 65024, o: "&varsupsetneq;" }], [1, "&cupdot;"], [0, "&UnionPlus;"], [0, { v: "&sqsub;", n: 824, o: "&NotSquareSubset;" }], [0, { v: "&sqsup;", n: 824, o: "&NotSquareSuperset;" }], [0, "&sqsube;"], [0, "&sqsupe;"], [0, { v: "&sqcap;", n: 65024, o: "&sqcaps;" }], [0, { v: "&sqcup;", n: 65024, o: "&sqcups;" }], [0, "&CirclePlus;"], [0, "&CircleMinus;"], [0, "&CircleTimes;"], [0, "&osol;"], [0, "&CircleDot;"], [0, "&circledcirc;"], [0, "&circledast;"], [1, "&circleddash;"], [0, "&boxplus;"], [0, "&boxminus;"], [0, "&boxtimes;"], [0, "&dotsquare;"], [0, "&RightTee;"], [0, "&dashv;"], [0, "&DownTee;"], [0, "&bot;"], [1, "&models;"], [0, "&DoubleRightTee;"], [0, "&Vdash;"], [0, "&Vvdash;"], [0, "&VDash;"], [0, "&nvdash;"], [0, "&nvDash;"], [0, "&nVdash;"], [0, "&nVDash;"], [0, "&prurel;"], [1, "&LeftTriangle;"], [0, "&RightTriangle;"], [0, { v: "&LeftTriangleEqual;", n: 8402, o: "&nvltrie;" }], [0, { v: "&RightTriangleEqual;", n: 8402, o: "&nvrtrie;" }], [0, "&origof;"], [0, "&imof;"], [0, "&multimap;"], [0, "&hercon;"], [0, "&intcal;"], [0, "&veebar;"], [1, "&barvee;"], [0, "&angrtvb;"], [0, "&lrtri;"], [0, "&bigwedge;"], [0, "&bigvee;"], [0, "&bigcap;"], [0, "&bigcup;"], [0, "&diam;"], [0, "&sdot;"], [0, "&sstarf;"], [0, "&divideontimes;"], [0, "&bowtie;"], [0, "&ltimes;"], [0, "&rtimes;"], [0, "&leftthreetimes;"], [0, "&rightthreetimes;"], [0, "&backsimeq;"], [0, "&curlyvee;"], [0, "&curlywedge;"], [0, "&Sub;"], [0, "&Sup;"], [0, "&Cap;"], [0, "&Cup;"], [0, "&fork;"], [0, "&epar;"], [0, "&lessdot;"], [0, "&gtdot;"], [0, { v: "&Ll;", n: 824, o: "&nLl;" }], [0, { v: "&Gg;", n: 824, o: "&nGg;" }], [0, { v: "&leg;", n: 65024, o: "&lesg;" }], [0, { v: "&gel;", n: 65024, o: "&gesl;" }], [2, "&cuepr;"], [0, "&cuesc;"], [0, "&NotPrecedesSlantEqual;"], [0, "&NotSucceedsSlantEqual;"], [0, "&NotSquareSubsetEqual;"], [0, "&NotSquareSupersetEqual;"], [2, "&lnsim;"], [0, "&gnsim;"], [0, "&precnsim;"], [0, "&scnsim;"], [0, "&nltri;"], [0, "&NotRightTriangle;"], [0, "&nltrie;"], [0, "&NotRightTriangleEqual;"], [0, "&vellip;"], [0, "&ctdot;"], [0, "&utdot;"], [0, "&dtdot;"], [0, "&disin;"], [0, "&isinsv;"], [0, "&isins;"], [0, { v: "&isindot;", n: 824, o: "&notindot;" }], [0, "&notinvc;"], [0, "&notinvb;"], [1, { v: "&isinE;", n: 824, o: "&notinE;" }], [0, "&nisd;"], [0, "&xnis;"], [0, "&nis;"], [0, "&notnivc;"], [0, "&notnivb;"], [6, "&barwed;"], [0, "&Barwed;"], [1, "&lceil;"], [0, "&rceil;"], [0, "&LeftFloor;"], [0, "&rfloor;"], [0, "&drcrop;"], [0, "&dlcrop;"], [0, "&urcrop;"], [0, "&ulcrop;"], [0, "&bnot;"], [1, "&profline;"], [0, "&profsurf;"], [1, "&telrec;"], [0, "&target;"], [5, "&ulcorn;"], [0, "&urcorn;"], [0, "&dlcorn;"], [0, "&drcorn;"], [2, "&frown;"], [0, "&smile;"], [9, "&cylcty;"], [0, "&profalar;"], [7, "&topbot;"], [6, "&ovbar;"], [1, "&solbar;"], [60, "&angzarr;"], [51, "&lmoustache;"], [0, "&rmoustache;"], [2, "&OverBracket;"], [0, "&bbrk;"], [0, "&bbrktbrk;"], [37, "&OverParenthesis;"], [0, "&UnderParenthesis;"], [0, "&OverBrace;"], [0, "&UnderBrace;"], [2, "&trpezium;"], [4, "&elinters;"], [59, "&blank;"], [164, "&circledS;"], [55, "&boxh;"], [1, "&boxv;"], [9, "&boxdr;"], [3, "&boxdl;"], [3, "&boxur;"], [3, "&boxul;"], [3, "&boxvr;"], [7, "&boxvl;"], [7, "&boxhd;"], [7, "&boxhu;"], [7, "&boxvh;"], [19, "&boxH;"], [0, "&boxV;"], [0, "&boxdR;"], [0, "&boxDr;"], [0, "&boxDR;"], [0, "&boxdL;"], [0, "&boxDl;"], [0, "&boxDL;"], [0, "&boxuR;"], [0, "&boxUr;"], [0, "&boxUR;"], [0, "&boxuL;"], [0, "&boxUl;"], [0, "&boxUL;"], [0, "&boxvR;"], [0, "&boxVr;"], [0, "&boxVR;"], [0, "&boxvL;"], [0, "&boxVl;"], [0, "&boxVL;"], [0, "&boxHd;"], [0, "&boxhD;"], [0, "&boxHD;"], [0, "&boxHu;"], [0, "&boxhU;"], [0, "&boxHU;"], [0, "&boxvH;"], [0, "&boxVh;"], [0, "&boxVH;"], [19, "&uhblk;"], [3, "&lhblk;"], [3, "&block;"], [8, "&blk14;"], [0, "&blk12;"], [0, "&blk34;"], [13, "&square;"], [8, "&blacksquare;"], [0, "&EmptyVerySmallSquare;"], [1, "&rect;"], [0, "&marker;"], [2, "&fltns;"], [1, "&bigtriangleup;"], [0, "&blacktriangle;"], [0, "&triangle;"], [2, "&blacktriangleright;"], [0, "&rtri;"], [3, "&bigtriangledown;"], [0, "&blacktriangledown;"], [0, "&dtri;"], [2, "&blacktriangleleft;"], [0, "&ltri;"], [6, "&loz;"], [0, "&cir;"], [32, "&tridot;"], [2, "&bigcirc;"], [8, "&ultri;"], [0, "&urtri;"], [0, "&lltri;"], [0, "&EmptySmallSquare;"], [0, "&FilledSmallSquare;"], [8, "&bigstar;"], [0, "&star;"], [7, "&phone;"], [49, "&female;"], [1, "&male;"], [29, "&spades;"], [2, "&clubs;"], [1, "&hearts;"], [0, "&diamondsuit;"], [3, "&sung;"], [2, "&flat;"], [0, "&natural;"], [0, "&sharp;"], [163, "&check;"], [3, "&cross;"], [8, "&malt;"], [21, "&sext;"], [33, "&VerticalSeparator;"], [25, "&lbbrk;"], [0, "&rbbrk;"], [84, "&bsolhsub;"], [0, "&suphsol;"], [28, "&LeftDoubleBracket;"], [0, "&RightDoubleBracket;"], [0, "&lang;"], [0, "&rang;"], [0, "&Lang;"], [0, "&Rang;"], [0, "&loang;"], [0, "&roang;"], [7, "&longleftarrow;"], [0, "&longrightarrow;"], [0, "&longleftrightarrow;"], [0, "&DoubleLongLeftArrow;"], [0, "&DoubleLongRightArrow;"], [0, "&DoubleLongLeftRightArrow;"], [1, "&longmapsto;"], [2, "&dzigrarr;"], [258, "&nvlArr;"], [0, "&nvrArr;"], [0, "&nvHarr;"], [0, "&Map;"], [6, "&lbarr;"], [0, "&bkarow;"], [0, "&lBarr;"], [0, "&dbkarow;"], [0, "&drbkarow;"], [0, "&DDotrahd;"], [0, "&UpArrowBar;"], [0, "&DownArrowBar;"], [2, "&Rarrtl;"], [2, "&latail;"], [0, "&ratail;"], [0, "&lAtail;"], [0, "&rAtail;"], [0, "&larrfs;"], [0, "&rarrfs;"], [0, "&larrbfs;"], [0, "&rarrbfs;"], [2, "&nwarhk;"], [0, "&nearhk;"], [0, "&hksearow;"], [0, "&hkswarow;"], [0, "&nwnear;"], [0, "&nesear;"], [0, "&seswar;"], [0, "&swnwar;"], [8, { v: "&rarrc;", n: 824, o: "&nrarrc;" }], [1, "&cudarrr;"], [0, "&ldca;"], [0, "&rdca;"], [0, "&cudarrl;"], [0, "&larrpl;"], [2, "&curarrm;"], [0, "&cularrp;"], [7, "&rarrpl;"], [2, "&harrcir;"], [0, "&Uarrocir;"], [0, "&lurdshar;"], [0, "&ldrushar;"], [2, "&LeftRightVector;"], [0, "&RightUpDownVector;"], [0, "&DownLeftRightVector;"], [0, "&LeftUpDownVector;"], [0, "&LeftVectorBar;"], [0, "&RightVectorBar;"], [0, "&RightUpVectorBar;"], [0, "&RightDownVectorBar;"], [0, "&DownLeftVectorBar;"], [0, "&DownRightVectorBar;"], [0, "&LeftUpVectorBar;"], [0, "&LeftDownVectorBar;"], [0, "&LeftTeeVector;"], [0, "&RightTeeVector;"], [0, "&RightUpTeeVector;"], [0, "&RightDownTeeVector;"], [0, "&DownLeftTeeVector;"], [0, "&DownRightTeeVector;"], [0, "&LeftUpTeeVector;"], [0, "&LeftDownTeeVector;"], [0, "&lHar;"], [0, "&uHar;"], [0, "&rHar;"], [0, "&dHar;"], [0, "&luruhar;"], [0, "&ldrdhar;"], [0, "&ruluhar;"], [0, "&rdldhar;"], [0, "&lharul;"], [0, "&llhard;"], [0, "&rharul;"], [0, "&lrhard;"], [0, "&udhar;"], [0, "&duhar;"], [0, "&RoundImplies;"], [0, "&erarr;"], [0, "&simrarr;"], [0, "&larrsim;"], [0, "&rarrsim;"], [0, "&rarrap;"], [0, "&ltlarr;"], [1, "&gtrarr;"], [0, "&subrarr;"], [1, "&suplarr;"], [0, "&lfisht;"], [0, "&rfisht;"], [0, "&ufisht;"], [0, "&dfisht;"], [5, "&lopar;"], [0, "&ropar;"], [4, "&lbrke;"], [0, "&rbrke;"], [0, "&lbrkslu;"], [0, "&rbrksld;"], [0, "&lbrksld;"], [0, "&rbrkslu;"], [0, "&langd;"], [0, "&rangd;"], [0, "&lparlt;"], [0, "&rpargt;"], [0, "&gtlPar;"], [0, "&ltrPar;"], [3, "&vzigzag;"], [1, "&vangrt;"], [0, "&angrtvbd;"], [6, "&ange;"], [0, "&range;"], [0, "&dwangle;"], [0, "&uwangle;"], [0, "&angmsdaa;"], [0, "&angmsdab;"], [0, "&angmsdac;"], [0, "&angmsdad;"], [0, "&angmsdae;"], [0, "&angmsdaf;"], [0, "&angmsdag;"], [0, "&angmsdah;"], [0, "&bemptyv;"], [0, "&demptyv;"], [0, "&cemptyv;"], [0, "&raemptyv;"], [0, "&laemptyv;"], [0, "&ohbar;"], [0, "&omid;"], [0, "&opar;"], [1, "&operp;"], [1, "&olcross;"], [0, "&odsold;"], [1, "&olcir;"], [0, "&ofcir;"], [0, "&olt;"], [0, "&ogt;"], [0, "&cirscir;"], [0, "&cirE;"], [0, "&solb;"], [0, "&bsolb;"], [3, "&boxbox;"], [3, "&trisb;"], [0, "&rtriltri;"], [0, { v: "&LeftTriangleBar;", n: 824, o: "&NotLeftTriangleBar;" }], [0, { v: "&RightTriangleBar;", n: 824, o: "&NotRightTriangleBar;" }], [11, "&iinfin;"], [0, "&infintie;"], [0, "&nvinfin;"], [4, "&eparsl;"], [0, "&smeparsl;"], [0, "&eqvparsl;"], [5, "&blacklozenge;"], [8, "&RuleDelayed;"], [1, "&dsol;"], [9, "&bigodot;"], [0, "&bigoplus;"], [0, "&bigotimes;"], [1, "&biguplus;"], [1, "&bigsqcup;"], [5, "&iiiint;"], [0, "&fpartint;"], [2, "&cirfnint;"], [0, "&awint;"], [0, "&rppolint;"], [0, "&scpolint;"], [0, "&npolint;"], [0, "&pointint;"], [0, "&quatint;"], [0, "&intlarhk;"], [10, "&pluscir;"], [0, "&plusacir;"], [0, "&simplus;"], [0, "&plusdu;"], [0, "&plussim;"], [0, "&plustwo;"], [1, "&mcomma;"], [0, "&minusdu;"], [2, "&loplus;"], [0, "&roplus;"], [0, "&Cross;"], [0, "&timesd;"], [0, "&timesbar;"], [1, "&smashp;"], [0, "&lotimes;"], [0, "&rotimes;"], [0, "&otimesas;"], [0, "&Otimes;"], [0, "&odiv;"], [0, "&triplus;"], [0, "&triminus;"], [0, "&tritime;"], [0, "&intprod;"], [2, "&amalg;"], [0, "&capdot;"], [1, "&ncup;"], [0, "&ncap;"], [0, "&capand;"], [0, "&cupor;"], [0, "&cupcap;"], [0, "&capcup;"], [0, "&cupbrcap;"], [0, "&capbrcup;"], [0, "&cupcup;"], [0, "&capcap;"], [0, "&ccups;"], [0, "&ccaps;"], [2, "&ccupssm;"], [2, "&And;"], [0, "&Or;"], [0, "&andand;"], [0, "&oror;"], [0, "&orslope;"], [0, "&andslope;"], [1, "&andv;"], [0, "&orv;"], [0, "&andd;"], [0, "&ord;"], [1, "&wedbar;"], [6, "&sdote;"], [3, "&simdot;"], [2, { v: "&congdot;", n: 824, o: "&ncongdot;" }], [0, "&easter;"], [0, "&apacir;"], [0, { v: "&apE;", n: 824, o: "&napE;" }], [0, "&eplus;"], [0, "&pluse;"], [0, "&Esim;"], [0, "&Colone;"], [0, "&Equal;"], [1, "&ddotseq;"], [0, "&equivDD;"], [0, "&ltcir;"], [0, "&gtcir;"], [0, "&ltquest;"], [0, "&gtquest;"], [0, { v: "&leqslant;", n: 824, o: "&nleqslant;" }], [0, { v: "&geqslant;", n: 824, o: "&ngeqslant;" }], [0, "&lesdot;"], [0, "&gesdot;"], [0, "&lesdoto;"], [0, "&gesdoto;"], [0, "&lesdotor;"], [0, "&gesdotol;"], [0, "&lap;"], [0, "&gap;"], [0, "&lne;"], [0, "&gne;"], [0, "&lnap;"], [0, "&gnap;"], [0, "&lEg;"], [0, "&gEl;"], [0, "&lsime;"], [0, "&gsime;"], [0, "&lsimg;"], [0, "&gsiml;"], [0, "&lgE;"], [0, "&glE;"], [0, "&lesges;"], [0, "&gesles;"], [0, "&els;"], [0, "&egs;"], [0, "&elsdot;"], [0, "&egsdot;"], [0, "&el;"], [0, "&eg;"], [2, "&siml;"], [0, "&simg;"], [0, "&simlE;"], [0, "&simgE;"], [0, { v: "&LessLess;", n: 824, o: "&NotNestedLessLess;" }], [0, { v: "&GreaterGreater;", n: 824, o: "&NotNestedGreaterGreater;" }], [1, "&glj;"], [0, "&gla;"], [0, "&ltcc;"], [0, "&gtcc;"], [0, "&lescc;"], [0, "&gescc;"], [0, "&smt;"], [0, "&lat;"], [0, { v: "&smte;", n: 65024, o: "&smtes;" }], [0, { v: "&late;", n: 65024, o: "&lates;" }], [0, "&bumpE;"], [0, { v: "&PrecedesEqual;", n: 824, o: "&NotPrecedesEqual;" }], [0, { v: "&sce;", n: 824, o: "&NotSucceedsEqual;" }], [2, "&prE;"], [0, "&scE;"], [0, "&precneqq;"], [0, "&scnE;"], [0, "&prap;"], [0, "&scap;"], [0, "&precnapprox;"], [0, "&scnap;"], [0, "&Pr;"], [0, "&Sc;"], [0, "&subdot;"], [0, "&supdot;"], [0, "&subplus;"], [0, "&supplus;"], [0, "&submult;"], [0, "&supmult;"], [0, "&subedot;"], [0, "&supedot;"], [0, { v: "&subE;", n: 824, o: "&nsubE;" }], [0, { v: "&supE;", n: 824, o: "&nsupE;" }], [0, "&subsim;"], [0, "&supsim;"], [2, { v: "&subnE;", n: 65024, o: "&varsubsetneqq;" }], [0, { v: "&supnE;", n: 65024, o: "&varsupsetneqq;" }], [2, "&csub;"], [0, "&csup;"], [0, "&csube;"], [0, "&csupe;"], [0, "&subsup;"], [0, "&supsub;"], [0, "&subsub;"], [0, "&supsup;"], [0, "&suphsub;"], [0, "&supdsub;"], [0, "&forkv;"], [0, "&topfork;"], [0, "&mlcp;"], [8, "&Dashv;"], [1, "&Vdashl;"], [0, "&Barv;"], [0, "&vBar;"], [0, "&vBarv;"], [1, "&Vbar;"], [0, "&Not;"], [0, "&bNot;"], [0, "&rnmid;"], [0, "&cirmid;"], [0, "&midcir;"], [0, "&topcir;"], [0, "&nhpar;"], [0, "&parsim;"], [9, { v: "&parsl;", n: 8421, o: "&nparsl;" }], [44343, { n: new Map(restoreDiff([[56476, "&Ascr;"], [1, "&Cscr;"], [0, "&Dscr;"], [2, "&Gscr;"], [2, "&Jscr;"], [0, "&Kscr;"], [2, "&Nscr;"], [0, "&Oscr;"], [0, "&Pscr;"], [0, "&Qscr;"], [1, "&Sscr;"], [0, "&Tscr;"], [0, "&Uscr;"], [0, "&Vscr;"], [0, "&Wscr;"], [0, "&Xscr;"], [0, "&Yscr;"], [0, "&Zscr;"], [0, "&ascr;"], [0, "&bscr;"], [0, "&cscr;"], [0, "&dscr;"], [1, "&fscr;"], [1, "&hscr;"], [0, "&iscr;"], [0, "&jscr;"], [0, "&kscr;"], [0, "&lscr;"], [0, "&mscr;"], [0, "&nscr;"], [1, "&pscr;"], [0, "&qscr;"], [0, "&rscr;"], [0, "&sscr;"], [0, "&tscr;"], [0, "&uscr;"], [0, "&vscr;"], [0, "&wscr;"], [0, "&xscr;"], [0, "&yscr;"], [0, "&zscr;"], [52, "&Afr;"], [0, "&Bfr;"], [1, "&Dfr;"], [0, "&Efr;"], [0, "&Ffr;"], [0, "&Gfr;"], [2, "&Jfr;"], [0, "&Kfr;"], [0, "&Lfr;"], [0, "&Mfr;"], [0, "&Nfr;"], [0, "&Ofr;"], [0, "&Pfr;"], [0, "&Qfr;"], [1, "&Sfr;"], [0, "&Tfr;"], [0, "&Ufr;"], [0, "&Vfr;"], [0, "&Wfr;"], [0, "&Xfr;"], [0, "&Yfr;"], [1, "&afr;"], [0, "&bfr;"], [0, "&cfr;"], [0, "&dfr;"], [0, "&efr;"], [0, "&ffr;"], [0, "&gfr;"], [0, "&hfr;"], [0, "&ifr;"], [0, "&jfr;"], [0, "&kfr;"], [0, "&lfr;"], [0, "&mfr;"], [0, "&nfr;"], [0, "&ofr;"], [0, "&pfr;"], [0, "&qfr;"], [0, "&rfr;"], [0, "&sfr;"], [0, "&tfr;"], [0, "&ufr;"], [0, "&vfr;"], [0, "&wfr;"], [0, "&xfr;"], [0, "&yfr;"], [0, "&zfr;"], [0, "&Aopf;"], [0, "&Bopf;"], [1, "&Dopf;"], [0, "&Eopf;"], [0, "&Fopf;"], [0, "&Gopf;"], [1, "&Iopf;"], [0, "&Jopf;"], [0, "&Kopf;"], [0, "&Lopf;"], [0, "&Mopf;"], [1, "&Oopf;"], [3, "&Sopf;"], [0, "&Topf;"], [0, "&Uopf;"], [0, "&Vopf;"], [0, "&Wopf;"], [0, "&Xopf;"], [0, "&Yopf;"], [1, "&aopf;"], [0, "&bopf;"], [0, "&copf;"], [0, "&dopf;"], [0, "&eopf;"], [0, "&fopf;"], [0, "&gopf;"], [0, "&hopf;"], [0, "&iopf;"], [0, "&jopf;"], [0, "&kopf;"], [0, "&lopf;"], [0, "&mopf;"], [0, "&nopf;"], [0, "&oopf;"], [0, "&popf;"], [0, "&qopf;"], [0, "&ropf;"], [0, "&sopf;"], [0, "&topf;"], [0, "&uopf;"], [0, "&vopf;"], [0, "&wopf;"], [0, "&xopf;"], [0, "&yopf;"], [0, "&zopf;"]])) }], [8906, "&fflig;"], [0, "&filig;"], [0, "&fllig;"], [0, "&ffilig;"], [0, "&ffllig;"]]));
});

// node_modules/entities/lib/escape.js
var require_escape = __commonJS((exports) => {
  var encodeXML = function(str) {
    var ret = "";
    var lastIdx = 0;
    var match;
    while ((match = exports.xmlReplacer.exec(str)) !== null) {
      var i = match.index;
      var char = str.charCodeAt(i);
      var next = xmlCodeMap.get(char);
      if (next !== undefined) {
        ret += str.substring(lastIdx, i) + next;
        lastIdx = i + 1;
      } else {
        ret += "".concat(str.substring(lastIdx, i), "&#x").concat((0, exports.getCodePoint)(str, i).toString(16), ";");
        lastIdx = exports.xmlReplacer.lastIndex += Number((char & 64512) === 55296);
      }
    }
    return ret + str.substr(lastIdx);
  };
  var getEscaper = function(regex, map) {
    return function escape(data) {
      var match;
      var lastIdx = 0;
      var result2 = "";
      while (match = regex.exec(data)) {
        if (lastIdx !== match.index) {
          result2 += data.substring(lastIdx, match.index);
        }
        result2 += map.get(match[0].charCodeAt(0));
        lastIdx = match.index + 1;
      }
      return result2 + data.substring(lastIdx);
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.escapeText = exports.escapeAttribute = exports.escapeUTF8 = exports.escape = exports.encodeXML = exports.getCodePoint = exports.xmlReplacer = undefined;
  exports.xmlReplacer = /["&'<>$\x80-\uFFFF]/g;
  var xmlCodeMap = new Map([
    [34, "&quot;"],
    [38, "&amp;"],
    [39, "&apos;"],
    [60, "&lt;"],
    [62, "&gt;"]
  ]);
  exports.getCodePoint = String.prototype.codePointAt != null ? function(str, index) {
    return str.codePointAt(index);
  } : function(c2, index) {
    return (c2.charCodeAt(index) & 64512) === 55296 ? (c2.charCodeAt(index) - 55296) * 1024 + c2.charCodeAt(index + 1) - 56320 + 65536 : c2.charCodeAt(index);
  };
  exports.encodeXML = encodeXML;
  exports.escape = encodeXML;
  exports.escapeUTF8 = getEscaper(/[&<>'"]/g, xmlCodeMap);
  exports.escapeAttribute = getEscaper(/["&\u00A0]/g, new Map([
    [34, "&quot;"],
    [38, "&amp;"],
    [160, "&nbsp;"]
  ]));
  exports.escapeText = getEscaper(/[&<>\u00A0]/g, new Map([
    [38, "&amp;"],
    [60, "&lt;"],
    [62, "&gt;"],
    [160, "&nbsp;"]
  ]));
});

// node_modules/entities/lib/encode.js
var require_encode = __commonJS((exports) => {
  var encodeHTML = function(data) {
    return encodeHTMLTrieRe(htmlReplacer, data);
  };
  var encodeNonAsciiHTML = function(data) {
    return encodeHTMLTrieRe(escape_js_1.xmlReplacer, data);
  };
  var encodeHTMLTrieRe = function(regExp, str) {
    var ret = "";
    var lastIdx = 0;
    var match;
    while ((match = regExp.exec(str)) !== null) {
      var i = match.index;
      ret += str.substring(lastIdx, i);
      var char = str.charCodeAt(i);
      var next = encode_html_js_1.default.get(char);
      if (typeof next === "object") {
        if (i + 1 < str.length) {
          var nextChar = str.charCodeAt(i + 1);
          var value = typeof next.n === "number" ? next.n === nextChar ? next.o : undefined : next.n.get(nextChar);
          if (value !== undefined) {
            ret += value;
            lastIdx = regExp.lastIndex += 1;
            continue;
          }
        }
        next = next.v;
      }
      if (next !== undefined) {
        ret += next;
        lastIdx = i + 1;
      } else {
        var cp = (0, escape_js_1.getCodePoint)(str, i);
        ret += "&#x".concat(cp.toString(16), ";");
        lastIdx = regExp.lastIndex += Number(cp !== char);
      }
    }
    return ret + str.substr(lastIdx);
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.encodeNonAsciiHTML = exports.encodeHTML = undefined;
  var encode_html_js_1 = __importDefault(require_encode_html());
  var escape_js_1 = require_escape();
  var htmlReplacer = /[\t\n!-,./:-@[-`\f{-}$\x80-\uFFFF]/g;
  exports.encodeHTML = encodeHTML;
  exports.encodeNonAsciiHTML = encodeNonAsciiHTML;
});

// node_modules/entities/lib/index.js
var require_lib3 = __commonJS((exports) => {
  var decode = function(data, options) {
    if (options === undefined) {
      options = EntityLevel.XML;
    }
    var level = typeof options === "number" ? options : options.level;
    if (level === EntityLevel.HTML) {
      var mode = typeof options === "object" ? options.mode : undefined;
      return (0, decode_js_1.decodeHTML)(data, mode);
    }
    return (0, decode_js_1.decodeXML)(data);
  };
  var decodeStrict = function(data, options) {
    var _a;
    if (options === undefined) {
      options = EntityLevel.XML;
    }
    var opts = typeof options === "number" ? { level: options } : options;
    (_a = opts.mode) !== null && _a !== undefined || (opts.mode = decode_js_1.DecodingMode.Strict);
    return decode(data, opts);
  };
  var encode = function(data, options) {
    if (options === undefined) {
      options = EntityLevel.XML;
    }
    var opts = typeof options === "number" ? { level: options } : options;
    if (opts.mode === EncodingMode.UTF8)
      return (0, escape_js_1.escapeUTF8)(data);
    if (opts.mode === EncodingMode.Attribute)
      return (0, escape_js_1.escapeAttribute)(data);
    if (opts.mode === EncodingMode.Text)
      return (0, escape_js_1.escapeText)(data);
    if (opts.level === EntityLevel.HTML) {
      if (opts.mode === EncodingMode.ASCII) {
        return (0, encode_js_1.encodeNonAsciiHTML)(data);
      }
      return (0, encode_js_1.encodeHTML)(data);
    }
    return (0, escape_js_1.encodeXML)(data);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.decodeXMLStrict = exports.decodeHTML5Strict = exports.decodeHTML4Strict = exports.decodeHTML5 = exports.decodeHTML4 = exports.decodeHTMLAttribute = exports.decodeHTMLStrict = exports.decodeHTML = exports.decodeXML = exports.DecodingMode = exports.EntityDecoder = exports.encodeHTML5 = exports.encodeHTML4 = exports.encodeNonAsciiHTML = exports.encodeHTML = exports.escapeText = exports.escapeAttribute = exports.escapeUTF8 = exports.escape = exports.encodeXML = exports.encode = exports.decodeStrict = exports.decode = exports.EncodingMode = exports.EntityLevel = undefined;
  var decode_js_1 = require_decode();
  var encode_js_1 = require_encode();
  var escape_js_1 = require_escape();
  var EntityLevel;
  (function(EntityLevel2) {
    EntityLevel2[EntityLevel2["XML"] = 0] = "XML";
    EntityLevel2[EntityLevel2["HTML"] = 1] = "HTML";
  })(EntityLevel = exports.EntityLevel || (exports.EntityLevel = {}));
  var EncodingMode;
  (function(EncodingMode2) {
    EncodingMode2[EncodingMode2["UTF8"] = 0] = "UTF8";
    EncodingMode2[EncodingMode2["ASCII"] = 1] = "ASCII";
    EncodingMode2[EncodingMode2["Extensive"] = 2] = "Extensive";
    EncodingMode2[EncodingMode2["Attribute"] = 3] = "Attribute";
    EncodingMode2[EncodingMode2["Text"] = 4] = "Text";
  })(EncodingMode = exports.EncodingMode || (exports.EncodingMode = {}));
  exports.decode = decode;
  exports.decodeStrict = decodeStrict;
  exports.encode = encode;
  var escape_js_2 = require_escape();
  Object.defineProperty(exports, "encodeXML", { enumerable: true, get: function() {
    return escape_js_2.encodeXML;
  } });
  Object.defineProperty(exports, "escape", { enumerable: true, get: function() {
    return escape_js_2.escape;
  } });
  Object.defineProperty(exports, "escapeUTF8", { enumerable: true, get: function() {
    return escape_js_2.escapeUTF8;
  } });
  Object.defineProperty(exports, "escapeAttribute", { enumerable: true, get: function() {
    return escape_js_2.escapeAttribute;
  } });
  Object.defineProperty(exports, "escapeText", { enumerable: true, get: function() {
    return escape_js_2.escapeText;
  } });
  var encode_js_2 = require_encode();
  Object.defineProperty(exports, "encodeHTML", { enumerable: true, get: function() {
    return encode_js_2.encodeHTML;
  } });
  Object.defineProperty(exports, "encodeNonAsciiHTML", { enumerable: true, get: function() {
    return encode_js_2.encodeNonAsciiHTML;
  } });
  Object.defineProperty(exports, "encodeHTML4", { enumerable: true, get: function() {
    return encode_js_2.encodeHTML;
  } });
  Object.defineProperty(exports, "encodeHTML5", { enumerable: true, get: function() {
    return encode_js_2.encodeHTML;
  } });
  var decode_js_2 = require_decode();
  Object.defineProperty(exports, "EntityDecoder", { enumerable: true, get: function() {
    return decode_js_2.EntityDecoder;
  } });
  Object.defineProperty(exports, "DecodingMode", { enumerable: true, get: function() {
    return decode_js_2.DecodingMode;
  } });
  Object.defineProperty(exports, "decodeXML", { enumerable: true, get: function() {
    return decode_js_2.decodeXML;
  } });
  Object.defineProperty(exports, "decodeHTML", { enumerable: true, get: function() {
    return decode_js_2.decodeHTML;
  } });
  Object.defineProperty(exports, "decodeHTMLStrict", { enumerable: true, get: function() {
    return decode_js_2.decodeHTMLStrict;
  } });
  Object.defineProperty(exports, "decodeHTMLAttribute", { enumerable: true, get: function() {
    return decode_js_2.decodeHTMLAttribute;
  } });
  Object.defineProperty(exports, "decodeHTML4", { enumerable: true, get: function() {
    return decode_js_2.decodeHTML;
  } });
  Object.defineProperty(exports, "decodeHTML5", { enumerable: true, get: function() {
    return decode_js_2.decodeHTML;
  } });
  Object.defineProperty(exports, "decodeHTML4Strict", { enumerable: true, get: function() {
    return decode_js_2.decodeHTMLStrict;
  } });
  Object.defineProperty(exports, "decodeHTML5Strict", { enumerable: true, get: function() {
    return decode_js_2.decodeHTMLStrict;
  } });
  Object.defineProperty(exports, "decodeXMLStrict", { enumerable: true, get: function() {
    return decode_js_2.decodeXML;
  } });
});

// node_modules/dom-serializer/lib/foreignNames.js
var require_foreignNames = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.attributeNames = exports.elementNames = undefined;
  exports.elementNames = new Map([
    "altGlyph",
    "altGlyphDef",
    "altGlyphItem",
    "animateColor",
    "animateMotion",
    "animateTransform",
    "clipPath",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDistantLight",
    "feDropShadow",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "foreignObject",
    "glyphRef",
    "linearGradient",
    "radialGradient",
    "textPath"
  ].map(function(val) {
    return [val.toLowerCase(), val];
  }));
  exports.attributeNames = new Map([
    "definitionURL",
    "attributeName",
    "attributeType",
    "baseFrequency",
    "baseProfile",
    "calcMode",
    "clipPathUnits",
    "diffuseConstant",
    "edgeMode",
    "filterUnits",
    "glyphRef",
    "gradientTransform",
    "gradientUnits",
    "kernelMatrix",
    "kernelUnitLength",
    "keyPoints",
    "keySplines",
    "keyTimes",
    "lengthAdjust",
    "limitingConeAngle",
    "markerHeight",
    "markerUnits",
    "markerWidth",
    "maskContentUnits",
    "maskUnits",
    "numOctaves",
    "pathLength",
    "patternContentUnits",
    "patternTransform",
    "patternUnits",
    "pointsAtX",
    "pointsAtY",
    "pointsAtZ",
    "preserveAlpha",
    "preserveAspectRatio",
    "primitiveUnits",
    "refX",
    "refY",
    "repeatCount",
    "repeatDur",
    "requiredExtensions",
    "requiredFeatures",
    "specularConstant",
    "specularExponent",
    "spreadMethod",
    "startOffset",
    "stdDeviation",
    "stitchTiles",
    "surfaceScale",
    "systemLanguage",
    "tableValues",
    "targetX",
    "targetY",
    "textLength",
    "viewBox",
    "viewTarget",
    "xChannelSelector",
    "yChannelSelector",
    "zoomAndPan"
  ].map(function(val) {
    return [val.toLowerCase(), val];
  }));
});

// node_modules/dom-serializer/lib/index.js
var require_lib4 = __commonJS((exports) => {
  var replaceQuotes = function(value) {
    return value.replace(/"/g, "&quot;");
  };
  var formatAttributes = function(attributes, opts) {
    var _a;
    if (!attributes)
      return;
    var encode = ((_a = opts.encodeEntities) !== null && _a !== undefined ? _a : opts.decodeEntities) === false ? replaceQuotes : opts.xmlMode || opts.encodeEntities !== "utf8" ? entities_1.encodeXML : entities_1.escapeAttribute;
    return Object.keys(attributes).map(function(key) {
      var _a2, _b;
      var value = (_a2 = attributes[key]) !== null && _a2 !== undefined ? _a2 : "";
      if (opts.xmlMode === "foreign") {
        key = (_b = foreignNames_js_1.attributeNames.get(key)) !== null && _b !== undefined ? _b : key;
      }
      if (!opts.emptyAttrs && !opts.xmlMode && value === "") {
        return key;
      }
      return "".concat(key, "=\"").concat(encode(value), "\"");
    }).join(" ");
  };
  var render = function(node, options) {
    if (options === undefined) {
      options = {};
    }
    var nodes = "length" in node ? node : [node];
    var output = "";
    for (var i = 0;i < nodes.length; i++) {
      output += renderNode(nodes[i], options);
    }
    return output;
  };
  var renderNode = function(node, options) {
    switch (node.type) {
      case ElementType.Root:
        return render(node.children, options);
      case ElementType.Doctype:
      case ElementType.Directive:
        return renderDirective(node);
      case ElementType.Comment:
        return renderComment(node);
      case ElementType.CDATA:
        return renderCdata(node);
      case ElementType.Script:
      case ElementType.Style:
      case ElementType.Tag:
        return renderTag(node, options);
      case ElementType.Text:
        return renderText(node, options);
    }
  };
  var renderTag = function(elem, opts) {
    var _a;
    if (opts.xmlMode === "foreign") {
      elem.name = (_a = foreignNames_js_1.elementNames.get(elem.name)) !== null && _a !== undefined ? _a : elem.name;
      if (elem.parent && foreignModeIntegrationPoints.has(elem.parent.name)) {
        opts = __assign(__assign({}, opts), { xmlMode: false });
      }
    }
    if (!opts.xmlMode && foreignElements.has(elem.name)) {
      opts = __assign(__assign({}, opts), { xmlMode: "foreign" });
    }
    var tag = "<".concat(elem.name);
    var attribs = formatAttributes(elem.attribs, opts);
    if (attribs) {
      tag += " ".concat(attribs);
    }
    if (elem.children.length === 0 && (opts.xmlMode ? opts.selfClosingTags !== false : opts.selfClosingTags && singleTag.has(elem.name))) {
      if (!opts.xmlMode)
        tag += " ";
      tag += "/>";
    } else {
      tag += ">";
      if (elem.children.length > 0) {
        tag += render(elem.children, opts);
      }
      if (opts.xmlMode || !singleTag.has(elem.name)) {
        tag += "</".concat(elem.name, ">");
      }
    }
    return tag;
  };
  var renderDirective = function(elem) {
    return "<".concat(elem.data, ">");
  };
  var renderText = function(elem, opts) {
    var _a;
    var data = elem.data || "";
    if (((_a = opts.encodeEntities) !== null && _a !== undefined ? _a : opts.decodeEntities) !== false && !(!opts.xmlMode && elem.parent && unencodedElements.has(elem.parent.name))) {
      data = opts.xmlMode || opts.encodeEntities !== "utf8" ? (0, entities_1.encodeXML)(data) : (0, entities_1.escapeText)(data);
    }
    return data;
  };
  var renderCdata = function(elem) {
    return "<![CDATA[".concat(elem.children[0].data, "]]>");
  };
  var renderComment = function(elem) {
    return "<!--".concat(elem.data, "-->");
  };
  var __assign = exports && exports.__assign || function() {
    __assign = Object.assign || function(t) {
      for (var s, i = 1, n = arguments.length;i < n; i++) {
        s = arguments[i];
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
      }
      return t;
    };
    return __assign.apply(this, arguments);
  };
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc2 = Object.getOwnPropertyDescriptor(m, k);
    if (!desc2 || ("get" in desc2 ? !m.__esModule : desc2.writable || desc2.configurable)) {
      desc2 = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o2, k2, desc2);
  } : function(o2, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o2[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v) {
    Object.defineProperty(o2, "default", { enumerable: true, value: v });
  } : function(o2, v) {
    o2["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result2 = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result2, mod, k);
    }
    __setModuleDefault(result2, mod);
    return result2;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.render = undefined;
  var ElementType = __importStar(require_lib());
  var entities_1 = require_lib3();
  var foreignNames_js_1 = require_foreignNames();
  var unencodedElements = new Set([
    "style",
    "script",
    "xmp",
    "iframe",
    "noembed",
    "noframes",
    "plaintext",
    "noscript"
  ]);
  var singleTag = new Set([
    "area",
    "base",
    "basefont",
    "br",
    "col",
    "command",
    "embed",
    "frame",
    "hr",
    "img",
    "input",
    "isindex",
    "keygen",
    "link",
    "meta",
    "param",
    "source",
    "track",
    "wbr"
  ]);
  exports.render = render;
  exports.default = render;
  var foreignModeIntegrationPoints = new Set([
    "mi",
    "mo",
    "mn",
    "ms",
    "mtext",
    "annotation-xml",
    "foreignObject",
    "desc",
    "title"
  ]);
  var foreignElements = new Set(["svg", "math"]);
});

// node_modules/domutils/lib/stringify.js
var require_stringify = __commonJS((exports) => {
  var getOuterHTML = function(node, options) {
    return (0, dom_serializer_1.default)(node, options);
  };
  var getInnerHTML = function(node, options) {
    return (0, domhandler_1.hasChildren)(node) ? node.children.map(function(node2) {
      return getOuterHTML(node2, options);
    }).join("") : "";
  };
  var getText = function(node) {
    if (Array.isArray(node))
      return node.map(getText).join("");
    if ((0, domhandler_1.isTag)(node))
      return node.name === "br" ? "\n" : getText(node.children);
    if ((0, domhandler_1.isCDATA)(node))
      return getText(node.children);
    if ((0, domhandler_1.isText)(node))
      return node.data;
    return "";
  };
  var textContent = function(node) {
    if (Array.isArray(node))
      return node.map(textContent).join("");
    if ((0, domhandler_1.hasChildren)(node) && !(0, domhandler_1.isComment)(node)) {
      return textContent(node.children);
    }
    if ((0, domhandler_1.isText)(node))
      return node.data;
    return "";
  };
  var innerText = function(node) {
    if (Array.isArray(node))
      return node.map(innerText).join("");
    if ((0, domhandler_1.hasChildren)(node) && (node.type === domelementtype_1.ElementType.Tag || (0, domhandler_1.isCDATA)(node))) {
      return innerText(node.children);
    }
    if ((0, domhandler_1.isText)(node))
      return node.data;
    return "";
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.innerText = exports.textContent = exports.getText = exports.getInnerHTML = exports.getOuterHTML = undefined;
  var domhandler_1 = require_lib2();
  var dom_serializer_1 = __importDefault(require_lib4());
  var domelementtype_1 = require_lib();
  exports.getOuterHTML = getOuterHTML;
  exports.getInnerHTML = getInnerHTML;
  exports.getText = getText;
  exports.textContent = textContent;
  exports.innerText = innerText;
});

// node_modules/domutils/lib/traversal.js
var require_traversal = __commonJS((exports) => {
  var getChildren = function(elem) {
    return (0, domhandler_1.hasChildren)(elem) ? elem.children : [];
  };
  var getParent = function(elem) {
    return elem.parent || null;
  };
  var getSiblings = function(elem) {
    var _a, _b;
    var parent = getParent(elem);
    if (parent != null)
      return getChildren(parent);
    var siblings = [elem];
    var { prev, next } = elem;
    while (prev != null) {
      siblings.unshift(prev);
      _a = prev, prev = _a.prev;
    }
    while (next != null) {
      siblings.push(next);
      _b = next, next = _b.next;
    }
    return siblings;
  };
  var getAttributeValue = function(elem, name) {
    var _a;
    return (_a = elem.attribs) === null || _a === undefined ? undefined : _a[name];
  };
  var hasAttrib = function(elem, name) {
    return elem.attribs != null && Object.prototype.hasOwnProperty.call(elem.attribs, name) && elem.attribs[name] != null;
  };
  var getName = function(elem) {
    return elem.name;
  };
  var nextElementSibling = function(elem) {
    var _a;
    var next = elem.next;
    while (next !== null && !(0, domhandler_1.isTag)(next))
      _a = next, next = _a.next;
    return next;
  };
  var prevElementSibling = function(elem) {
    var _a;
    var prev = elem.prev;
    while (prev !== null && !(0, domhandler_1.isTag)(prev))
      _a = prev, prev = _a.prev;
    return prev;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.prevElementSibling = exports.nextElementSibling = exports.getName = exports.hasAttrib = exports.getAttributeValue = exports.getSiblings = exports.getParent = exports.getChildren = undefined;
  var domhandler_1 = require_lib2();
  exports.getChildren = getChildren;
  exports.getParent = getParent;
  exports.getSiblings = getSiblings;
  exports.getAttributeValue = getAttributeValue;
  exports.hasAttrib = hasAttrib;
  exports.getName = getName;
  exports.nextElementSibling = nextElementSibling;
  exports.prevElementSibling = prevElementSibling;
});

// node_modules/domutils/lib/manipulation.js
var require_manipulation = __commonJS((exports) => {
  var removeElement = function(elem) {
    if (elem.prev)
      elem.prev.next = elem.next;
    if (elem.next)
      elem.next.prev = elem.prev;
    if (elem.parent) {
      var childs = elem.parent.children;
      var childsIndex = childs.lastIndexOf(elem);
      if (childsIndex >= 0) {
        childs.splice(childsIndex, 1);
      }
    }
    elem.next = null;
    elem.prev = null;
    elem.parent = null;
  };
  var replaceElement = function(elem, replacement) {
    var prev = replacement.prev = elem.prev;
    if (prev) {
      prev.next = replacement;
    }
    var next = replacement.next = elem.next;
    if (next) {
      next.prev = replacement;
    }
    var parent = replacement.parent = elem.parent;
    if (parent) {
      var childs = parent.children;
      childs[childs.lastIndexOf(elem)] = replacement;
      elem.parent = null;
    }
  };
  var appendChild = function(parent, child) {
    removeElement(child);
    child.next = null;
    child.parent = parent;
    if (parent.children.push(child) > 1) {
      var sibling = parent.children[parent.children.length - 2];
      sibling.next = child;
      child.prev = sibling;
    } else {
      child.prev = null;
    }
  };
  var append = function(elem, next) {
    removeElement(next);
    var parent = elem.parent;
    var currNext = elem.next;
    next.next = currNext;
    next.prev = elem;
    elem.next = next;
    next.parent = parent;
    if (currNext) {
      currNext.prev = next;
      if (parent) {
        var childs = parent.children;
        childs.splice(childs.lastIndexOf(currNext), 0, next);
      }
    } else if (parent) {
      parent.children.push(next);
    }
  };
  var prependChild = function(parent, child) {
    removeElement(child);
    child.parent = parent;
    child.prev = null;
    if (parent.children.unshift(child) !== 1) {
      var sibling = parent.children[1];
      sibling.prev = child;
      child.next = sibling;
    } else {
      child.next = null;
    }
  };
  var prepend = function(elem, prev) {
    removeElement(prev);
    var parent = elem.parent;
    if (parent) {
      var childs = parent.children;
      childs.splice(childs.indexOf(elem), 0, prev);
    }
    if (elem.prev) {
      elem.prev.next = prev;
    }
    prev.parent = parent;
    prev.prev = elem.prev;
    prev.next = elem;
    elem.prev = prev;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.prepend = exports.prependChild = exports.append = exports.appendChild = exports.replaceElement = exports.removeElement = undefined;
  exports.removeElement = removeElement;
  exports.replaceElement = replaceElement;
  exports.appendChild = appendChild;
  exports.append = append;
  exports.prependChild = prependChild;
  exports.prepend = prepend;
});

// node_modules/domutils/lib/querying.js
var require_querying = __commonJS((exports) => {
  var filter = function(test, node, recurse, limit) {
    if (recurse === undefined) {
      recurse = true;
    }
    if (limit === undefined) {
      limit = Infinity;
    }
    return find(test, Array.isArray(node) ? node : [node], recurse, limit);
  };
  var find = function(test, nodes, recurse, limit) {
    var result2 = [];
    var nodeStack = [nodes];
    var indexStack = [0];
    for (;; ) {
      if (indexStack[0] >= nodeStack[0].length) {
        if (indexStack.length === 1) {
          return result2;
        }
        nodeStack.shift();
        indexStack.shift();
        continue;
      }
      var elem = nodeStack[0][indexStack[0]++];
      if (test(elem)) {
        result2.push(elem);
        if (--limit <= 0)
          return result2;
      }
      if (recurse && (0, domhandler_1.hasChildren)(elem) && elem.children.length > 0) {
        indexStack.unshift(0);
        nodeStack.unshift(elem.children);
      }
    }
  };
  var findOneChild = function(test, nodes) {
    return nodes.find(test);
  };
  var findOne = function(test, nodes, recurse) {
    if (recurse === undefined) {
      recurse = true;
    }
    var elem = null;
    for (var i = 0;i < nodes.length && !elem; i++) {
      var node = nodes[i];
      if (!(0, domhandler_1.isTag)(node)) {
        continue;
      } else if (test(node)) {
        elem = node;
      } else if (recurse && node.children.length > 0) {
        elem = findOne(test, node.children, true);
      }
    }
    return elem;
  };
  var existsOne = function(test, nodes) {
    return nodes.some(function(checked) {
      return (0, domhandler_1.isTag)(checked) && (test(checked) || existsOne(test, checked.children));
    });
  };
  var findAll = function(test, nodes) {
    var result2 = [];
    var nodeStack = [nodes];
    var indexStack = [0];
    for (;; ) {
      if (indexStack[0] >= nodeStack[0].length) {
        if (nodeStack.length === 1) {
          return result2;
        }
        nodeStack.shift();
        indexStack.shift();
        continue;
      }
      var elem = nodeStack[0][indexStack[0]++];
      if (!(0, domhandler_1.isTag)(elem))
        continue;
      if (test(elem))
        result2.push(elem);
      if (elem.children.length > 0) {
        indexStack.unshift(0);
        nodeStack.unshift(elem.children);
      }
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.findAll = exports.existsOne = exports.findOne = exports.findOneChild = exports.find = exports.filter = undefined;
  var domhandler_1 = require_lib2();
  exports.filter = filter;
  exports.find = find;
  exports.findOneChild = findOneChild;
  exports.findOne = findOne;
  exports.existsOne = existsOne;
  exports.findAll = findAll;
});

// node_modules/domutils/lib/legacy.js
var require_legacy = __commonJS((exports) => {
  var getAttribCheck = function(attrib, value) {
    if (typeof value === "function") {
      return function(elem) {
        return (0, domhandler_1.isTag)(elem) && value(elem.attribs[attrib]);
      };
    }
    return function(elem) {
      return (0, domhandler_1.isTag)(elem) && elem.attribs[attrib] === value;
    };
  };
  var combineFuncs = function(a, b2) {
    return function(elem) {
      return a(elem) || b2(elem);
    };
  };
  var compileTest = function(options) {
    var funcs = Object.keys(options).map(function(key) {
      var value = options[key];
      return Object.prototype.hasOwnProperty.call(Checks, key) ? Checks[key](value) : getAttribCheck(key, value);
    });
    return funcs.length === 0 ? null : funcs.reduce(combineFuncs);
  };
  var testElement = function(options, node) {
    var test = compileTest(options);
    return test ? test(node) : true;
  };
  var getElements = function(options, nodes, recurse, limit) {
    if (limit === undefined) {
      limit = Infinity;
    }
    var test = compileTest(options);
    return test ? (0, querying_js_1.filter)(test, nodes, recurse, limit) : [];
  };
  var getElementById = function(id, nodes, recurse) {
    if (recurse === undefined) {
      recurse = true;
    }
    if (!Array.isArray(nodes))
      nodes = [nodes];
    return (0, querying_js_1.findOne)(getAttribCheck("id", id), nodes, recurse);
  };
  var getElementsByTagName = function(tagName, nodes, recurse, limit) {
    if (recurse === undefined) {
      recurse = true;
    }
    if (limit === undefined) {
      limit = Infinity;
    }
    return (0, querying_js_1.filter)(Checks["tag_name"](tagName), nodes, recurse, limit);
  };
  var getElementsByTagType = function(type, nodes, recurse, limit) {
    if (recurse === undefined) {
      recurse = true;
    }
    if (limit === undefined) {
      limit = Infinity;
    }
    return (0, querying_js_1.filter)(Checks["tag_type"](type), nodes, recurse, limit);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getElementsByTagType = exports.getElementsByTagName = exports.getElementById = exports.getElements = exports.testElement = undefined;
  var domhandler_1 = require_lib2();
  var querying_js_1 = require_querying();
  var Checks = {
    tag_name: function(name) {
      if (typeof name === "function") {
        return function(elem) {
          return (0, domhandler_1.isTag)(elem) && name(elem.name);
        };
      } else if (name === "*") {
        return domhandler_1.isTag;
      }
      return function(elem) {
        return (0, domhandler_1.isTag)(elem) && elem.name === name;
      };
    },
    tag_type: function(type) {
      if (typeof type === "function") {
        return function(elem) {
          return type(elem.type);
        };
      }
      return function(elem) {
        return elem.type === type;
      };
    },
    tag_contains: function(data) {
      if (typeof data === "function") {
        return function(elem) {
          return (0, domhandler_1.isText)(elem) && data(elem.data);
        };
      }
      return function(elem) {
        return (0, domhandler_1.isText)(elem) && elem.data === data;
      };
    }
  };
  exports.testElement = testElement;
  exports.getElements = getElements;
  exports.getElementById = getElementById;
  exports.getElementsByTagName = getElementsByTagName;
  exports.getElementsByTagType = getElementsByTagType;
});

// node_modules/domutils/lib/helpers.js
var require_helpers = __commonJS((exports) => {
  var removeSubsets = function(nodes) {
    var idx = nodes.length;
    while (--idx >= 0) {
      var node = nodes[idx];
      if (idx > 0 && nodes.lastIndexOf(node, idx - 1) >= 0) {
        nodes.splice(idx, 1);
        continue;
      }
      for (var ancestor = node.parent;ancestor; ancestor = ancestor.parent) {
        if (nodes.includes(ancestor)) {
          nodes.splice(idx, 1);
          break;
        }
      }
    }
    return nodes;
  };
  var compareDocumentPosition = function(nodeA, nodeB) {
    var aParents = [];
    var bParents = [];
    if (nodeA === nodeB) {
      return 0;
    }
    var current = (0, domhandler_1.hasChildren)(nodeA) ? nodeA : nodeA.parent;
    while (current) {
      aParents.unshift(current);
      current = current.parent;
    }
    current = (0, domhandler_1.hasChildren)(nodeB) ? nodeB : nodeB.parent;
    while (current) {
      bParents.unshift(current);
      current = current.parent;
    }
    var maxIdx = Math.min(aParents.length, bParents.length);
    var idx = 0;
    while (idx < maxIdx && aParents[idx] === bParents[idx]) {
      idx++;
    }
    if (idx === 0) {
      return DocumentPosition.DISCONNECTED;
    }
    var sharedParent = aParents[idx - 1];
    var siblings = sharedParent.children;
    var aSibling = aParents[idx];
    var bSibling = bParents[idx];
    if (siblings.indexOf(aSibling) > siblings.indexOf(bSibling)) {
      if (sharedParent === nodeB) {
        return DocumentPosition.FOLLOWING | DocumentPosition.CONTAINED_BY;
      }
      return DocumentPosition.FOLLOWING;
    }
    if (sharedParent === nodeA) {
      return DocumentPosition.PRECEDING | DocumentPosition.CONTAINS;
    }
    return DocumentPosition.PRECEDING;
  };
  var uniqueSort = function(nodes) {
    nodes = nodes.filter(function(node, i, arr) {
      return !arr.includes(node, i + 1);
    });
    nodes.sort(function(a, b2) {
      var relative = compareDocumentPosition(a, b2);
      if (relative & DocumentPosition.PRECEDING) {
        return -1;
      } else if (relative & DocumentPosition.FOLLOWING) {
        return 1;
      }
      return 0;
    });
    return nodes;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.uniqueSort = exports.compareDocumentPosition = exports.DocumentPosition = exports.removeSubsets = undefined;
  var domhandler_1 = require_lib2();
  exports.removeSubsets = removeSubsets;
  var DocumentPosition;
  (function(DocumentPosition2) {
    DocumentPosition2[DocumentPosition2["DISCONNECTED"] = 1] = "DISCONNECTED";
    DocumentPosition2[DocumentPosition2["PRECEDING"] = 2] = "PRECEDING";
    DocumentPosition2[DocumentPosition2["FOLLOWING"] = 4] = "FOLLOWING";
    DocumentPosition2[DocumentPosition2["CONTAINS"] = 8] = "CONTAINS";
    DocumentPosition2[DocumentPosition2["CONTAINED_BY"] = 16] = "CONTAINED_BY";
  })(DocumentPosition = exports.DocumentPosition || (exports.DocumentPosition = {}));
  exports.compareDocumentPosition = compareDocumentPosition;
  exports.uniqueSort = uniqueSort;
});

// node_modules/domutils/lib/feeds.js
var require_feeds = __commonJS((exports) => {
  var getFeed = function(doc) {
    var feedRoot = getOneElement(isValidFeed, doc);
    return !feedRoot ? null : feedRoot.name === "feed" ? getAtomFeed(feedRoot) : getRssFeed(feedRoot);
  };
  var getAtomFeed = function(feedRoot) {
    var _a;
    var childs = feedRoot.children;
    var feed = {
      type: "atom",
      items: (0, legacy_js_1.getElementsByTagName)("entry", childs).map(function(item) {
        var _a2;
        var children = item.children;
        var entry = { media: getMediaElements(children) };
        addConditionally(entry, "id", "id", children);
        addConditionally(entry, "title", "title", children);
        var href2 = (_a2 = getOneElement("link", children)) === null || _a2 === undefined ? undefined : _a2.attribs["href"];
        if (href2) {
          entry.link = href2;
        }
        var description = fetch2("summary", children) || fetch2("content", children);
        if (description) {
          entry.description = description;
        }
        var pubDate = fetch2("updated", children);
        if (pubDate) {
          entry.pubDate = new Date(pubDate);
        }
        return entry;
      })
    };
    addConditionally(feed, "id", "id", childs);
    addConditionally(feed, "title", "title", childs);
    var href = (_a = getOneElement("link", childs)) === null || _a === undefined ? undefined : _a.attribs["href"];
    if (href) {
      feed.link = href;
    }
    addConditionally(feed, "description", "subtitle", childs);
    var updated = fetch2("updated", childs);
    if (updated) {
      feed.updated = new Date(updated);
    }
    addConditionally(feed, "author", "email", childs, true);
    return feed;
  };
  var getRssFeed = function(feedRoot) {
    var _a, _b;
    var childs = (_b = (_a = getOneElement("channel", feedRoot.children)) === null || _a === undefined ? undefined : _a.children) !== null && _b !== undefined ? _b : [];
    var feed = {
      type: feedRoot.name.substr(0, 3),
      id: "",
      items: (0, legacy_js_1.getElementsByTagName)("item", feedRoot.children).map(function(item) {
        var children = item.children;
        var entry = { media: getMediaElements(children) };
        addConditionally(entry, "id", "guid", children);
        addConditionally(entry, "title", "title", children);
        addConditionally(entry, "link", "link", children);
        addConditionally(entry, "description", "description", children);
        var pubDate = fetch2("pubDate", children) || fetch2("dc:date", children);
        if (pubDate)
          entry.pubDate = new Date(pubDate);
        return entry;
      })
    };
    addConditionally(feed, "title", "title", childs);
    addConditionally(feed, "link", "link", childs);
    addConditionally(feed, "description", "description", childs);
    var updated = fetch2("lastBuildDate", childs);
    if (updated) {
      feed.updated = new Date(updated);
    }
    addConditionally(feed, "author", "managingEditor", childs, true);
    return feed;
  };
  var getMediaElements = function(where) {
    return (0, legacy_js_1.getElementsByTagName)("media:content", where).map(function(elem) {
      var attribs = elem.attribs;
      var media = {
        medium: attribs["medium"],
        isDefault: !!attribs["isDefault"]
      };
      for (var _i = 0, MEDIA_KEYS_STRING_1 = MEDIA_KEYS_STRING;_i < MEDIA_KEYS_STRING_1.length; _i++) {
        var attrib = MEDIA_KEYS_STRING_1[_i];
        if (attribs[attrib]) {
          media[attrib] = attribs[attrib];
        }
      }
      for (var _a = 0, MEDIA_KEYS_INT_1 = MEDIA_KEYS_INT;_a < MEDIA_KEYS_INT_1.length; _a++) {
        var attrib = MEDIA_KEYS_INT_1[_a];
        if (attribs[attrib]) {
          media[attrib] = parseInt(attribs[attrib], 10);
        }
      }
      if (attribs["expression"]) {
        media.expression = attribs["expression"];
      }
      return media;
    });
  };
  var getOneElement = function(tagName, node) {
    return (0, legacy_js_1.getElementsByTagName)(tagName, node, true, 1)[0];
  };
  var fetch2 = function(tagName, where, recurse) {
    if (recurse === undefined) {
      recurse = false;
    }
    return (0, stringify_js_1.textContent)((0, legacy_js_1.getElementsByTagName)(tagName, where, recurse, 1)).trim();
  };
  var addConditionally = function(obj, prop, tagName, where, recurse) {
    if (recurse === undefined) {
      recurse = false;
    }
    var val = fetch2(tagName, where, recurse);
    if (val)
      obj[prop] = val;
  };
  var isValidFeed = function(value) {
    return value === "rss" || value === "feed" || value === "rdf:RDF";
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getFeed = undefined;
  var stringify_js_1 = require_stringify();
  var legacy_js_1 = require_legacy();
  exports.getFeed = getFeed;
  var MEDIA_KEYS_STRING = ["url", "type", "lang"];
  var MEDIA_KEYS_INT = [
    "fileSize",
    "bitrate",
    "framerate",
    "samplingrate",
    "channels",
    "duration",
    "height",
    "width"
  ];
});

// node_modules/domutils/lib/index.js
var require_lib5 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc2 = Object.getOwnPropertyDescriptor(m, k);
    if (!desc2 || ("get" in desc2 ? !m.__esModule : desc2.writable || desc2.configurable)) {
      desc2 = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o2, k2, desc2);
  } : function(o2, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o2[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.hasChildren = exports.isDocument = exports.isComment = exports.isText = exports.isCDATA = exports.isTag = undefined;
  __exportStar(require_stringify(), exports);
  __exportStar(require_traversal(), exports);
  __exportStar(require_manipulation(), exports);
  __exportStar(require_querying(), exports);
  __exportStar(require_legacy(), exports);
  __exportStar(require_helpers(), exports);
  __exportStar(require_feeds(), exports);
  var domhandler_1 = require_lib2();
  Object.defineProperty(exports, "isTag", { enumerable: true, get: function() {
    return domhandler_1.isTag;
  } });
  Object.defineProperty(exports, "isCDATA", { enumerable: true, get: function() {
    return domhandler_1.isCDATA;
  } });
  Object.defineProperty(exports, "isText", { enumerable: true, get: function() {
    return domhandler_1.isText;
  } });
  Object.defineProperty(exports, "isComment", { enumerable: true, get: function() {
    return domhandler_1.isComment;
  } });
  Object.defineProperty(exports, "isDocument", { enumerable: true, get: function() {
    return domhandler_1.isDocument;
  } });
  Object.defineProperty(exports, "hasChildren", { enumerable: true, get: function() {
    return domhandler_1.hasChildren;
  } });
});

// node_modules/htmlparser2/lib/index.js
var require_lib6 = __commonJS((exports) => {
  var parseDocument = function(data, options) {
    var handler = new domhandler_1.DomHandler(undefined, options);
    new Parser_js_1.Parser(handler, options).end(data);
    return handler.root;
  };
  var parseDOM = function(data, options) {
    return parseDocument(data, options).children;
  };
  var createDomStream = function(callback, options, elementCallback) {
    var handler = new domhandler_1.DomHandler(callback, options, elementCallback);
    return new Parser_js_1.Parser(handler, options);
  };
  var parseFeed = function(feed, options) {
    if (options === undefined) {
      options = parseFeedDefaultOptions;
    }
    return (0, domutils_1.getFeed)(parseDOM(feed, options));
  };
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc2 = Object.getOwnPropertyDescriptor(m, k);
    if (!desc2 || ("get" in desc2 ? !m.__esModule : desc2.writable || desc2.configurable)) {
      desc2 = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o2, k2, desc2);
  } : function(o2, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o2[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v) {
    Object.defineProperty(o2, "default", { enumerable: true, value: v });
  } : function(o2, v) {
    o2["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result2 = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result2, mod, k);
    }
    __setModuleDefault(result2, mod);
    return result2;
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DomUtils = exports.parseFeed = exports.getFeed = exports.ElementType = exports.Tokenizer = exports.createDomStream = exports.parseDOM = exports.parseDocument = exports.DefaultHandler = exports.DomHandler = exports.Parser = undefined;
  var Parser_js_1 = require_Parser();
  var Parser_js_2 = require_Parser();
  Object.defineProperty(exports, "Parser", { enumerable: true, get: function() {
    return Parser_js_2.Parser;
  } });
  var domhandler_1 = require_lib2();
  var domhandler_2 = require_lib2();
  Object.defineProperty(exports, "DomHandler", { enumerable: true, get: function() {
    return domhandler_2.DomHandler;
  } });
  Object.defineProperty(exports, "DefaultHandler", { enumerable: true, get: function() {
    return domhandler_2.DomHandler;
  } });
  exports.parseDocument = parseDocument;
  exports.parseDOM = parseDOM;
  exports.createDomStream = createDomStream;
  var Tokenizer_js_1 = require_Tokenizer();
  Object.defineProperty(exports, "Tokenizer", { enumerable: true, get: function() {
    return __importDefault(Tokenizer_js_1).default;
  } });
  exports.ElementType = __importStar(require_lib());
  var domutils_1 = require_lib5();
  var domutils_2 = require_lib5();
  Object.defineProperty(exports, "getFeed", { enumerable: true, get: function() {
    return domutils_2.getFeed;
  } });
  var parseFeedDefaultOptions = { xmlMode: true };
  exports.parseFeed = parseFeed;
  exports.DomUtils = __importStar(require_lib5());
});

// node_modules/deepmerge/dist/cjs.js
var require_cjs = __commonJS((exports, module) => {
  var isNonNullObject = function(value) {
    return !!value && typeof value === "object";
  };
  var isSpecial = function(value) {
    var stringValue = Object.prototype.toString.call(value);
    return stringValue === "[object RegExp]" || stringValue === "[object Date]" || isReactElement(value);
  };
  var isReactElement = function(value) {
    return value.$$typeof === REACT_ELEMENT_TYPE;
  };
  var emptyTarget = function(val) {
    return Array.isArray(val) ? [] : {};
  };
  var cloneUnlessOtherwiseSpecified = function(value, options) {
    return options.clone !== false && options.isMergeableObject(value) ? deepmerge(emptyTarget(value), value, options) : value;
  };
  var defaultArrayMerge = function(target, source, options) {
    return target.concat(source).map(function(element) {
      return cloneUnlessOtherwiseSpecified(element, options);
    });
  };
  var getMergeFunction = function(key, options) {
    if (!options.customMerge) {
      return deepmerge;
    }
    var customMerge = options.customMerge(key);
    return typeof customMerge === "function" ? customMerge : deepmerge;
  };
  var getEnumerableOwnPropertySymbols = function(target) {
    return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(target).filter(function(symbol) {
      return Object.propertyIsEnumerable.call(target, symbol);
    }) : [];
  };
  var getKeys = function(target) {
    return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target));
  };
  var propertyIsOnObject = function(object, property) {
    try {
      return property in object;
    } catch (_) {
      return false;
    }
  };
  var propertyIsUnsafe = function(target, key) {
    return propertyIsOnObject(target, key) && !(Object.hasOwnProperty.call(target, key) && Object.propertyIsEnumerable.call(target, key));
  };
  var mergeObject = function(target, source, options) {
    var destination = {};
    if (options.isMergeableObject(target)) {
      getKeys(target).forEach(function(key) {
        destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
      });
    }
    getKeys(source).forEach(function(key) {
      if (propertyIsUnsafe(target, key)) {
        return;
      }
      if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {
        destination[key] = getMergeFunction(key, options)(target[key], source[key], options);
      } else {
        destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
      }
    });
    return destination;
  };
  var deepmerge = function(target, source, options) {
    options = options || {};
    options.arrayMerge = options.arrayMerge || defaultArrayMerge;
    options.isMergeableObject = options.isMergeableObject || isMergeableObject;
    options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;
    var sourceIsArray = Array.isArray(source);
    var targetIsArray = Array.isArray(target);
    var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;
    if (!sourceAndTargetTypesMatch) {
      return cloneUnlessOtherwiseSpecified(source, options);
    } else if (sourceIsArray) {
      return options.arrayMerge(target, source, options);
    } else {
      return mergeObject(target, source, options);
    }
  };
  var isMergeableObject = function isMergeableObject(value) {
    return isNonNullObject(value) && !isSpecial(value);
  };
  var canUseSymbol = typeof Symbol === "function" && Symbol.for;
  var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for("react.element") : 60103;
  deepmerge.all = function deepmergeAll(array2, options) {
    if (!Array.isArray(array2)) {
      throw new Error("first argument should be an array");
    }
    return array2.reduce(function(prev, next) {
      return deepmerge(prev, next, options);
    }, {});
  };
  var deepmerge_1 = deepmerge;
  module.exports = deepmerge_1;
});

// node_modules/html-to-text/lib/html-to-text.cjs
var require_html_to_text = __commonJS((exports) => {
  var _interopDefaultLegacy = function(e) {
    return e && typeof e === "object" && "default" in e ? e : { default: e };
  };
  var limitedDepthRecursive = function(n, f, g = () => {
    return;
  }) {
    if (n === undefined) {
      const f1 = function(...args) {
        return f(f1, ...args);
      };
      return f1;
    }
    if (n >= 0) {
      return function(...args) {
        return f(limitedDepthRecursive(n - 1, f, g), ...args);
      };
    }
    return g;
  };
  var trimCharacter = function(str, char) {
    let start = 0;
    let end = str.length;
    while (start < end && str[start] === char) {
      ++start;
    }
    while (end > start && str[end - 1] === char) {
      --end;
    }
    return start > 0 || end < str.length ? str.substring(start, end) : str;
  };
  var trimCharacterEnd = function(str, char) {
    let end = str.length;
    while (end > 0 && str[end - 1] === char) {
      --end;
    }
    return end < str.length ? str.substring(0, end) : str;
  };
  var unicodeEscape = function(str) {
    return str.replace(/[\s\S]/g, (c2) => "\\u" + c2.charCodeAt().toString(16).padStart(4, "0"));
  };
  var mergeDuplicatesPreferLast = function(items, getKey) {
    const map = new Map;
    for (let i = items.length;i-- > 0; ) {
      const item = items[i];
      const key = getKey(item);
      map.set(key, map.has(key) ? merge__default["default"](item, map.get(key), { arrayMerge: overwriteMerge$1 }) : item);
    }
    return [...map.values()].reverse();
  };
  var get = function(obj, path) {
    for (const key of path) {
      if (!obj) {
        return;
      }
      obj = obj[key];
    }
    return obj;
  };
  var numberToLetterSequence = function(num, baseChar = "a", base = 26) {
    const digits = [];
    do {
      num -= 1;
      digits.push(num % base);
      num = num / base >> 0;
    } while (num > 0);
    const baseCode = baseChar.charCodeAt(0);
    return digits.reverse().map((n) => String.fromCharCode(baseCode + n)).join("");
  };
  var numberToRoman = function(num) {
    return [...num + ""].map((n) => +n).reverse().map((v, i) => v % 5 < 4 ? (v < 5 ? "" : V[i]) + I[i].repeat(v % 5) : I[i] + (v < 5 ? V[i] : I[i + 1])).reverse().join("");
  };
  var charactersToCodes = function(str) {
    return [...str].map((c2) => "\\u" + c2.charCodeAt(0).toString(16).padStart(4, "0")).join("");
  };
  var getText = function(stackItem) {
    if (!(stackItem instanceof BlockStackItem || stackItem instanceof ListItemStackItem || stackItem instanceof TableCellStackItem)) {
      throw new Error("Only blocks, list items and table cells can be requested for text contents.");
    }
    return stackItem.inlineTextBuilder.isEmpty() ? stackItem.rawText : stackItem.rawText + stackItem.inlineTextBuilder.toString();
  };
  var addText = function(stackItem, text2, leadingLineBreaks, trailingLineBreaks) {
    if (!(stackItem instanceof BlockStackItem || stackItem instanceof ListItemStackItem || stackItem instanceof TableCellStackItem)) {
      throw new Error("Only blocks, list items and table cells can contain text.");
    }
    const parentText = getText(stackItem);
    const lineBreaks = Math.max(stackItem.stashedLineBreaks, leadingLineBreaks);
    stackItem.inlineTextBuilder.clear();
    if (parentText) {
      stackItem.rawText = parentText + "\n".repeat(lineBreaks) + text2;
    } else {
      stackItem.rawText = text2;
      stackItem.leadingLineBreaks = lineBreaks;
    }
    stackItem.stashedLineBreaks = trailingLineBreaks;
  };
  var applyTransformer = function(str, transformer) {
    return transformer ? applyTransformer(transformer.transform(str), transformer.next) : str;
  };
  var compile$1 = function(options = {}) {
    const selectorsWithoutFormat = options.selectors.filter((s) => !s.format);
    if (selectorsWithoutFormat.length) {
      throw new Error("Following selectors have no specified format: " + selectorsWithoutFormat.map((s) => `\`${s.selector}\``).join(", "));
    }
    const picker = new selderee.DecisionTree(options.selectors.map((s) => [s.selector, s])).build(pluginHtmlparser2.hp2Builder);
    if (typeof options.encodeCharacters !== "function") {
      options.encodeCharacters = makeReplacerFromDict(options.encodeCharacters);
    }
    const baseSelectorsPicker = new selderee.DecisionTree(options.baseElements.selectors.map((s, i) => [s, i + 1])).build(pluginHtmlparser2.hp2Builder);
    function findBaseElements(dom) {
      return findBases(dom, options, baseSelectorsPicker);
    }
    const limitedWalk = limitedDepthRecursive(options.limits.maxDepth, recursiveWalk, function(dom, builder) {
      builder.addInline(options.limits.ellipsis || "");
    });
    return function(html, metadata = undefined) {
      return process2(html, metadata, options, picker, findBaseElements, limitedWalk);
    };
  };
  var process2 = function(html, metadata, options, picker, findBaseElements, walk) {
    const maxInputLength = options.limits.maxInputLength;
    if (maxInputLength && html && html.length > maxInputLength) {
      console.warn(`Input length ${html.length} is above allowed limit of ${maxInputLength}. Truncating without ellipsis.`);
      html = html.substring(0, maxInputLength);
    }
    const document = htmlparser2.parseDocument(html, { decodeEntities: options.decodeEntities });
    const bases = findBaseElements(document.children);
    const builder = new BlockTextBuilder(options, picker, metadata);
    walk(bases, builder);
    return builder.toString();
  };
  var findBases = function(dom, options, baseSelectorsPicker) {
    const results = [];
    function recursiveWalk2(walk, dom2) {
      dom2 = dom2.slice(0, options.limits.maxChildNodes);
      for (const elem of dom2) {
        if (elem.type !== "tag") {
          continue;
        }
        const pickedSelectorIndex = baseSelectorsPicker.pick1(elem);
        if (pickedSelectorIndex > 0) {
          results.push({ selectorIndex: pickedSelectorIndex, element: elem });
        } else if (elem.children) {
          walk(elem.children);
        }
        if (results.length >= options.limits.maxBaseElements) {
          return;
        }
      }
    }
    const limitedWalk = limitedDepthRecursive(options.limits.maxDepth, recursiveWalk2);
    limitedWalk(dom);
    if (options.baseElements.orderBy !== "occurrence") {
      results.sort((a, b2) => a.selectorIndex - b2.selectorIndex);
    }
    return options.baseElements.returnDomByDefault && results.length === 0 ? dom : results.map((x) => x.element);
  };
  var recursiveWalk = function(walk, dom, builder) {
    if (!dom) {
      return;
    }
    const options = builder.options;
    const tooManyChildNodes = dom.length > options.limits.maxChildNodes;
    if (tooManyChildNodes) {
      dom = dom.slice(0, options.limits.maxChildNodes);
      dom.push({
        data: options.limits.ellipsis,
        type: "text"
      });
    }
    for (const elem of dom) {
      switch (elem.type) {
        case "text": {
          builder.addInline(elem.data);
          break;
        }
        case "tag": {
          const tagDefinition = builder.picker.pick1(elem);
          const format = options.formatters[tagDefinition.format];
          format(elem, walk, builder, tagDefinition.options || {});
          break;
        }
      }
    }
    return;
  };
  var makeReplacerFromDict = function(dict) {
    if (!dict || Object.keys(dict).length === 0) {
      return;
    }
    const entries = Object.entries(dict).filter(([, v]) => v !== false);
    const regex = new RegExp(entries.map(([c2]) => `(${unicodeEscape([...c2][0])})`).join("|"), "g");
    const values2 = entries.map(([, v]) => v);
    const replacer = (m, ...cgs) => values2[cgs.findIndex((cg) => cg)];
    return (str) => str.replace(regex, replacer);
  };
  var formatSkip = function(elem, walk, builder, formatOptions) {
  };
  var formatInlineString = function(elem, walk, builder, formatOptions) {
    builder.addLiteral(formatOptions.string || "");
  };
  var formatBlockString = function(elem, walk, builder, formatOptions) {
    builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });
    builder.addLiteral(formatOptions.string || "");
    builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
  };
  var formatInline = function(elem, walk, builder, formatOptions) {
    walk(elem.children, builder);
  };
  var formatBlock$1 = function(elem, walk, builder, formatOptions) {
    builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });
    walk(elem.children, builder);
    builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
  };
  var renderOpenTag = function(elem) {
    const attrs = elem.attribs && elem.attribs.length ? " " + Object.entries(elem.attribs).map(([k, v]) => v === "" ? k : `${k}=${v.replace(/"/g, "&quot;")}`).join(" ") : "";
    return `<${elem.name}${attrs}>`;
  };
  var renderCloseTag = function(elem) {
    return `</${elem.name}>`;
  };
  var formatInlineTag = function(elem, walk, builder, formatOptions) {
    builder.startNoWrap();
    builder.addLiteral(renderOpenTag(elem));
    builder.stopNoWrap();
    walk(elem.children, builder);
    builder.startNoWrap();
    builder.addLiteral(renderCloseTag(elem));
    builder.stopNoWrap();
  };
  var formatBlockTag = function(elem, walk, builder, formatOptions) {
    builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });
    builder.startNoWrap();
    builder.addLiteral(renderOpenTag(elem));
    builder.stopNoWrap();
    walk(elem.children, builder);
    builder.startNoWrap();
    builder.addLiteral(renderCloseTag(elem));
    builder.stopNoWrap();
    builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
  };
  var formatInlineHtml = function(elem, walk, builder, formatOptions) {
    builder.startNoWrap();
    builder.addLiteral(domSerializer.render(elem, { decodeEntities: builder.options.decodeEntities }));
    builder.stopNoWrap();
  };
  var formatBlockHtml = function(elem, walk, builder, formatOptions) {
    builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });
    builder.startNoWrap();
    builder.addLiteral(domSerializer.render(elem, { decodeEntities: builder.options.decodeEntities }));
    builder.stopNoWrap();
    builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
  };
  var formatInlineSurround = function(elem, walk, builder, formatOptions) {
    builder.addLiteral(formatOptions.prefix || "");
    walk(elem.children, builder);
    builder.addLiteral(formatOptions.suffix || "");
  };
  var getRow = function(matrix, j) {
    if (!matrix[j]) {
      matrix[j] = [];
    }
    return matrix[j];
  };
  var findFirstVacantIndex = function(row, x = 0) {
    while (row[x]) {
      x++;
    }
    return x;
  };
  var transposeInPlace = function(matrix, maxSize) {
    for (let i = 0;i < maxSize; i++) {
      const rowI = getRow(matrix, i);
      for (let j = 0;j < i; j++) {
        const rowJ = getRow(matrix, j);
        if (rowI[j] || rowJ[i]) {
          const temp = rowI[j];
          rowI[j] = rowJ[i];
          rowJ[i] = temp;
        }
      }
    }
  };
  var putCellIntoLayout = function(cell, layout, baseRow, baseCol) {
    for (let r = 0;r < cell.rowspan; r++) {
      const layoutRow = getRow(layout, baseRow + r);
      for (let c2 = 0;c2 < cell.colspan; c2++) {
        layoutRow[baseCol + c2] = cell;
      }
    }
  };
  var getOrInitOffset = function(offsets, index) {
    if (offsets[index] === undefined) {
      offsets[index] = index === 0 ? 0 : 1 + getOrInitOffset(offsets, index - 1);
    }
    return offsets[index];
  };
  var updateOffset = function(offsets, base, span, value) {
    offsets[base + span] = Math.max(getOrInitOffset(offsets, base + span), getOrInitOffset(offsets, base) + value);
  };
  var tableToString = function(tableRows, rowSpacing, colSpacing) {
    const layout = [];
    let colNumber = 0;
    const rowNumber = tableRows.length;
    const rowOffsets = [0];
    for (let j = 0;j < rowNumber; j++) {
      const layoutRow = getRow(layout, j);
      const cells = tableRows[j];
      let x = 0;
      for (let i = 0;i < cells.length; i++) {
        const cell = cells[i];
        x = findFirstVacantIndex(layoutRow, x);
        putCellIntoLayout(cell, layout, j, x);
        x += cell.colspan;
        cell.lines = cell.text.split("\n");
        const cellHeight = cell.lines.length;
        updateOffset(rowOffsets, j, cell.rowspan, cellHeight + rowSpacing);
      }
      colNumber = layoutRow.length > colNumber ? layoutRow.length : colNumber;
    }
    transposeInPlace(layout, rowNumber > colNumber ? rowNumber : colNumber);
    const outputLines = [];
    const colOffsets = [0];
    for (let x = 0;x < colNumber; x++) {
      let y = 0;
      let cell;
      const rowsInThisColumn = Math.min(rowNumber, layout[x].length);
      while (y < rowsInThisColumn) {
        cell = layout[x][y];
        if (cell) {
          if (!cell.rendered) {
            let cellWidth = 0;
            for (let j = 0;j < cell.lines.length; j++) {
              const line = cell.lines[j];
              const lineOffset = rowOffsets[y] + j;
              outputLines[lineOffset] = (outputLines[lineOffset] || "").padEnd(colOffsets[x]) + line;
              cellWidth = line.length > cellWidth ? line.length : cellWidth;
            }
            updateOffset(colOffsets, x, cell.colspan, cellWidth + colSpacing);
            cell.rendered = true;
          }
          y += cell.rowspan;
        } else {
          const lineOffset = rowOffsets[y];
          outputLines[lineOffset] = outputLines[lineOffset] || "";
          y++;
        }
      }
    }
    return outputLines.join("\n");
  };
  var formatLineBreak = function(elem, walk, builder, formatOptions) {
    builder.addLineBreak();
  };
  var formatWbr = function(elem, walk, builder, formatOptions) {
    builder.addWordBreakOpportunity();
  };
  var formatHorizontalLine = function(elem, walk, builder, formatOptions) {
    builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });
    builder.addInline("-".repeat(formatOptions.length || builder.options.wordwrap || 40));
    builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
  };
  var formatParagraph = function(elem, walk, builder, formatOptions) {
    builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });
    walk(elem.children, builder);
    builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
  };
  var formatPre = function(elem, walk, builder, formatOptions) {
    builder.openBlock({
      isPre: true,
      leadingLineBreaks: formatOptions.leadingLineBreaks || 2
    });
    walk(elem.children, builder);
    builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
  };
  var formatHeading = function(elem, walk, builder, formatOptions) {
    builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });
    if (formatOptions.uppercase !== false) {
      builder.pushWordTransform((str) => str.toUpperCase());
      walk(elem.children, builder);
      builder.popWordTransform();
    } else {
      walk(elem.children, builder);
    }
    builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
  };
  var formatBlockquote = function(elem, walk, builder, formatOptions) {
    builder.openBlock({
      leadingLineBreaks: formatOptions.leadingLineBreaks || 2,
      reservedLineLength: 2
    });
    walk(elem.children, builder);
    builder.closeBlock({
      trailingLineBreaks: formatOptions.trailingLineBreaks || 2,
      blockTransform: (str) => (formatOptions.trimEmptyLines !== false ? trimCharacter(str, "\n") : str).split("\n").map((line) => "> " + line).join("\n")
    });
  };
  var withBrackets = function(str, brackets) {
    if (!brackets) {
      return str;
    }
    const lbr = typeof brackets[0] === "string" ? brackets[0] : "[";
    const rbr = typeof brackets[1] === "string" ? brackets[1] : "]";
    return lbr + str + rbr;
  };
  var pathRewrite = function(path, rewriter, baseUrl, metadata, elem) {
    const modifiedPath = typeof rewriter === "function" ? rewriter(path, metadata, elem) : path;
    return modifiedPath[0] === "/" && baseUrl ? trimCharacterEnd(baseUrl, "/") + modifiedPath : modifiedPath;
  };
  var formatImage = function(elem, walk, builder, formatOptions) {
    const attribs = elem.attribs || {};
    const alt = attribs.alt ? attribs.alt : "";
    const src = !attribs.src ? "" : pathRewrite(attribs.src, formatOptions.pathRewrite, formatOptions.baseUrl, builder.metadata, elem);
    const text2 = !src ? alt : !alt ? withBrackets(src, formatOptions.linkBrackets) : alt + " " + withBrackets(src, formatOptions.linkBrackets);
    builder.addInline(text2, { noWordTransform: true });
  };
  var formatAnchor = function(elem, walk, builder, formatOptions) {
    function getHref() {
      if (formatOptions.ignoreHref) {
        return "";
      }
      if (!elem.attribs || !elem.attribs.href) {
        return "";
      }
      let href2 = elem.attribs.href.replace(/^mailto:/, "");
      if (formatOptions.noAnchorUrl && href2[0] === "#") {
        return "";
      }
      href2 = pathRewrite(href2, formatOptions.pathRewrite, formatOptions.baseUrl, builder.metadata, elem);
      return href2;
    }
    const href = getHref();
    if (!href) {
      walk(elem.children, builder);
    } else {
      let text2 = "";
      builder.pushWordTransform((str) => {
        if (str) {
          text2 += str;
        }
        return str;
      });
      walk(elem.children, builder);
      builder.popWordTransform();
      const hideSameLink = formatOptions.hideLinkHrefIfSameAsText && href === text2;
      if (!hideSameLink) {
        builder.addInline(!text2 ? href : " " + withBrackets(href, formatOptions.linkBrackets), { noWordTransform: true });
      }
    }
  };
  var formatList = function(elem, walk, builder, formatOptions, nextPrefixCallback) {
    const isNestedList = get(elem, ["parent", "name"]) === "li";
    let maxPrefixLength = 0;
    const listItems = (elem.children || []).filter((child) => child.type !== "text" || !/^\s*$/.test(child.data)).map(function(child) {
      if (child.name !== "li") {
        return { node: child, prefix: "" };
      }
      const prefix = isNestedList ? nextPrefixCallback().trimStart() : nextPrefixCallback();
      if (prefix.length > maxPrefixLength) {
        maxPrefixLength = prefix.length;
      }
      return { node: child, prefix };
    });
    if (!listItems.length) {
      return;
    }
    builder.openList({
      interRowLineBreaks: 1,
      leadingLineBreaks: isNestedList ? 1 : formatOptions.leadingLineBreaks || 2,
      maxPrefixLength,
      prefixAlign: "left"
    });
    for (const { node, prefix } of listItems) {
      builder.openListItem({ prefix });
      walk([node], builder);
      builder.closeListItem();
    }
    builder.closeList({ trailingLineBreaks: isNestedList ? 1 : formatOptions.trailingLineBreaks || 2 });
  };
  var formatUnorderedList = function(elem, walk, builder, formatOptions) {
    const prefix = formatOptions.itemPrefix || " * ";
    return formatList(elem, walk, builder, formatOptions, () => prefix);
  };
  var formatOrderedList = function(elem, walk, builder, formatOptions) {
    let nextIndex = Number(elem.attribs.start || "1");
    const indexFunction = getOrderedListIndexFunction(elem.attribs.type);
    const nextPrefixCallback = () => " " + indexFunction(nextIndex++) + ". ";
    return formatList(elem, walk, builder, formatOptions, nextPrefixCallback);
  };
  var getOrderedListIndexFunction = function(olType = "1") {
    switch (olType) {
      case "a":
        return (i) => numberToLetterSequence(i, "a");
      case "A":
        return (i) => numberToLetterSequence(i, "A");
      case "i":
        return (i) => numberToRoman(i).toLowerCase();
      case "I":
        return (i) => numberToRoman(i);
      case "1":
      default:
        return (i) => i.toString();
    }
  };
  var splitClassesAndIds = function(selectors) {
    const classes = [];
    const ids = [];
    for (const selector of selectors) {
      if (selector.startsWith(".")) {
        classes.push(selector.substring(1));
      } else if (selector.startsWith("#")) {
        ids.push(selector.substring(1));
      }
    }
    return { classes, ids };
  };
  var isDataTable = function(attr, tables) {
    if (tables === true) {
      return true;
    }
    if (!attr) {
      return false;
    }
    const { classes, ids } = splitClassesAndIds(tables);
    const attrClasses = (attr["class"] || "").split(" ");
    const attrIds = (attr["id"] || "").split(" ");
    return attrClasses.some((x) => classes.includes(x)) || attrIds.some((x) => ids.includes(x));
  };
  var formatTable = function(elem, walk, builder, formatOptions) {
    return isDataTable(elem.attribs, builder.options.tables) ? formatDataTable(elem, walk, builder, formatOptions) : formatBlock(elem, walk, builder, formatOptions);
  };
  var formatBlock = function(elem, walk, builder, formatOptions) {
    builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks });
    walk(elem.children, builder);
    builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks });
  };
  var formatDataTable = function(elem, walk, builder, formatOptions) {
    builder.openTable();
    elem.children.forEach(walkTable);
    builder.closeTable({
      tableToString: (rows) => tableToString(rows, formatOptions.rowSpacing ?? 0, formatOptions.colSpacing ?? 3),
      leadingLineBreaks: formatOptions.leadingLineBreaks,
      trailingLineBreaks: formatOptions.trailingLineBreaks
    });
    function formatCell(cellNode) {
      const colspan = +get(cellNode, ["attribs", "colspan"]) || 1;
      const rowspan = +get(cellNode, ["attribs", "rowspan"]) || 1;
      builder.openTableCell({ maxColumnWidth: formatOptions.maxColumnWidth });
      walk(cellNode.children, builder);
      builder.closeTableCell({ colspan, rowspan });
    }
    function walkTable(elem2) {
      if (elem2.type !== "tag") {
        return;
      }
      const formatHeaderCell = formatOptions.uppercaseHeaderCells !== false ? (cellNode) => {
        builder.pushWordTransform((str) => str.toUpperCase());
        formatCell(cellNode);
        builder.popWordTransform();
      } : formatCell;
      switch (elem2.name) {
        case "thead":
        case "tbody":
        case "tfoot":
        case "center":
          elem2.children.forEach(walkTable);
          return;
        case "tr": {
          builder.openTableRow();
          for (const childOfTr of elem2.children) {
            if (childOfTr.type !== "tag") {
              continue;
            }
            switch (childOfTr.name) {
              case "th": {
                formatHeaderCell(childOfTr);
                break;
              }
              case "td": {
                formatCell(childOfTr);
                break;
              }
            }
          }
          builder.closeTableRow();
          break;
        }
      }
    }
  };
  var compile = function(options = {}) {
    options = merge__default["default"](DEFAULT_OPTIONS, options, {
      arrayMerge: overwriteMerge,
      customMerge: (key) => key === "selectors" ? selectorsMerge : undefined
    });
    options.formatters = Object.assign({}, genericFormatters, textFormatters, options.formatters);
    options.selectors = mergeDuplicatesPreferLast(options.selectors, (s) => s.selector);
    handleDeprecatedOptions(options);
    return compile$1(options);
  };
  var convert = function(html, options = {}, metadata = undefined) {
    return compile(options)(html, metadata);
  };
  var handleDeprecatedOptions = function(options) {
    if (options.tags) {
      const tagDefinitions = Object.entries(options.tags).map(([selector, definition]) => ({ ...definition, selector: selector || "*" }));
      options.selectors.push(...tagDefinitions);
      options.selectors = mergeDuplicatesPreferLast(options.selectors, (s) => s.selector);
    }
    function set(obj, path, value) {
      const valueKey = path.pop();
      for (const key of path) {
        let nested = obj[key];
        if (!nested) {
          nested = {};
          obj[key] = nested;
        }
        obj = nested;
      }
      obj[valueKey] = value;
    }
    if (options["baseElement"]) {
      const baseElement = options["baseElement"];
      set(options, ["baseElements", "selectors"], Array.isArray(baseElement) ? baseElement : [baseElement]);
    }
    if (options["returnDomByDefault"] !== undefined) {
      set(options, ["baseElements", "returnDomByDefault"], options["returnDomByDefault"]);
    }
    for (const definition of options.selectors) {
      if (definition.format === "anchor" && get(definition, ["options", "noLinkBrackets"])) {
        set(definition, ["options", "linkBrackets"], false);
      }
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var pluginHtmlparser2 = require_hp2_builder();
  var htmlparser2 = require_lib6();
  var selderee = require_selderee();
  var merge = require_cjs();
  var domSerializer = require_lib4();
  var merge__default = _interopDefaultLegacy(merge);
  var overwriteMerge$1 = (acc, src, options) => [...src];
  var I = ["I", "X", "C", "M"];
  var V = ["V", "L", "D"];

  class InlineTextBuilder {
    constructor(options, maxLineLength = undefined) {
      this.lines = [];
      this.nextLineWords = [];
      this.maxLineLength = maxLineLength || options.wordwrap || Number.MAX_VALUE;
      this.nextLineAvailableChars = this.maxLineLength;
      this.wrapCharacters = get(options, ["longWordSplit", "wrapCharacters"]) || [];
      this.forceWrapOnLimit = get(options, ["longWordSplit", "forceWrapOnLimit"]) || false;
      this.stashedSpace = false;
      this.wordBreakOpportunity = false;
    }
    pushWord(word, noWrap = false) {
      if (this.nextLineAvailableChars <= 0 && !noWrap) {
        this.startNewLine();
      }
      const isLineStart = this.nextLineWords.length === 0;
      const cost = word.length + (isLineStart ? 0 : 1);
      if (cost <= this.nextLineAvailableChars || noWrap) {
        this.nextLineWords.push(word);
        this.nextLineAvailableChars -= cost;
      } else {
        const [first, ...rest] = this.splitLongWord(word);
        if (!isLineStart) {
          this.startNewLine();
        }
        this.nextLineWords.push(first);
        this.nextLineAvailableChars -= first.length;
        for (const part of rest) {
          this.startNewLine();
          this.nextLineWords.push(part);
          this.nextLineAvailableChars -= part.length;
        }
      }
    }
    popWord() {
      const lastWord = this.nextLineWords.pop();
      if (lastWord !== undefined) {
        const isLineStart = this.nextLineWords.length === 0;
        const cost = lastWord.length + (isLineStart ? 0 : 1);
        this.nextLineAvailableChars += cost;
      }
      return lastWord;
    }
    concatWord(word, noWrap = false) {
      if (this.wordBreakOpportunity && word.length > this.nextLineAvailableChars) {
        this.pushWord(word, noWrap);
        this.wordBreakOpportunity = false;
      } else {
        const lastWord = this.popWord();
        this.pushWord(lastWord ? lastWord.concat(word) : word, noWrap);
      }
    }
    startNewLine(n = 1) {
      this.lines.push(this.nextLineWords);
      if (n > 1) {
        this.lines.push(...Array.from({ length: n - 1 }, () => []));
      }
      this.nextLineWords = [];
      this.nextLineAvailableChars = this.maxLineLength;
    }
    isEmpty() {
      return this.lines.length === 0 && this.nextLineWords.length === 0;
    }
    clear() {
      this.lines.length = 0;
      this.nextLineWords.length = 0;
      this.nextLineAvailableChars = this.maxLineLength;
    }
    toString() {
      return [...this.lines, this.nextLineWords].map((words) => words.join(" ")).join("\n");
    }
    splitLongWord(word) {
      const parts = [];
      let idx = 0;
      while (word.length > this.maxLineLength) {
        const firstLine = word.substring(0, this.maxLineLength);
        const remainingChars = word.substring(this.maxLineLength);
        const splitIndex = firstLine.lastIndexOf(this.wrapCharacters[idx]);
        if (splitIndex > -1) {
          word = firstLine.substring(splitIndex + 1) + remainingChars;
          parts.push(firstLine.substring(0, splitIndex + 1));
        } else {
          idx++;
          if (idx < this.wrapCharacters.length) {
            word = firstLine + remainingChars;
          } else {
            if (this.forceWrapOnLimit) {
              parts.push(firstLine);
              word = remainingChars;
              if (word.length > this.maxLineLength) {
                continue;
              }
            } else {
              word = firstLine + remainingChars;
            }
            break;
          }
        }
      }
      parts.push(word);
      return parts;
    }
  }

  class StackItem {
    constructor(next = null) {
      this.next = next;
    }
    getRoot() {
      return this.next ? this.next : this;
    }
  }

  class BlockStackItem extends StackItem {
    constructor(options, next = null, leadingLineBreaks = 1, maxLineLength = undefined) {
      super(next);
      this.leadingLineBreaks = leadingLineBreaks;
      this.inlineTextBuilder = new InlineTextBuilder(options, maxLineLength);
      this.rawText = "";
      this.stashedLineBreaks = 0;
      this.isPre = next && next.isPre;
      this.isNoWrap = next && next.isNoWrap;
    }
  }

  class ListStackItem extends BlockStackItem {
    constructor(options, next = null, {
      interRowLineBreaks = 1,
      leadingLineBreaks = 2,
      maxLineLength = undefined,
      maxPrefixLength = 0,
      prefixAlign = "left"
    } = {}) {
      super(options, next, leadingLineBreaks, maxLineLength);
      this.maxPrefixLength = maxPrefixLength;
      this.prefixAlign = prefixAlign;
      this.interRowLineBreaks = interRowLineBreaks;
    }
  }

  class ListItemStackItem extends BlockStackItem {
    constructor(options, next = null, {
      leadingLineBreaks = 1,
      maxLineLength = undefined,
      prefix = ""
    } = {}) {
      super(options, next, leadingLineBreaks, maxLineLength);
      this.prefix = prefix;
    }
  }

  class TableStackItem extends StackItem {
    constructor(next = null) {
      super(next);
      this.rows = [];
      this.isPre = next && next.isPre;
      this.isNoWrap = next && next.isNoWrap;
    }
  }

  class TableRowStackItem extends StackItem {
    constructor(next = null) {
      super(next);
      this.cells = [];
      this.isPre = next && next.isPre;
      this.isNoWrap = next && next.isNoWrap;
    }
  }

  class TableCellStackItem extends StackItem {
    constructor(options, next = null, maxColumnWidth = undefined) {
      super(next);
      this.inlineTextBuilder = new InlineTextBuilder(options, maxColumnWidth);
      this.rawText = "";
      this.stashedLineBreaks = 0;
      this.isPre = next && next.isPre;
      this.isNoWrap = next && next.isNoWrap;
    }
  }

  class TransformerStackItem extends StackItem {
    constructor(next = null, transform) {
      super(next);
      this.transform = transform;
    }
  }

  class WhitespaceProcessor {
    constructor(options) {
      this.whitespaceChars = options.preserveNewlines ? options.whitespaceCharacters.replace(/\n/g, "") : options.whitespaceCharacters;
      const whitespaceCodes = charactersToCodes(this.whitespaceChars);
      this.leadingWhitespaceRe = new RegExp(`^[${whitespaceCodes}]`);
      this.trailingWhitespaceRe = new RegExp(`[${whitespaceCodes}]\$`);
      this.allWhitespaceOrEmptyRe = new RegExp(`^[${whitespaceCodes}]*\$`);
      this.newlineOrNonWhitespaceRe = new RegExp(`(\\n|[^\\n${whitespaceCodes}])`, "g");
      this.newlineOrNonNewlineStringRe = new RegExp(`(\\n|[^\\n]+)`, "g");
      if (options.preserveNewlines) {
        const wordOrNewlineRe = new RegExp(`\\n|[^\\n${whitespaceCodes}]+`, "gm");
        this.shrinkWrapAdd = function(text2, inlineTextBuilder, transform = (str) => str, noWrap = false) {
          if (!text2) {
            return;
          }
          const previouslyStashedSpace = inlineTextBuilder.stashedSpace;
          let anyMatch = false;
          let m = wordOrNewlineRe.exec(text2);
          if (m) {
            anyMatch = true;
            if (m[0] === "\n") {
              inlineTextBuilder.startNewLine();
            } else if (previouslyStashedSpace || this.testLeadingWhitespace(text2)) {
              inlineTextBuilder.pushWord(transform(m[0]), noWrap);
            } else {
              inlineTextBuilder.concatWord(transform(m[0]), noWrap);
            }
            while ((m = wordOrNewlineRe.exec(text2)) !== null) {
              if (m[0] === "\n") {
                inlineTextBuilder.startNewLine();
              } else {
                inlineTextBuilder.pushWord(transform(m[0]), noWrap);
              }
            }
          }
          inlineTextBuilder.stashedSpace = previouslyStashedSpace && !anyMatch || this.testTrailingWhitespace(text2);
        };
      } else {
        const wordRe = new RegExp(`[^${whitespaceCodes}]+`, "g");
        this.shrinkWrapAdd = function(text2, inlineTextBuilder, transform = (str) => str, noWrap = false) {
          if (!text2) {
            return;
          }
          const previouslyStashedSpace = inlineTextBuilder.stashedSpace;
          let anyMatch = false;
          let m = wordRe.exec(text2);
          if (m) {
            anyMatch = true;
            if (previouslyStashedSpace || this.testLeadingWhitespace(text2)) {
              inlineTextBuilder.pushWord(transform(m[0]), noWrap);
            } else {
              inlineTextBuilder.concatWord(transform(m[0]), noWrap);
            }
            while ((m = wordRe.exec(text2)) !== null) {
              inlineTextBuilder.pushWord(transform(m[0]), noWrap);
            }
          }
          inlineTextBuilder.stashedSpace = previouslyStashedSpace && !anyMatch || this.testTrailingWhitespace(text2);
        };
      }
    }
    addLiteral(text2, inlineTextBuilder, noWrap = true) {
      if (!text2) {
        return;
      }
      const previouslyStashedSpace = inlineTextBuilder.stashedSpace;
      let anyMatch = false;
      let m = this.newlineOrNonNewlineStringRe.exec(text2);
      if (m) {
        anyMatch = true;
        if (m[0] === "\n") {
          inlineTextBuilder.startNewLine();
        } else if (previouslyStashedSpace) {
          inlineTextBuilder.pushWord(m[0], noWrap);
        } else {
          inlineTextBuilder.concatWord(m[0], noWrap);
        }
        while ((m = this.newlineOrNonNewlineStringRe.exec(text2)) !== null) {
          if (m[0] === "\n") {
            inlineTextBuilder.startNewLine();
          } else {
            inlineTextBuilder.pushWord(m[0], noWrap);
          }
        }
      }
      inlineTextBuilder.stashedSpace = previouslyStashedSpace && !anyMatch;
    }
    testLeadingWhitespace(text2) {
      return this.leadingWhitespaceRe.test(text2);
    }
    testTrailingWhitespace(text2) {
      return this.trailingWhitespaceRe.test(text2);
    }
    testContainsWords(text2) {
      return !this.allWhitespaceOrEmptyRe.test(text2);
    }
    countNewlinesNoWords(text2) {
      this.newlineOrNonWhitespaceRe.lastIndex = 0;
      let counter = 0;
      let match;
      while ((match = this.newlineOrNonWhitespaceRe.exec(text2)) !== null) {
        if (match[0] === "\n") {
          counter++;
        } else {
          return 0;
        }
      }
      return counter;
    }
  }

  class BlockTextBuilder {
    constructor(options, picker, metadata = undefined) {
      this.options = options;
      this.picker = picker;
      this.metadata = metadata;
      this.whitespaceProcessor = new WhitespaceProcessor(options);
      this._stackItem = new BlockStackItem(options);
      this._wordTransformer = undefined;
    }
    pushWordTransform(wordTransform) {
      this._wordTransformer = new TransformerStackItem(this._wordTransformer, wordTransform);
    }
    popWordTransform() {
      if (!this._wordTransformer) {
        return;
      }
      const transform = this._wordTransformer.transform;
      this._wordTransformer = this._wordTransformer.next;
      return transform;
    }
    startNoWrap() {
      this._stackItem.isNoWrap = true;
    }
    stopNoWrap() {
      this._stackItem.isNoWrap = false;
    }
    _getCombinedWordTransformer() {
      const wt = this._wordTransformer ? (str) => applyTransformer(str, this._wordTransformer) : undefined;
      const ce = this.options.encodeCharacters;
      return wt ? ce ? (str) => ce(wt(str)) : wt : ce;
    }
    _popStackItem() {
      const item = this._stackItem;
      this._stackItem = item.next;
      return item;
    }
    addLineBreak() {
      if (!(this._stackItem instanceof BlockStackItem || this._stackItem instanceof ListItemStackItem || this._stackItem instanceof TableCellStackItem)) {
        return;
      }
      if (this._stackItem.isPre) {
        this._stackItem.rawText += "\n";
      } else {
        this._stackItem.inlineTextBuilder.startNewLine();
      }
    }
    addWordBreakOpportunity() {
      if (this._stackItem instanceof BlockStackItem || this._stackItem instanceof ListItemStackItem || this._stackItem instanceof TableCellStackItem) {
        this._stackItem.inlineTextBuilder.wordBreakOpportunity = true;
      }
    }
    addInline(str, { noWordTransform = false } = {}) {
      if (!(this._stackItem instanceof BlockStackItem || this._stackItem instanceof ListItemStackItem || this._stackItem instanceof TableCellStackItem)) {
        return;
      }
      if (this._stackItem.isPre) {
        this._stackItem.rawText += str;
        return;
      }
      if (str.length === 0 || this._stackItem.stashedLineBreaks && !this.whitespaceProcessor.testContainsWords(str)) {
        return;
      }
      if (this.options.preserveNewlines) {
        const newlinesNumber = this.whitespaceProcessor.countNewlinesNoWords(str);
        if (newlinesNumber > 0) {
          this._stackItem.inlineTextBuilder.startNewLine(newlinesNumber);
          return;
        }
      }
      if (this._stackItem.stashedLineBreaks) {
        this._stackItem.inlineTextBuilder.startNewLine(this._stackItem.stashedLineBreaks);
      }
      this.whitespaceProcessor.shrinkWrapAdd(str, this._stackItem.inlineTextBuilder, noWordTransform ? undefined : this._getCombinedWordTransformer(), this._stackItem.isNoWrap);
      this._stackItem.stashedLineBreaks = 0;
    }
    addLiteral(str) {
      if (!(this._stackItem instanceof BlockStackItem || this._stackItem instanceof ListItemStackItem || this._stackItem instanceof TableCellStackItem)) {
        return;
      }
      if (str.length === 0) {
        return;
      }
      if (this._stackItem.isPre) {
        this._stackItem.rawText += str;
        return;
      }
      if (this._stackItem.stashedLineBreaks) {
        this._stackItem.inlineTextBuilder.startNewLine(this._stackItem.stashedLineBreaks);
      }
      this.whitespaceProcessor.addLiteral(str, this._stackItem.inlineTextBuilder, this._stackItem.isNoWrap);
      this._stackItem.stashedLineBreaks = 0;
    }
    openBlock({ leadingLineBreaks = 1, reservedLineLength = 0, isPre = false } = {}) {
      const maxLineLength = Math.max(20, this._stackItem.inlineTextBuilder.maxLineLength - reservedLineLength);
      this._stackItem = new BlockStackItem(this.options, this._stackItem, leadingLineBreaks, maxLineLength);
      if (isPre) {
        this._stackItem.isPre = true;
      }
    }
    closeBlock({ trailingLineBreaks = 1, blockTransform = undefined } = {}) {
      const block = this._popStackItem();
      const blockText = blockTransform ? blockTransform(getText(block)) : getText(block);
      addText(this._stackItem, blockText, block.leadingLineBreaks, Math.max(block.stashedLineBreaks, trailingLineBreaks));
    }
    openList({ maxPrefixLength = 0, prefixAlign = "left", interRowLineBreaks = 1, leadingLineBreaks = 2 } = {}) {
      this._stackItem = new ListStackItem(this.options, this._stackItem, {
        interRowLineBreaks,
        leadingLineBreaks,
        maxLineLength: this._stackItem.inlineTextBuilder.maxLineLength,
        maxPrefixLength,
        prefixAlign
      });
    }
    openListItem({ prefix = "" } = {}) {
      if (!(this._stackItem instanceof ListStackItem)) {
        throw new Error("Can\'t add a list item to something that is not a list! Check the formatter.");
      }
      const list = this._stackItem;
      const prefixLength = Math.max(prefix.length, list.maxPrefixLength);
      const maxLineLength = Math.max(20, list.inlineTextBuilder.maxLineLength - prefixLength);
      this._stackItem = new ListItemStackItem(this.options, list, {
        prefix,
        maxLineLength,
        leadingLineBreaks: list.interRowLineBreaks
      });
    }
    closeListItem() {
      const listItem = this._popStackItem();
      const list = listItem.next;
      const prefixLength = Math.max(listItem.prefix.length, list.maxPrefixLength);
      const spacing = "\n" + " ".repeat(prefixLength);
      const prefix = list.prefixAlign === "right" ? listItem.prefix.padStart(prefixLength) : listItem.prefix.padEnd(prefixLength);
      const text2 = prefix + getText(listItem).replace(/\n/g, spacing);
      addText(list, text2, listItem.leadingLineBreaks, Math.max(listItem.stashedLineBreaks, list.interRowLineBreaks));
    }
    closeList({ trailingLineBreaks = 2 } = {}) {
      const list = this._popStackItem();
      const text2 = getText(list);
      if (text2) {
        addText(this._stackItem, text2, list.leadingLineBreaks, trailingLineBreaks);
      }
    }
    openTable() {
      this._stackItem = new TableStackItem(this._stackItem);
    }
    openTableRow() {
      if (!(this._stackItem instanceof TableStackItem)) {
        throw new Error("Can\'t add a table row to something that is not a table! Check the formatter.");
      }
      this._stackItem = new TableRowStackItem(this._stackItem);
    }
    openTableCell({ maxColumnWidth = undefined } = {}) {
      if (!(this._stackItem instanceof TableRowStackItem)) {
        throw new Error("Can\'t add a table cell to something that is not a table row! Check the formatter.");
      }
      this._stackItem = new TableCellStackItem(this.options, this._stackItem, maxColumnWidth);
    }
    closeTableCell({ colspan = 1, rowspan = 1 } = {}) {
      const cell = this._popStackItem();
      const text2 = trimCharacter(getText(cell), "\n");
      cell.next.cells.push({ colspan, rowspan, text: text2 });
    }
    closeTableRow() {
      const row = this._popStackItem();
      row.next.rows.push(row.cells);
    }
    closeTable({ tableToString: tableToString2, leadingLineBreaks = 2, trailingLineBreaks = 2 }) {
      const table16 = this._popStackItem();
      const output = tableToString2(table16.rows);
      if (output) {
        addText(this._stackItem, output, leadingLineBreaks, trailingLineBreaks);
      }
    }
    toString() {
      return getText(this._stackItem.getRoot());
    }
  }
  var genericFormatters = Object.freeze({
    __proto__: null,
    block: formatBlock$1,
    blockHtml: formatBlockHtml,
    blockString: formatBlockString,
    blockTag: formatBlockTag,
    inline: formatInline,
    inlineHtml: formatInlineHtml,
    inlineString: formatInlineString,
    inlineSurround: formatInlineSurround,
    inlineTag: formatInlineTag,
    skip: formatSkip
  });
  var textFormatters = Object.freeze({
    __proto__: null,
    anchor: formatAnchor,
    blockquote: formatBlockquote,
    dataTable: formatDataTable,
    heading: formatHeading,
    horizontalLine: formatHorizontalLine,
    image: formatImage,
    lineBreak: formatLineBreak,
    orderedList: formatOrderedList,
    paragraph: formatParagraph,
    pre: formatPre,
    table: formatTable,
    unorderedList: formatUnorderedList,
    wbr: formatWbr
  });
  var DEFAULT_OPTIONS = {
    baseElements: {
      selectors: ["body"],
      orderBy: "selectors",
      returnDomByDefault: true
    },
    decodeEntities: true,
    encodeCharacters: {},
    formatters: {},
    limits: {
      ellipsis: "...",
      maxBaseElements: undefined,
      maxChildNodes: undefined,
      maxDepth: undefined,
      maxInputLength: 1 << 24
    },
    longWordSplit: {
      forceWrapOnLimit: false,
      wrapCharacters: []
    },
    preserveNewlines: false,
    selectors: [
      { selector: "*", format: "inline" },
      {
        selector: "a",
        format: "anchor",
        options: {
          baseUrl: null,
          hideLinkHrefIfSameAsText: false,
          ignoreHref: false,
          linkBrackets: ["[", "]"],
          noAnchorUrl: true
        }
      },
      { selector: "article", format: "block", options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
      { selector: "aside", format: "block", options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
      {
        selector: "blockquote",
        format: "blockquote",
        options: { leadingLineBreaks: 2, trailingLineBreaks: 2, trimEmptyLines: true }
      },
      { selector: "br", format: "lineBreak" },
      { selector: "div", format: "block", options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
      { selector: "footer", format: "block", options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
      { selector: "form", format: "block", options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
      { selector: "h1", format: "heading", options: { leadingLineBreaks: 3, trailingLineBreaks: 2, uppercase: true } },
      { selector: "h2", format: "heading", options: { leadingLineBreaks: 3, trailingLineBreaks: 2, uppercase: true } },
      { selector: "h3", format: "heading", options: { leadingLineBreaks: 3, trailingLineBreaks: 2, uppercase: true } },
      { selector: "h4", format: "heading", options: { leadingLineBreaks: 2, trailingLineBreaks: 2, uppercase: true } },
      { selector: "h5", format: "heading", options: { leadingLineBreaks: 2, trailingLineBreaks: 2, uppercase: true } },
      { selector: "h6", format: "heading", options: { leadingLineBreaks: 2, trailingLineBreaks: 2, uppercase: true } },
      { selector: "header", format: "block", options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
      {
        selector: "hr",
        format: "horizontalLine",
        options: { leadingLineBreaks: 2, length: undefined, trailingLineBreaks: 2 }
      },
      {
        selector: "img",
        format: "image",
        options: { baseUrl: null, linkBrackets: ["[", "]"] }
      },
      { selector: "main", format: "block", options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
      { selector: "nav", format: "block", options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
      {
        selector: "ol",
        format: "orderedList",
        options: { leadingLineBreaks: 2, trailingLineBreaks: 2 }
      },
      { selector: "p", format: "paragraph", options: { leadingLineBreaks: 2, trailingLineBreaks: 2 } },
      { selector: "pre", format: "pre", options: { leadingLineBreaks: 2, trailingLineBreaks: 2 } },
      { selector: "section", format: "block", options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
      {
        selector: "table",
        format: "table",
        options: {
          colSpacing: 3,
          leadingLineBreaks: 2,
          maxColumnWidth: 60,
          rowSpacing: 0,
          trailingLineBreaks: 2,
          uppercaseHeaderCells: true
        }
      },
      {
        selector: "ul",
        format: "unorderedList",
        options: { itemPrefix: " * ", leadingLineBreaks: 2, trailingLineBreaks: 2 }
      },
      { selector: "wbr", format: "wbr" }
    ],
    tables: [],
    whitespaceCharacters: ` 	\r
\u200B`,
    wordwrap: 80
  };
  var concatMerge = (acc, src, options) => [...acc, ...src];
  var overwriteMerge = (acc, src, options) => [...src];
  var selectorsMerge = (acc, src, options) => acc.some((s) => typeof s === "object") ? concatMerge(acc, src) : overwriteMerge(acc, src);
  exports.compile = compile;
  exports.convert = convert;
  exports.htmlToText = convert;
});

// node_modules/js-beautify/js/src/core/output.js
var require_output = __commonJS((exports, module) => {
  var OutputLine = function(parent) {
    this.__parent = parent;
    this.__character_count = 0;
    this.__indent_count = -1;
    this.__alignment_count = 0;
    this.__wrap_point_index = 0;
    this.__wrap_point_character_count = 0;
    this.__wrap_point_indent_count = -1;
    this.__wrap_point_alignment_count = 0;
    this.__items = [];
  };
  var IndentStringCache = function(options, baseIndentString) {
    this.__cache = [""];
    this.__indent_size = options.indent_size;
    this.__indent_string = options.indent_char;
    if (!options.indent_with_tabs) {
      this.__indent_string = new Array(options.indent_size + 1).join(options.indent_char);
    }
    baseIndentString = baseIndentString || "";
    if (options.indent_level > 0) {
      baseIndentString = new Array(options.indent_level + 1).join(this.__indent_string);
    }
    this.__base_string = baseIndentString;
    this.__base_string_length = baseIndentString.length;
  };
  var Output = function(options, baseIndentString) {
    this.__indent_cache = new IndentStringCache(options, baseIndentString);
    this.raw = false;
    this._end_with_newline = options.end_with_newline;
    this.indent_size = options.indent_size;
    this.wrap_line_length = options.wrap_line_length;
    this.indent_empty_lines = options.indent_empty_lines;
    this.__lines = [];
    this.previous_line = null;
    this.current_line = null;
    this.next_line = new OutputLine(this);
    this.space_before_token = false;
    this.non_breaking_space = false;
    this.previous_token_wrapped = false;
    this.__add_outputline();
  };
  OutputLine.prototype.clone_empty = function() {
    var line = new OutputLine(this.__parent);
    line.set_indent(this.__indent_count, this.__alignment_count);
    return line;
  };
  OutputLine.prototype.item = function(index) {
    if (index < 0) {
      return this.__items[this.__items.length + index];
    } else {
      return this.__items[index];
    }
  };
  OutputLine.prototype.has_match = function(pattern) {
    for (var lastCheckedOutput = this.__items.length - 1;lastCheckedOutput >= 0; lastCheckedOutput--) {
      if (this.__items[lastCheckedOutput].match(pattern)) {
        return true;
      }
    }
    return false;
  };
  OutputLine.prototype.set_indent = function(indent, alignment) {
    if (this.is_empty()) {
      this.__indent_count = indent || 0;
      this.__alignment_count = alignment || 0;
      this.__character_count = this.__parent.get_indent_size(this.__indent_count, this.__alignment_count);
    }
  };
  OutputLine.prototype._set_wrap_point = function() {
    if (this.__parent.wrap_line_length) {
      this.__wrap_point_index = this.__items.length;
      this.__wrap_point_character_count = this.__character_count;
      this.__wrap_point_indent_count = this.__parent.next_line.__indent_count;
      this.__wrap_point_alignment_count = this.__parent.next_line.__alignment_count;
    }
  };
  OutputLine.prototype._should_wrap = function() {
    return this.__wrap_point_index && this.__character_count > this.__parent.wrap_line_length && this.__wrap_point_character_count > this.__parent.next_line.__character_count;
  };
  OutputLine.prototype._allow_wrap = function() {
    if (this._should_wrap()) {
      this.__parent.add_new_line();
      var next = this.__parent.current_line;
      next.set_indent(this.__wrap_point_indent_count, this.__wrap_point_alignment_count);
      next.__items = this.__items.slice(this.__wrap_point_index);
      this.__items = this.__items.slice(0, this.__wrap_point_index);
      next.__character_count += this.__character_count - this.__wrap_point_character_count;
      this.__character_count = this.__wrap_point_character_count;
      if (next.__items[0] === " ") {
        next.__items.splice(0, 1);
        next.__character_count -= 1;
      }
      return true;
    }
    return false;
  };
  OutputLine.prototype.is_empty = function() {
    return this.__items.length === 0;
  };
  OutputLine.prototype.last = function() {
    if (!this.is_empty()) {
      return this.__items[this.__items.length - 1];
    } else {
      return null;
    }
  };
  OutputLine.prototype.push = function(item) {
    this.__items.push(item);
    var last_newline_index = item.lastIndexOf("\n");
    if (last_newline_index !== -1) {
      this.__character_count = item.length - last_newline_index;
    } else {
      this.__character_count += item.length;
    }
  };
  OutputLine.prototype.pop = function() {
    var item = null;
    if (!this.is_empty()) {
      item = this.__items.pop();
      this.__character_count -= item.length;
    }
    return item;
  };
  OutputLine.prototype._remove_indent = function() {
    if (this.__indent_count > 0) {
      this.__indent_count -= 1;
      this.__character_count -= this.__parent.indent_size;
    }
  };
  OutputLine.prototype._remove_wrap_indent = function() {
    if (this.__wrap_point_indent_count > 0) {
      this.__wrap_point_indent_count -= 1;
    }
  };
  OutputLine.prototype.trim = function() {
    while (this.last() === " ") {
      this.__items.pop();
      this.__character_count -= 1;
    }
  };
  OutputLine.prototype.toString = function() {
    var result2 = "";
    if (this.is_empty()) {
      if (this.__parent.indent_empty_lines) {
        result2 = this.__parent.get_indent_string(this.__indent_count);
      }
    } else {
      result2 = this.__parent.get_indent_string(this.__indent_count, this.__alignment_count);
      result2 += this.__items.join("");
    }
    return result2;
  };
  IndentStringCache.prototype.get_indent_size = function(indent, column9) {
    var result2 = this.__base_string_length;
    column9 = column9 || 0;
    if (indent < 0) {
      result2 = 0;
    }
    result2 += indent * this.__indent_size;
    result2 += column9;
    return result2;
  };
  IndentStringCache.prototype.get_indent_string = function(indent_level, column9) {
    var result2 = this.__base_string;
    column9 = column9 || 0;
    if (indent_level < 0) {
      indent_level = 0;
      result2 = "";
    }
    column9 += indent_level * this.__indent_size;
    this.__ensure_cache(column9);
    result2 += this.__cache[column9];
    return result2;
  };
  IndentStringCache.prototype.__ensure_cache = function(column9) {
    while (column9 >= this.__cache.length) {
      this.__add_column();
    }
  };
  IndentStringCache.prototype.__add_column = function() {
    var column9 = this.__cache.length;
    var indent = 0;
    var result2 = "";
    if (this.__indent_size && column9 >= this.__indent_size) {
      indent = Math.floor(column9 / this.__indent_size);
      column9 -= indent * this.__indent_size;
      result2 = new Array(indent + 1).join(this.__indent_string);
    }
    if (column9) {
      result2 += new Array(column9 + 1).join(" ");
    }
    this.__cache.push(result2);
  };
  Output.prototype.__add_outputline = function() {
    this.previous_line = this.current_line;
    this.current_line = this.next_line.clone_empty();
    this.__lines.push(this.current_line);
  };
  Output.prototype.get_line_number = function() {
    return this.__lines.length;
  };
  Output.prototype.get_indent_string = function(indent, column9) {
    return this.__indent_cache.get_indent_string(indent, column9);
  };
  Output.prototype.get_indent_size = function(indent, column9) {
    return this.__indent_cache.get_indent_size(indent, column9);
  };
  Output.prototype.is_empty = function() {
    return !this.previous_line && this.current_line.is_empty();
  };
  Output.prototype.add_new_line = function(force_newline) {
    if (this.is_empty() || !force_newline && this.just_added_newline()) {
      return false;
    }
    if (!this.raw) {
      this.__add_outputline();
    }
    return true;
  };
  Output.prototype.get_code = function(eol) {
    this.trim(true);
    var last_item = this.current_line.pop();
    if (last_item) {
      if (last_item[last_item.length - 1] === "\n") {
        last_item = last_item.replace(/\n+$/g, "");
      }
      this.current_line.push(last_item);
    }
    if (this._end_with_newline) {
      this.__add_outputline();
    }
    var sweet_code = this.__lines.join("\n");
    if (eol !== "\n") {
      sweet_code = sweet_code.replace(/[\n]/g, eol);
    }
    return sweet_code;
  };
  Output.prototype.set_wrap_point = function() {
    this.current_line._set_wrap_point();
  };
  Output.prototype.set_indent = function(indent, alignment) {
    indent = indent || 0;
    alignment = alignment || 0;
    this.next_line.set_indent(indent, alignment);
    if (this.__lines.length > 1) {
      this.current_line.set_indent(indent, alignment);
      return true;
    }
    this.current_line.set_indent();
    return false;
  };
  Output.prototype.add_raw_token = function(token) {
    for (var x = 0;x < token.newlines; x++) {
      this.__add_outputline();
    }
    this.current_line.set_indent(-1);
    this.current_line.push(token.whitespace_before);
    this.current_line.push(token.text);
    this.space_before_token = false;
    this.non_breaking_space = false;
    this.previous_token_wrapped = false;
  };
  Output.prototype.add_token = function(printable_token) {
    this.__add_space_before_token();
    this.current_line.push(printable_token);
    this.space_before_token = false;
    this.non_breaking_space = false;
    this.previous_token_wrapped = this.current_line._allow_wrap();
  };
  Output.prototype.__add_space_before_token = function() {
    if (this.space_before_token && !this.just_added_newline()) {
      if (!this.non_breaking_space) {
        this.set_wrap_point();
      }
      this.current_line.push(" ");
    }
  };
  Output.prototype.remove_indent = function(index) {
    var output_length = this.__lines.length;
    while (index < output_length) {
      this.__lines[index]._remove_indent();
      index++;
    }
    this.current_line._remove_wrap_indent();
  };
  Output.prototype.trim = function(eat_newlines) {
    eat_newlines = eat_newlines === undefined ? false : eat_newlines;
    this.current_line.trim();
    while (eat_newlines && this.__lines.length > 1 && this.current_line.is_empty()) {
      this.__lines.pop();
      this.current_line = this.__lines[this.__lines.length - 1];
      this.current_line.trim();
    }
    this.previous_line = this.__lines.length > 1 ? this.__lines[this.__lines.length - 2] : null;
  };
  Output.prototype.just_added_newline = function() {
    return this.current_line.is_empty();
  };
  Output.prototype.just_added_blankline = function() {
    return this.is_empty() || this.current_line.is_empty() && this.previous_line.is_empty();
  };
  Output.prototype.ensure_empty_line_above = function(starts_with, ends_with) {
    var index = this.__lines.length - 2;
    while (index >= 0) {
      var potentialEmptyLine = this.__lines[index];
      if (potentialEmptyLine.is_empty()) {
        break;
      } else if (potentialEmptyLine.item(0).indexOf(starts_with) !== 0 && potentialEmptyLine.item(-1) !== ends_with) {
        this.__lines.splice(index + 1, 0, new OutputLine(this));
        this.previous_line = this.__lines[this.__lines.length - 2];
        break;
      }
      index--;
    }
  };
  exports.Output = Output;
});

// node_modules/js-beautify/js/src/core/token.js
var require_token = __commonJS((exports, module) => {
  var Token = function(type, text2, newlines, whitespace_before) {
    this.type = type;
    this.text = text2;
    this.comments_before = null;
    this.newlines = newlines || 0;
    this.whitespace_before = whitespace_before || "";
    this.parent = null;
    this.next = null;
    this.previous = null;
    this.opened = null;
    this.closed = null;
    this.directives = null;
  };
  exports.Token = Token;
});

// node_modules/js-beautify/js/src/javascript/acorn.js
var require_acorn = __commonJS((exports) => {
  var baseASCIIidentifierStartChars = "\\x23\\x24\\x40\\x41-\\x5a\\x5f\\x61-\\x7a";
  var baseASCIIidentifierChars = "\\x24\\x30-\\x39\\x41-\\x5a\\x5f\\x61-\\x7a";
  var nonASCIIidentifierStartChars = "\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u0527\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05d0-\\u05ea\\u05f0-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u08a0\\u08a2-\\u08ac\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0977\\u0979-\\u097f\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c33\\u0c35-\\u0c39\\u0c3d\\u0c58\\u0c59\\u0c60\\u0c61\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d05-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d60\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e87\\u0e88\\u0e8a\\u0e8d\\u0e94-\\u0e97\\u0e99-\\u0e9f\\u0ea1-\\u0ea3\\u0ea5\\u0ea7\\u0eaa\\u0eab\\u0ead-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f4\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f0\\u1700-\\u170c\\u170e-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1877\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191c\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19c1-\\u19c7\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4b\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1ce9-\\u1cec\\u1cee-\\u1cf1\\u1cf5\\u1cf6\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2119-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u212d\\u212f-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u2e2f\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309d-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312d\\u3131-\\u318e\\u31a0-\\u31ba\\u31f0-\\u31ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua697\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua78e\\ua790-\\ua793\\ua7a0-\\ua7aa\\ua7f8-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa80-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uabc0-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc";
  var nonASCIIidentifierChars = "\\u0300-\\u036f\\u0483-\\u0487\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u0620-\\u0649\\u0672-\\u06d3\\u06e7-\\u06e8\\u06fb-\\u06fc\\u0730-\\u074a\\u0800-\\u0814\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0840-\\u0857\\u08e4-\\u08fe\\u0900-\\u0903\\u093a-\\u093c\\u093e-\\u094f\\u0951-\\u0957\\u0962-\\u0963\\u0966-\\u096f\\u0981-\\u0983\\u09bc\\u09be-\\u09c4\\u09c7\\u09c8\\u09d7\\u09df-\\u09e0\\u0a01-\\u0a03\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a66-\\u0a71\\u0a75\\u0a81-\\u0a83\\u0abc\\u0abe-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ae2-\\u0ae3\\u0ae6-\\u0aef\\u0b01-\\u0b03\\u0b3c\\u0b3e-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b56\\u0b57\\u0b5f-\\u0b60\\u0b66-\\u0b6f\\u0b82\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd7\\u0be6-\\u0bef\\u0c01-\\u0c03\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62-\\u0c63\\u0c66-\\u0c6f\\u0c82\\u0c83\\u0cbc\\u0cbe-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0ce2-\\u0ce3\\u0ce6-\\u0cef\\u0d02\\u0d03\\u0d46-\\u0d48\\u0d57\\u0d62-\\u0d63\\u0d66-\\u0d6f\\u0d82\\u0d83\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0df2\\u0df3\\u0e34-\\u0e3a\\u0e40-\\u0e45\\u0e50-\\u0e59\\u0eb4-\\u0eb9\\u0ec8-\\u0ecd\\u0ed0-\\u0ed9\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f41-\\u0f47\\u0f71-\\u0f84\\u0f86-\\u0f87\\u0f8d-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u1000-\\u1029\\u1040-\\u1049\\u1067-\\u106d\\u1071-\\u1074\\u1082-\\u108d\\u108f-\\u109d\\u135d-\\u135f\\u170e-\\u1710\\u1720-\\u1730\\u1740-\\u1750\\u1772\\u1773\\u1780-\\u17b2\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u1810-\\u1819\\u1920-\\u192b\\u1930-\\u193b\\u1951-\\u196d\\u19b0-\\u19c0\\u19c8-\\u19c9\\u19d0-\\u19d9\\u1a00-\\u1a15\\u1a20-\\u1a53\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1b46-\\u1b4b\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1bb0-\\u1bb9\\u1be6-\\u1bf3\\u1c00-\\u1c22\\u1c40-\\u1c49\\u1c5b-\\u1c7d\\u1cd0-\\u1cd2\\u1d00-\\u1dbe\\u1e01-\\u1f15\\u200c\\u200d\\u203f\\u2040\\u2054\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2d81-\\u2d96\\u2de0-\\u2dff\\u3021-\\u3028\\u3099\\u309a\\ua640-\\ua66d\\ua674-\\ua67d\\ua69f\\ua6f0-\\ua6f1\\ua7f8-\\ua800\\ua806\\ua80b\\ua823-\\ua827\\ua880-\\ua881\\ua8b4-\\ua8c4\\ua8d0-\\ua8d9\\ua8f3-\\ua8f7\\ua900-\\ua909\\ua926-\\ua92d\\ua930-\\ua945\\ua980-\\ua983\\ua9b3-\\ua9c0\\uaa00-\\uaa27\\uaa40-\\uaa41\\uaa4c-\\uaa4d\\uaa50-\\uaa59\\uaa7b\\uaae0-\\uaae9\\uaaf2-\\uaaf3\\uabc0-\\uabe1\\uabec\\uabed\\uabf0-\\uabf9\\ufb20-\\ufb28\\ufe00-\\ufe0f\\ufe20-\\ufe26\\ufe33\\ufe34\\ufe4d-\\ufe4f\\uff10-\\uff19\\uff3f";
  var unicodeEscapeOrCodePoint = "\\\\u[0-9a-fA-F]{4}|\\\\u\\{[0-9a-fA-F]+\\}";
  var identifierStart = "(?:" + unicodeEscapeOrCodePoint + "|[" + baseASCIIidentifierStartChars + nonASCIIidentifierStartChars + "])";
  var identifierChars = "(?:" + unicodeEscapeOrCodePoint + "|[" + baseASCIIidentifierChars + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "])*";
  exports.identifier = new RegExp(identifierStart + identifierChars, "g");
  exports.identifierStart = new RegExp(identifierStart);
  exports.identifierMatch = new RegExp("(?:" + unicodeEscapeOrCodePoint + "|[" + baseASCIIidentifierChars + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "])+");
  exports.newline = /[\n\r\u2028\u2029]/;
  exports.lineBreak = new RegExp("\r\n|" + exports.newline.source);
  exports.allLineBreaks = new RegExp(exports.lineBreak.source, "g");
});

// node_modules/js-beautify/js/src/core/options.js
var require_options = __commonJS((exports, module) => {
  var Options = function(options, merge_child_field) {
    this.raw_options = _mergeOpts(options, merge_child_field);
    this.disabled = this._get_boolean("disabled");
    this.eol = this._get_characters("eol", "auto");
    this.end_with_newline = this._get_boolean("end_with_newline");
    this.indent_size = this._get_number("indent_size", 4);
    this.indent_char = this._get_characters("indent_char", " ");
    this.indent_level = this._get_number("indent_level");
    this.preserve_newlines = this._get_boolean("preserve_newlines", true);
    this.max_preserve_newlines = this._get_number("max_preserve_newlines", 32786);
    if (!this.preserve_newlines) {
      this.max_preserve_newlines = 0;
    }
    this.indent_with_tabs = this._get_boolean("indent_with_tabs", this.indent_char === "\t");
    if (this.indent_with_tabs) {
      this.indent_char = "\t";
      if (this.indent_size === 1) {
        this.indent_size = 4;
      }
    }
    this.wrap_line_length = this._get_number("wrap_line_length", this._get_number("max_char"));
    this.indent_empty_lines = this._get_boolean("indent_empty_lines");
    this.templating = this._get_selection_list("templating", ["auto", "none", "django", "erb", "handlebars", "php", "smarty"], ["auto"]);
  };
  var _mergeOpts = function(allOptions, childFieldName) {
    var finalOpts = {};
    allOptions = _normalizeOpts(allOptions);
    var name;
    for (name in allOptions) {
      if (name !== childFieldName) {
        finalOpts[name] = allOptions[name];
      }
    }
    if (childFieldName && allOptions[childFieldName]) {
      for (name in allOptions[childFieldName]) {
        finalOpts[name] = allOptions[childFieldName][name];
      }
    }
    return finalOpts;
  };
  var _normalizeOpts = function(options) {
    var convertedOpts = {};
    var key;
    for (key in options) {
      var newKey = key.replace(/-/g, "_");
      convertedOpts[newKey] = options[key];
    }
    return convertedOpts;
  };
  Options.prototype._get_array = function(name, default_value) {
    var option_value = this.raw_options[name];
    var result2 = default_value || [];
    if (typeof option_value === "object") {
      if (option_value !== null && typeof option_value.concat === "function") {
        result2 = option_value.concat();
      }
    } else if (typeof option_value === "string") {
      result2 = option_value.split(/[^a-zA-Z0-9_\/\-]+/);
    }
    return result2;
  };
  Options.prototype._get_boolean = function(name, default_value) {
    var option_value = this.raw_options[name];
    var result2 = option_value === undefined ? !!default_value : !!option_value;
    return result2;
  };
  Options.prototype._get_characters = function(name, default_value) {
    var option_value = this.raw_options[name];
    var result2 = default_value || "";
    if (typeof option_value === "string") {
      result2 = option_value.replace(/\\r/, "\r").replace(/\\n/, "\n").replace(/\\t/, "\t");
    }
    return result2;
  };
  Options.prototype._get_number = function(name, default_value) {
    var option_value = this.raw_options[name];
    default_value = parseInt(default_value, 10);
    if (isNaN(default_value)) {
      default_value = 0;
    }
    var result2 = parseInt(option_value, 10);
    if (isNaN(result2)) {
      result2 = default_value;
    }
    return result2;
  };
  Options.prototype._get_selection = function(name, selection_list, default_value) {
    var result2 = this._get_selection_list(name, selection_list, default_value);
    if (result2.length !== 1) {
      throw new Error("Invalid Option Value: The option '" + name + "' can only be one of the following values:\n" + selection_list + "\nYou passed in: '" + this.raw_options[name] + "'");
    }
    return result2[0];
  };
  Options.prototype._get_selection_list = function(name, selection_list, default_value) {
    if (!selection_list || selection_list.length === 0) {
      throw new Error("Selection list cannot be empty.");
    }
    default_value = default_value || [selection_list[0]];
    if (!this._is_valid_selection(default_value, selection_list)) {
      throw new Error("Invalid Default Value!");
    }
    var result2 = this._get_array(name, default_value);
    if (!this._is_valid_selection(result2, selection_list)) {
      throw new Error("Invalid Option Value: The option '" + name + "' can contain only the following values:\n" + selection_list + "\nYou passed in: '" + this.raw_options[name] + "'");
    }
    return result2;
  };
  Options.prototype._is_valid_selection = function(result2, selection_list) {
    return result2.length && selection_list.length && !result2.some(function(item) {
      return selection_list.indexOf(item) === -1;
    });
  };
  exports.Options = Options;
  exports.normalizeOpts = _normalizeOpts;
  exports.mergeOpts = _mergeOpts;
});

// node_modules/js-beautify/js/src/javascript/options.js
var require_options2 = __commonJS((exports, module) => {
  var Options = function(options) {
    BaseOptions.call(this, options, "js");
    var raw_brace_style = this.raw_options.brace_style || null;
    if (raw_brace_style === "expand-strict") {
      this.raw_options.brace_style = "expand";
    } else if (raw_brace_style === "collapse-preserve-inline") {
      this.raw_options.brace_style = "collapse,preserve-inline";
    } else if (this.raw_options.braces_on_own_line !== undefined) {
      this.raw_options.brace_style = this.raw_options.braces_on_own_line ? "expand" : "collapse";
    }
    var brace_style_split = this._get_selection_list("brace_style", ["collapse", "expand", "end-expand", "none", "preserve-inline"]);
    this.brace_preserve_inline = false;
    this.brace_style = "collapse";
    for (var bs = 0;bs < brace_style_split.length; bs++) {
      if (brace_style_split[bs] === "preserve-inline") {
        this.brace_preserve_inline = true;
      } else {
        this.brace_style = brace_style_split[bs];
      }
    }
    this.unindent_chained_methods = this._get_boolean("unindent_chained_methods");
    this.break_chained_methods = this._get_boolean("break_chained_methods");
    this.space_in_paren = this._get_boolean("space_in_paren");
    this.space_in_empty_paren = this._get_boolean("space_in_empty_paren");
    this.jslint_happy = this._get_boolean("jslint_happy");
    this.space_after_anon_function = this._get_boolean("space_after_anon_function");
    this.space_after_named_function = this._get_boolean("space_after_named_function");
    this.keep_array_indentation = this._get_boolean("keep_array_indentation");
    this.space_before_conditional = this._get_boolean("space_before_conditional", true);
    this.unescape_strings = this._get_boolean("unescape_strings");
    this.e4x = this._get_boolean("e4x");
    this.comma_first = this._get_boolean("comma_first");
    this.operator_position = this._get_selection("operator_position", validPositionValues);
    this.test_output_raw = this._get_boolean("test_output_raw");
    if (this.jslint_happy) {
      this.space_after_anon_function = true;
    }
  };
  var BaseOptions = require_options().Options;
  var validPositionValues = ["before-newline", "after-newline", "preserve-newline"];
  Options.prototype = new BaseOptions;
  exports.Options = Options;
});

// node_modules/js-beautify/js/src/core/inputscanner.js
var require_inputscanner = __commonJS((exports, module) => {
  var InputScanner = function(input_string) {
    this.__input = input_string || "";
    this.__input_length = this.__input.length;
    this.__position = 0;
  };
  var regexp_has_sticky = RegExp.prototype.hasOwnProperty("sticky");
  InputScanner.prototype.restart = function() {
    this.__position = 0;
  };
  InputScanner.prototype.back = function() {
    if (this.__position > 0) {
      this.__position -= 1;
    }
  };
  InputScanner.prototype.hasNext = function() {
    return this.__position < this.__input_length;
  };
  InputScanner.prototype.next = function() {
    var val = null;
    if (this.hasNext()) {
      val = this.__input.charAt(this.__position);
      this.__position += 1;
    }
    return val;
  };
  InputScanner.prototype.peek = function(index) {
    var val = null;
    index = index || 0;
    index += this.__position;
    if (index >= 0 && index < this.__input_length) {
      val = this.__input.charAt(index);
    }
    return val;
  };
  InputScanner.prototype.__match = function(pattern, index) {
    pattern.lastIndex = index;
    var pattern_match = pattern.exec(this.__input);
    if (pattern_match && !(regexp_has_sticky && pattern.sticky)) {
      if (pattern_match.index !== index) {
        pattern_match = null;
      }
    }
    return pattern_match;
  };
  InputScanner.prototype.test = function(pattern, index) {
    index = index || 0;
    index += this.__position;
    if (index >= 0 && index < this.__input_length) {
      return !!this.__match(pattern, index);
    } else {
      return false;
    }
  };
  InputScanner.prototype.testChar = function(pattern, index) {
    var val = this.peek(index);
    pattern.lastIndex = 0;
    return val !== null && pattern.test(val);
  };
  InputScanner.prototype.match = function(pattern) {
    var pattern_match = this.__match(pattern, this.__position);
    if (pattern_match) {
      this.__position += pattern_match[0].length;
    } else {
      pattern_match = null;
    }
    return pattern_match;
  };
  InputScanner.prototype.read = function(starting_pattern, until_pattern, until_after) {
    var val = "";
    var match;
    if (starting_pattern) {
      match = this.match(starting_pattern);
      if (match) {
        val += match[0];
      }
    }
    if (until_pattern && (match || !starting_pattern)) {
      val += this.readUntil(until_pattern, until_after);
    }
    return val;
  };
  InputScanner.prototype.readUntil = function(pattern, until_after) {
    var val = "";
    var match_index = this.__position;
    pattern.lastIndex = this.__position;
    var pattern_match = pattern.exec(this.__input);
    if (pattern_match) {
      match_index = pattern_match.index;
      if (until_after) {
        match_index += pattern_match[0].length;
      }
    } else {
      match_index = this.__input_length;
    }
    val = this.__input.substring(this.__position, match_index);
    this.__position = match_index;
    return val;
  };
  InputScanner.prototype.readUntilAfter = function(pattern) {
    return this.readUntil(pattern, true);
  };
  InputScanner.prototype.get_regexp = function(pattern, match_from) {
    var result2 = null;
    var flags = "g";
    if (match_from && regexp_has_sticky) {
      flags = "y";
    }
    if (typeof pattern === "string" && pattern !== "") {
      result2 = new RegExp(pattern, flags);
    } else if (pattern) {
      result2 = new RegExp(pattern.source, flags);
    }
    return result2;
  };
  InputScanner.prototype.get_literal_regexp = function(literal_string) {
    return RegExp(literal_string.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&"));
  };
  InputScanner.prototype.peekUntilAfter = function(pattern) {
    var start = this.__position;
    var val = this.readUntilAfter(pattern);
    this.__position = start;
    return val;
  };
  InputScanner.prototype.lookBack = function(testVal) {
    var start = this.__position - 1;
    return start >= testVal.length && this.__input.substring(start - testVal.length, start).toLowerCase() === testVal;
  };
  exports.InputScanner = InputScanner;
});

// node_modules/js-beautify/js/src/core/tokenstream.js
var require_tokenstream = __commonJS((exports, module) => {
  var TokenStream = function(parent_token) {
    this.__tokens = [];
    this.__tokens_length = this.__tokens.length;
    this.__position = 0;
    this.__parent_token = parent_token;
  };
  TokenStream.prototype.restart = function() {
    this.__position = 0;
  };
  TokenStream.prototype.isEmpty = function() {
    return this.__tokens_length === 0;
  };
  TokenStream.prototype.hasNext = function() {
    return this.__position < this.__tokens_length;
  };
  TokenStream.prototype.next = function() {
    var val = null;
    if (this.hasNext()) {
      val = this.__tokens[this.__position];
      this.__position += 1;
    }
    return val;
  };
  TokenStream.prototype.peek = function(index) {
    var val = null;
    index = index || 0;
    index += this.__position;
    if (index >= 0 && index < this.__tokens_length) {
      val = this.__tokens[index];
    }
    return val;
  };
  TokenStream.prototype.add = function(token) {
    if (this.__parent_token) {
      token.parent = this.__parent_token;
    }
    this.__tokens.push(token);
    this.__tokens_length += 1;
  };
  exports.TokenStream = TokenStream;
});

// node_modules/js-beautify/js/src/core/pattern.js
var require_pattern = __commonJS((exports, module) => {
  var Pattern = function(input_scanner, parent) {
    this._input = input_scanner;
    this._starting_pattern = null;
    this._match_pattern = null;
    this._until_pattern = null;
    this._until_after = false;
    if (parent) {
      this._starting_pattern = this._input.get_regexp(parent._starting_pattern, true);
      this._match_pattern = this._input.get_regexp(parent._match_pattern, true);
      this._until_pattern = this._input.get_regexp(parent._until_pattern);
      this._until_after = parent._until_after;
    }
  };
  Pattern.prototype.read = function() {
    var result2 = this._input.read(this._starting_pattern);
    if (!this._starting_pattern || result2) {
      result2 += this._input.read(this._match_pattern, this._until_pattern, this._until_after);
    }
    return result2;
  };
  Pattern.prototype.read_match = function() {
    return this._input.match(this._match_pattern);
  };
  Pattern.prototype.until_after = function(pattern) {
    var result2 = this._create();
    result2._until_after = true;
    result2._until_pattern = this._input.get_regexp(pattern);
    result2._update();
    return result2;
  };
  Pattern.prototype.until = function(pattern) {
    var result2 = this._create();
    result2._until_after = false;
    result2._until_pattern = this._input.get_regexp(pattern);
    result2._update();
    return result2;
  };
  Pattern.prototype.starting_with = function(pattern) {
    var result2 = this._create();
    result2._starting_pattern = this._input.get_regexp(pattern, true);
    result2._update();
    return result2;
  };
  Pattern.prototype.matching = function(pattern) {
    var result2 = this._create();
    result2._match_pattern = this._input.get_regexp(pattern, true);
    result2._update();
    return result2;
  };
  Pattern.prototype._create = function() {
    return new Pattern(this._input, this);
  };
  Pattern.prototype._update = function() {
  };
  exports.Pattern = Pattern;
});

// node_modules/js-beautify/js/src/core/whitespacepattern.js
var require_whitespacepattern = __commonJS((exports, module) => {
  var WhitespacePattern = function(input_scanner, parent) {
    Pattern.call(this, input_scanner, parent);
    if (parent) {
      this._line_regexp = this._input.get_regexp(parent._line_regexp);
    } else {
      this.__set_whitespace_patterns("", "");
    }
    this.newline_count = 0;
    this.whitespace_before_token = "";
  };
  var Pattern = require_pattern().Pattern;
  WhitespacePattern.prototype = new Pattern;
  WhitespacePattern.prototype.__set_whitespace_patterns = function(whitespace_chars, newline_chars) {
    whitespace_chars += "\\t ";
    newline_chars += "\\n\\r";
    this._match_pattern = this._input.get_regexp("[" + whitespace_chars + newline_chars + "]+", true);
    this._newline_regexp = this._input.get_regexp("\\r\\n|[" + newline_chars + "]");
  };
  WhitespacePattern.prototype.read = function() {
    this.newline_count = 0;
    this.whitespace_before_token = "";
    var resulting_string = this._input.read(this._match_pattern);
    if (resulting_string === " ") {
      this.whitespace_before_token = " ";
    } else if (resulting_string) {
      var matches = this.__split(this._newline_regexp, resulting_string);
      this.newline_count = matches.length - 1;
      this.whitespace_before_token = matches[this.newline_count];
    }
    return resulting_string;
  };
  WhitespacePattern.prototype.matching = function(whitespace_chars, newline_chars) {
    var result2 = this._create();
    result2.__set_whitespace_patterns(whitespace_chars, newline_chars);
    result2._update();
    return result2;
  };
  WhitespacePattern.prototype._create = function() {
    return new WhitespacePattern(this._input, this);
  };
  WhitespacePattern.prototype.__split = function(regexp, input_string) {
    regexp.lastIndex = 0;
    var start_index = 0;
    var result2 = [];
    var next_match = regexp.exec(input_string);
    while (next_match) {
      result2.push(input_string.substring(start_index, next_match.index));
      start_index = next_match.index + next_match[0].length;
      next_match = regexp.exec(input_string);
    }
    if (start_index < input_string.length) {
      result2.push(input_string.substring(start_index, input_string.length));
    } else {
      result2.push("");
    }
    return result2;
  };
  exports.WhitespacePattern = WhitespacePattern;
});

// node_modules/js-beautify/js/src/core/tokenizer.js
var require_tokenizer = __commonJS((exports, module) => {
  var InputScanner = require_inputscanner().InputScanner;
  var Token = require_token().Token;
  var TokenStream = require_tokenstream().TokenStream;
  var WhitespacePattern = require_whitespacepattern().WhitespacePattern;
  var TOKEN = {
    START: "TK_START",
    RAW: "TK_RAW",
    EOF: "TK_EOF"
  };
  var Tokenizer = function(input_string, options) {
    this._input = new InputScanner(input_string);
    this._options = options || {};
    this.__tokens = null;
    this._patterns = {};
    this._patterns.whitespace = new WhitespacePattern(this._input);
  };
  Tokenizer.prototype.tokenize = function() {
    this._input.restart();
    this.__tokens = new TokenStream;
    this._reset();
    var current;
    var previous = new Token(TOKEN.START, "");
    var open_token = null;
    var open_stack = [];
    var comments = new TokenStream;
    while (previous.type !== TOKEN.EOF) {
      current = this._get_next_token(previous, open_token);
      while (this._is_comment(current)) {
        comments.add(current);
        current = this._get_next_token(previous, open_token);
      }
      if (!comments.isEmpty()) {
        current.comments_before = comments;
        comments = new TokenStream;
      }
      current.parent = open_token;
      if (this._is_opening(current)) {
        open_stack.push(open_token);
        open_token = current;
      } else if (open_token && this._is_closing(current, open_token)) {
        current.opened = open_token;
        open_token.closed = current;
        open_token = open_stack.pop();
        current.parent = open_token;
      }
      current.previous = previous;
      previous.next = current;
      this.__tokens.add(current);
      previous = current;
    }
    return this.__tokens;
  };
  Tokenizer.prototype._is_first_token = function() {
    return this.__tokens.isEmpty();
  };
  Tokenizer.prototype._reset = function() {
  };
  Tokenizer.prototype._get_next_token = function(previous_token, open_token) {
    this._readWhitespace();
    var resulting_string = this._input.read(/.+/g);
    if (resulting_string) {
      return this._create_token(TOKEN.RAW, resulting_string);
    } else {
      return this._create_token(TOKEN.EOF, "");
    }
  };
  Tokenizer.prototype._is_comment = function(current_token) {
    return false;
  };
  Tokenizer.prototype._is_opening = function(current_token) {
    return false;
  };
  Tokenizer.prototype._is_closing = function(current_token, open_token) {
    return false;
  };
  Tokenizer.prototype._create_token = function(type, text2) {
    var token = new Token(type, text2, this._patterns.whitespace.newline_count, this._patterns.whitespace.whitespace_before_token);
    return token;
  };
  Tokenizer.prototype._readWhitespace = function() {
    return this._patterns.whitespace.read();
  };
  exports.Tokenizer = Tokenizer;
  exports.TOKEN = TOKEN;
});

// node_modules/js-beautify/js/src/core/directives.js
var require_directives = __commonJS((exports, module) => {
  var Directives = function(start_block_pattern, end_block_pattern) {
    start_block_pattern = typeof start_block_pattern === "string" ? start_block_pattern : start_block_pattern.source;
    end_block_pattern = typeof end_block_pattern === "string" ? end_block_pattern : end_block_pattern.source;
    this.__directives_block_pattern = new RegExp(start_block_pattern + / beautify( \w+[:]\w+)+ /.source + end_block_pattern, "g");
    this.__directive_pattern = / (\w+)[:](\w+)/g;
    this.__directives_end_ignore_pattern = new RegExp(start_block_pattern + /\sbeautify\signore:end\s/.source + end_block_pattern, "g");
  };
  Directives.prototype.get_directives = function(text2) {
    if (!text2.match(this.__directives_block_pattern)) {
      return null;
    }
    var directives = {};
    this.__directive_pattern.lastIndex = 0;
    var directive_match = this.__directive_pattern.exec(text2);
    while (directive_match) {
      directives[directive_match[1]] = directive_match[2];
      directive_match = this.__directive_pattern.exec(text2);
    }
    return directives;
  };
  Directives.prototype.readIgnored = function(input) {
    return input.readUntilAfter(this.__directives_end_ignore_pattern);
  };
  exports.Directives = Directives;
});

// node_modules/js-beautify/js/src/core/templatablepattern.js
var require_templatablepattern = __commonJS((exports, module) => {
  var TemplatablePattern = function(input_scanner, parent) {
    Pattern.call(this, input_scanner, parent);
    this.__template_pattern = null;
    this._disabled = Object.assign({}, template_names);
    this._excluded = Object.assign({}, template_names);
    if (parent) {
      this.__template_pattern = this._input.get_regexp(parent.__template_pattern);
      this._excluded = Object.assign(this._excluded, parent._excluded);
      this._disabled = Object.assign(this._disabled, parent._disabled);
    }
    var pattern = new Pattern(input_scanner);
    this.__patterns = {
      handlebars_comment: pattern.starting_with(/{{!--/).until_after(/--}}/),
      handlebars_unescaped: pattern.starting_with(/{{{/).until_after(/}}}/),
      handlebars: pattern.starting_with(/{{/).until_after(/}}/),
      php: pattern.starting_with(/<\?(?:[= ]|php)/).until_after(/\?>/),
      erb: pattern.starting_with(/<%[^%]/).until_after(/[^%]%>/),
      django: pattern.starting_with(/{%/).until_after(/%}/),
      django_value: pattern.starting_with(/{{/).until_after(/}}/),
      django_comment: pattern.starting_with(/{#/).until_after(/#}/),
      smarty: pattern.starting_with(/{(?=[^}{\s\n])/).until_after(/[^\s\n]}/),
      smarty_comment: pattern.starting_with(/{\*/).until_after(/\*}/),
      smarty_literal: pattern.starting_with(/{literal}/).until_after(/{\/literal}/)
    };
  };
  var Pattern = require_pattern().Pattern;
  var template_names = {
    django: false,
    erb: false,
    handlebars: false,
    php: false,
    smarty: false
  };
  TemplatablePattern.prototype = new Pattern;
  TemplatablePattern.prototype._create = function() {
    return new TemplatablePattern(this._input, this);
  };
  TemplatablePattern.prototype._update = function() {
    this.__set_templated_pattern();
  };
  TemplatablePattern.prototype.disable = function(language) {
    var result2 = this._create();
    result2._disabled[language] = true;
    result2._update();
    return result2;
  };
  TemplatablePattern.prototype.read_options = function(options) {
    var result2 = this._create();
    for (var language in template_names) {
      result2._disabled[language] = options.templating.indexOf(language) === -1;
    }
    result2._update();
    return result2;
  };
  TemplatablePattern.prototype.exclude = function(language) {
    var result2 = this._create();
    result2._excluded[language] = true;
    result2._update();
    return result2;
  };
  TemplatablePattern.prototype.read = function() {
    var result2 = "";
    if (this._match_pattern) {
      result2 = this._input.read(this._starting_pattern);
    } else {
      result2 = this._input.read(this._starting_pattern, this.__template_pattern);
    }
    var next = this._read_template();
    while (next) {
      if (this._match_pattern) {
        next += this._input.read(this._match_pattern);
      } else {
        next += this._input.readUntil(this.__template_pattern);
      }
      result2 += next;
      next = this._read_template();
    }
    if (this._until_after) {
      result2 += this._input.readUntilAfter(this._until_pattern);
    }
    return result2;
  };
  TemplatablePattern.prototype.__set_templated_pattern = function() {
    var items = [];
    if (!this._disabled.php) {
      items.push(this.__patterns.php._starting_pattern.source);
    }
    if (!this._disabled.handlebars) {
      items.push(this.__patterns.handlebars._starting_pattern.source);
    }
    if (!this._disabled.erb) {
      items.push(this.__patterns.erb._starting_pattern.source);
    }
    if (!this._disabled.django) {
      items.push(this.__patterns.django._starting_pattern.source);
      items.push(this.__patterns.django_value._starting_pattern.source);
      items.push(this.__patterns.django_comment._starting_pattern.source);
    }
    if (!this._disabled.smarty) {
      items.push(this.__patterns.smarty._starting_pattern.source);
    }
    if (this._until_pattern) {
      items.push(this._until_pattern.source);
    }
    this.__template_pattern = this._input.get_regexp("(?:" + items.join("|") + ")");
  };
  TemplatablePattern.prototype._read_template = function() {
    var resulting_string = "";
    var c2 = this._input.peek();
    if (c2 === "<") {
      var peek1 = this._input.peek(1);
      if (!this._disabled.php && !this._excluded.php && peek1 === "?") {
        resulting_string = resulting_string || this.__patterns.php.read();
      }
      if (!this._disabled.erb && !this._excluded.erb && peek1 === "%") {
        resulting_string = resulting_string || this.__patterns.erb.read();
      }
    } else if (c2 === "{") {
      if (!this._disabled.handlebars && !this._excluded.handlebars) {
        resulting_string = resulting_string || this.__patterns.handlebars_comment.read();
        resulting_string = resulting_string || this.__patterns.handlebars_unescaped.read();
        resulting_string = resulting_string || this.__patterns.handlebars.read();
      }
      if (!this._disabled.django) {
        if (!this._excluded.django && !this._excluded.handlebars) {
          resulting_string = resulting_string || this.__patterns.django_value.read();
        }
        if (!this._excluded.django) {
          resulting_string = resulting_string || this.__patterns.django_comment.read();
          resulting_string = resulting_string || this.__patterns.django.read();
        }
      }
      if (!this._disabled.smarty) {
        if (this._disabled.django && this._disabled.handlebars) {
          resulting_string = resulting_string || this.__patterns.smarty_comment.read();
          resulting_string = resulting_string || this.__patterns.smarty_literal.read();
          resulting_string = resulting_string || this.__patterns.smarty.read();
        }
      }
    }
    return resulting_string;
  };
  exports.TemplatablePattern = TemplatablePattern;
});

// node_modules/js-beautify/js/src/javascript/tokenizer.js
var require_tokenizer2 = __commonJS((exports, module) => {
  var in_array = function(what, arr) {
    return arr.indexOf(what) !== -1;
  };
  var unescape_string = function(s) {
    var out = "", escaped = 0;
    var input_scan = new InputScanner(s);
    var matched = null;
    while (input_scan.hasNext()) {
      matched = input_scan.match(/([\s]|[^\\]|\\\\)+/g);
      if (matched) {
        out += matched[0];
      }
      if (input_scan.peek() === "\\") {
        input_scan.next();
        if (input_scan.peek() === "x") {
          matched = input_scan.match(/x([0-9A-Fa-f]{2})/g);
        } else if (input_scan.peek() === "u") {
          matched = input_scan.match(/u([0-9A-Fa-f]{4})/g);
          if (!matched) {
            matched = input_scan.match(/u\{([0-9A-Fa-f]+)\}/g);
          }
        } else {
          out += "\\";
          if (input_scan.hasNext()) {
            out += input_scan.next();
          }
          continue;
        }
        if (!matched) {
          return s;
        }
        escaped = parseInt(matched[1], 16);
        if (escaped > 126 && escaped <= 255 && matched[0].indexOf("x") === 0) {
          return s;
        } else if (escaped >= 0 && escaped < 32) {
          out += "\\" + matched[0];
        } else if (escaped > 1114111) {
          out += "\\" + matched[0];
        } else if (escaped === 34 || escaped === 39 || escaped === 92) {
          out += "\\" + String.fromCharCode(escaped);
        } else {
          out += String.fromCharCode(escaped);
        }
      }
    }
    return out;
  };
  var InputScanner = require_inputscanner().InputScanner;
  var BaseTokenizer = require_tokenizer().Tokenizer;
  var BASETOKEN = require_tokenizer().TOKEN;
  var Directives = require_directives().Directives;
  var acorn = require_acorn();
  var Pattern = require_pattern().Pattern;
  var TemplatablePattern = require_templatablepattern().TemplatablePattern;
  var TOKEN = {
    START_EXPR: "TK_START_EXPR",
    END_EXPR: "TK_END_EXPR",
    START_BLOCK: "TK_START_BLOCK",
    END_BLOCK: "TK_END_BLOCK",
    WORD: "TK_WORD",
    RESERVED: "TK_RESERVED",
    SEMICOLON: "TK_SEMICOLON",
    STRING: "TK_STRING",
    EQUALS: "TK_EQUALS",
    OPERATOR: "TK_OPERATOR",
    COMMA: "TK_COMMA",
    BLOCK_COMMENT: "TK_BLOCK_COMMENT",
    COMMENT: "TK_COMMENT",
    DOT: "TK_DOT",
    UNKNOWN: "TK_UNKNOWN",
    START: BASETOKEN.START,
    RAW: BASETOKEN.RAW,
    EOF: BASETOKEN.EOF
  };
  var directives_core = new Directives(/\/\*/, /\*\//);
  var number_pattern = /0[xX][0123456789abcdefABCDEF_]*n?|0[oO][01234567_]*n?|0[bB][01_]*n?|\d[\d_]*n|(?:\.\d[\d_]*|\d[\d_]*\.?[\d_]*)(?:[eE][+-]?[\d_]+)?/;
  var digit = /[0-9]/;
  var dot_pattern = /[^\d\.]/;
  var positionable_operators = ">>> === !== &&= ??= ||= << && >= ** != == <= >> || ?? |> < / - + > : & % ? ^ | *".split(" ");
  var punct = ">>>= ... >>= <<= === >>> !== **= &&= ??= ||= => ^= :: /= << <= == && -= >= >> != -- += ** || ?? ++ %= &= *= |= |> = ! ? > < : / ^ - + * & % ~ |";
  punct = punct.replace(/[-[\]{}()*+?.,\\^$|#]/g, "\\$&");
  punct = "\\?\\.(?!\\d) " + punct;
  punct = punct.replace(/ /g, "|");
  var punct_pattern = new RegExp(punct);
  var line_starters = "continue,try,throw,return,var,let,const,if,switch,case,default,for,while,break,function,import,export".split(",");
  var reserved_words = line_starters.concat(["do", "in", "of", "else", "get", "set", "new", "catch", "finally", "typeof", "yield", "async", "await", "from", "as", "class", "extends"]);
  var reserved_word_pattern = new RegExp("^(?:" + reserved_words.join("|") + ")$");
  var in_html_comment;
  var Tokenizer = function(input_string, options) {
    BaseTokenizer.call(this, input_string, options);
    this._patterns.whitespace = this._patterns.whitespace.matching(/\u00A0\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff/.source, /\u2028\u2029/.source);
    var pattern_reader = new Pattern(this._input);
    var templatable = new TemplatablePattern(this._input).read_options(this._options);
    this.__patterns = {
      template: templatable,
      identifier: templatable.starting_with(acorn.identifier).matching(acorn.identifierMatch),
      number: pattern_reader.matching(number_pattern),
      punct: pattern_reader.matching(punct_pattern),
      comment: pattern_reader.starting_with(/\/\//).until(/[\n\r\u2028\u2029]/),
      block_comment: pattern_reader.starting_with(/\/\*/).until_after(/\*\//),
      html_comment_start: pattern_reader.matching(/<!--/),
      html_comment_end: pattern_reader.matching(/-->/),
      include: pattern_reader.starting_with(/#include/).until_after(acorn.lineBreak),
      shebang: pattern_reader.starting_with(/#!/).until_after(acorn.lineBreak),
      xml: pattern_reader.matching(/[\s\S]*?<(\/?)([-a-zA-Z:0-9_.]+|{[^}]+?}|!\[CDATA\[[^\]]*?\]\]|)(\s*{[^}]+?}|\s+[-a-zA-Z:0-9_.]+|\s+[-a-zA-Z:0-9_.]+\s*=\s*('[^']*'|"[^"]*"|{([^{}]|{[^}]+?})+?}))*\s*(\/?)\s*>/),
      single_quote: templatable.until(/['\\\n\r\u2028\u2029]/),
      double_quote: templatable.until(/["\\\n\r\u2028\u2029]/),
      template_text: templatable.until(/[`\\$]/),
      template_expression: templatable.until(/[`}\\]/)
    };
  };
  Tokenizer.prototype = new BaseTokenizer;
  Tokenizer.prototype._is_comment = function(current_token) {
    return current_token.type === TOKEN.COMMENT || current_token.type === TOKEN.BLOCK_COMMENT || current_token.type === TOKEN.UNKNOWN;
  };
  Tokenizer.prototype._is_opening = function(current_token) {
    return current_token.type === TOKEN.START_BLOCK || current_token.type === TOKEN.START_EXPR;
  };
  Tokenizer.prototype._is_closing = function(current_token, open_token) {
    return (current_token.type === TOKEN.END_BLOCK || current_token.type === TOKEN.END_EXPR) && (open_token && (current_token.text === "]" && open_token.text === "[" || current_token.text === ")" && open_token.text === "(" || current_token.text === "}" && open_token.text === "{"));
  };
  Tokenizer.prototype._reset = function() {
    in_html_comment = false;
  };
  Tokenizer.prototype._get_next_token = function(previous_token, open_token) {
    var token = null;
    this._readWhitespace();
    var c2 = this._input.peek();
    if (c2 === null) {
      return this._create_token(TOKEN.EOF, "");
    }
    token = token || this._read_non_javascript(c2);
    token = token || this._read_string(c2);
    token = token || this._read_pair(c2, this._input.peek(1));
    token = token || this._read_word(previous_token);
    token = token || this._read_singles(c2);
    token = token || this._read_comment(c2);
    token = token || this._read_regexp(c2, previous_token);
    token = token || this._read_xml(c2, previous_token);
    token = token || this._read_punctuation();
    token = token || this._create_token(TOKEN.UNKNOWN, this._input.next());
    return token;
  };
  Tokenizer.prototype._read_word = function(previous_token) {
    var resulting_string;
    resulting_string = this.__patterns.identifier.read();
    if (resulting_string !== "") {
      resulting_string = resulting_string.replace(acorn.allLineBreaks, "\n");
      if (!(previous_token.type === TOKEN.DOT || previous_token.type === TOKEN.RESERVED && (previous_token.text === "set" || previous_token.text === "get")) && reserved_word_pattern.test(resulting_string)) {
        if ((resulting_string === "in" || resulting_string === "of") && (previous_token.type === TOKEN.WORD || previous_token.type === TOKEN.STRING)) {
          return this._create_token(TOKEN.OPERATOR, resulting_string);
        }
        return this._create_token(TOKEN.RESERVED, resulting_string);
      }
      return this._create_token(TOKEN.WORD, resulting_string);
    }
    resulting_string = this.__patterns.number.read();
    if (resulting_string !== "") {
      return this._create_token(TOKEN.WORD, resulting_string);
    }
  };
  Tokenizer.prototype._read_singles = function(c2) {
    var token = null;
    if (c2 === "(" || c2 === "[") {
      token = this._create_token(TOKEN.START_EXPR, c2);
    } else if (c2 === ")" || c2 === "]") {
      token = this._create_token(TOKEN.END_EXPR, c2);
    } else if (c2 === "{") {
      token = this._create_token(TOKEN.START_BLOCK, c2);
    } else if (c2 === "}") {
      token = this._create_token(TOKEN.END_BLOCK, c2);
    } else if (c2 === ";") {
      token = this._create_token(TOKEN.SEMICOLON, c2);
    } else if (c2 === "." && dot_pattern.test(this._input.peek(1))) {
      token = this._create_token(TOKEN.DOT, c2);
    } else if (c2 === ",") {
      token = this._create_token(TOKEN.COMMA, c2);
    }
    if (token) {
      this._input.next();
    }
    return token;
  };
  Tokenizer.prototype._read_pair = function(c2, d) {
    var token = null;
    if (c2 === "#" && d === "{") {
      token = this._create_token(TOKEN.START_BLOCK, c2 + d);
    }
    if (token) {
      this._input.next();
      this._input.next();
    }
    return token;
  };
  Tokenizer.prototype._read_punctuation = function() {
    var resulting_string = this.__patterns.punct.read();
    if (resulting_string !== "") {
      if (resulting_string === "=") {
        return this._create_token(TOKEN.EQUALS, resulting_string);
      } else if (resulting_string === "?.") {
        return this._create_token(TOKEN.DOT, resulting_string);
      } else {
        return this._create_token(TOKEN.OPERATOR, resulting_string);
      }
    }
  };
  Tokenizer.prototype._read_non_javascript = function(c2) {
    var resulting_string = "";
    if (c2 === "#") {
      if (this._is_first_token()) {
        resulting_string = this.__patterns.shebang.read();
        if (resulting_string) {
          return this._create_token(TOKEN.UNKNOWN, resulting_string.trim() + "\n");
        }
      }
      resulting_string = this.__patterns.include.read();
      if (resulting_string) {
        return this._create_token(TOKEN.UNKNOWN, resulting_string.trim() + "\n");
      }
      c2 = this._input.next();
      var sharp = "#";
      if (this._input.hasNext() && this._input.testChar(digit)) {
        do {
          c2 = this._input.next();
          sharp += c2;
        } while (this._input.hasNext() && c2 !== "#" && c2 !== "=");
        if (c2 === "#") {
        } else if (this._input.peek() === "[" && this._input.peek(1) === "]") {
          sharp += "[]";
          this._input.next();
          this._input.next();
        } else if (this._input.peek() === "{" && this._input.peek(1) === "}") {
          sharp += "{}";
          this._input.next();
          this._input.next();
        }
        return this._create_token(TOKEN.WORD, sharp);
      }
      this._input.back();
    } else if (c2 === "<" && this._is_first_token()) {
      resulting_string = this.__patterns.html_comment_start.read();
      if (resulting_string) {
        while (this._input.hasNext() && !this._input.testChar(acorn.newline)) {
          resulting_string += this._input.next();
        }
        in_html_comment = true;
        return this._create_token(TOKEN.COMMENT, resulting_string);
      }
    } else if (in_html_comment && c2 === "-") {
      resulting_string = this.__patterns.html_comment_end.read();
      if (resulting_string) {
        in_html_comment = false;
        return this._create_token(TOKEN.COMMENT, resulting_string);
      }
    }
    return null;
  };
  Tokenizer.prototype._read_comment = function(c2) {
    var token = null;
    if (c2 === "/") {
      var comment = "";
      if (this._input.peek(1) === "*") {
        comment = this.__patterns.block_comment.read();
        var directives = directives_core.get_directives(comment);
        if (directives && directives.ignore === "start") {
          comment += directives_core.readIgnored(this._input);
        }
        comment = comment.replace(acorn.allLineBreaks, "\n");
        token = this._create_token(TOKEN.BLOCK_COMMENT, comment);
        token.directives = directives;
      } else if (this._input.peek(1) === "/") {
        comment = this.__patterns.comment.read();
        token = this._create_token(TOKEN.COMMENT, comment);
      }
    }
    return token;
  };
  Tokenizer.prototype._read_string = function(c2) {
    if (c2 === "`" || c2 === "'" || c2 === '"') {
      var resulting_string = this._input.next();
      this.has_char_escapes = false;
      if (c2 === "`") {
        resulting_string += this._read_string_recursive("`", true, "${");
      } else {
        resulting_string += this._read_string_recursive(c2);
      }
      if (this.has_char_escapes && this._options.unescape_strings) {
        resulting_string = unescape_string(resulting_string);
      }
      if (this._input.peek() === c2) {
        resulting_string += this._input.next();
      }
      resulting_string = resulting_string.replace(acorn.allLineBreaks, "\n");
      return this._create_token(TOKEN.STRING, resulting_string);
    }
    return null;
  };
  Tokenizer.prototype._allow_regexp_or_xml = function(previous_token) {
    return previous_token.type === TOKEN.RESERVED && in_array(previous_token.text, ["return", "case", "throw", "else", "do", "typeof", "yield"]) || previous_token.type === TOKEN.END_EXPR && previous_token.text === ")" && previous_token.opened.previous.type === TOKEN.RESERVED && in_array(previous_token.opened.previous.text, ["if", "while", "for"]) || in_array(previous_token.type, [
      TOKEN.COMMENT,
      TOKEN.START_EXPR,
      TOKEN.START_BLOCK,
      TOKEN.START,
      TOKEN.END_BLOCK,
      TOKEN.OPERATOR,
      TOKEN.EQUALS,
      TOKEN.EOF,
      TOKEN.SEMICOLON,
      TOKEN.COMMA
    ]);
  };
  Tokenizer.prototype._read_regexp = function(c2, previous_token) {
    if (c2 === "/" && this._allow_regexp_or_xml(previous_token)) {
      var resulting_string = this._input.next();
      var esc = false;
      var in_char_class = false;
      while (this._input.hasNext() && ((esc || in_char_class || this._input.peek() !== c2) && !this._input.testChar(acorn.newline))) {
        resulting_string += this._input.peek();
        if (!esc) {
          esc = this._input.peek() === "\\";
          if (this._input.peek() === "[") {
            in_char_class = true;
          } else if (this._input.peek() === "]") {
            in_char_class = false;
          }
        } else {
          esc = false;
        }
        this._input.next();
      }
      if (this._input.peek() === c2) {
        resulting_string += this._input.next();
        resulting_string += this._input.read(acorn.identifier);
      }
      return this._create_token(TOKEN.STRING, resulting_string);
    }
    return null;
  };
  Tokenizer.prototype._read_xml = function(c2, previous_token) {
    if (this._options.e4x && c2 === "<" && this._allow_regexp_or_xml(previous_token)) {
      var xmlStr = "";
      var match = this.__patterns.xml.read_match();
      if (match) {
        var rootTag = match[2].replace(/^{\s+/, "{").replace(/\s+}$/, "}");
        var isCurlyRoot = rootTag.indexOf("{") === 0;
        var depth = 0;
        while (match) {
          var isEndTag = !!match[1];
          var tagName = match[2];
          var isSingletonTag = !!match[match.length - 1] || tagName.slice(0, 8) === "![CDATA[";
          if (!isSingletonTag && (tagName === rootTag || isCurlyRoot && tagName.replace(/^{\s+/, "{").replace(/\s+}$/, "}"))) {
            if (isEndTag) {
              --depth;
            } else {
              ++depth;
            }
          }
          xmlStr += match[0];
          if (depth <= 0) {
            break;
          }
          match = this.__patterns.xml.read_match();
        }
        if (!match) {
          xmlStr += this._input.match(/[\s\S]*/g)[0];
        }
        xmlStr = xmlStr.replace(acorn.allLineBreaks, "\n");
        return this._create_token(TOKEN.STRING, xmlStr);
      }
    }
    return null;
  };
  Tokenizer.prototype._read_string_recursive = function(delimiter, allow_unescaped_newlines, start_sub) {
    var current_char;
    var pattern;
    if (delimiter === "\'") {
      pattern = this.__patterns.single_quote;
    } else if (delimiter === '"') {
      pattern = this.__patterns.double_quote;
    } else if (delimiter === "`") {
      pattern = this.__patterns.template_text;
    } else if (delimiter === "}") {
      pattern = this.__patterns.template_expression;
    }
    var resulting_string = pattern.read();
    var next = "";
    while (this._input.hasNext()) {
      next = this._input.next();
      if (next === delimiter || !allow_unescaped_newlines && acorn.newline.test(next)) {
        this._input.back();
        break;
      } else if (next === "\\" && this._input.hasNext()) {
        current_char = this._input.peek();
        if (current_char === "x" || current_char === "u") {
          this.has_char_escapes = true;
        } else if (current_char === "\r" && this._input.peek(1) === "\n") {
          this._input.next();
        }
        next += this._input.next();
      } else if (start_sub) {
        if (start_sub === "${" && next === "$" && this._input.peek() === "{") {
          next += this._input.next();
        }
        if (start_sub === next) {
          if (delimiter === "`") {
            next += this._read_string_recursive("}", allow_unescaped_newlines, "`");
          } else {
            next += this._read_string_recursive("`", allow_unescaped_newlines, "${");
          }
          if (this._input.hasNext()) {
            next += this._input.next();
          }
        }
      }
      next += pattern.read();
      resulting_string += next;
    }
    return resulting_string;
  };
  exports.Tokenizer = Tokenizer;
  exports.TOKEN = TOKEN;
  exports.positionable_operators = positionable_operators.slice();
  exports.line_starters = line_starters.slice();
});

// node_modules/js-beautify/js/src/javascript/beautifier.js
var require_beautifier = __commonJS((exports, module) => {
  var in_array = function(what, arr) {
    return arr.indexOf(what) !== -1;
  };
  var ltrim = function(s) {
    return s.replace(/^\s+/g, "");
  };
  var generateMapFromStrings = function(list) {
    var result2 = {};
    for (var x = 0;x < list.length; x++) {
      result2[list[x].replace(/-/g, "_")] = list[x];
    }
    return result2;
  };
  var reserved_word = function(token, word) {
    return token && token.type === TOKEN.RESERVED && token.text === word;
  };
  var reserved_array = function(token, words) {
    return token && token.type === TOKEN.RESERVED && in_array(token.text, words);
  };
  var remove_redundant_indentation = function(output, frame) {
    if (frame.multiline_frame || frame.mode === MODE.ForInitializer || frame.mode === MODE.Conditional) {
      return;
    }
    output.remove_indent(frame.start_line_index);
  };
  var split_linebreaks = function(s) {
    s = s.replace(acorn.allLineBreaks, "\n");
    var out = [], idx = s.indexOf("\n");
    while (idx !== -1) {
      out.push(s.substring(0, idx));
      s = s.substring(idx + 1);
      idx = s.indexOf("\n");
    }
    if (s.length) {
      out.push(s);
    }
    return out;
  };
  var is_array = function(mode) {
    return mode === MODE.ArrayLiteral;
  };
  var is_expression = function(mode) {
    return in_array(mode, [MODE.Expression, MODE.ForInitializer, MODE.Conditional]);
  };
  var all_lines_start_with = function(lines, c2) {
    for (var i = 0;i < lines.length; i++) {
      var line = lines[i].trim();
      if (line.charAt(0) !== c2) {
        return false;
      }
    }
    return true;
  };
  var each_line_matches_indent = function(lines, indent) {
    var i = 0, len = lines.length, line;
    for (;i < len; i++) {
      line = lines[i];
      if (line && line.indexOf(indent) !== 0) {
        return false;
      }
    }
    return true;
  };
  var Beautifier = function(source_text, options) {
    options = options || {};
    this._source_text = source_text || "";
    this._output = null;
    this._tokens = null;
    this._last_last_text = null;
    this._flags = null;
    this._previous_flags = null;
    this._flag_store = null;
    this._options = new Options(options);
  };
  var Output = require_output().Output;
  var Token = require_token().Token;
  var acorn = require_acorn();
  var Options = require_options2().Options;
  var Tokenizer = require_tokenizer2().Tokenizer;
  var line_starters = require_tokenizer2().line_starters;
  var positionable_operators = require_tokenizer2().positionable_operators;
  var TOKEN = require_tokenizer2().TOKEN;
  var special_words = ["case", "return", "do", "if", "throw", "else", "await", "break", "continue", "async"];
  var validPositionValues = ["before-newline", "after-newline", "preserve-newline"];
  var OPERATOR_POSITION = generateMapFromStrings(validPositionValues);
  var OPERATOR_POSITION_BEFORE_OR_PRESERVE = [OPERATOR_POSITION.before_newline, OPERATOR_POSITION.preserve_newline];
  var MODE = {
    BlockStatement: "BlockStatement",
    Statement: "Statement",
    ObjectLiteral: "ObjectLiteral",
    ArrayLiteral: "ArrayLiteral",
    ForInitializer: "ForInitializer",
    Conditional: "Conditional",
    Expression: "Expression"
  };
  Beautifier.prototype.create_flags = function(flags_base, mode) {
    var next_indent_level = 0;
    if (flags_base) {
      next_indent_level = flags_base.indentation_level;
      if (!this._output.just_added_newline() && flags_base.line_indent_level > next_indent_level) {
        next_indent_level = flags_base.line_indent_level;
      }
    }
    var next_flags = {
      mode,
      parent: flags_base,
      last_token: flags_base ? flags_base.last_token : new Token(TOKEN.START_BLOCK, ""),
      last_word: flags_base ? flags_base.last_word : "",
      declaration_statement: false,
      declaration_assignment: false,
      multiline_frame: false,
      inline_frame: false,
      if_block: false,
      else_block: false,
      class_start_block: false,
      do_block: false,
      do_while: false,
      import_block: false,
      in_case_statement: false,
      in_case: false,
      case_body: false,
      case_block: false,
      indentation_level: next_indent_level,
      alignment: 0,
      line_indent_level: flags_base ? flags_base.line_indent_level : next_indent_level,
      start_line_index: this._output.get_line_number(),
      ternary_depth: 0
    };
    return next_flags;
  };
  Beautifier.prototype._reset = function(source_text) {
    var baseIndentString = source_text.match(/^[\t ]*/)[0];
    this._last_last_text = "";
    this._output = new Output(this._options, baseIndentString);
    this._output.raw = this._options.test_output_raw;
    this._flag_store = [];
    this.set_mode(MODE.BlockStatement);
    var tokenizer = new Tokenizer(source_text, this._options);
    this._tokens = tokenizer.tokenize();
    return source_text;
  };
  Beautifier.prototype.beautify = function() {
    if (this._options.disabled) {
      return this._source_text;
    }
    var sweet_code;
    var source_text = this._reset(this._source_text);
    var eol = this._options.eol;
    if (this._options.eol === "auto") {
      eol = "\n";
      if (source_text && acorn.lineBreak.test(source_text || "")) {
        eol = source_text.match(acorn.lineBreak)[0];
      }
    }
    var current_token = this._tokens.next();
    while (current_token) {
      this.handle_token(current_token);
      this._last_last_text = this._flags.last_token.text;
      this._flags.last_token = current_token;
      current_token = this._tokens.next();
    }
    sweet_code = this._output.get_code(eol);
    return sweet_code;
  };
  Beautifier.prototype.handle_token = function(current_token, preserve_statement_flags) {
    if (current_token.type === TOKEN.START_EXPR) {
      this.handle_start_expr(current_token);
    } else if (current_token.type === TOKEN.END_EXPR) {
      this.handle_end_expr(current_token);
    } else if (current_token.type === TOKEN.START_BLOCK) {
      this.handle_start_block(current_token);
    } else if (current_token.type === TOKEN.END_BLOCK) {
      this.handle_end_block(current_token);
    } else if (current_token.type === TOKEN.WORD) {
      this.handle_word(current_token);
    } else if (current_token.type === TOKEN.RESERVED) {
      this.handle_word(current_token);
    } else if (current_token.type === TOKEN.SEMICOLON) {
      this.handle_semicolon(current_token);
    } else if (current_token.type === TOKEN.STRING) {
      this.handle_string(current_token);
    } else if (current_token.type === TOKEN.EQUALS) {
      this.handle_equals(current_token);
    } else if (current_token.type === TOKEN.OPERATOR) {
      this.handle_operator(current_token);
    } else if (current_token.type === TOKEN.COMMA) {
      this.handle_comma(current_token);
    } else if (current_token.type === TOKEN.BLOCK_COMMENT) {
      this.handle_block_comment(current_token, preserve_statement_flags);
    } else if (current_token.type === TOKEN.COMMENT) {
      this.handle_comment(current_token, preserve_statement_flags);
    } else if (current_token.type === TOKEN.DOT) {
      this.handle_dot(current_token);
    } else if (current_token.type === TOKEN.EOF) {
      this.handle_eof(current_token);
    } else if (current_token.type === TOKEN.UNKNOWN) {
      this.handle_unknown(current_token, preserve_statement_flags);
    } else {
      this.handle_unknown(current_token, preserve_statement_flags);
    }
  };
  Beautifier.prototype.handle_whitespace_and_comments = function(current_token, preserve_statement_flags) {
    var newlines = current_token.newlines;
    var keep_whitespace = this._options.keep_array_indentation && is_array(this._flags.mode);
    if (current_token.comments_before) {
      var comment_token = current_token.comments_before.next();
      while (comment_token) {
        this.handle_whitespace_and_comments(comment_token, preserve_statement_flags);
        this.handle_token(comment_token, preserve_statement_flags);
        comment_token = current_token.comments_before.next();
      }
    }
    if (keep_whitespace) {
      for (var i = 0;i < newlines; i += 1) {
        this.print_newline(i > 0, preserve_statement_flags);
      }
    } else {
      if (this._options.max_preserve_newlines && newlines > this._options.max_preserve_newlines) {
        newlines = this._options.max_preserve_newlines;
      }
      if (this._options.preserve_newlines) {
        if (newlines > 1) {
          this.print_newline(false, preserve_statement_flags);
          for (var j = 1;j < newlines; j += 1) {
            this.print_newline(true, preserve_statement_flags);
          }
        }
      }
    }
  };
  var newline_restricted_tokens = ["async", "break", "continue", "return", "throw", "yield"];
  Beautifier.prototype.allow_wrap_or_preserved_newline = function(current_token, force_linewrap) {
    force_linewrap = force_linewrap === undefined ? false : force_linewrap;
    if (this._output.just_added_newline()) {
      return;
    }
    var shouldPreserveOrForce = this._options.preserve_newlines && current_token.newlines || force_linewrap;
    var operatorLogicApplies = in_array(this._flags.last_token.text, positionable_operators) || in_array(current_token.text, positionable_operators);
    if (operatorLogicApplies) {
      var shouldPrintOperatorNewline = in_array(this._flags.last_token.text, positionable_operators) && in_array(this._options.operator_position, OPERATOR_POSITION_BEFORE_OR_PRESERVE) || in_array(current_token.text, positionable_operators);
      shouldPreserveOrForce = shouldPreserveOrForce && shouldPrintOperatorNewline;
    }
    if (shouldPreserveOrForce) {
      this.print_newline(false, true);
    } else if (this._options.wrap_line_length) {
      if (reserved_array(this._flags.last_token, newline_restricted_tokens)) {
        return;
      }
      this._output.set_wrap_point();
    }
  };
  Beautifier.prototype.print_newline = function(force_newline, preserve_statement_flags) {
    if (!preserve_statement_flags) {
      if (this._flags.last_token.text !== ";" && this._flags.last_token.text !== "," && this._flags.last_token.text !== "=" && (this._flags.last_token.type !== TOKEN.OPERATOR || this._flags.last_token.text === "--" || this._flags.last_token.text === "++")) {
        var next_token = this._tokens.peek();
        while (this._flags.mode === MODE.Statement && !(this._flags.if_block && reserved_word(next_token, "else")) && !this._flags.do_block) {
          this.restore_mode();
        }
      }
    }
    if (this._output.add_new_line(force_newline)) {
      this._flags.multiline_frame = true;
    }
  };
  Beautifier.prototype.print_token_line_indentation = function(current_token) {
    if (this._output.just_added_newline()) {
      if (this._options.keep_array_indentation && current_token.newlines && (current_token.text === "[" || is_array(this._flags.mode))) {
        this._output.current_line.set_indent(-1);
        this._output.current_line.push(current_token.whitespace_before);
        this._output.space_before_token = false;
      } else if (this._output.set_indent(this._flags.indentation_level, this._flags.alignment)) {
        this._flags.line_indent_level = this._flags.indentation_level;
      }
    }
  };
  Beautifier.prototype.print_token = function(current_token) {
    if (this._output.raw) {
      this._output.add_raw_token(current_token);
      return;
    }
    if (this._options.comma_first && current_token.previous && current_token.previous.type === TOKEN.COMMA && this._output.just_added_newline()) {
      if (this._output.previous_line.last() === ",") {
        var popped = this._output.previous_line.pop();
        if (this._output.previous_line.is_empty()) {
          this._output.previous_line.push(popped);
          this._output.trim(true);
          this._output.current_line.pop();
          this._output.trim();
        }
        this.print_token_line_indentation(current_token);
        this._output.add_token(",");
        this._output.space_before_token = true;
      }
    }
    this.print_token_line_indentation(current_token);
    this._output.non_breaking_space = true;
    this._output.add_token(current_token.text);
    if (this._output.previous_token_wrapped) {
      this._flags.multiline_frame = true;
    }
  };
  Beautifier.prototype.indent = function() {
    this._flags.indentation_level += 1;
    this._output.set_indent(this._flags.indentation_level, this._flags.alignment);
  };
  Beautifier.prototype.deindent = function() {
    if (this._flags.indentation_level > 0 && (!this._flags.parent || this._flags.indentation_level > this._flags.parent.indentation_level)) {
      this._flags.indentation_level -= 1;
      this._output.set_indent(this._flags.indentation_level, this._flags.alignment);
    }
  };
  Beautifier.prototype.set_mode = function(mode) {
    if (this._flags) {
      this._flag_store.push(this._flags);
      this._previous_flags = this._flags;
    } else {
      this._previous_flags = this.create_flags(null, mode);
    }
    this._flags = this.create_flags(this._previous_flags, mode);
    this._output.set_indent(this._flags.indentation_level, this._flags.alignment);
  };
  Beautifier.prototype.restore_mode = function() {
    if (this._flag_store.length > 0) {
      this._previous_flags = this._flags;
      this._flags = this._flag_store.pop();
      if (this._previous_flags.mode === MODE.Statement) {
        remove_redundant_indentation(this._output, this._previous_flags);
      }
      this._output.set_indent(this._flags.indentation_level, this._flags.alignment);
    }
  };
  Beautifier.prototype.start_of_object_property = function() {
    return this._flags.parent.mode === MODE.ObjectLiteral && this._flags.mode === MODE.Statement && (this._flags.last_token.text === ":" && this._flags.ternary_depth === 0 || reserved_array(this._flags.last_token, ["get", "set"]));
  };
  Beautifier.prototype.start_of_statement = function(current_token) {
    var start = false;
    start = start || reserved_array(this._flags.last_token, ["var", "let", "const"]) && current_token.type === TOKEN.WORD;
    start = start || reserved_word(this._flags.last_token, "do");
    start = start || !(this._flags.parent.mode === MODE.ObjectLiteral && this._flags.mode === MODE.Statement) && reserved_array(this._flags.last_token, newline_restricted_tokens) && !current_token.newlines;
    start = start || reserved_word(this._flags.last_token, "else") && !(reserved_word(current_token, "if") && !current_token.comments_before);
    start = start || this._flags.last_token.type === TOKEN.END_EXPR && (this._previous_flags.mode === MODE.ForInitializer || this._previous_flags.mode === MODE.Conditional);
    start = start || this._flags.last_token.type === TOKEN.WORD && this._flags.mode === MODE.BlockStatement && !this._flags.in_case && !(current_token.text === "--" || current_token.text === "++") && this._last_last_text !== "function" && current_token.type !== TOKEN.WORD && current_token.type !== TOKEN.RESERVED;
    start = start || this._flags.mode === MODE.ObjectLiteral && (this._flags.last_token.text === ":" && this._flags.ternary_depth === 0 || reserved_array(this._flags.last_token, ["get", "set"]));
    if (start) {
      this.set_mode(MODE.Statement);
      this.indent();
      this.handle_whitespace_and_comments(current_token, true);
      if (!this.start_of_object_property()) {
        this.allow_wrap_or_preserved_newline(current_token, reserved_array(current_token, ["do", "for", "if", "while"]));
      }
      return true;
    }
    return false;
  };
  Beautifier.prototype.handle_start_expr = function(current_token) {
    if (!this.start_of_statement(current_token)) {
      this.handle_whitespace_and_comments(current_token);
    }
    var next_mode = MODE.Expression;
    if (current_token.text === "[") {
      if (this._flags.last_token.type === TOKEN.WORD || this._flags.last_token.text === ")") {
        if (reserved_array(this._flags.last_token, line_starters)) {
          this._output.space_before_token = true;
        }
        this.print_token(current_token);
        this.set_mode(next_mode);
        this.indent();
        if (this._options.space_in_paren) {
          this._output.space_before_token = true;
        }
        return;
      }
      next_mode = MODE.ArrayLiteral;
      if (is_array(this._flags.mode)) {
        if (this._flags.last_token.text === "[" || this._flags.last_token.text === "," && (this._last_last_text === "]" || this._last_last_text === "}")) {
          if (!this._options.keep_array_indentation) {
            this.print_newline();
          }
        }
      }
      if (!in_array(this._flags.last_token.type, [TOKEN.START_EXPR, TOKEN.END_EXPR, TOKEN.WORD, TOKEN.OPERATOR, TOKEN.DOT])) {
        this._output.space_before_token = true;
      }
    } else {
      if (this._flags.last_token.type === TOKEN.RESERVED) {
        if (this._flags.last_token.text === "for") {
          this._output.space_before_token = this._options.space_before_conditional;
          next_mode = MODE.ForInitializer;
        } else if (in_array(this._flags.last_token.text, ["if", "while", "switch"])) {
          this._output.space_before_token = this._options.space_before_conditional;
          next_mode = MODE.Conditional;
        } else if (in_array(this._flags.last_word, ["await", "async"])) {
          this._output.space_before_token = true;
        } else if (this._flags.last_token.text === "import" && current_token.whitespace_before === "") {
          this._output.space_before_token = false;
        } else if (in_array(this._flags.last_token.text, line_starters) || this._flags.last_token.text === "catch") {
          this._output.space_before_token = true;
        }
      } else if (this._flags.last_token.type === TOKEN.EQUALS || this._flags.last_token.type === TOKEN.OPERATOR) {
        if (!this.start_of_object_property()) {
          this.allow_wrap_or_preserved_newline(current_token);
        }
      } else if (this._flags.last_token.type === TOKEN.WORD) {
        this._output.space_before_token = false;
        var peek_back_two = this._tokens.peek(-3);
        if (this._options.space_after_named_function && peek_back_two) {
          var peek_back_three = this._tokens.peek(-4);
          if (reserved_array(peek_back_two, ["async", "function"]) || peek_back_two.text === "*" && reserved_array(peek_back_three, ["async", "function"])) {
            this._output.space_before_token = true;
          } else if (this._flags.mode === MODE.ObjectLiteral) {
            if (peek_back_two.text === "{" || peek_back_two.text === "," || peek_back_two.text === "*" && (peek_back_three.text === "{" || peek_back_three.text === ",")) {
              this._output.space_before_token = true;
            }
          } else if (this._flags.parent && this._flags.parent.class_start_block) {
            this._output.space_before_token = true;
          }
        }
      } else {
        this.allow_wrap_or_preserved_newline(current_token);
      }
      if (this._flags.last_token.type === TOKEN.RESERVED && (this._flags.last_word === "function" || this._flags.last_word === "typeof") || this._flags.last_token.text === "*" && (in_array(this._last_last_text, ["function", "yield"]) || this._flags.mode === MODE.ObjectLiteral && in_array(this._last_last_text, ["{", ","]))) {
        this._output.space_before_token = this._options.space_after_anon_function;
      }
    }
    if (this._flags.last_token.text === ";" || this._flags.last_token.type === TOKEN.START_BLOCK) {
      this.print_newline();
    } else if (this._flags.last_token.type === TOKEN.END_EXPR || this._flags.last_token.type === TOKEN.START_EXPR || this._flags.last_token.type === TOKEN.END_BLOCK || this._flags.last_token.text === "." || this._flags.last_token.type === TOKEN.COMMA) {
      this.allow_wrap_or_preserved_newline(current_token, current_token.newlines);
    }
    this.print_token(current_token);
    this.set_mode(next_mode);
    if (this._options.space_in_paren) {
      this._output.space_before_token = true;
    }
    this.indent();
  };
  Beautifier.prototype.handle_end_expr = function(current_token) {
    while (this._flags.mode === MODE.Statement) {
      this.restore_mode();
    }
    this.handle_whitespace_and_comments(current_token);
    if (this._flags.multiline_frame) {
      this.allow_wrap_or_preserved_newline(current_token, current_token.text === "]" && is_array(this._flags.mode) && !this._options.keep_array_indentation);
    }
    if (this._options.space_in_paren) {
      if (this._flags.last_token.type === TOKEN.START_EXPR && !this._options.space_in_empty_paren) {
        this._output.trim();
        this._output.space_before_token = false;
      } else {
        this._output.space_before_token = true;
      }
    }
    this.deindent();
    this.print_token(current_token);
    this.restore_mode();
    remove_redundant_indentation(this._output, this._previous_flags);
    if (this._flags.do_while && this._previous_flags.mode === MODE.Conditional) {
      this._previous_flags.mode = MODE.Expression;
      this._flags.do_block = false;
      this._flags.do_while = false;
    }
  };
  Beautifier.prototype.handle_start_block = function(current_token) {
    this.handle_whitespace_and_comments(current_token);
    var next_token = this._tokens.peek();
    var second_token = this._tokens.peek(1);
    if (this._flags.last_word === "switch" && this._flags.last_token.type === TOKEN.END_EXPR) {
      this.set_mode(MODE.BlockStatement);
      this._flags.in_case_statement = true;
    } else if (this._flags.case_body) {
      this.set_mode(MODE.BlockStatement);
    } else if (second_token && (in_array(second_token.text, [":", ","]) && in_array(next_token.type, [TOKEN.STRING, TOKEN.WORD, TOKEN.RESERVED]) || in_array(next_token.text, ["get", "set", "..."]) && in_array(second_token.type, [TOKEN.WORD, TOKEN.RESERVED]))) {
      if (in_array(this._last_last_text, ["class", "interface"]) && !in_array(second_token.text, [":", ","])) {
        this.set_mode(MODE.BlockStatement);
      } else {
        this.set_mode(MODE.ObjectLiteral);
      }
    } else if (this._flags.last_token.type === TOKEN.OPERATOR && this._flags.last_token.text === "=>") {
      this.set_mode(MODE.BlockStatement);
    } else if (in_array(this._flags.last_token.type, [TOKEN.EQUALS, TOKEN.START_EXPR, TOKEN.COMMA, TOKEN.OPERATOR]) || reserved_array(this._flags.last_token, ["return", "throw", "import", "default"])) {
      this.set_mode(MODE.ObjectLiteral);
    } else {
      this.set_mode(MODE.BlockStatement);
    }
    if (this._flags.last_token) {
      if (reserved_array(this._flags.last_token.previous, ["class", "extends"])) {
        this._flags.class_start_block = true;
      }
    }
    var empty_braces = !next_token.comments_before && next_token.text === "}";
    var empty_anonymous_function = empty_braces && this._flags.last_word === "function" && this._flags.last_token.type === TOKEN.END_EXPR;
    if (this._options.brace_preserve_inline) {
      var index = 0;
      var check_token = null;
      this._flags.inline_frame = true;
      do {
        index += 1;
        check_token = this._tokens.peek(index - 1);
        if (check_token.newlines) {
          this._flags.inline_frame = false;
          break;
        }
      } while (check_token.type !== TOKEN.EOF && !(check_token.type === TOKEN.END_BLOCK && check_token.opened === current_token));
    }
    if ((this._options.brace_style === "expand" || this._options.brace_style === "none" && current_token.newlines) && !this._flags.inline_frame) {
      if (this._flags.last_token.type !== TOKEN.OPERATOR && (empty_anonymous_function || this._flags.last_token.type === TOKEN.EQUALS || reserved_array(this._flags.last_token, special_words) && this._flags.last_token.text !== "else")) {
        this._output.space_before_token = true;
      } else {
        this.print_newline(false, true);
      }
    } else {
      if (is_array(this._previous_flags.mode) && (this._flags.last_token.type === TOKEN.START_EXPR || this._flags.last_token.type === TOKEN.COMMA)) {
        if (this._flags.last_token.type === TOKEN.COMMA || this._options.space_in_paren) {
          this._output.space_before_token = true;
        }
        if (this._flags.last_token.type === TOKEN.COMMA || this._flags.last_token.type === TOKEN.START_EXPR && this._flags.inline_frame) {
          this.allow_wrap_or_preserved_newline(current_token);
          this._previous_flags.multiline_frame = this._previous_flags.multiline_frame || this._flags.multiline_frame;
          this._flags.multiline_frame = false;
        }
      }
      if (this._flags.last_token.type !== TOKEN.OPERATOR && this._flags.last_token.type !== TOKEN.START_EXPR) {
        if (in_array(this._flags.last_token.type, [TOKEN.START_BLOCK, TOKEN.SEMICOLON]) && !this._flags.inline_frame) {
          this.print_newline();
        } else {
          this._output.space_before_token = true;
        }
      }
    }
    this.print_token(current_token);
    this.indent();
    if (!empty_braces && !(this._options.brace_preserve_inline && this._flags.inline_frame)) {
      this.print_newline();
    }
  };
  Beautifier.prototype.handle_end_block = function(current_token) {
    this.handle_whitespace_and_comments(current_token);
    while (this._flags.mode === MODE.Statement) {
      this.restore_mode();
    }
    var empty_braces = this._flags.last_token.type === TOKEN.START_BLOCK;
    if (this._flags.inline_frame && !empty_braces) {
      this._output.space_before_token = true;
    } else if (this._options.brace_style === "expand") {
      if (!empty_braces) {
        this.print_newline();
      }
    } else {
      if (!empty_braces) {
        if (is_array(this._flags.mode) && this._options.keep_array_indentation) {
          this._options.keep_array_indentation = false;
          this.print_newline();
          this._options.keep_array_indentation = true;
        } else {
          this.print_newline();
        }
      }
    }
    this.restore_mode();
    this.print_token(current_token);
  };
  Beautifier.prototype.handle_word = function(current_token) {
    if (current_token.type === TOKEN.RESERVED) {
      if (in_array(current_token.text, ["set", "get"]) && this._flags.mode !== MODE.ObjectLiteral) {
        current_token.type = TOKEN.WORD;
      } else if (current_token.text === "import" && in_array(this._tokens.peek().text, ["(", "."])) {
        current_token.type = TOKEN.WORD;
      } else if (in_array(current_token.text, ["as", "from"]) && !this._flags.import_block) {
        current_token.type = TOKEN.WORD;
      } else if (this._flags.mode === MODE.ObjectLiteral) {
        var next_token = this._tokens.peek();
        if (next_token.text === ":") {
          current_token.type = TOKEN.WORD;
        }
      }
    }
    if (this.start_of_statement(current_token)) {
      if (reserved_array(this._flags.last_token, ["var", "let", "const"]) && current_token.type === TOKEN.WORD) {
        this._flags.declaration_statement = true;
      }
    } else if (current_token.newlines && !is_expression(this._flags.mode) && (this._flags.last_token.type !== TOKEN.OPERATOR || (this._flags.last_token.text === "--" || this._flags.last_token.text === "++")) && this._flags.last_token.type !== TOKEN.EQUALS && (this._options.preserve_newlines || !reserved_array(this._flags.last_token, ["var", "let", "const", "set", "get"]))) {
      this.handle_whitespace_and_comments(current_token);
      this.print_newline();
    } else {
      this.handle_whitespace_and_comments(current_token);
    }
    if (this._flags.do_block && !this._flags.do_while) {
      if (reserved_word(current_token, "while")) {
        this._output.space_before_token = true;
        this.print_token(current_token);
        this._output.space_before_token = true;
        this._flags.do_while = true;
        return;
      } else {
        this.print_newline();
        this._flags.do_block = false;
      }
    }
    if (this._flags.if_block) {
      if (!this._flags.else_block && reserved_word(current_token, "else")) {
        this._flags.else_block = true;
      } else {
        while (this._flags.mode === MODE.Statement) {
          this.restore_mode();
        }
        this._flags.if_block = false;
        this._flags.else_block = false;
      }
    }
    if (this._flags.in_case_statement && reserved_array(current_token, ["case", "default"])) {
      this.print_newline();
      if (!this._flags.case_block && (this._flags.case_body || this._options.jslint_happy)) {
        this.deindent();
      }
      this._flags.case_body = false;
      this.print_token(current_token);
      this._flags.in_case = true;
      return;
    }
    if (this._flags.last_token.type === TOKEN.COMMA || this._flags.last_token.type === TOKEN.START_EXPR || this._flags.last_token.type === TOKEN.EQUALS || this._flags.last_token.type === TOKEN.OPERATOR) {
      if (!this.start_of_object_property() && !(in_array(this._flags.last_token.text, ["+", "-"]) && this._last_last_text === ":" && this._flags.parent.mode === MODE.ObjectLiteral)) {
        this.allow_wrap_or_preserved_newline(current_token);
      }
    }
    if (reserved_word(current_token, "function")) {
      if (in_array(this._flags.last_token.text, ["}", ";"]) || this._output.just_added_newline() && !(in_array(this._flags.last_token.text, ["(", "[", "{", ":", "=", ","]) || this._flags.last_token.type === TOKEN.OPERATOR)) {
        if (!this._output.just_added_blankline() && !current_token.comments_before) {
          this.print_newline();
          this.print_newline(true);
        }
      }
      if (this._flags.last_token.type === TOKEN.RESERVED || this._flags.last_token.type === TOKEN.WORD) {
        if (reserved_array(this._flags.last_token, ["get", "set", "new", "export"]) || reserved_array(this._flags.last_token, newline_restricted_tokens)) {
          this._output.space_before_token = true;
        } else if (reserved_word(this._flags.last_token, "default") && this._last_last_text === "export") {
          this._output.space_before_token = true;
        } else if (this._flags.last_token.text === "declare") {
          this._output.space_before_token = true;
        } else {
          this.print_newline();
        }
      } else if (this._flags.last_token.type === TOKEN.OPERATOR || this._flags.last_token.text === "=") {
        this._output.space_before_token = true;
      } else if (!this._flags.multiline_frame && (is_expression(this._flags.mode) || is_array(this._flags.mode))) {
      } else {
        this.print_newline();
      }
      this.print_token(current_token);
      this._flags.last_word = current_token.text;
      return;
    }
    var prefix = "NONE";
    if (this._flags.last_token.type === TOKEN.END_BLOCK) {
      if (this._previous_flags.inline_frame) {
        prefix = "SPACE";
      } else if (!reserved_array(current_token, ["else", "catch", "finally", "from"])) {
        prefix = "NEWLINE";
      } else {
        if (this._options.brace_style === "expand" || this._options.brace_style === "end-expand" || this._options.brace_style === "none" && current_token.newlines) {
          prefix = "NEWLINE";
        } else {
          prefix = "SPACE";
          this._output.space_before_token = true;
        }
      }
    } else if (this._flags.last_token.type === TOKEN.SEMICOLON && this._flags.mode === MODE.BlockStatement) {
      prefix = "NEWLINE";
    } else if (this._flags.last_token.type === TOKEN.SEMICOLON && is_expression(this._flags.mode)) {
      prefix = "SPACE";
    } else if (this._flags.last_token.type === TOKEN.STRING) {
      prefix = "NEWLINE";
    } else if (this._flags.last_token.type === TOKEN.RESERVED || this._flags.last_token.type === TOKEN.WORD || this._flags.last_token.text === "*" && (in_array(this._last_last_text, ["function", "yield"]) || this._flags.mode === MODE.ObjectLiteral && in_array(this._last_last_text, ["{", ","]))) {
      prefix = "SPACE";
    } else if (this._flags.last_token.type === TOKEN.START_BLOCK) {
      if (this._flags.inline_frame) {
        prefix = "SPACE";
      } else {
        prefix = "NEWLINE";
      }
    } else if (this._flags.last_token.type === TOKEN.END_EXPR) {
      this._output.space_before_token = true;
      prefix = "NEWLINE";
    }
    if (reserved_array(current_token, line_starters) && this._flags.last_token.text !== ")") {
      if (this._flags.inline_frame || this._flags.last_token.text === "else" || this._flags.last_token.text === "export") {
        prefix = "SPACE";
      } else {
        prefix = "NEWLINE";
      }
    }
    if (reserved_array(current_token, ["else", "catch", "finally"])) {
      if ((!(this._flags.last_token.type === TOKEN.END_BLOCK && this._previous_flags.mode === MODE.BlockStatement) || this._options.brace_style === "expand" || this._options.brace_style === "end-expand" || this._options.brace_style === "none" && current_token.newlines) && !this._flags.inline_frame) {
        this.print_newline();
      } else {
        this._output.trim(true);
        var line = this._output.current_line;
        if (line.last() !== "}") {
          this.print_newline();
        }
        this._output.space_before_token = true;
      }
    } else if (prefix === "NEWLINE") {
      if (reserved_array(this._flags.last_token, special_words)) {
        this._output.space_before_token = true;
      } else if (this._flags.last_token.text === "declare" && reserved_array(current_token, ["var", "let", "const"])) {
        this._output.space_before_token = true;
      } else if (this._flags.last_token.type !== TOKEN.END_EXPR) {
        if ((this._flags.last_token.type !== TOKEN.START_EXPR || !reserved_array(current_token, ["var", "let", "const"])) && this._flags.last_token.text !== ":") {
          if (reserved_word(current_token, "if") && reserved_word(current_token.previous, "else")) {
            this._output.space_before_token = true;
          } else {
            this.print_newline();
          }
        }
      } else if (reserved_array(current_token, line_starters) && this._flags.last_token.text !== ")") {
        this.print_newline();
      }
    } else if (this._flags.multiline_frame && is_array(this._flags.mode) && this._flags.last_token.text === "," && this._last_last_text === "}") {
      this.print_newline();
    } else if (prefix === "SPACE") {
      this._output.space_before_token = true;
    }
    if (current_token.previous && (current_token.previous.type === TOKEN.WORD || current_token.previous.type === TOKEN.RESERVED)) {
      this._output.space_before_token = true;
    }
    this.print_token(current_token);
    this._flags.last_word = current_token.text;
    if (current_token.type === TOKEN.RESERVED) {
      if (current_token.text === "do") {
        this._flags.do_block = true;
      } else if (current_token.text === "if") {
        this._flags.if_block = true;
      } else if (current_token.text === "import") {
        this._flags.import_block = true;
      } else if (this._flags.import_block && reserved_word(current_token, "from")) {
        this._flags.import_block = false;
      }
    }
  };
  Beautifier.prototype.handle_semicolon = function(current_token) {
    if (this.start_of_statement(current_token)) {
      this._output.space_before_token = false;
    } else {
      this.handle_whitespace_and_comments(current_token);
    }
    var next_token = this._tokens.peek();
    while (this._flags.mode === MODE.Statement && !(this._flags.if_block && reserved_word(next_token, "else")) && !this._flags.do_block) {
      this.restore_mode();
    }
    if (this._flags.import_block) {
      this._flags.import_block = false;
    }
    this.print_token(current_token);
  };
  Beautifier.prototype.handle_string = function(current_token) {
    if (current_token.text.startsWith("`") && current_token.newlines === 0 && current_token.whitespace_before === "" && (current_token.previous.text === ")" || this._flags.last_token.type === TOKEN.WORD)) {
    } else if (this.start_of_statement(current_token)) {
      this._output.space_before_token = true;
    } else {
      this.handle_whitespace_and_comments(current_token);
      if (this._flags.last_token.type === TOKEN.RESERVED || this._flags.last_token.type === TOKEN.WORD || this._flags.inline_frame) {
        this._output.space_before_token = true;
      } else if (this._flags.last_token.type === TOKEN.COMMA || this._flags.last_token.type === TOKEN.START_EXPR || this._flags.last_token.type === TOKEN.EQUALS || this._flags.last_token.type === TOKEN.OPERATOR) {
        if (!this.start_of_object_property()) {
          this.allow_wrap_or_preserved_newline(current_token);
        }
      } else if (current_token.text.startsWith("`") && this._flags.last_token.type === TOKEN.END_EXPR && (current_token.previous.text === "]" || current_token.previous.text === ")") && current_token.newlines === 0) {
        this._output.space_before_token = true;
      } else {
        this.print_newline();
      }
    }
    this.print_token(current_token);
  };
  Beautifier.prototype.handle_equals = function(current_token) {
    if (this.start_of_statement(current_token)) {
    } else {
      this.handle_whitespace_and_comments(current_token);
    }
    if (this._flags.declaration_statement) {
      this._flags.declaration_assignment = true;
    }
    this._output.space_before_token = true;
    this.print_token(current_token);
    this._output.space_before_token = true;
  };
  Beautifier.prototype.handle_comma = function(current_token) {
    this.handle_whitespace_and_comments(current_token, true);
    this.print_token(current_token);
    this._output.space_before_token = true;
    if (this._flags.declaration_statement) {
      if (is_expression(this._flags.parent.mode)) {
        this._flags.declaration_assignment = false;
      }
      if (this._flags.declaration_assignment) {
        this._flags.declaration_assignment = false;
        this.print_newline(false, true);
      } else if (this._options.comma_first) {
        this.allow_wrap_or_preserved_newline(current_token);
      }
    } else if (this._flags.mode === MODE.ObjectLiteral || this._flags.mode === MODE.Statement && this._flags.parent.mode === MODE.ObjectLiteral) {
      if (this._flags.mode === MODE.Statement) {
        this.restore_mode();
      }
      if (!this._flags.inline_frame) {
        this.print_newline();
      }
    } else if (this._options.comma_first) {
      this.allow_wrap_or_preserved_newline(current_token);
    }
  };
  Beautifier.prototype.handle_operator = function(current_token) {
    var isGeneratorAsterisk = current_token.text === "*" && (reserved_array(this._flags.last_token, ["function", "yield"]) || in_array(this._flags.last_token.type, [TOKEN.START_BLOCK, TOKEN.COMMA, TOKEN.END_BLOCK, TOKEN.SEMICOLON]));
    var isUnary = in_array(current_token.text, ["-", "+"]) && (in_array(this._flags.last_token.type, [TOKEN.START_BLOCK, TOKEN.START_EXPR, TOKEN.EQUALS, TOKEN.OPERATOR]) || in_array(this._flags.last_token.text, line_starters) || this._flags.last_token.text === ",");
    if (this.start_of_statement(current_token)) {
    } else {
      var preserve_statement_flags = !isGeneratorAsterisk;
      this.handle_whitespace_and_comments(current_token, preserve_statement_flags);
    }
    if (current_token.text === "*" && this._flags.last_token.type === TOKEN.DOT) {
      this.print_token(current_token);
      return;
    }
    if (current_token.text === "::") {
      this.print_token(current_token);
      return;
    }
    if (in_array(current_token.text, ["-", "+"]) && this.start_of_object_property()) {
      this.print_token(current_token);
      return;
    }
    if (this._flags.last_token.type === TOKEN.OPERATOR && in_array(this._options.operator_position, OPERATOR_POSITION_BEFORE_OR_PRESERVE)) {
      this.allow_wrap_or_preserved_newline(current_token);
    }
    if (current_token.text === ":" && this._flags.in_case) {
      this.print_token(current_token);
      this._flags.in_case = false;
      this._flags.case_body = true;
      if (this._tokens.peek().type !== TOKEN.START_BLOCK) {
        this.indent();
        this.print_newline();
        this._flags.case_block = false;
      } else {
        this._flags.case_block = true;
        this._output.space_before_token = true;
      }
      return;
    }
    var space_before = true;
    var space_after = true;
    var in_ternary = false;
    if (current_token.text === ":") {
      if (this._flags.ternary_depth === 0) {
        space_before = false;
      } else {
        this._flags.ternary_depth -= 1;
        in_ternary = true;
      }
    } else if (current_token.text === "?") {
      this._flags.ternary_depth += 1;
    }
    if (!isUnary && !isGeneratorAsterisk && this._options.preserve_newlines && in_array(current_token.text, positionable_operators)) {
      var isColon = current_token.text === ":";
      var isTernaryColon = isColon && in_ternary;
      var isOtherColon = isColon && !in_ternary;
      switch (this._options.operator_position) {
        case OPERATOR_POSITION.before_newline:
          this._output.space_before_token = !isOtherColon;
          this.print_token(current_token);
          if (!isColon || isTernaryColon) {
            this.allow_wrap_or_preserved_newline(current_token);
          }
          this._output.space_before_token = true;
          return;
        case OPERATOR_POSITION.after_newline:
          this._output.space_before_token = true;
          if (!isColon || isTernaryColon) {
            if (this._tokens.peek().newlines) {
              this.print_newline(false, true);
            } else {
              this.allow_wrap_or_preserved_newline(current_token);
            }
          } else {
            this._output.space_before_token = false;
          }
          this.print_token(current_token);
          this._output.space_before_token = true;
          return;
        case OPERATOR_POSITION.preserve_newline:
          if (!isOtherColon) {
            this.allow_wrap_or_preserved_newline(current_token);
          }
          space_before = !(this._output.just_added_newline() || isOtherColon);
          this._output.space_before_token = space_before;
          this.print_token(current_token);
          this._output.space_before_token = true;
          return;
      }
    }
    if (isGeneratorAsterisk) {
      this.allow_wrap_or_preserved_newline(current_token);
      space_before = false;
      var next_token = this._tokens.peek();
      space_after = next_token && in_array(next_token.type, [TOKEN.WORD, TOKEN.RESERVED]);
    } else if (current_token.text === "...") {
      this.allow_wrap_or_preserved_newline(current_token);
      space_before = this._flags.last_token.type === TOKEN.START_BLOCK;
      space_after = false;
    } else if (in_array(current_token.text, ["--", "++", "!", "~"]) || isUnary) {
      if (this._flags.last_token.type === TOKEN.COMMA || this._flags.last_token.type === TOKEN.START_EXPR) {
        this.allow_wrap_or_preserved_newline(current_token);
      }
      space_before = false;
      space_after = false;
      if (current_token.newlines && (current_token.text === "--" || current_token.text === "++" || current_token.text === "~")) {
        var new_line_needed = reserved_array(this._flags.last_token, special_words) && current_token.newlines;
        if (new_line_needed && (this._previous_flags.if_block || this._previous_flags.else_block)) {
          this.restore_mode();
        }
        this.print_newline(new_line_needed, true);
      }
      if (this._flags.last_token.text === ";" && is_expression(this._flags.mode)) {
        space_before = true;
      }
      if (this._flags.last_token.type === TOKEN.RESERVED) {
        space_before = true;
      } else if (this._flags.last_token.type === TOKEN.END_EXPR) {
        space_before = !(this._flags.last_token.text === "]" && (current_token.text === "--" || current_token.text === "++"));
      } else if (this._flags.last_token.type === TOKEN.OPERATOR) {
        space_before = in_array(current_token.text, ["--", "-", "++", "+"]) && in_array(this._flags.last_token.text, ["--", "-", "++", "+"]);
        if (in_array(current_token.text, ["+", "-"]) && in_array(this._flags.last_token.text, ["--", "++"])) {
          space_after = true;
        }
      }
      if ((this._flags.mode === MODE.BlockStatement && !this._flags.inline_frame || this._flags.mode === MODE.Statement) && (this._flags.last_token.text === "{" || this._flags.last_token.text === ";")) {
        this.print_newline();
      }
    }
    this._output.space_before_token = this._output.space_before_token || space_before;
    this.print_token(current_token);
    this._output.space_before_token = space_after;
  };
  Beautifier.prototype.handle_block_comment = function(current_token, preserve_statement_flags) {
    if (this._output.raw) {
      this._output.add_raw_token(current_token);
      if (current_token.directives && current_token.directives.preserve === "end") {
        this._output.raw = this._options.test_output_raw;
      }
      return;
    }
    if (current_token.directives) {
      this.print_newline(false, preserve_statement_flags);
      this.print_token(current_token);
      if (current_token.directives.preserve === "start") {
        this._output.raw = true;
      }
      this.print_newline(false, true);
      return;
    }
    if (!acorn.newline.test(current_token.text) && !current_token.newlines) {
      this._output.space_before_token = true;
      this.print_token(current_token);
      this._output.space_before_token = true;
      return;
    } else {
      this.print_block_commment(current_token, preserve_statement_flags);
    }
  };
  Beautifier.prototype.print_block_commment = function(current_token, preserve_statement_flags) {
    var lines = split_linebreaks(current_token.text);
    var j;
    var javadoc = false;
    var starless = false;
    var lastIndent = current_token.whitespace_before;
    var lastIndentLength = lastIndent.length;
    this.print_newline(false, preserve_statement_flags);
    this.print_token_line_indentation(current_token);
    this._output.add_token(lines[0]);
    this.print_newline(false, preserve_statement_flags);
    if (lines.length > 1) {
      lines = lines.slice(1);
      javadoc = all_lines_start_with(lines, "*");
      starless = each_line_matches_indent(lines, lastIndent);
      if (javadoc) {
        this._flags.alignment = 1;
      }
      for (j = 0;j < lines.length; j++) {
        if (javadoc) {
          this.print_token_line_indentation(current_token);
          this._output.add_token(ltrim(lines[j]));
        } else if (starless && lines[j]) {
          this.print_token_line_indentation(current_token);
          this._output.add_token(lines[j].substring(lastIndentLength));
        } else {
          this._output.current_line.set_indent(-1);
          this._output.add_token(lines[j]);
        }
        this.print_newline(false, preserve_statement_flags);
      }
      this._flags.alignment = 0;
    }
  };
  Beautifier.prototype.handle_comment = function(current_token, preserve_statement_flags) {
    if (current_token.newlines) {
      this.print_newline(false, preserve_statement_flags);
    } else {
      this._output.trim(true);
    }
    this._output.space_before_token = true;
    this.print_token(current_token);
    this.print_newline(false, preserve_statement_flags);
  };
  Beautifier.prototype.handle_dot = function(current_token) {
    if (this.start_of_statement(current_token)) {
    } else {
      this.handle_whitespace_and_comments(current_token, true);
    }
    if (this._flags.last_token.text.match("^[0-9]+$")) {
      this._output.space_before_token = true;
    }
    if (reserved_array(this._flags.last_token, special_words)) {
      this._output.space_before_token = false;
    } else {
      this.allow_wrap_or_preserved_newline(current_token, this._flags.last_token.text === ")" && this._options.break_chained_methods);
    }
    if (this._options.unindent_chained_methods && this._output.just_added_newline()) {
      this.deindent();
    }
    this.print_token(current_token);
  };
  Beautifier.prototype.handle_unknown = function(current_token, preserve_statement_flags) {
    this.print_token(current_token);
    if (current_token.text[current_token.text.length - 1] === "\n") {
      this.print_newline(false, preserve_statement_flags);
    }
  };
  Beautifier.prototype.handle_eof = function(current_token) {
    while (this._flags.mode === MODE.Statement) {
      this.restore_mode();
    }
    this.handle_whitespace_and_comments(current_token);
  };
  exports.Beautifier = Beautifier;
});

// node_modules/js-beautify/js/src/javascript/index.js
var require_javascript = __commonJS((exports, module) => {
  var js_beautify = function(js_source_text, options) {
    var beautifier = new Beautifier(js_source_text, options);
    return beautifier.beautify();
  };
  var Beautifier = require_beautifier().Beautifier;
  var Options = require_options2().Options;
  module.exports = js_beautify;
  module.exports.defaultOptions = function() {
    return new Options;
  };
});

// node_modules/js-beautify/js/src/css/options.js
var require_options3 = __commonJS((exports, module) => {
  var Options = function(options) {
    BaseOptions.call(this, options, "css");
    this.selector_separator_newline = this._get_boolean("selector_separator_newline", true);
    this.newline_between_rules = this._get_boolean("newline_between_rules", true);
    var space_around_selector_separator = this._get_boolean("space_around_selector_separator");
    this.space_around_combinator = this._get_boolean("space_around_combinator") || space_around_selector_separator;
    var brace_style_split = this._get_selection_list("brace_style", ["collapse", "expand", "end-expand", "none", "preserve-inline"]);
    this.brace_style = "collapse";
    for (var bs = 0;bs < brace_style_split.length; bs++) {
      if (brace_style_split[bs] !== "expand") {
        this.brace_style = "collapse";
      } else {
        this.brace_style = brace_style_split[bs];
      }
    }
  };
  var BaseOptions = require_options().Options;
  Options.prototype = new BaseOptions;
  exports.Options = Options;
});

// node_modules/js-beautify/js/src/css/beautifier.js
var require_beautifier2 = __commonJS((exports, module) => {
  var Beautifier = function(source_text, options) {
    this._source_text = source_text || "";
    this._options = new Options(options);
    this._ch = null;
    this._input = null;
    this.NESTED_AT_RULE = {
      page: true,
      "font-face": true,
      keyframes: true,
      media: true,
      supports: true,
      document: true
    };
    this.CONDITIONAL_GROUP_RULE = {
      media: true,
      supports: true,
      document: true
    };
    this.NON_SEMICOLON_NEWLINE_PROPERTY = [
      "grid-template-areas",
      "grid-template"
    ];
  };
  var Options = require_options3().Options;
  var Output = require_output().Output;
  var InputScanner = require_inputscanner().InputScanner;
  var Directives = require_directives().Directives;
  var directives_core = new Directives(/\/\*/, /\*\//);
  var lineBreak = /\r\n|[\r\n]/;
  var allLineBreaks = /\r\n|[\r\n]/g;
  var whitespaceChar = /\s/;
  var whitespacePattern = /(?:\s|\n)+/g;
  var block_comment_pattern = /\/\*(?:[\s\S]*?)((?:\*\/)|$)/g;
  var comment_pattern = /\/\/(?:[^\n\r\u2028\u2029]*)/g;
  Beautifier.prototype.eatString = function(endChars) {
    var result2 = "";
    this._ch = this._input.next();
    while (this._ch) {
      result2 += this._ch;
      if (this._ch === "\\") {
        result2 += this._input.next();
      } else if (endChars.indexOf(this._ch) !== -1 || this._ch === "\n") {
        break;
      }
      this._ch = this._input.next();
    }
    return result2;
  };
  Beautifier.prototype.eatWhitespace = function(allowAtLeastOneNewLine) {
    var result2 = whitespaceChar.test(this._input.peek());
    var newline_count = 0;
    while (whitespaceChar.test(this._input.peek())) {
      this._ch = this._input.next();
      if (allowAtLeastOneNewLine && this._ch === "\n") {
        if (newline_count === 0 || newline_count < this._options.max_preserve_newlines) {
          newline_count++;
          this._output.add_new_line(true);
        }
      }
    }
    return result2;
  };
  Beautifier.prototype.foundNestedPseudoClass = function() {
    var openParen = 0;
    var i = 1;
    var ch = this._input.peek(i);
    while (ch) {
      if (ch === "{") {
        return true;
      } else if (ch === "(") {
        openParen += 1;
      } else if (ch === ")") {
        if (openParen === 0) {
          return false;
        }
        openParen -= 1;
      } else if (ch === ";" || ch === "}") {
        return false;
      }
      i++;
      ch = this._input.peek(i);
    }
    return false;
  };
  Beautifier.prototype.print_string = function(output_string) {
    this._output.set_indent(this._indentLevel);
    this._output.non_breaking_space = true;
    this._output.add_token(output_string);
  };
  Beautifier.prototype.preserveSingleSpace = function(isAfterSpace) {
    if (isAfterSpace) {
      this._output.space_before_token = true;
    }
  };
  Beautifier.prototype.indent = function() {
    this._indentLevel++;
  };
  Beautifier.prototype.outdent = function() {
    if (this._indentLevel > 0) {
      this._indentLevel--;
    }
  };
  Beautifier.prototype.beautify = function() {
    if (this._options.disabled) {
      return this._source_text;
    }
    var source_text = this._source_text;
    var eol = this._options.eol;
    if (eol === "auto") {
      eol = "\n";
      if (source_text && lineBreak.test(source_text || "")) {
        eol = source_text.match(lineBreak)[0];
      }
    }
    source_text = source_text.replace(allLineBreaks, "\n");
    var baseIndentString = source_text.match(/^[\t ]*/)[0];
    this._output = new Output(this._options, baseIndentString);
    this._input = new InputScanner(source_text);
    this._indentLevel = 0;
    this._nestedLevel = 0;
    this._ch = null;
    var parenLevel = 0;
    var insideRule = false;
    var insidePropertyValue = false;
    var enteringConditionalGroup = false;
    var insideNonNestedAtRule = false;
    var insideScssMap = false;
    var topCharacter = this._ch;
    var insideNonSemiColonValues = false;
    var whitespace;
    var isAfterSpace;
    var previous_ch;
    while (true) {
      whitespace = this._input.read(whitespacePattern);
      isAfterSpace = whitespace !== "";
      previous_ch = topCharacter;
      this._ch = this._input.next();
      if (this._ch === "\\" && this._input.hasNext()) {
        this._ch += this._input.next();
      }
      topCharacter = this._ch;
      if (!this._ch) {
        break;
      } else if (this._ch === "/" && this._input.peek() === "*") {
        this._output.add_new_line();
        this._input.back();
        var comment = this._input.read(block_comment_pattern);
        var directives = directives_core.get_directives(comment);
        if (directives && directives.ignore === "start") {
          comment += directives_core.readIgnored(this._input);
        }
        this.print_string(comment);
        this.eatWhitespace(true);
        this._output.add_new_line();
      } else if (this._ch === "/" && this._input.peek() === "/") {
        this._output.space_before_token = true;
        this._input.back();
        this.print_string(this._input.read(comment_pattern));
        this.eatWhitespace(true);
      } else if (this._ch === "$") {
        this.preserveSingleSpace(isAfterSpace);
        this.print_string(this._ch);
        var variable = this._input.peekUntilAfter(/[: ,;{}()[\]\/='"]/g);
        if (variable.match(/[ :]$/)) {
          variable = this.eatString(": ").replace(/\s+$/, "");
          this.print_string(variable);
          this._output.space_before_token = true;
        }
        if (parenLevel === 0 && variable.indexOf(":") !== -1) {
          insidePropertyValue = true;
          this.indent();
        }
      } else if (this._ch === "@") {
        this.preserveSingleSpace(isAfterSpace);
        if (this._input.peek() === "{") {
          this.print_string(this._ch + this.eatString("}"));
        } else {
          this.print_string(this._ch);
          var variableOrRule = this._input.peekUntilAfter(/[: ,;{}()[\]\/='"]/g);
          if (variableOrRule.match(/[ :]$/)) {
            variableOrRule = this.eatString(": ").replace(/\s+$/, "");
            this.print_string(variableOrRule);
            this._output.space_before_token = true;
          }
          if (parenLevel === 0 && variableOrRule.indexOf(":") !== -1) {
            insidePropertyValue = true;
            this.indent();
          } else if (variableOrRule in this.NESTED_AT_RULE) {
            this._nestedLevel += 1;
            if (variableOrRule in this.CONDITIONAL_GROUP_RULE) {
              enteringConditionalGroup = true;
            }
          } else if (parenLevel === 0 && !insidePropertyValue) {
            insideNonNestedAtRule = true;
          }
        }
      } else if (this._ch === "#" && this._input.peek() === "{") {
        this.preserveSingleSpace(isAfterSpace);
        this.print_string(this._ch + this.eatString("}"));
      } else if (this._ch === "{") {
        if (insidePropertyValue) {
          insidePropertyValue = false;
          this.outdent();
        }
        insideNonNestedAtRule = false;
        if (enteringConditionalGroup) {
          enteringConditionalGroup = false;
          insideRule = this._indentLevel >= this._nestedLevel;
        } else {
          insideRule = this._indentLevel >= this._nestedLevel - 1;
        }
        if (this._options.newline_between_rules && insideRule) {
          if (this._output.previous_line && this._output.previous_line.item(-1) !== "{") {
            this._output.ensure_empty_line_above("/", ",");
          }
        }
        this._output.space_before_token = true;
        if (this._options.brace_style === "expand") {
          this._output.add_new_line();
          this.print_string(this._ch);
          this.indent();
          this._output.set_indent(this._indentLevel);
        } else {
          if (previous_ch === "(") {
            this._output.space_before_token = false;
          } else if (previous_ch !== ",") {
            this.indent();
          }
          this.print_string(this._ch);
        }
        this.eatWhitespace(true);
        this._output.add_new_line();
      } else if (this._ch === "}") {
        this.outdent();
        this._output.add_new_line();
        if (previous_ch === "{") {
          this._output.trim(true);
        }
        if (insidePropertyValue) {
          this.outdent();
          insidePropertyValue = false;
        }
        this.print_string(this._ch);
        insideRule = false;
        if (this._nestedLevel) {
          this._nestedLevel--;
        }
        this.eatWhitespace(true);
        this._output.add_new_line();
        if (this._options.newline_between_rules && !this._output.just_added_blankline()) {
          if (this._input.peek() !== "}") {
            this._output.add_new_line(true);
          }
        }
        if (this._input.peek() === ")") {
          this._output.trim(true);
          if (this._options.brace_style === "expand") {
            this._output.add_new_line(true);
          }
        }
      } else if (this._ch === ":") {
        for (var i = 0;i < this.NON_SEMICOLON_NEWLINE_PROPERTY.length; i++) {
          if (this._input.lookBack(this.NON_SEMICOLON_NEWLINE_PROPERTY[i])) {
            insideNonSemiColonValues = true;
            break;
          }
        }
        if ((insideRule || enteringConditionalGroup) && !(this._input.lookBack("&") || this.foundNestedPseudoClass()) && !this._input.lookBack("(") && !insideNonNestedAtRule && parenLevel === 0) {
          this.print_string(":");
          if (!insidePropertyValue) {
            insidePropertyValue = true;
            this._output.space_before_token = true;
            this.eatWhitespace(true);
            this.indent();
          }
        } else {
          if (this._input.lookBack(" ")) {
            this._output.space_before_token = true;
          }
          if (this._input.peek() === ":") {
            this._ch = this._input.next();
            this.print_string("::");
          } else {
            this.print_string(":");
          }
        }
      } else if (this._ch === '"' || this._ch === "\'") {
        var preserveQuoteSpace = previous_ch === '"' || previous_ch === "\'";
        this.preserveSingleSpace(preserveQuoteSpace || isAfterSpace);
        this.print_string(this._ch + this.eatString(this._ch));
        this.eatWhitespace(true);
      } else if (this._ch === ";") {
        insideNonSemiColonValues = false;
        if (parenLevel === 0) {
          if (insidePropertyValue) {
            this.outdent();
            insidePropertyValue = false;
          }
          insideNonNestedAtRule = false;
          this.print_string(this._ch);
          this.eatWhitespace(true);
          if (this._input.peek() !== "/") {
            this._output.add_new_line();
          }
        } else {
          this.print_string(this._ch);
          this.eatWhitespace(true);
          this._output.space_before_token = true;
        }
      } else if (this._ch === "(") {
        if (this._input.lookBack("url")) {
          this.print_string(this._ch);
          this.eatWhitespace();
          parenLevel++;
          this.indent();
          this._ch = this._input.next();
          if (this._ch === ")" || this._ch === '"' || this._ch === "\'") {
            this._input.back();
          } else if (this._ch) {
            this.print_string(this._ch + this.eatString(")"));
            if (parenLevel) {
              parenLevel--;
              this.outdent();
            }
          }
        } else {
          var space_needed = false;
          if (this._input.lookBack("with")) {
            space_needed = true;
          }
          this.preserveSingleSpace(isAfterSpace || space_needed);
          this.print_string(this._ch);
          if (insidePropertyValue && previous_ch === "$" && this._options.selector_separator_newline) {
            this._output.add_new_line();
            insideScssMap = true;
          } else {
            this.eatWhitespace();
            parenLevel++;
            this.indent();
          }
        }
      } else if (this._ch === ")") {
        if (parenLevel) {
          parenLevel--;
          this.outdent();
        }
        if (insideScssMap && this._input.peek() === ";" && this._options.selector_separator_newline) {
          insideScssMap = false;
          this.outdent();
          this._output.add_new_line();
        }
        this.print_string(this._ch);
      } else if (this._ch === ",") {
        this.print_string(this._ch);
        this.eatWhitespace(true);
        if (this._options.selector_separator_newline && (!insidePropertyValue || insideScssMap) && parenLevel === 0 && !insideNonNestedAtRule) {
          this._output.add_new_line();
        } else {
          this._output.space_before_token = true;
        }
      } else if ((this._ch === ">" || this._ch === "+" || this._ch === "~") && !insidePropertyValue && parenLevel === 0) {
        if (this._options.space_around_combinator) {
          this._output.space_before_token = true;
          this.print_string(this._ch);
          this._output.space_before_token = true;
        } else {
          this.print_string(this._ch);
          this.eatWhitespace();
          if (this._ch && whitespaceChar.test(this._ch)) {
            this._ch = "";
          }
        }
      } else if (this._ch === "]") {
        this.print_string(this._ch);
      } else if (this._ch === "[") {
        this.preserveSingleSpace(isAfterSpace);
        this.print_string(this._ch);
      } else if (this._ch === "=") {
        this.eatWhitespace();
        this.print_string("=");
        if (whitespaceChar.test(this._ch)) {
          this._ch = "";
        }
      } else if (this._ch === "!" && !this._input.lookBack("\\")) {
        this._output.space_before_token = true;
        this.print_string(this._ch);
      } else {
        var preserveAfterSpace = previous_ch === '"' || previous_ch === "\'";
        this.preserveSingleSpace(preserveAfterSpace || isAfterSpace);
        this.print_string(this._ch);
        if (!this._output.just_added_newline() && this._input.peek() === "\n" && insideNonSemiColonValues) {
          this._output.add_new_line();
        }
      }
    }
    var sweetCode = this._output.get_code(eol);
    return sweetCode;
  };
  exports.Beautifier = Beautifier;
});

// node_modules/js-beautify/js/src/css/index.js
var require_css = __commonJS((exports, module) => {
  var css_beautify = function(source_text, options) {
    var beautifier = new Beautifier(source_text, options);
    return beautifier.beautify();
  };
  var Beautifier = require_beautifier2().Beautifier;
  var Options = require_options3().Options;
  module.exports = css_beautify;
  module.exports.defaultOptions = function() {
    return new Options;
  };
});

// node_modules/js-beautify/js/src/html/options.js
var require_options4 = __commonJS((exports, module) => {
  var Options = function(options) {
    BaseOptions.call(this, options, "html");
    if (this.templating.length === 1 && this.templating[0] === "auto") {
      this.templating = ["django", "erb", "handlebars", "php"];
    }
    this.indent_inner_html = this._get_boolean("indent_inner_html");
    this.indent_body_inner_html = this._get_boolean("indent_body_inner_html", true);
    this.indent_head_inner_html = this._get_boolean("indent_head_inner_html", true);
    this.indent_handlebars = this._get_boolean("indent_handlebars", true);
    this.wrap_attributes = this._get_selection("wrap_attributes", ["auto", "force", "force-aligned", "force-expand-multiline", "aligned-multiple", "preserve", "preserve-aligned"]);
    this.wrap_attributes_min_attrs = this._get_number("wrap_attributes_min_attrs", 2);
    this.wrap_attributes_indent_size = this._get_number("wrap_attributes_indent_size", this.indent_size);
    this.extra_liners = this._get_array("extra_liners", ["head", "body", "/html"]);
    this.inline = this._get_array("inline", [
      "a",
      "abbr",
      "area",
      "audio",
      "b",
      "bdi",
      "bdo",
      "br",
      "button",
      "canvas",
      "cite",
      "code",
      "data",
      "datalist",
      "del",
      "dfn",
      "em",
      "embed",
      "i",
      "iframe",
      "img",
      "input",
      "ins",
      "kbd",
      "keygen",
      "label",
      "map",
      "mark",
      "math",
      "meter",
      "noscript",
      "object",
      "output",
      "progress",
      "q",
      "ruby",
      "s",
      "samp",
      "select",
      "small",
      "span",
      "strong",
      "sub",
      "sup",
      "svg",
      "template",
      "textarea",
      "time",
      "u",
      "var",
      "video",
      "wbr",
      "text",
      "acronym",
      "big",
      "strike",
      "tt"
    ]);
    this.inline_custom_elements = this._get_boolean("inline_custom_elements", true);
    this.void_elements = this._get_array("void_elements", [
      "area",
      "base",
      "br",
      "col",
      "embed",
      "hr",
      "img",
      "input",
      "keygen",
      "link",
      "menuitem",
      "meta",
      "param",
      "source",
      "track",
      "wbr",
      "!doctype",
      "?xml",
      "basefont",
      "isindex"
    ]);
    this.unformatted = this._get_array("unformatted", []);
    this.content_unformatted = this._get_array("content_unformatted", [
      "pre",
      "textarea"
    ]);
    this.unformatted_content_delimiter = this._get_characters("unformatted_content_delimiter");
    this.indent_scripts = this._get_selection("indent_scripts", ["normal", "keep", "separate"]);
  };
  var BaseOptions = require_options().Options;
  Options.prototype = new BaseOptions;
  exports.Options = Options;
});

// node_modules/js-beautify/js/src/html/tokenizer.js
var require_tokenizer3 = __commonJS((exports, module) => {
  var BaseTokenizer = require_tokenizer().Tokenizer;
  var BASETOKEN = require_tokenizer().TOKEN;
  var Directives = require_directives().Directives;
  var TemplatablePattern = require_templatablepattern().TemplatablePattern;
  var Pattern = require_pattern().Pattern;
  var TOKEN = {
    TAG_OPEN: "TK_TAG_OPEN",
    TAG_CLOSE: "TK_TAG_CLOSE",
    ATTRIBUTE: "TK_ATTRIBUTE",
    EQUALS: "TK_EQUALS",
    VALUE: "TK_VALUE",
    COMMENT: "TK_COMMENT",
    TEXT: "TK_TEXT",
    UNKNOWN: "TK_UNKNOWN",
    START: BASETOKEN.START,
    RAW: BASETOKEN.RAW,
    EOF: BASETOKEN.EOF
  };
  var directives_core = new Directives(/<\!--/, /-->/);
  var Tokenizer = function(input_string, options) {
    BaseTokenizer.call(this, input_string, options);
    this._current_tag_name = "";
    var templatable_reader = new TemplatablePattern(this._input).read_options(this._options);
    var pattern_reader = new Pattern(this._input);
    this.__patterns = {
      word: templatable_reader.until(/[\n\r\t <]/),
      single_quote: templatable_reader.until_after(/'/),
      double_quote: templatable_reader.until_after(/"/),
      attribute: templatable_reader.until(/[\n\r\t =>]|\/>/),
      element_name: templatable_reader.until(/[\n\r\t >\/]/),
      handlebars_comment: pattern_reader.starting_with(/{{!--/).until_after(/--}}/),
      handlebars: pattern_reader.starting_with(/{{/).until_after(/}}/),
      handlebars_open: pattern_reader.until(/[\n\r\t }]/),
      handlebars_raw_close: pattern_reader.until(/}}/),
      comment: pattern_reader.starting_with(/<!--/).until_after(/-->/),
      cdata: pattern_reader.starting_with(/<!\[CDATA\[/).until_after(/]]>/),
      conditional_comment: pattern_reader.starting_with(/<!\[/).until_after(/]>/),
      processing: pattern_reader.starting_with(/<\?/).until_after(/\?>/)
    };
    if (this._options.indent_handlebars) {
      this.__patterns.word = this.__patterns.word.exclude("handlebars");
    }
    this._unformatted_content_delimiter = null;
    if (this._options.unformatted_content_delimiter) {
      var literal_regexp = this._input.get_literal_regexp(this._options.unformatted_content_delimiter);
      this.__patterns.unformatted_content_delimiter = pattern_reader.matching(literal_regexp).until_after(literal_regexp);
    }
  };
  Tokenizer.prototype = new BaseTokenizer;
  Tokenizer.prototype._is_comment = function(current_token) {
    return false;
  };
  Tokenizer.prototype._is_opening = function(current_token) {
    return current_token.type === TOKEN.TAG_OPEN;
  };
  Tokenizer.prototype._is_closing = function(current_token, open_token) {
    return current_token.type === TOKEN.TAG_CLOSE && (open_token && ((current_token.text === ">" || current_token.text === "/>") && open_token.text[0] === "<" || current_token.text === "}}" && open_token.text[0] === "{" && open_token.text[1] === "{"));
  };
  Tokenizer.prototype._reset = function() {
    this._current_tag_name = "";
  };
  Tokenizer.prototype._get_next_token = function(previous_token, open_token) {
    var token = null;
    this._readWhitespace();
    var c2 = this._input.peek();
    if (c2 === null) {
      return this._create_token(TOKEN.EOF, "");
    }
    token = token || this._read_open_handlebars(c2, open_token);
    token = token || this._read_attribute(c2, previous_token, open_token);
    token = token || this._read_close(c2, open_token);
    token = token || this._read_raw_content(c2, previous_token, open_token);
    token = token || this._read_content_word(c2);
    token = token || this._read_comment_or_cdata(c2);
    token = token || this._read_processing(c2);
    token = token || this._read_open(c2, open_token);
    token = token || this._create_token(TOKEN.UNKNOWN, this._input.next());
    return token;
  };
  Tokenizer.prototype._read_comment_or_cdata = function(c2) {
    var token = null;
    var resulting_string = null;
    var directives = null;
    if (c2 === "<") {
      var peek1 = this._input.peek(1);
      if (peek1 === "!") {
        resulting_string = this.__patterns.comment.read();
        if (resulting_string) {
          directives = directives_core.get_directives(resulting_string);
          if (directives && directives.ignore === "start") {
            resulting_string += directives_core.readIgnored(this._input);
          }
        } else {
          resulting_string = this.__patterns.cdata.read();
        }
      }
      if (resulting_string) {
        token = this._create_token(TOKEN.COMMENT, resulting_string);
        token.directives = directives;
      }
    }
    return token;
  };
  Tokenizer.prototype._read_processing = function(c2) {
    var token = null;
    var resulting_string = null;
    var directives = null;
    if (c2 === "<") {
      var peek1 = this._input.peek(1);
      if (peek1 === "!" || peek1 === "?") {
        resulting_string = this.__patterns.conditional_comment.read();
        resulting_string = resulting_string || this.__patterns.processing.read();
      }
      if (resulting_string) {
        token = this._create_token(TOKEN.COMMENT, resulting_string);
        token.directives = directives;
      }
    }
    return token;
  };
  Tokenizer.prototype._read_open = function(c2, open_token) {
    var resulting_string = null;
    var token = null;
    if (!open_token) {
      if (c2 === "<") {
        resulting_string = this._input.next();
        if (this._input.peek() === "/") {
          resulting_string += this._input.next();
        }
        resulting_string += this.__patterns.element_name.read();
        token = this._create_token(TOKEN.TAG_OPEN, resulting_string);
      }
    }
    return token;
  };
  Tokenizer.prototype._read_open_handlebars = function(c2, open_token) {
    var resulting_string = null;
    var token = null;
    if (!open_token) {
      if (this._options.indent_handlebars && c2 === "{" && this._input.peek(1) === "{") {
        if (this._input.peek(2) === "!") {
          resulting_string = this.__patterns.handlebars_comment.read();
          resulting_string = resulting_string || this.__patterns.handlebars.read();
          token = this._create_token(TOKEN.COMMENT, resulting_string);
        } else {
          resulting_string = this.__patterns.handlebars_open.read();
          token = this._create_token(TOKEN.TAG_OPEN, resulting_string);
        }
      }
    }
    return token;
  };
  Tokenizer.prototype._read_close = function(c2, open_token) {
    var resulting_string = null;
    var token = null;
    if (open_token) {
      if (open_token.text[0] === "<" && (c2 === ">" || c2 === "/" && this._input.peek(1) === ">")) {
        resulting_string = this._input.next();
        if (c2 === "/") {
          resulting_string += this._input.next();
        }
        token = this._create_token(TOKEN.TAG_CLOSE, resulting_string);
      } else if (open_token.text[0] === "{" && c2 === "}" && this._input.peek(1) === "}") {
        this._input.next();
        this._input.next();
        token = this._create_token(TOKEN.TAG_CLOSE, "}}");
      }
    }
    return token;
  };
  Tokenizer.prototype._read_attribute = function(c2, previous_token, open_token) {
    var token = null;
    var resulting_string = "";
    if (open_token && open_token.text[0] === "<") {
      if (c2 === "=") {
        token = this._create_token(TOKEN.EQUALS, this._input.next());
      } else if (c2 === '"' || c2 === "'") {
        var content = this._input.next();
        if (c2 === '"') {
          content += this.__patterns.double_quote.read();
        } else {
          content += this.__patterns.single_quote.read();
        }
        token = this._create_token(TOKEN.VALUE, content);
      } else {
        resulting_string = this.__patterns.attribute.read();
        if (resulting_string) {
          if (previous_token.type === TOKEN.EQUALS) {
            token = this._create_token(TOKEN.VALUE, resulting_string);
          } else {
            token = this._create_token(TOKEN.ATTRIBUTE, resulting_string);
          }
        }
      }
    }
    return token;
  };
  Tokenizer.prototype._is_content_unformatted = function(tag_name) {
    return this._options.void_elements.indexOf(tag_name) === -1 && (this._options.content_unformatted.indexOf(tag_name) !== -1 || this._options.unformatted.indexOf(tag_name) !== -1);
  };
  Tokenizer.prototype._read_raw_content = function(c2, previous_token, open_token) {
    var resulting_string = "";
    if (open_token && open_token.text[0] === "{") {
      resulting_string = this.__patterns.handlebars_raw_close.read();
    } else if (previous_token.type === TOKEN.TAG_CLOSE && previous_token.opened.text[0] === "<" && previous_token.text[0] !== "/") {
      var tag_name = previous_token.opened.text.substr(1).toLowerCase();
      if (tag_name === "script" || tag_name === "style") {
        var token = this._read_comment_or_cdata(c2);
        if (token) {
          token.type = TOKEN.TEXT;
          return token;
        }
        resulting_string = this._input.readUntil(new RegExp("</" + tag_name + "[\\n\\r\\t ]*?>", "ig"));
      } else if (this._is_content_unformatted(tag_name)) {
        resulting_string = this._input.readUntil(new RegExp("</" + tag_name + "[\\n\\r\\t ]*?>", "ig"));
      }
    }
    if (resulting_string) {
      return this._create_token(TOKEN.TEXT, resulting_string);
    }
    return null;
  };
  Tokenizer.prototype._read_content_word = function(c2) {
    var resulting_string = "";
    if (this._options.unformatted_content_delimiter) {
      if (c2 === this._options.unformatted_content_delimiter[0]) {
        resulting_string = this.__patterns.unformatted_content_delimiter.read();
      }
    }
    if (!resulting_string) {
      resulting_string = this.__patterns.word.read();
    }
    if (resulting_string) {
      return this._create_token(TOKEN.TEXT, resulting_string);
    }
  };
  exports.Tokenizer = Tokenizer;
  exports.TOKEN = TOKEN;
});

// node_modules/js-beautify/js/src/html/beautifier.js
var require_beautifier3 = __commonJS((exports, module) => {
  var in_array = function(what, arr) {
    return arr.indexOf(what) !== -1;
  };
  var TagFrame = function(parent, parser_token, indent_level) {
    this.parent = parent || null;
    this.tag = parser_token ? parser_token.tag_name : "";
    this.indent_level = indent_level || 0;
    this.parser_token = parser_token || null;
  };
  var TagStack = function(printer) {
    this._printer = printer;
    this._current_frame = null;
  };
  var Beautifier = function(source_text, options, js_beautify, css_beautify) {
    this._source_text = source_text || "";
    options = options || {};
    this._js_beautify = js_beautify;
    this._css_beautify = css_beautify;
    this._tag_stack = null;
    var optionHtml = new Options(options, "html");
    this._options = optionHtml;
    this._is_wrap_attributes_force = this._options.wrap_attributes.substr(0, "force".length) === "force";
    this._is_wrap_attributes_force_expand_multiline = this._options.wrap_attributes === "force-expand-multiline";
    this._is_wrap_attributes_force_aligned = this._options.wrap_attributes === "force-aligned";
    this._is_wrap_attributes_aligned_multiple = this._options.wrap_attributes === "aligned-multiple";
    this._is_wrap_attributes_preserve = this._options.wrap_attributes.substr(0, "preserve".length) === "preserve";
    this._is_wrap_attributes_preserve_aligned = this._options.wrap_attributes === "preserve-aligned";
  };
  var Options = require_options4().Options;
  var Output = require_output().Output;
  var Tokenizer = require_tokenizer3().Tokenizer;
  var TOKEN = require_tokenizer3().TOKEN;
  var lineBreak = /\r\n|[\r\n]/;
  var allLineBreaks = /\r\n|[\r\n]/g;
  var Printer = function(options, base_indent_string) {
    this.indent_level = 0;
    this.alignment_size = 0;
    this.max_preserve_newlines = options.max_preserve_newlines;
    this.preserve_newlines = options.preserve_newlines;
    this._output = new Output(options, base_indent_string);
  };
  Printer.prototype.current_line_has_match = function(pattern) {
    return this._output.current_line.has_match(pattern);
  };
  Printer.prototype.set_space_before_token = function(value, non_breaking) {
    this._output.space_before_token = value;
    this._output.non_breaking_space = non_breaking;
  };
  Printer.prototype.set_wrap_point = function() {
    this._output.set_indent(this.indent_level, this.alignment_size);
    this._output.set_wrap_point();
  };
  Printer.prototype.add_raw_token = function(token) {
    this._output.add_raw_token(token);
  };
  Printer.prototype.print_preserved_newlines = function(raw_token) {
    var newlines = 0;
    if (raw_token.type !== TOKEN.TEXT && raw_token.previous.type !== TOKEN.TEXT) {
      newlines = raw_token.newlines ? 1 : 0;
    }
    if (this.preserve_newlines) {
      newlines = raw_token.newlines < this.max_preserve_newlines + 1 ? raw_token.newlines : this.max_preserve_newlines + 1;
    }
    for (var n = 0;n < newlines; n++) {
      this.print_newline(n > 0);
    }
    return newlines !== 0;
  };
  Printer.prototype.traverse_whitespace = function(raw_token) {
    if (raw_token.whitespace_before || raw_token.newlines) {
      if (!this.print_preserved_newlines(raw_token)) {
        this._output.space_before_token = true;
      }
      return true;
    }
    return false;
  };
  Printer.prototype.previous_token_wrapped = function() {
    return this._output.previous_token_wrapped;
  };
  Printer.prototype.print_newline = function(force) {
    this._output.add_new_line(force);
  };
  Printer.prototype.print_token = function(token) {
    if (token.text) {
      this._output.set_indent(this.indent_level, this.alignment_size);
      this._output.add_token(token.text);
    }
  };
  Printer.prototype.indent = function() {
    this.indent_level++;
  };
  Printer.prototype.get_full_indent = function(level) {
    level = this.indent_level + (level || 0);
    if (level < 1) {
      return "";
    }
    return this._output.get_indent_string(level);
  };
  var get_type_attribute = function(start_token) {
    var result2 = null;
    var raw_token = start_token.next;
    while (raw_token.type !== TOKEN.EOF && start_token.closed !== raw_token) {
      if (raw_token.type === TOKEN.ATTRIBUTE && raw_token.text === "type") {
        if (raw_token.next && raw_token.next.type === TOKEN.EQUALS && raw_token.next.next && raw_token.next.next.type === TOKEN.VALUE) {
          result2 = raw_token.next.next.text;
        }
        break;
      }
      raw_token = raw_token.next;
    }
    return result2;
  };
  var get_custom_beautifier_name = function(tag_check, raw_token) {
    var typeAttribute = null;
    var result2 = null;
    if (!raw_token.closed) {
      return null;
    }
    if (tag_check === "script") {
      typeAttribute = "text/javascript";
    } else if (tag_check === "style") {
      typeAttribute = "text/css";
    }
    typeAttribute = get_type_attribute(raw_token) || typeAttribute;
    if (typeAttribute.search("text/css") > -1) {
      result2 = "css";
    } else if (typeAttribute.search(/module|((text|application|dojo)\/(x-)?(javascript|ecmascript|jscript|livescript|(ld\+)?json|method|aspect))/) > -1) {
      result2 = "javascript";
    } else if (typeAttribute.search(/(text|application|dojo)\/(x-)?(html)/) > -1) {
      result2 = "html";
    } else if (typeAttribute.search(/test\/null/) > -1) {
      result2 = "null";
    }
    return result2;
  };
  TagStack.prototype.get_parser_token = function() {
    return this._current_frame ? this._current_frame.parser_token : null;
  };
  TagStack.prototype.record_tag = function(parser_token) {
    var new_frame = new TagFrame(this._current_frame, parser_token, this._printer.indent_level);
    this._current_frame = new_frame;
  };
  TagStack.prototype._try_pop_frame = function(frame) {
    var parser_token = null;
    if (frame) {
      parser_token = frame.parser_token;
      this._printer.indent_level = frame.indent_level;
      this._current_frame = frame.parent;
    }
    return parser_token;
  };
  TagStack.prototype._get_frame = function(tag_list, stop_list) {
    var frame = this._current_frame;
    while (frame) {
      if (tag_list.indexOf(frame.tag) !== -1) {
        break;
      } else if (stop_list && stop_list.indexOf(frame.tag) !== -1) {
        frame = null;
        break;
      }
      frame = frame.parent;
    }
    return frame;
  };
  TagStack.prototype.try_pop = function(tag, stop_list) {
    var frame = this._get_frame([tag], stop_list);
    return this._try_pop_frame(frame);
  };
  TagStack.prototype.indent_to_tag = function(tag_list) {
    var frame = this._get_frame(tag_list);
    if (frame) {
      this._printer.indent_level = frame.indent_level;
    }
  };
  Beautifier.prototype.beautify = function() {
    if (this._options.disabled) {
      return this._source_text;
    }
    var source_text = this._source_text;
    var eol = this._options.eol;
    if (this._options.eol === "auto") {
      eol = "\n";
      if (source_text && lineBreak.test(source_text)) {
        eol = source_text.match(lineBreak)[0];
      }
    }
    source_text = source_text.replace(allLineBreaks, "\n");
    var baseIndentString = source_text.match(/^[\t ]*/)[0];
    var last_token = {
      text: "",
      type: ""
    };
    var last_tag_token = new TagOpenParserToken;
    var printer = new Printer(this._options, baseIndentString);
    var tokens = new Tokenizer(source_text, this._options).tokenize();
    this._tag_stack = new TagStack(printer);
    var parser_token = null;
    var raw_token = tokens.next();
    while (raw_token.type !== TOKEN.EOF) {
      if (raw_token.type === TOKEN.TAG_OPEN || raw_token.type === TOKEN.COMMENT) {
        parser_token = this._handle_tag_open(printer, raw_token, last_tag_token, last_token, tokens);
        last_tag_token = parser_token;
      } else if (raw_token.type === TOKEN.ATTRIBUTE || raw_token.type === TOKEN.EQUALS || raw_token.type === TOKEN.VALUE || raw_token.type === TOKEN.TEXT && !last_tag_token.tag_complete) {
        parser_token = this._handle_inside_tag(printer, raw_token, last_tag_token, last_token);
      } else if (raw_token.type === TOKEN.TAG_CLOSE) {
        parser_token = this._handle_tag_close(printer, raw_token, last_tag_token);
      } else if (raw_token.type === TOKEN.TEXT) {
        parser_token = this._handle_text(printer, raw_token, last_tag_token);
      } else {
        printer.add_raw_token(raw_token);
      }
      last_token = parser_token;
      raw_token = tokens.next();
    }
    var sweet_code = printer._output.get_code(eol);
    return sweet_code;
  };
  Beautifier.prototype._handle_tag_close = function(printer, raw_token, last_tag_token) {
    var parser_token = {
      text: raw_token.text,
      type: raw_token.type
    };
    printer.alignment_size = 0;
    last_tag_token.tag_complete = true;
    printer.set_space_before_token(raw_token.newlines || raw_token.whitespace_before !== "", true);
    if (last_tag_token.is_unformatted) {
      printer.add_raw_token(raw_token);
    } else {
      if (last_tag_token.tag_start_char === "<") {
        printer.set_space_before_token(raw_token.text[0] === "/", true);
        if (this._is_wrap_attributes_force_expand_multiline && last_tag_token.has_wrapped_attrs) {
          printer.print_newline(false);
        }
      }
      printer.print_token(raw_token);
    }
    if (last_tag_token.indent_content && !(last_tag_token.is_unformatted || last_tag_token.is_content_unformatted)) {
      printer.indent();
      last_tag_token.indent_content = false;
    }
    if (!last_tag_token.is_inline_element && !(last_tag_token.is_unformatted || last_tag_token.is_content_unformatted)) {
      printer.set_wrap_point();
    }
    return parser_token;
  };
  Beautifier.prototype._handle_inside_tag = function(printer, raw_token, last_tag_token, last_token) {
    var wrapped = last_tag_token.has_wrapped_attrs;
    var parser_token = {
      text: raw_token.text,
      type: raw_token.type
    };
    printer.set_space_before_token(raw_token.newlines || raw_token.whitespace_before !== "", true);
    if (last_tag_token.is_unformatted) {
      printer.add_raw_token(raw_token);
    } else if (last_tag_token.tag_start_char === "{" && raw_token.type === TOKEN.TEXT) {
      if (printer.print_preserved_newlines(raw_token)) {
        raw_token.newlines = 0;
        printer.add_raw_token(raw_token);
      } else {
        printer.print_token(raw_token);
      }
    } else {
      if (raw_token.type === TOKEN.ATTRIBUTE) {
        printer.set_space_before_token(true);
      } else if (raw_token.type === TOKEN.EQUALS) {
        printer.set_space_before_token(false);
      } else if (raw_token.type === TOKEN.VALUE && raw_token.previous.type === TOKEN.EQUALS) {
        printer.set_space_before_token(false);
      }
      if (raw_token.type === TOKEN.ATTRIBUTE && last_tag_token.tag_start_char === "<") {
        if (this._is_wrap_attributes_preserve || this._is_wrap_attributes_preserve_aligned) {
          printer.traverse_whitespace(raw_token);
          wrapped = wrapped || raw_token.newlines !== 0;
        }
        if (this._is_wrap_attributes_force && last_tag_token.attr_count >= this._options.wrap_attributes_min_attrs && (last_token.type !== TOKEN.TAG_OPEN || this._is_wrap_attributes_force_expand_multiline)) {
          printer.print_newline(false);
          wrapped = true;
        }
      }
      printer.print_token(raw_token);
      wrapped = wrapped || printer.previous_token_wrapped();
      last_tag_token.has_wrapped_attrs = wrapped;
    }
    return parser_token;
  };
  Beautifier.prototype._handle_text = function(printer, raw_token, last_tag_token) {
    var parser_token = {
      text: raw_token.text,
      type: "TK_CONTENT"
    };
    if (last_tag_token.custom_beautifier_name) {
      this._print_custom_beatifier_text(printer, raw_token, last_tag_token);
    } else if (last_tag_token.is_unformatted || last_tag_token.is_content_unformatted) {
      printer.add_raw_token(raw_token);
    } else {
      printer.traverse_whitespace(raw_token);
      printer.print_token(raw_token);
    }
    return parser_token;
  };
  Beautifier.prototype._print_custom_beatifier_text = function(printer, raw_token, last_tag_token) {
    var local = this;
    if (raw_token.text !== "") {
      var text2 = raw_token.text, _beautifier, script_indent_level = 1, pre = "", post = "";
      if (last_tag_token.custom_beautifier_name === "javascript" && typeof this._js_beautify === "function") {
        _beautifier = this._js_beautify;
      } else if (last_tag_token.custom_beautifier_name === "css" && typeof this._css_beautify === "function") {
        _beautifier = this._css_beautify;
      } else if (last_tag_token.custom_beautifier_name === "html") {
        _beautifier = function(html_source, options) {
          var beautifier = new Beautifier(html_source, options, local._js_beautify, local._css_beautify);
          return beautifier.beautify();
        };
      }
      if (this._options.indent_scripts === "keep") {
        script_indent_level = 0;
      } else if (this._options.indent_scripts === "separate") {
        script_indent_level = -printer.indent_level;
      }
      var indentation = printer.get_full_indent(script_indent_level);
      text2 = text2.replace(/\n[ \t]*$/, "");
      if (last_tag_token.custom_beautifier_name !== "html" && text2[0] === "<" && text2.match(/^(<!--|<!\[CDATA\[)/)) {
        var matched = /^(<!--[^\n]*|<!\[CDATA\[)(\n?)([ \t\n]*)([\s\S]*)(-->|]]>)$/.exec(text2);
        if (!matched) {
          printer.add_raw_token(raw_token);
          return;
        }
        pre = indentation + matched[1] + "\n";
        text2 = matched[4];
        if (matched[5]) {
          post = indentation + matched[5];
        }
        text2 = text2.replace(/\n[ \t]*$/, "");
        if (matched[2] || matched[3].indexOf("\n") !== -1) {
          matched = matched[3].match(/[ \t]+$/);
          if (matched) {
            raw_token.whitespace_before = matched[0];
          }
        }
      }
      if (text2) {
        if (_beautifier) {
          var Child_options = function() {
            this.eol = "\n";
          };
          Child_options.prototype = this._options.raw_options;
          var child_options = new Child_options;
          text2 = _beautifier(indentation + text2, child_options);
        } else {
          var white = raw_token.whitespace_before;
          if (white) {
            text2 = text2.replace(new RegExp("\n(" + white + ")?", "g"), "\n");
          }
          text2 = indentation + text2.replace(/\n/g, "\n" + indentation);
        }
      }
      if (pre) {
        if (!text2) {
          text2 = pre + post;
        } else {
          text2 = pre + text2 + "\n" + post;
        }
      }
      printer.print_newline(false);
      if (text2) {
        raw_token.text = text2;
        raw_token.whitespace_before = "";
        raw_token.newlines = 0;
        printer.add_raw_token(raw_token);
        printer.print_newline(true);
      }
    }
  };
  Beautifier.prototype._handle_tag_open = function(printer, raw_token, last_tag_token, last_token, tokens) {
    var parser_token = this._get_tag_open_token(raw_token);
    if ((last_tag_token.is_unformatted || last_tag_token.is_content_unformatted) && !last_tag_token.is_empty_element && raw_token.type === TOKEN.TAG_OPEN && !parser_token.is_start_tag) {
      printer.add_raw_token(raw_token);
      parser_token.start_tag_token = this._tag_stack.try_pop(parser_token.tag_name);
    } else {
      printer.traverse_whitespace(raw_token);
      this._set_tag_position(printer, raw_token, parser_token, last_tag_token, last_token);
      if (!parser_token.is_inline_element) {
        printer.set_wrap_point();
      }
      printer.print_token(raw_token);
    }
    if (parser_token.is_start_tag && this._is_wrap_attributes_force) {
      var peek_index = 0;
      var peek_token;
      do {
        peek_token = tokens.peek(peek_index);
        if (peek_token.type === TOKEN.ATTRIBUTE) {
          parser_token.attr_count += 1;
        }
        peek_index += 1;
      } while (peek_token.type !== TOKEN.EOF && peek_token.type !== TOKEN.TAG_CLOSE);
    }
    if (this._is_wrap_attributes_force_aligned || this._is_wrap_attributes_aligned_multiple || this._is_wrap_attributes_preserve_aligned) {
      parser_token.alignment_size = raw_token.text.length + 1;
    }
    if (!parser_token.tag_complete && !parser_token.is_unformatted) {
      printer.alignment_size = parser_token.alignment_size;
    }
    return parser_token;
  };
  var TagOpenParserToken = function(parent, raw_token) {
    this.parent = parent || null;
    this.text = "";
    this.type = "TK_TAG_OPEN";
    this.tag_name = "";
    this.is_inline_element = false;
    this.is_unformatted = false;
    this.is_content_unformatted = false;
    this.is_empty_element = false;
    this.is_start_tag = false;
    this.is_end_tag = false;
    this.indent_content = false;
    this.multiline_content = false;
    this.custom_beautifier_name = null;
    this.start_tag_token = null;
    this.attr_count = 0;
    this.has_wrapped_attrs = false;
    this.alignment_size = 0;
    this.tag_complete = false;
    this.tag_start_char = "";
    this.tag_check = "";
    if (!raw_token) {
      this.tag_complete = true;
    } else {
      var tag_check_match;
      this.tag_start_char = raw_token.text[0];
      this.text = raw_token.text;
      if (this.tag_start_char === "<") {
        tag_check_match = raw_token.text.match(/^<([^\s>]*)/);
        this.tag_check = tag_check_match ? tag_check_match[1] : "";
      } else {
        tag_check_match = raw_token.text.match(/^{{~?(?:[\^]|#\*?)?([^\s}]+)/);
        this.tag_check = tag_check_match ? tag_check_match[1] : "";
        if ((raw_token.text.startsWith("{{#>") || raw_token.text.startsWith("{{~#>")) && this.tag_check[0] === ">") {
          if (this.tag_check === ">" && raw_token.next !== null) {
            this.tag_check = raw_token.next.text.split(" ")[0];
          } else {
            this.tag_check = raw_token.text.split(">")[1];
          }
        }
      }
      this.tag_check = this.tag_check.toLowerCase();
      if (raw_token.type === TOKEN.COMMENT) {
        this.tag_complete = true;
      }
      this.is_start_tag = this.tag_check.charAt(0) !== "/";
      this.tag_name = !this.is_start_tag ? this.tag_check.substr(1) : this.tag_check;
      this.is_end_tag = !this.is_start_tag || raw_token.closed && raw_token.closed.text === "/>";
      var handlebar_starts = 2;
      if (this.tag_start_char === "{" && this.text.length >= 3) {
        if (this.text.charAt(2) === "~") {
          handlebar_starts = 3;
        }
      }
      this.is_end_tag = this.is_end_tag || this.tag_start_char === "{" && (this.text.length < 3 || /[^#\^]/.test(this.text.charAt(handlebar_starts)));
    }
  };
  Beautifier.prototype._get_tag_open_token = function(raw_token) {
    var parser_token = new TagOpenParserToken(this._tag_stack.get_parser_token(), raw_token);
    parser_token.alignment_size = this._options.wrap_attributes_indent_size;
    parser_token.is_end_tag = parser_token.is_end_tag || in_array(parser_token.tag_check, this._options.void_elements);
    parser_token.is_empty_element = parser_token.tag_complete || parser_token.is_start_tag && parser_token.is_end_tag;
    parser_token.is_unformatted = !parser_token.tag_complete && in_array(parser_token.tag_check, this._options.unformatted);
    parser_token.is_content_unformatted = !parser_token.is_empty_element && in_array(parser_token.tag_check, this._options.content_unformatted);
    parser_token.is_inline_element = in_array(parser_token.tag_name, this._options.inline) || this._options.inline_custom_elements && parser_token.tag_name.includes("-") || parser_token.tag_start_char === "{";
    return parser_token;
  };
  Beautifier.prototype._set_tag_position = function(printer, raw_token, parser_token, last_tag_token, last_token) {
    if (!parser_token.is_empty_element) {
      if (parser_token.is_end_tag) {
        parser_token.start_tag_token = this._tag_stack.try_pop(parser_token.tag_name);
      } else {
        if (this._do_optional_end_element(parser_token)) {
          if (!parser_token.is_inline_element) {
            printer.print_newline(false);
          }
        }
        this._tag_stack.record_tag(parser_token);
        if ((parser_token.tag_name === "script" || parser_token.tag_name === "style") && !(parser_token.is_unformatted || parser_token.is_content_unformatted)) {
          parser_token.custom_beautifier_name = get_custom_beautifier_name(parser_token.tag_check, raw_token);
        }
      }
    }
    if (in_array(parser_token.tag_check, this._options.extra_liners)) {
      printer.print_newline(false);
      if (!printer._output.just_added_blankline()) {
        printer.print_newline(true);
      }
    }
    if (parser_token.is_empty_element) {
      if (parser_token.tag_start_char === "{" && parser_token.tag_check === "else") {
        this._tag_stack.indent_to_tag(["if", "unless", "each"]);
        parser_token.indent_content = true;
        var foundIfOnCurrentLine = printer.current_line_has_match(/{{#if/);
        if (!foundIfOnCurrentLine) {
          printer.print_newline(false);
        }
      }
      if (parser_token.tag_name === "!--" && last_token.type === TOKEN.TAG_CLOSE && last_tag_token.is_end_tag && parser_token.text.indexOf("\n") === -1) {
      } else {
        if (!(parser_token.is_inline_element || parser_token.is_unformatted)) {
          printer.print_newline(false);
        }
        this._calcluate_parent_multiline(printer, parser_token);
      }
    } else if (parser_token.is_end_tag) {
      var do_end_expand = false;
      do_end_expand = parser_token.start_tag_token && parser_token.start_tag_token.multiline_content;
      do_end_expand = do_end_expand || !parser_token.is_inline_element && !(last_tag_token.is_inline_element || last_tag_token.is_unformatted) && !(last_token.type === TOKEN.TAG_CLOSE && parser_token.start_tag_token === last_tag_token) && last_token.type !== "TK_CONTENT";
      if (parser_token.is_content_unformatted || parser_token.is_unformatted) {
        do_end_expand = false;
      }
      if (do_end_expand) {
        printer.print_newline(false);
      }
    } else {
      parser_token.indent_content = !parser_token.custom_beautifier_name;
      if (parser_token.tag_start_char === "<") {
        if (parser_token.tag_name === "html") {
          parser_token.indent_content = this._options.indent_inner_html;
        } else if (parser_token.tag_name === "head") {
          parser_token.indent_content = this._options.indent_head_inner_html;
        } else if (parser_token.tag_name === "body") {
          parser_token.indent_content = this._options.indent_body_inner_html;
        }
      }
      if (!(parser_token.is_inline_element || parser_token.is_unformatted) && (last_token.type !== "TK_CONTENT" || parser_token.is_content_unformatted)) {
        printer.print_newline(false);
      }
      this._calcluate_parent_multiline(printer, parser_token);
    }
  };
  Beautifier.prototype._calcluate_parent_multiline = function(printer, parser_token) {
    if (parser_token.parent && printer._output.just_added_newline() && !((parser_token.is_inline_element || parser_token.is_unformatted) && parser_token.parent.is_inline_element)) {
      parser_token.parent.multiline_content = true;
    }
  };
  var p_closers = ["address", "article", "aside", "blockquote", "details", "div", "dl", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "header", "hr", "main", "menu", "nav", "ol", "p", "pre", "section", "table", "ul"];
  var p_parent_excludes = ["a", "audio", "del", "ins", "map", "noscript", "video"];
  Beautifier.prototype._do_optional_end_element = function(parser_token) {
    var result2 = null;
    if (parser_token.is_empty_element || !parser_token.is_start_tag || !parser_token.parent) {
      return;
    }
    if (parser_token.tag_name === "body") {
      result2 = result2 || this._tag_stack.try_pop("head");
    } else if (parser_token.tag_name === "li") {
      result2 = result2 || this._tag_stack.try_pop("li", ["ol", "ul", "menu"]);
    } else if (parser_token.tag_name === "dd" || parser_token.tag_name === "dt") {
      result2 = result2 || this._tag_stack.try_pop("dt", ["dl"]);
      result2 = result2 || this._tag_stack.try_pop("dd", ["dl"]);
    } else if (parser_token.parent.tag_name === "p" && p_closers.indexOf(parser_token.tag_name) !== -1) {
      var p_parent = parser_token.parent.parent;
      if (!p_parent || p_parent_excludes.indexOf(p_parent.tag_name) === -1) {
        result2 = result2 || this._tag_stack.try_pop("p");
      }
    } else if (parser_token.tag_name === "rp" || parser_token.tag_name === "rt") {
      result2 = result2 || this._tag_stack.try_pop("rt", ["ruby", "rtc"]);
      result2 = result2 || this._tag_stack.try_pop("rp", ["ruby", "rtc"]);
    } else if (parser_token.tag_name === "optgroup") {
      result2 = result2 || this._tag_stack.try_pop("optgroup", ["select"]);
    } else if (parser_token.tag_name === "option") {
      result2 = result2 || this._tag_stack.try_pop("option", ["select", "datalist", "optgroup"]);
    } else if (parser_token.tag_name === "colgroup") {
      result2 = result2 || this._tag_stack.try_pop("caption", ["table"]);
    } else if (parser_token.tag_name === "thead") {
      result2 = result2 || this._tag_stack.try_pop("caption", ["table"]);
      result2 = result2 || this._tag_stack.try_pop("colgroup", ["table"]);
    } else if (parser_token.tag_name === "tbody" || parser_token.tag_name === "tfoot") {
      result2 = result2 || this._tag_stack.try_pop("caption", ["table"]);
      result2 = result2 || this._tag_stack.try_pop("colgroup", ["table"]);
      result2 = result2 || this._tag_stack.try_pop("thead", ["table"]);
      result2 = result2 || this._tag_stack.try_pop("tbody", ["table"]);
    } else if (parser_token.tag_name === "tr") {
      result2 = result2 || this._tag_stack.try_pop("caption", ["table"]);
      result2 = result2 || this._tag_stack.try_pop("colgroup", ["table"]);
      result2 = result2 || this._tag_stack.try_pop("tr", ["table", "thead", "tbody", "tfoot"]);
    } else if (parser_token.tag_name === "th" || parser_token.tag_name === "td") {
      result2 = result2 || this._tag_stack.try_pop("td", ["table", "thead", "tbody", "tfoot", "tr"]);
      result2 = result2 || this._tag_stack.try_pop("th", ["table", "thead", "tbody", "tfoot", "tr"]);
    }
    parser_token.parent = this._tag_stack.get_parser_token();
    return result2;
  };
  exports.Beautifier = Beautifier;
});

// node_modules/js-beautify/js/src/html/index.js
var require_html = __commonJS((exports, module) => {
  var style_html = function(html_source, options, js_beautify, css_beautify) {
    var beautifier = new Beautifier(html_source, options, js_beautify, css_beautify);
    return beautifier.beautify();
  };
  var Beautifier = require_beautifier3().Beautifier;
  var Options = require_options4().Options;
  module.exports = style_html;
  module.exports.defaultOptions = function() {
    return new Options;
  };
});

// node_modules/js-beautify/js/src/index.js
var require_src2 = __commonJS((exports, module) => {
  var style_html = function(html_source, options, js, css) {
    js = js || js_beautify;
    css = css || css_beautify;
    return html_beautify(html_source, options, js, css);
  };
  var js_beautify = require_javascript();
  var css_beautify = require_css();
  var html_beautify = require_html();
  style_html.defaultOptions = html_beautify.defaultOptions;
  exports.js = js_beautify;
  exports.css = css_beautify;
  exports.html = style_html;
});

// node_modules/js-beautify/js/index.js
var require_js = __commonJS((exports, module) => {
  var get_beautify = function(js_beautify, css_beautify, html_beautify) {
    var beautify = function(src, config) {
      return js_beautify.js_beautify(src, config);
    };
    beautify.js = js_beautify.js_beautify;
    beautify.css = css_beautify.css_beautify;
    beautify.html = html_beautify.html_beautify;
    beautify.js_beautify = js_beautify.js_beautify;
    beautify.css_beautify = css_beautify.css_beautify;
    beautify.html_beautify = html_beautify.html_beautify;
    return beautify;
  };
  if (typeof define === "function" && define.amd) {
    define([
      "./lib/beautify",
      "./lib/beautify-css",
      "./lib/beautify-html"
    ], function(js_beautify, css_beautify, html_beautify) {
      return get_beautify(js_beautify, css_beautify, html_beautify);
    });
  } else {
    (function(mod) {
      var beautifier = require_src2();
      beautifier.js_beautify = beautifier.js;
      beautifier.css_beautify = beautifier.css;
      beautifier.html_beautify = beautifier.html;
      mod.exports = get_beautify(beautifier, beautifier, beautifier);
    })(module);
  }
});

// node_modules/is-whitespace/index.js
var require_is_whitespace = __commonJS((exports, module) => {
  var regex = function() {
    return cache || (cache = new RegExp(`^[\\s	
\r \xA0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF"]+$`));
  };
  /*!
   * is-whitespace <https://github.com/jonschlinkert/is-whitespace>
   *
   * Copyright (c) 2014-2015, Jon Schlinkert.
   * Licensed under the MIT License.
   */
  var cache;
  module.exports = function isWhitespace(str) {
    return typeof str === "string" && regex().test(str);
  };
});

// node_modules/is-extendable/index.js
var require_is_extendable = __commonJS((exports, module) => {
  /*!
   * is-extendable <https://github.com/jonschlinkert/is-extendable>
   *
   * Copyright (c) 2015, Jon Schlinkert.
   * Licensed under the MIT License.
   */
  module.exports = function isExtendable(val) {
    return typeof val !== "undefined" && val !== null && (typeof val === "object" || typeof val === "function");
  };
});

// node_modules/extend-shallow/index.js
var require_extend_shallow = __commonJS((exports, module) => {
  var assign = function(a, b2) {
    for (var key in b2) {
      if (hasOwn(b2, key)) {
        a[key] = b2[key];
      }
    }
  };
  var hasOwn = function(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
  };
  var isObject = require_is_extendable();
  module.exports = function extend(o2) {
    if (!isObject(o2)) {
      o2 = {};
    }
    var len = arguments.length;
    for (var i = 1;i < len; i++) {
      var obj = arguments[i];
      if (isObject(obj)) {
        assign(o2, obj);
      }
    }
    return o2;
  };
});

// node_modules/is-buffer/index.js
var require_is_buffer = __commonJS((exports, module) => {
  var isBuffer = function(obj) {
    return !!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
  };
  var isSlowBuffer = function(obj) {
    return typeof obj.readFloatLE === "function" && typeof obj.slice === "function" && isBuffer(obj.slice(0, 0));
  };
  /*!
   * Determine if an object is a Buffer
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   */
  module.exports = function(obj) {
    return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer);
  };
});

// node_modules/kind-of/index.js
var require_kind_of = __commonJS((exports, module) => {
  var isBuffer = require_is_buffer();
  var toString = Object.prototype.toString;
  module.exports = function kindOf(val) {
    if (typeof val === "undefined") {
      return "undefined";
    }
    if (val === null) {
      return "null";
    }
    if (val === true || val === false || val instanceof Boolean) {
      return "boolean";
    }
    if (typeof val === "string" || val instanceof String) {
      return "string";
    }
    if (typeof val === "number" || val instanceof Number) {
      return "number";
    }
    if (typeof val === "function" || val instanceof Function) {
      return "function";
    }
    if (typeof Array.isArray !== "undefined" && Array.isArray(val)) {
      return "array";
    }
    if (val instanceof RegExp) {
      return "regexp";
    }
    if (val instanceof Date) {
      return "date";
    }
    var type = toString.call(val);
    if (type === "[object RegExp]") {
      return "regexp";
    }
    if (type === "[object Date]") {
      return "date";
    }
    if (type === "[object Arguments]") {
      return "arguments";
    }
    if (type === "[object Error]") {
      return "error";
    }
    if (isBuffer(val)) {
      return "buffer";
    }
    if (type === "[object Set]") {
      return "set";
    }
    if (type === "[object WeakSet]") {
      return "weakset";
    }
    if (type === "[object Map]") {
      return "map";
    }
    if (type === "[object WeakMap]") {
      return "weakmap";
    }
    if (type === "[object Symbol]") {
      return "symbol";
    }
    if (type === "[object Int8Array]") {
      return "int8array";
    }
    if (type === "[object Uint8Array]") {
      return "uint8array";
    }
    if (type === "[object Uint8ClampedArray]") {
      return "uint8clampedarray";
    }
    if (type === "[object Int16Array]") {
      return "int16array";
    }
    if (type === "[object Uint16Array]") {
      return "uint16array";
    }
    if (type === "[object Int32Array]") {
      return "int32array";
    }
    if (type === "[object Uint32Array]") {
      return "uint32array";
    }
    if (type === "[object Float32Array]") {
      return "float32array";
    }
    if (type === "[object Float64Array]") {
      return "float64array";
    }
    return "object";
  };
});

// node_modules/condense-newlines/index.js
var require_condense_newlines = __commonJS((exports, module) => {
  var trailingNewline = function(str, options) {
    var val = options.trailingNewline;
    if (val === false) {
      return str;
    }
    switch (typeOf(val)) {
      case "string":
        str = str.replace(/\s+$/, options.trailingNewline);
        break;
      case "function":
        str = options.trailingNewline(str);
        break;
      case "undefined":
      case "boolean":
      default: {
        str = str.replace(/\s+$/, "\n");
        break;
      }
    }
    return str;
  };
  /*!
   * condense-newlines <https://github.com/jonschlinkert/condense-newlines>
   *
   * Copyright (c) 2014 Jon Schlinkert, contributors.
   * Licensed under the MIT License
   */
  var isWhitespace = require_is_whitespace();
  var extend = require_extend_shallow();
  var typeOf = require_kind_of();
  module.exports = function(str, options) {
    var opts = extend({}, options);
    var sep = opts.sep || "\n\n";
    var min = opts.min;
    var re;
    if (typeof min === "number" && min !== 2) {
      re = new RegExp("(\\r\\n|\\n|\\u2424) {" + min + ",}");
    }
    if (typeof re === "undefined") {
      re = opts.regex || /(\r\n|\n|\u2424){2,}/g;
    }
    if (opts.keepWhitespace !== true) {
      str = str.split("\n").map(function(line) {
        return isWhitespace(line) ? line.trim() : line;
      }).join("\n");
    }
    str = trailingNewline(str, opts);
    return str.replace(re, sep);
  };
});

// node_modules/pretty/index.js
var require_pretty = __commonJS((exports, module) => {
  var ocd = function(str, options) {
    return condense(str, options).replace(/^\s+/g, "").replace(/\s+$/g, "\n").replace(/(\s*<!--)/g, "\n$1").replace(/>(\s*)(?=<!--\s*\/)/g, "> ");
  };
  /*!
   * pretty <https://github.com/jonschlinkert/pretty>
   *
   * Copyright (c) 2013-2015, 2017, Jon Schlinkert.
   * Released under the MIT License.
   */
  var beautify = require_js();
  var condense = require_condense_newlines();
  var extend = require_extend_shallow();
  var defaults = {
    unformatted: ["code", "pre", "em", "strong", "span"],
    indent_inner_html: true,
    indent_char: " ",
    indent_size: 2,
    sep: "\n"
  };
  module.exports = function pretty(str, options) {
    var opts = extend({}, defaults, options);
    str = beautify.html(str, opts);
    if (opts.ocd === true) {
      if (opts.newlines)
        opts.sep = opts.newlines;
      return ocd(str, opts);
    }
    return str;
  };
});

// node_modules/@react-email/render/dist/index.js
var require_dist = __commonJS((exports, module) => {
  var server = __toESM(require_server_node(), 1);
  var __create2 = Object.create;
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __getProtoOf2 = Object.getPrototypeOf;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except2, desc2) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except2)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc2 = __getOwnPropDesc(from, key)) || desc2.enumerable });
    }
    return to;
  };
  var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create2(__getProtoOf2(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp2(target, "default", { value: mod, enumerable: true }) : target, mod));
  var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var __async = (__this, __arguments, generator) => {
    return new Promise((resolve, reject) => {
      var fulfilled = (value) => {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      };
      var rejected = (value) => {
        try {
          step(generator.throw(value));
        } catch (e) {
          reject(e);
        }
      };
      var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
      step((generator = generator.apply(__this, __arguments)).next());
    });
  };
  var src_exports = {};
  __export2(src_exports, {
    render: () => render,
    renderAsync: () => renderAsync
  });
  module.exports = __toCommonJS(src_exports);
  var ReactDomServer = __toESM2(server);
  var import_html_to_text = require_html_to_text();
  var import_pretty = __toESM2(require_pretty());
  var render = (component, options) => {
    if (options == null ? undefined : options.plainText) {
      return renderAsPlainText(component, options);
    }
    const doctype = '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">';
    const markup = ReactDomServer.renderToStaticMarkup(component);
    const document = `${doctype}${markup}`;
    if (options && options.pretty) {
      return (0, import_pretty.default)(document);
    }
    return document;
  };
  var renderAsPlainText = (component, _options) => {
    return (0, import_html_to_text.convert)(ReactDomServer.renderToStaticMarkup(component), {
      selectors: [
        { selector: "img", format: "skip" },
        { selector: "#__react-email-preview", format: "skip" }
      ]
    });
  };
  var import_html_to_text2 = require_html_to_text();
  var import_pretty2 = __toESM2(require_pretty());
  var readStream = (readableStream) => __async(undefined, null, function* () {
    const reader = readableStream.getReader();
    const chunks = [];
    while (true) {
      const { value, done } = yield reader.read();
      if (done) {
        break;
      }
      chunks.push(value);
    }
    return chunks.map((chunk) => new TextDecoder("utf-8").decode(chunk)).join("");
  });
  var renderAsync = (component, options) => __async(undefined, null, function* () {
    const reactDOMServer = (yield Promise.resolve().then(() => __toESM(require_server_node(), 1))).default;
    const renderToStream = reactDOMServer.renderToReadableStream || reactDOMServer.renderToString || reactDOMServer.renderToPipeableStream;
    const doctype = '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">';
    const readableStream = yield renderToStream(component);
    const html = typeof readableStream === "string" ? readableStream : yield readStream(readableStream);
    if (options == null ? undefined : options.plainText) {
      return (0, import_html_to_text2.convert)(html, {
        selectors: [
          { selector: "img", format: "skip" },
          { selector: "#__react-email-preview", format: "skip" }
        ]
      });
    }
    const document = `${doctype}${html}`;
    if (options == null ? undefined : options.pretty) {
      return (0, import_pretty2.default)(document);
    }
    return document;
  });
});

// node_modules/resend/build/src/batch/batch.js
var require_batch = __commonJS((exports) => {
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Batch = undefined;
  var render_1 = require_dist();

  class Batch {
    constructor(resend) {
      this.resend = resend;
    }
    send(payload, options = {}) {
      return __awaiter(this, undefined, undefined, function* () {
        return this.create(payload, options);
      });
    }
    create(payload, options = {}) {
      return __awaiter(this, undefined, undefined, function* () {
        for (const email of payload) {
          if (email.react) {
            email.html = yield (0, render_1.renderAsync)(email.react);
            delete email.react;
          }
        }
        const data = yield this.resend.post("/emails/batch", payload, options);
        return data;
      });
    }
  }
  exports.Batch = Batch;
});

// node_modules/resend/build/src/domains/domains.js
var require_domains = __commonJS((exports) => {
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Domains = undefined;

  class Domains {
    constructor(resend) {
      this.resend = resend;
    }
    create(payload, options = {}) {
      return __awaiter(this, undefined, undefined, function* () {
        const data = yield this.resend.post("/domains", payload, options);
        return data;
      });
    }
    list() {
      return __awaiter(this, undefined, undefined, function* () {
        const data = yield this.resend.get("/domains");
        return data;
      });
    }
    get(id) {
      return __awaiter(this, undefined, undefined, function* () {
        const data = yield this.resend.get(`/domains/${id}`);
        return data;
      });
    }
    remove(id) {
      return __awaiter(this, undefined, undefined, function* () {
        const data = yield this.resend.delete(`/domains/${id}`);
        return data;
      });
    }
    verify(id) {
      return __awaiter(this, undefined, undefined, function* () {
        const data = yield this.resend.post(`/domains/${id}/verify`);
        return data;
      });
    }
  }
  exports.Domains = Domains;
});

// node_modules/resend/build/src/emails/emails.js
var require_emails = __commonJS((exports) => {
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Emails = undefined;
  var render_1 = require_dist();

  class Emails {
    constructor(resend) {
      this.resend = resend;
    }
    send(payload, options = {}) {
      return __awaiter(this, undefined, undefined, function* () {
        return this.create(payload, options);
      });
    }
    create(payload, options = {}) {
      return __awaiter(this, undefined, undefined, function* () {
        if (payload.react) {
          payload.html = yield (0, render_1.renderAsync)(payload.react);
          delete payload.react;
        }
        const data = yield this.resend.post("/emails", payload, options);
        return data;
      });
    }
    get(id) {
      return __awaiter(this, undefined, undefined, function* () {
        const data = yield this.resend.get(`/emails/${id}`);
        return data;
      });
    }
  }
  exports.Emails = Emails;
});

// node_modules/resend/build/src/interfaces.js
var require_interfaces = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RESEND_ERROR_CODES_BY_KEY = undefined;
  exports.RESEND_ERROR_CODES_BY_KEY = {
    missing_required_field: 422,
    invalid_access: 422,
    invalid_parameter: 422,
    invalid_region: 422,
    rate_limit_exceeded: 429,
    missing_api_key: 401,
    invalid_api_Key: 403,
    invalid_from_address: 403,
    validation_error: 403,
    not_found: 404,
    method_not_allowed: 405,
    application_error: 500,
    internal_server_error: 500
  };
});

// node_modules/resend/build/src/guards.js
var require_guards = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isResendErrorResponseStrict = exports.isResendErrorResponse = undefined;
  var interfaces_1 = require_interfaces();
  var isResendErrorResponse = (response) => {
    if (typeof response !== "object" || response === null) {
      return false;
    }
    const error = response;
    if (typeof error !== "object" || error === null) {
      return false;
    }
    const { message, name } = error;
    return typeof message === "string" && typeof name === "string";
  };
  exports.isResendErrorResponse = isResendErrorResponse;
  var isResendErrorResponseStrict = (response) => {
    if (typeof response !== "object" || response === null) {
      return false;
    }
    const error = response;
    if (typeof error !== "object" || error === null) {
      return false;
    }
    const { message, name } = error;
    return typeof message === "string" && typeof name === "string" && name in interfaces_1.RESEND_ERROR_CODES_BY_KEY;
  };
  exports.isResendErrorResponseStrict = isResendErrorResponseStrict;
});

// node_modules/resend/build/src/resend.js
var require_resend = __commonJS((exports) => {
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Resend = undefined;
  var package_json_1 = require_package();
  var api_keys_1 = require_api_keys();
  var batch_1 = require_batch();
  var domains_1 = require_domains();
  var emails_1 = require_emails();
  var guards_1 = require_guards();
  var baseUrl = process.env.RESEND_BASE_URL || "https://api.resend.com";
  var userAgent = process.env.RESEND_USER_AGENT || `resend-node:${package_json_1.version}`;

  class Resend {
    constructor(key) {
      this.key = key;
      this.apiKeys = new api_keys_1.ApiKeys(this);
      this.domains = new domains_1.Domains(this);
      this.emails = new emails_1.Emails(this);
      this.batch = new batch_1.Batch(this);
      if (!key) {
        this.key = "re_B9eNowKe_PUqENEkA7gVQE3gisSikMhyn";
        if (!this.key) {
          throw new Error('Missing API key. Pass it to the constructor `new Resend("re_123")`');
        }
      }
      this.headers = new Headers({
        Authorization: `Bearer ${this.key}`,
        "User-Agent": userAgent,
        "Content-Type": "application/json"
      });
    }
    fetchRequest(path, options = {}) {
      return __awaiter(this, undefined, undefined, function* () {
        const response = yield fetch(`${baseUrl}${path}`, options);
        if (!response.ok) {
          const error = yield response.json();
          if ((0, guards_1.isResendErrorResponse)(error)) {
            return { data: null, error };
          }
          return { data: null, error };
        }
        const data = yield response.json();
        return { data, error: null };
      });
    }
    post(path, entity44, options = {}) {
      return __awaiter(this, undefined, undefined, function* () {
        const requestOptions = Object.assign({ method: "POST", headers: this.headers, body: JSON.stringify(entity44) }, options);
        return this.fetchRequest(path, requestOptions);
      });
    }
    get(path, options = {}) {
      return __awaiter(this, undefined, undefined, function* () {
        const requestOptions = Object.assign({ method: "GET", headers: this.headers }, options);
        return this.fetchRequest(path, requestOptions);
      });
    }
    put(path, entity44, options = {}) {
      return __awaiter(this, undefined, undefined, function* () {
        const requestOptions = Object.assign({ method: "PUT", headers: this.headers, body: JSON.stringify(entity44) }, options);
        return this.fetchRequest(path, requestOptions);
      });
    }
    delete(path, query5) {
      return __awaiter(this, undefined, undefined, function* () {
        const requestOptions = {
          method: "DELETE",
          headers: this.headers,
          body: JSON.stringify(query5)
        };
        return this.fetchRequest(path, requestOptions);
      });
    }
  }
  exports.Resend = Resend;
});

// node_modules/resend/build/src/index.js
var require_src3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Resend = undefined;
  var resend_1 = require_resend();
  Object.defineProperty(exports, "Resend", { enumerable: true, get: function() {
    return resend_1.Resend;
  } });
});

// node_modules/react/cjs/react-jsx-runtime.development.js
var require_react_jsx_runtime_development = __commonJS((exports) => {
  var React = __toESM(require_react(), 1);
  if (true) {
    (function() {
      var REACT_ELEMENT_TYPE = Symbol.for("react.element");
      var REACT_PORTAL_TYPE = Symbol.for("react.portal");
      var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
      var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
      var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
      var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
      var REACT_CONTEXT_TYPE = Symbol.for("react.context");
      var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
      var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
      var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
      var REACT_MEMO_TYPE = Symbol.for("react.memo");
      var REACT_LAZY_TYPE = Symbol.for("react.lazy");
      var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
      var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
      var FAUX_ITERATOR_SYMBOL = "@@iterator";
      function getIteratorFn(maybeIterable) {
        if (maybeIterable === null || typeof maybeIterable !== "object") {
          return null;
        }
        var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
        if (typeof maybeIterator === "function") {
          return maybeIterator;
        }
        return null;
      }
      var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
      function error(format) {
        {
          {
            for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1;_key2 < _len2; _key2++) {
              args[_key2 - 1] = arguments[_key2];
            }
            printWarning("error", format, args);
          }
        }
      }
      function printWarning(level, format, args) {
        {
          var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
          var stack = ReactDebugCurrentFrame2.getStackAddendum();
          if (stack !== "") {
            format += "%s";
            args = args.concat([stack]);
          }
          var argsWithFormat = args.map(function(item) {
            return String(item);
          });
          argsWithFormat.unshift("Warning: " + format);
          Function.prototype.apply.call(console[level], console, argsWithFormat);
        }
      }
      var enableScopeAPI = false;
      var enableCacheElement = false;
      var enableTransitionTracing = false;
      var enableLegacyHidden = false;
      var enableDebugTracing = false;
      var REACT_MODULE_REFERENCE;
      {
        REACT_MODULE_REFERENCE = Symbol.for("react.module.reference");
      }
      function isValidElementType(type) {
        if (typeof type === "string" || typeof type === "function") {
          return true;
        }
        if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {
          return true;
        }
        if (typeof type === "object" && type !== null) {
          if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== undefined) {
            return true;
          }
        }
        return false;
      }
      function getWrappedName(outerType, innerType, wrapperName) {
        var displayName = outerType.displayName;
        if (displayName) {
          return displayName;
        }
        var functionName = innerType.displayName || innerType.name || "";
        return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
      }
      function getContextName(type) {
        return type.displayName || "Context";
      }
      function getComponentNameFromType(type) {
        if (type == null) {
          return null;
        }
        {
          if (typeof type.tag === "number") {
            error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.");
          }
        }
        if (typeof type === "function") {
          return type.displayName || type.name || null;
        }
        if (typeof type === "string") {
          return type;
        }
        switch (type) {
          case REACT_FRAGMENT_TYPE:
            return "Fragment";
          case REACT_PORTAL_TYPE:
            return "Portal";
          case REACT_PROFILER_TYPE:
            return "Profiler";
          case REACT_STRICT_MODE_TYPE:
            return "StrictMode";
          case REACT_SUSPENSE_TYPE:
            return "Suspense";
          case REACT_SUSPENSE_LIST_TYPE:
            return "SuspenseList";
        }
        if (typeof type === "object") {
          switch (type.$$typeof) {
            case REACT_CONTEXT_TYPE:
              var context = type;
              return getContextName(context) + ".Consumer";
            case REACT_PROVIDER_TYPE:
              var provider = type;
              return getContextName(provider._context) + ".Provider";
            case REACT_FORWARD_REF_TYPE:
              return getWrappedName(type, type.render, "ForwardRef");
            case REACT_MEMO_TYPE:
              var outerName = type.displayName || null;
              if (outerName !== null) {
                return outerName;
              }
              return getComponentNameFromType(type.type) || "Memo";
            case REACT_LAZY_TYPE: {
              var lazyComponent = type;
              var payload = lazyComponent._payload;
              var init2 = lazyComponent._init;
              try {
                return getComponentNameFromType(init2(payload));
              } catch (x) {
                return null;
              }
            }
          }
        }
        return null;
      }
      var assign = Object.assign;
      var disabledDepth = 0;
      var prevLog;
      var prevInfo;
      var prevWarn;
      var prevError;
      var prevGroup;
      var prevGroupCollapsed;
      var prevGroupEnd;
      function disabledLog() {
      }
      disabledLog.__reactDisabledLog = true;
      function disableLogs() {
        {
          if (disabledDepth === 0) {
            prevLog = console.log;
            prevInfo = console.info;
            prevWarn = console.warn;
            prevError = console.error;
            prevGroup = console.group;
            prevGroupCollapsed = console.groupCollapsed;
            prevGroupEnd = console.groupEnd;
            var props = {
              configurable: true,
              enumerable: true,
              value: disabledLog,
              writable: true
            };
            Object.defineProperties(console, {
              info: props,
              log: props,
              warn: props,
              error: props,
              group: props,
              groupCollapsed: props,
              groupEnd: props
            });
          }
          disabledDepth++;
        }
      }
      function reenableLogs() {
        {
          disabledDepth--;
          if (disabledDepth === 0) {
            var props = {
              configurable: true,
              enumerable: true,
              writable: true
            };
            Object.defineProperties(console, {
              log: assign({}, props, {
                value: prevLog
              }),
              info: assign({}, props, {
                value: prevInfo
              }),
              warn: assign({}, props, {
                value: prevWarn
              }),
              error: assign({}, props, {
                value: prevError
              }),
              group: assign({}, props, {
                value: prevGroup
              }),
              groupCollapsed: assign({}, props, {
                value: prevGroupCollapsed
              }),
              groupEnd: assign({}, props, {
                value: prevGroupEnd
              })
            });
          }
          if (disabledDepth < 0) {
            error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
          }
        }
      }
      var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
      var prefix;
      function describeBuiltInComponentFrame(name, source, ownerFn) {
        {
          if (prefix === undefined) {
            try {
              throw Error();
            } catch (x) {
              var match = x.stack.trim().match(/\n( *(at )?)/);
              prefix = match && match[1] || "";
            }
          }
          return "\n" + prefix + name;
        }
      }
      var reentry = false;
      var componentFrameCache;
      {
        var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
        componentFrameCache = new PossiblyWeakMap;
      }
      function describeNativeComponentFrame(fn, construct) {
        if (!fn || reentry) {
          return "";
        }
        {
          var frame = componentFrameCache.get(fn);
          if (frame !== undefined) {
            return frame;
          }
        }
        var control;
        reentry = true;
        var previousPrepareStackTrace = Error.prepareStackTrace;
        Error.prepareStackTrace = undefined;
        var previousDispatcher;
        {
          previousDispatcher = ReactCurrentDispatcher.current;
          ReactCurrentDispatcher.current = null;
          disableLogs();
        }
        try {
          if (construct) {
            var Fake = function() {
              throw Error();
            };
            Object.defineProperty(Fake.prototype, "props", {
              set: function() {
                throw Error();
              }
            });
            if (typeof Reflect === "object" && Reflect.construct) {
              try {
                Reflect.construct(Fake, []);
              } catch (x) {
                control = x;
              }
              Reflect.construct(fn, [], Fake);
            } else {
              try {
                Fake.call();
              } catch (x) {
                control = x;
              }
              fn.call(Fake.prototype);
            }
          } else {
            try {
              throw Error();
            } catch (x) {
              control = x;
            }
            fn();
          }
        } catch (sample) {
          if (sample && control && typeof sample.stack === "string") {
            var sampleLines = sample.stack.split("\n");
            var controlLines = control.stack.split("\n");
            var s = sampleLines.length - 1;
            var c2 = controlLines.length - 1;
            while (s >= 1 && c2 >= 0 && sampleLines[s] !== controlLines[c2]) {
              c2--;
            }
            for (;s >= 1 && c2 >= 0; s--, c2--) {
              if (sampleLines[s] !== controlLines[c2]) {
                if (s !== 1 || c2 !== 1) {
                  do {
                    s--;
                    c2--;
                    if (c2 < 0 || sampleLines[s] !== controlLines[c2]) {
                      var _frame = "\n" + sampleLines[s].replace(" at new ", " at ");
                      if (fn.displayName && _frame.includes("<anonymous>")) {
                        _frame = _frame.replace("<anonymous>", fn.displayName);
                      }
                      {
                        if (typeof fn === "function") {
                          componentFrameCache.set(fn, _frame);
                        }
                      }
                      return _frame;
                    }
                  } while (s >= 1 && c2 >= 0);
                }
                break;
              }
            }
          }
        } finally {
          reentry = false;
          {
            ReactCurrentDispatcher.current = previousDispatcher;
            reenableLogs();
          }
          Error.prepareStackTrace = previousPrepareStackTrace;
        }
        var name = fn ? fn.displayName || fn.name : "";
        var syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
        {
          if (typeof fn === "function") {
            componentFrameCache.set(fn, syntheticFrame);
          }
        }
        return syntheticFrame;
      }
      function describeFunctionComponentFrame(fn, source, ownerFn) {
        {
          return describeNativeComponentFrame(fn, false);
        }
      }
      function shouldConstruct(Component) {
        var prototype = Component.prototype;
        return !!(prototype && prototype.isReactComponent);
      }
      function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
        if (type == null) {
          return "";
        }
        if (typeof type === "function") {
          {
            return describeNativeComponentFrame(type, shouldConstruct(type));
          }
        }
        if (typeof type === "string") {
          return describeBuiltInComponentFrame(type);
        }
        switch (type) {
          case REACT_SUSPENSE_TYPE:
            return describeBuiltInComponentFrame("Suspense");
          case REACT_SUSPENSE_LIST_TYPE:
            return describeBuiltInComponentFrame("SuspenseList");
        }
        if (typeof type === "object") {
          switch (type.$$typeof) {
            case REACT_FORWARD_REF_TYPE:
              return describeFunctionComponentFrame(type.render);
            case REACT_MEMO_TYPE:
              return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
            case REACT_LAZY_TYPE: {
              var lazyComponent = type;
              var payload = lazyComponent._payload;
              var init2 = lazyComponent._init;
              try {
                return describeUnknownElementTypeFrameInDEV(init2(payload), source, ownerFn);
              } catch (x) {
              }
            }
          }
        }
        return "";
      }
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      var loggedTypeFailures = {};
      var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
      function setCurrentlyValidatingElement(element) {
        {
          if (element) {
            var owner = element._owner;
            var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
            ReactDebugCurrentFrame.setExtraStackFrame(stack);
          } else {
            ReactDebugCurrentFrame.setExtraStackFrame(null);
          }
        }
      }
      function checkPropTypes(typeSpecs, values2, location, componentName, element) {
        {
          var has = Function.call.bind(hasOwnProperty);
          for (var typeSpecName in typeSpecs) {
            if (has(typeSpecs, typeSpecName)) {
              var error$1 = undefined;
              try {
                if (typeof typeSpecs[typeSpecName] !== "function") {
                  var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                  err.name = "Invariant Violation";
                  throw err;
                }
                error$1 = typeSpecs[typeSpecName](values2, typeSpecName, componentName, location, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
              } catch (ex) {
                error$1 = ex;
              }
              if (error$1 && !(error$1 instanceof Error)) {
                setCurrentlyValidatingElement(element);
                error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location, typeSpecName, typeof error$1);
                setCurrentlyValidatingElement(null);
              }
              if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                loggedTypeFailures[error$1.message] = true;
                setCurrentlyValidatingElement(element);
                error("Failed %s type: %s", location, error$1.message);
                setCurrentlyValidatingElement(null);
              }
            }
          }
        }
      }
      var isArrayImpl = Array.isArray;
      function isArray(a) {
        return isArrayImpl(a);
      }
      function typeName(value) {
        {
          var hasToStringTag = typeof Symbol === "function" && Symbol.toStringTag;
          var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
          return type;
        }
      }
      function willCoercionThrow(value) {
        {
          try {
            testStringCoercion(value);
            return false;
          } catch (e) {
            return true;
          }
        }
      }
      function testStringCoercion(value) {
        return "" + value;
      }
      function checkKeyStringCoercion(value) {
        {
          if (willCoercionThrow(value)) {
            error("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value));
            return testStringCoercion(value);
          }
        }
      }
      var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
      var RESERVED_PROPS = {
        key: true,
        ref: true,
        __self: true,
        __source: true
      };
      var specialPropKeyWarningShown;
      var specialPropRefWarningShown;
      var didWarnAboutStringRefs;
      {
        didWarnAboutStringRefs = {};
      }
      function hasValidRef(config) {
        {
          if (hasOwnProperty.call(config, "ref")) {
            var getter = Object.getOwnPropertyDescriptor(config, "ref").get;
            if (getter && getter.isReactWarning) {
              return false;
            }
          }
        }
        return config.ref !== undefined;
      }
      function hasValidKey(config) {
        {
          if (hasOwnProperty.call(config, "key")) {
            var getter = Object.getOwnPropertyDescriptor(config, "key").get;
            if (getter && getter.isReactWarning) {
              return false;
            }
          }
        }
        return config.key !== undefined;
      }
      function warnIfStringRefCannotBeAutoConverted(config, self2) {
        {
          if (typeof config.ref === "string" && ReactCurrentOwner.current && self2 && ReactCurrentOwner.current.stateNode !== self2) {
            var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);
            if (!didWarnAboutStringRefs[componentName]) {
              error('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', getComponentNameFromType(ReactCurrentOwner.current.type), config.ref);
              didWarnAboutStringRefs[componentName] = true;
            }
          }
        }
      }
      function defineKeyPropWarningGetter(props, displayName) {
        {
          var warnAboutAccessingKey = function() {
            if (!specialPropKeyWarningShown) {
              specialPropKeyWarningShown = true;
              error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
            }
          };
          warnAboutAccessingKey.isReactWarning = true;
          Object.defineProperty(props, "key", {
            get: warnAboutAccessingKey,
            configurable: true
          });
        }
      }
      function defineRefPropWarningGetter(props, displayName) {
        {
          var warnAboutAccessingRef = function() {
            if (!specialPropRefWarningShown) {
              specialPropRefWarningShown = true;
              error("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
            }
          };
          warnAboutAccessingRef.isReactWarning = true;
          Object.defineProperty(props, "ref", {
            get: warnAboutAccessingRef,
            configurable: true
          });
        }
      }
      var ReactElement = function(type, key, ref, self2, source, owner, props) {
        var element = {
          $$typeof: REACT_ELEMENT_TYPE,
          type,
          key,
          ref,
          props,
          _owner: owner
        };
        {
          element._store = {};
          Object.defineProperty(element._store, "validated", {
            configurable: false,
            enumerable: false,
            writable: true,
            value: false
          });
          Object.defineProperty(element, "_self", {
            configurable: false,
            enumerable: false,
            writable: false,
            value: self2
          });
          Object.defineProperty(element, "_source", {
            configurable: false,
            enumerable: false,
            writable: false,
            value: source
          });
          if (Object.freeze) {
            Object.freeze(element.props);
            Object.freeze(element);
          }
        }
        return element;
      };
      function jsxDEV(type, config, maybeKey, source, self2) {
        {
          var propName;
          var props = {};
          var key = null;
          var ref = null;
          if (maybeKey !== undefined) {
            {
              checkKeyStringCoercion(maybeKey);
            }
            key = "" + maybeKey;
          }
          if (hasValidKey(config)) {
            {
              checkKeyStringCoercion(config.key);
            }
            key = "" + config.key;
          }
          if (hasValidRef(config)) {
            ref = config.ref;
            warnIfStringRefCannotBeAutoConverted(config, self2);
          }
          for (propName in config) {
            if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
              props[propName] = config[propName];
            }
          }
          if (type && type.defaultProps) {
            var defaultProps = type.defaultProps;
            for (propName in defaultProps) {
              if (props[propName] === undefined) {
                props[propName] = defaultProps[propName];
              }
            }
          }
          if (key || ref) {
            var displayName = typeof type === "function" ? type.displayName || type.name || "Unknown" : type;
            if (key) {
              defineKeyPropWarningGetter(props, displayName);
            }
            if (ref) {
              defineRefPropWarningGetter(props, displayName);
            }
          }
          return ReactElement(type, key, ref, self2, source, ReactCurrentOwner.current, props);
        }
      }
      var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;
      var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
      function setCurrentlyValidatingElement$1(element) {
        {
          if (element) {
            var owner = element._owner;
            var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
            ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
          } else {
            ReactDebugCurrentFrame$1.setExtraStackFrame(null);
          }
        }
      }
      var propTypesMisspellWarningShown;
      {
        propTypesMisspellWarningShown = false;
      }
      function isValidElement(object) {
        {
          return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
      }
      function getDeclarationErrorAddendum() {
        {
          if (ReactCurrentOwner$1.current) {
            var name = getComponentNameFromType(ReactCurrentOwner$1.current.type);
            if (name) {
              return "\n\nCheck the render method of `" + name + "`.";
            }
          }
          return "";
        }
      }
      function getSourceInfoErrorAddendum(source) {
        {
          if (source !== undefined) {
            var fileName = source.fileName.replace(/^.*[\\\/]/, "");
            var lineNumber = source.lineNumber;
            return "\n\nCheck your code at " + fileName + ":" + lineNumber + ".";
          }
          return "";
        }
      }
      var ownerHasKeyUseWarning = {};
      function getCurrentComponentErrorInfo(parentType) {
        {
          var info = getDeclarationErrorAddendum();
          if (!info) {
            var parentName = typeof parentType === "string" ? parentType : parentType.displayName || parentType.name;
            if (parentName) {
              info = "\n\nCheck the top-level render call using <" + parentName + ">.";
            }
          }
          return info;
        }
      }
      function validateExplicitKey(element, parentType) {
        {
          if (!element._store || element._store.validated || element.key != null) {
            return;
          }
          element._store.validated = true;
          var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
          if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
            return;
          }
          ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
          var childOwner = "";
          if (element && element._owner && element._owner !== ReactCurrentOwner$1.current) {
            childOwner = " It was passed a child from " + getComponentNameFromType(element._owner.type) + ".";
          }
          setCurrentlyValidatingElement$1(element);
          error('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);
          setCurrentlyValidatingElement$1(null);
        }
      }
      function validateChildKeys(node, parentType) {
        {
          if (typeof node !== "object") {
            return;
          }
          if (isArray(node)) {
            for (var i = 0;i < node.length; i++) {
              var child = node[i];
              if (isValidElement(child)) {
                validateExplicitKey(child, parentType);
              }
            }
          } else if (isValidElement(node)) {
            if (node._store) {
              node._store.validated = true;
            }
          } else if (node) {
            var iteratorFn = getIteratorFn(node);
            if (typeof iteratorFn === "function") {
              if (iteratorFn !== node.entries) {
                var iterator = iteratorFn.call(node);
                var step;
                while (!(step = iterator.next()).done) {
                  if (isValidElement(step.value)) {
                    validateExplicitKey(step.value, parentType);
                  }
                }
              }
            }
          }
        }
      }
      function validatePropTypes(element) {
        {
          var type = element.type;
          if (type === null || type === undefined || typeof type === "string") {
            return;
          }
          var propTypes;
          if (typeof type === "function") {
            propTypes = type.propTypes;
          } else if (typeof type === "object" && (type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_MEMO_TYPE)) {
            propTypes = type.propTypes;
          } else {
            return;
          }
          if (propTypes) {
            var name = getComponentNameFromType(type);
            checkPropTypes(propTypes, element.props, "prop", name, element);
          } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {
            propTypesMisspellWarningShown = true;
            var _name = getComponentNameFromType(type);
            error("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", _name || "Unknown");
          }
          if (typeof type.getDefaultProps === "function" && !type.getDefaultProps.isReactClassApproved) {
            error("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
          }
        }
      }
      function validateFragmentProps(fragment2) {
        {
          var keys = Object.keys(fragment2.props);
          for (var i = 0;i < keys.length; i++) {
            var key = keys[i];
            if (key !== "children" && key !== "key") {
              setCurrentlyValidatingElement$1(fragment2);
              error("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", key);
              setCurrentlyValidatingElement$1(null);
              break;
            }
          }
          if (fragment2.ref !== null) {
            setCurrentlyValidatingElement$1(fragment2);
            error("Invalid attribute `ref` supplied to `React.Fragment`.");
            setCurrentlyValidatingElement$1(null);
          }
        }
      }
      function jsxWithValidation(type, props, key, isStaticChildren, source, self2) {
        {
          var validType = isValidElementType(type);
          if (!validType) {
            var info = "";
            if (type === undefined || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
              info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
            }
            var sourceInfo = getSourceInfoErrorAddendum(source);
            if (sourceInfo) {
              info += sourceInfo;
            } else {
              info += getDeclarationErrorAddendum();
            }
            var typeString;
            if (type === null) {
              typeString = "null";
            } else if (isArray(type)) {
              typeString = "array";
            } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {
              typeString = "<" + (getComponentNameFromType(type.type) || "Unknown") + " />";
              info = " Did you accidentally export a JSX literal instead of a component?";
            } else {
              typeString = typeof type;
            }
            error("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", typeString, info);
          }
          var element = jsxDEV(type, props, key, source, self2);
          if (element == null) {
            return element;
          }
          if (validType) {
            var children = props.children;
            if (children !== undefined) {
              if (isStaticChildren) {
                if (isArray(children)) {
                  for (var i = 0;i < children.length; i++) {
                    validateChildKeys(children[i], type);
                  }
                  if (Object.freeze) {
                    Object.freeze(children);
                  }
                } else {
                  error("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
                }
              } else {
                validateChildKeys(children, type);
              }
            }
          }
          if (type === REACT_FRAGMENT_TYPE) {
            validateFragmentProps(element);
          } else {
            validatePropTypes(element);
          }
          return element;
        }
      }
      function jsxWithValidationStatic(type, props, key) {
        {
          return jsxWithValidation(type, props, key, true);
        }
      }
      function jsxWithValidationDynamic(type, props, key) {
        {
          return jsxWithValidation(type, props, key, false);
        }
      }
      var jsx = jsxWithValidationDynamic;
      var jsxs = jsxWithValidationStatic;
      exports.Fragment = REACT_FRAGMENT_TYPE;
      exports.jsx = jsx;
      exports.jsxs = jsxs;
    })();
  }
});

// node_modules/react/jsx-runtime.js
var require_jsx_runtime = __commonJS((exports, module) => {
  if (false) {
  } else {
    module.exports = require_react_jsx_runtime_development();
  }
});

// node_modules/react/cjs/react-jsx-dev-runtime.development.js
var require_react_jsx_dev_runtime_development = __commonJS((exports) => {
  var React3 = __toESM(require_react(), 1);
  if (true) {
    (function() {
      var REACT_ELEMENT_TYPE = Symbol.for("react.element");
      var REACT_PORTAL_TYPE = Symbol.for("react.portal");
      var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
      var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
      var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
      var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
      var REACT_CONTEXT_TYPE = Symbol.for("react.context");
      var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
      var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
      var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
      var REACT_MEMO_TYPE = Symbol.for("react.memo");
      var REACT_LAZY_TYPE = Symbol.for("react.lazy");
      var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
      var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
      var FAUX_ITERATOR_SYMBOL = "@@iterator";
      function getIteratorFn(maybeIterable) {
        if (maybeIterable === null || typeof maybeIterable !== "object") {
          return null;
        }
        var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
        if (typeof maybeIterator === "function") {
          return maybeIterator;
        }
        return null;
      }
      var ReactSharedInternals = React3.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
      function error(format) {
        {
          {
            for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1;_key2 < _len2; _key2++) {
              args[_key2 - 1] = arguments[_key2];
            }
            printWarning("error", format, args);
          }
        }
      }
      function printWarning(level, format, args) {
        {
          var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
          var stack = ReactDebugCurrentFrame2.getStackAddendum();
          if (stack !== "") {
            format += "%s";
            args = args.concat([stack]);
          }
          var argsWithFormat = args.map(function(item) {
            return String(item);
          });
          argsWithFormat.unshift("Warning: " + format);
          Function.prototype.apply.call(console[level], console, argsWithFormat);
        }
      }
      var enableScopeAPI = false;
      var enableCacheElement = false;
      var enableTransitionTracing = false;
      var enableLegacyHidden = false;
      var enableDebugTracing = false;
      var REACT_MODULE_REFERENCE;
      {
        REACT_MODULE_REFERENCE = Symbol.for("react.module.reference");
      }
      function isValidElementType(type) {
        if (typeof type === "string" || typeof type === "function") {
          return true;
        }
        if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {
          return true;
        }
        if (typeof type === "object" && type !== null) {
          if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== undefined) {
            return true;
          }
        }
        return false;
      }
      function getWrappedName(outerType, innerType, wrapperName) {
        var displayName = outerType.displayName;
        if (displayName) {
          return displayName;
        }
        var functionName = innerType.displayName || innerType.name || "";
        return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
      }
      function getContextName(type) {
        return type.displayName || "Context";
      }
      function getComponentNameFromType(type) {
        if (type == null) {
          return null;
        }
        {
          if (typeof type.tag === "number") {
            error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.");
          }
        }
        if (typeof type === "function") {
          return type.displayName || type.name || null;
        }
        if (typeof type === "string") {
          return type;
        }
        switch (type) {
          case REACT_FRAGMENT_TYPE:
            return "Fragment";
          case REACT_PORTAL_TYPE:
            return "Portal";
          case REACT_PROFILER_TYPE:
            return "Profiler";
          case REACT_STRICT_MODE_TYPE:
            return "StrictMode";
          case REACT_SUSPENSE_TYPE:
            return "Suspense";
          case REACT_SUSPENSE_LIST_TYPE:
            return "SuspenseList";
        }
        if (typeof type === "object") {
          switch (type.$$typeof) {
            case REACT_CONTEXT_TYPE:
              var context = type;
              return getContextName(context) + ".Consumer";
            case REACT_PROVIDER_TYPE:
              var provider = type;
              return getContextName(provider._context) + ".Provider";
            case REACT_FORWARD_REF_TYPE:
              return getWrappedName(type, type.render, "ForwardRef");
            case REACT_MEMO_TYPE:
              var outerName = type.displayName || null;
              if (outerName !== null) {
                return outerName;
              }
              return getComponentNameFromType(type.type) || "Memo";
            case REACT_LAZY_TYPE: {
              var lazyComponent = type;
              var payload = lazyComponent._payload;
              var init2 = lazyComponent._init;
              try {
                return getComponentNameFromType(init2(payload));
              } catch (x) {
                return null;
              }
            }
          }
        }
        return null;
      }
      var assign = Object.assign;
      var disabledDepth = 0;
      var prevLog;
      var prevInfo;
      var prevWarn;
      var prevError;
      var prevGroup;
      var prevGroupCollapsed;
      var prevGroupEnd;
      function disabledLog() {
      }
      disabledLog.__reactDisabledLog = true;
      function disableLogs() {
        {
          if (disabledDepth === 0) {
            prevLog = console.log;
            prevInfo = console.info;
            prevWarn = console.warn;
            prevError = console.error;
            prevGroup = console.group;
            prevGroupCollapsed = console.groupCollapsed;
            prevGroupEnd = console.groupEnd;
            var props = {
              configurable: true,
              enumerable: true,
              value: disabledLog,
              writable: true
            };
            Object.defineProperties(console, {
              info: props,
              log: props,
              warn: props,
              error: props,
              group: props,
              groupCollapsed: props,
              groupEnd: props
            });
          }
          disabledDepth++;
        }
      }
      function reenableLogs() {
        {
          disabledDepth--;
          if (disabledDepth === 0) {
            var props = {
              configurable: true,
              enumerable: true,
              writable: true
            };
            Object.defineProperties(console, {
              log: assign({}, props, {
                value: prevLog
              }),
              info: assign({}, props, {
                value: prevInfo
              }),
              warn: assign({}, props, {
                value: prevWarn
              }),
              error: assign({}, props, {
                value: prevError
              }),
              group: assign({}, props, {
                value: prevGroup
              }),
              groupCollapsed: assign({}, props, {
                value: prevGroupCollapsed
              }),
              groupEnd: assign({}, props, {
                value: prevGroupEnd
              })
            });
          }
          if (disabledDepth < 0) {
            error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
          }
        }
      }
      var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
      var prefix;
      function describeBuiltInComponentFrame(name, source, ownerFn) {
        {
          if (prefix === undefined) {
            try {
              throw Error();
            } catch (x) {
              var match = x.stack.trim().match(/\n( *(at )?)/);
              prefix = match && match[1] || "";
            }
          }
          return "\n" + prefix + name;
        }
      }
      var reentry = false;
      var componentFrameCache;
      {
        var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
        componentFrameCache = new PossiblyWeakMap;
      }
      function describeNativeComponentFrame(fn2, construct) {
        if (!fn2 || reentry) {
          return "";
        }
        {
          var frame = componentFrameCache.get(fn2);
          if (frame !== undefined) {
            return frame;
          }
        }
        var control;
        reentry = true;
        var previousPrepareStackTrace = Error.prepareStackTrace;
        Error.prepareStackTrace = undefined;
        var previousDispatcher;
        {
          previousDispatcher = ReactCurrentDispatcher.current;
          ReactCurrentDispatcher.current = null;
          disableLogs();
        }
        try {
          if (construct) {
            var Fake = function() {
              throw Error();
            };
            Object.defineProperty(Fake.prototype, "props", {
              set: function() {
                throw Error();
              }
            });
            if (typeof Reflect === "object" && Reflect.construct) {
              try {
                Reflect.construct(Fake, []);
              } catch (x) {
                control = x;
              }
              Reflect.construct(fn2, [], Fake);
            } else {
              try {
                Fake.call();
              } catch (x) {
                control = x;
              }
              fn2.call(Fake.prototype);
            }
          } else {
            try {
              throw Error();
            } catch (x) {
              control = x;
            }
            fn2();
          }
        } catch (sample) {
          if (sample && control && typeof sample.stack === "string") {
            var sampleLines = sample.stack.split("\n");
            var controlLines = control.stack.split("\n");
            var s = sampleLines.length - 1;
            var c2 = controlLines.length - 1;
            while (s >= 1 && c2 >= 0 && sampleLines[s] !== controlLines[c2]) {
              c2--;
            }
            for (;s >= 1 && c2 >= 0; s--, c2--) {
              if (sampleLines[s] !== controlLines[c2]) {
                if (s !== 1 || c2 !== 1) {
                  do {
                    s--;
                    c2--;
                    if (c2 < 0 || sampleLines[s] !== controlLines[c2]) {
                      var _frame = "\n" + sampleLines[s].replace(" at new ", " at ");
                      if (fn2.displayName && _frame.includes("<anonymous>")) {
                        _frame = _frame.replace("<anonymous>", fn2.displayName);
                      }
                      {
                        if (typeof fn2 === "function") {
                          componentFrameCache.set(fn2, _frame);
                        }
                      }
                      return _frame;
                    }
                  } while (s >= 1 && c2 >= 0);
                }
                break;
              }
            }
          }
        } finally {
          reentry = false;
          {
            ReactCurrentDispatcher.current = previousDispatcher;
            reenableLogs();
          }
          Error.prepareStackTrace = previousPrepareStackTrace;
        }
        var name = fn2 ? fn2.displayName || fn2.name : "";
        var syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
        {
          if (typeof fn2 === "function") {
            componentFrameCache.set(fn2, syntheticFrame);
          }
        }
        return syntheticFrame;
      }
      function describeFunctionComponentFrame(fn2, source, ownerFn) {
        {
          return describeNativeComponentFrame(fn2, false);
        }
      }
      function shouldConstruct(Component) {
        var prototype = Component.prototype;
        return !!(prototype && prototype.isReactComponent);
      }
      function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
        if (type == null) {
          return "";
        }
        if (typeof type === "function") {
          {
            return describeNativeComponentFrame(type, shouldConstruct(type));
          }
        }
        if (typeof type === "string") {
          return describeBuiltInComponentFrame(type);
        }
        switch (type) {
          case REACT_SUSPENSE_TYPE:
            return describeBuiltInComponentFrame("Suspense");
          case REACT_SUSPENSE_LIST_TYPE:
            return describeBuiltInComponentFrame("SuspenseList");
        }
        if (typeof type === "object") {
          switch (type.$$typeof) {
            case REACT_FORWARD_REF_TYPE:
              return describeFunctionComponentFrame(type.render);
            case REACT_MEMO_TYPE:
              return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
            case REACT_LAZY_TYPE: {
              var lazyComponent = type;
              var payload = lazyComponent._payload;
              var init2 = lazyComponent._init;
              try {
                return describeUnknownElementTypeFrameInDEV(init2(payload), source, ownerFn);
              } catch (x) {
              }
            }
          }
        }
        return "";
      }
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      var loggedTypeFailures = {};
      var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
      function setCurrentlyValidatingElement(element) {
        {
          if (element) {
            var owner = element._owner;
            var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
            ReactDebugCurrentFrame.setExtraStackFrame(stack);
          } else {
            ReactDebugCurrentFrame.setExtraStackFrame(null);
          }
        }
      }
      function checkPropTypes(typeSpecs, values2, location, componentName, element) {
        {
          var has = Function.call.bind(hasOwnProperty);
          for (var typeSpecName in typeSpecs) {
            if (has(typeSpecs, typeSpecName)) {
              var error$1 = undefined;
              try {
                if (typeof typeSpecs[typeSpecName] !== "function") {
                  var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                  err.name = "Invariant Violation";
                  throw err;
                }
                error$1 = typeSpecs[typeSpecName](values2, typeSpecName, componentName, location, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
              } catch (ex2) {
                error$1 = ex2;
              }
              if (error$1 && !(error$1 instanceof Error)) {
                setCurrentlyValidatingElement(element);
                error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location, typeSpecName, typeof error$1);
                setCurrentlyValidatingElement(null);
              }
              if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                loggedTypeFailures[error$1.message] = true;
                setCurrentlyValidatingElement(element);
                error("Failed %s type: %s", location, error$1.message);
                setCurrentlyValidatingElement(null);
              }
            }
          }
        }
      }
      var isArrayImpl = Array.isArray;
      function isArray(a) {
        return isArrayImpl(a);
      }
      function typeName(value) {
        {
          var hasToStringTag = typeof Symbol === "function" && Symbol.toStringTag;
          var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
          return type;
        }
      }
      function willCoercionThrow(value) {
        {
          try {
            testStringCoercion(value);
            return false;
          } catch (e) {
            return true;
          }
        }
      }
      function testStringCoercion(value) {
        return "" + value;
      }
      function checkKeyStringCoercion(value) {
        {
          if (willCoercionThrow(value)) {
            error("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value));
            return testStringCoercion(value);
          }
        }
      }
      var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
      var RESERVED_PROPS = {
        key: true,
        ref: true,
        __self: true,
        __source: true
      };
      var specialPropKeyWarningShown;
      var specialPropRefWarningShown;
      var didWarnAboutStringRefs;
      {
        didWarnAboutStringRefs = {};
      }
      function hasValidRef(config) {
        {
          if (hasOwnProperty.call(config, "ref")) {
            var getter = Object.getOwnPropertyDescriptor(config, "ref").get;
            if (getter && getter.isReactWarning) {
              return false;
            }
          }
        }
        return config.ref !== undefined;
      }
      function hasValidKey(config) {
        {
          if (hasOwnProperty.call(config, "key")) {
            var getter = Object.getOwnPropertyDescriptor(config, "key").get;
            if (getter && getter.isReactWarning) {
              return false;
            }
          }
        }
        return config.key !== undefined;
      }
      function warnIfStringRefCannotBeAutoConverted(config, self2) {
        {
          if (typeof config.ref === "string" && ReactCurrentOwner.current && self2 && ReactCurrentOwner.current.stateNode !== self2) {
            var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);
            if (!didWarnAboutStringRefs[componentName]) {
              error('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', getComponentNameFromType(ReactCurrentOwner.current.type), config.ref);
              didWarnAboutStringRefs[componentName] = true;
            }
          }
        }
      }
      function defineKeyPropWarningGetter(props, displayName) {
        {
          var warnAboutAccessingKey = function() {
            if (!specialPropKeyWarningShown) {
              specialPropKeyWarningShown = true;
              error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
            }
          };
          warnAboutAccessingKey.isReactWarning = true;
          Object.defineProperty(props, "key", {
            get: warnAboutAccessingKey,
            configurable: true
          });
        }
      }
      function defineRefPropWarningGetter(props, displayName) {
        {
          var warnAboutAccessingRef = function() {
            if (!specialPropRefWarningShown) {
              specialPropRefWarningShown = true;
              error("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
            }
          };
          warnAboutAccessingRef.isReactWarning = true;
          Object.defineProperty(props, "ref", {
            get: warnAboutAccessingRef,
            configurable: true
          });
        }
      }
      var ReactElement = function(type, key, ref, self2, source, owner, props) {
        var element = {
          $$typeof: REACT_ELEMENT_TYPE,
          type,
          key,
          ref,
          props,
          _owner: owner
        };
        {
          element._store = {};
          Object.defineProperty(element._store, "validated", {
            configurable: false,
            enumerable: false,
            writable: true,
            value: false
          });
          Object.defineProperty(element, "_self", {
            configurable: false,
            enumerable: false,
            writable: false,
            value: self2
          });
          Object.defineProperty(element, "_source", {
            configurable: false,
            enumerable: false,
            writable: false,
            value: source
          });
          if (Object.freeze) {
            Object.freeze(element.props);
            Object.freeze(element);
          }
        }
        return element;
      };
      function jsxDEV(type, config, maybeKey, source, self2) {
        {
          var propName;
          var props = {};
          var key = null;
          var ref = null;
          if (maybeKey !== undefined) {
            {
              checkKeyStringCoercion(maybeKey);
            }
            key = "" + maybeKey;
          }
          if (hasValidKey(config)) {
            {
              checkKeyStringCoercion(config.key);
            }
            key = "" + config.key;
          }
          if (hasValidRef(config)) {
            ref = config.ref;
            warnIfStringRefCannotBeAutoConverted(config, self2);
          }
          for (propName in config) {
            if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
              props[propName] = config[propName];
            }
          }
          if (type && type.defaultProps) {
            var defaultProps = type.defaultProps;
            for (propName in defaultProps) {
              if (props[propName] === undefined) {
                props[propName] = defaultProps[propName];
              }
            }
          }
          if (key || ref) {
            var displayName = typeof type === "function" ? type.displayName || type.name || "Unknown" : type;
            if (key) {
              defineKeyPropWarningGetter(props, displayName);
            }
            if (ref) {
              defineRefPropWarningGetter(props, displayName);
            }
          }
          return ReactElement(type, key, ref, self2, source, ReactCurrentOwner.current, props);
        }
      }
      var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;
      var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
      function setCurrentlyValidatingElement$1(element) {
        {
          if (element) {
            var owner = element._owner;
            var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
            ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
          } else {
            ReactDebugCurrentFrame$1.setExtraStackFrame(null);
          }
        }
      }
      var propTypesMisspellWarningShown;
      {
        propTypesMisspellWarningShown = false;
      }
      function isValidElement2(object) {
        {
          return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
      }
      function getDeclarationErrorAddendum() {
        {
          if (ReactCurrentOwner$1.current) {
            var name = getComponentNameFromType(ReactCurrentOwner$1.current.type);
            if (name) {
              return "\n\nCheck the render method of `" + name + "`.";
            }
          }
          return "";
        }
      }
      function getSourceInfoErrorAddendum(source) {
        {
          if (source !== undefined) {
            var fileName = source.fileName.replace(/^.*[\\\/]/, "");
            var lineNumber = source.lineNumber;
            return "\n\nCheck your code at " + fileName + ":" + lineNumber + ".";
          }
          return "";
        }
      }
      var ownerHasKeyUseWarning = {};
      function getCurrentComponentErrorInfo(parentType) {
        {
          var info = getDeclarationErrorAddendum();
          if (!info) {
            var parentName = typeof parentType === "string" ? parentType : parentType.displayName || parentType.name;
            if (parentName) {
              info = "\n\nCheck the top-level render call using <" + parentName + ">.";
            }
          }
          return info;
        }
      }
      function validateExplicitKey(element, parentType) {
        {
          if (!element._store || element._store.validated || element.key != null) {
            return;
          }
          element._store.validated = true;
          var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
          if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
            return;
          }
          ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
          var childOwner = "";
          if (element && element._owner && element._owner !== ReactCurrentOwner$1.current) {
            childOwner = " It was passed a child from " + getComponentNameFromType(element._owner.type) + ".";
          }
          setCurrentlyValidatingElement$1(element);
          error('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);
          setCurrentlyValidatingElement$1(null);
        }
      }
      function validateChildKeys(node, parentType) {
        {
          if (typeof node !== "object") {
            return;
          }
          if (isArray(node)) {
            for (var i = 0;i < node.length; i++) {
              var child = node[i];
              if (isValidElement2(child)) {
                validateExplicitKey(child, parentType);
              }
            }
          } else if (isValidElement2(node)) {
            if (node._store) {
              node._store.validated = true;
            }
          } else if (node) {
            var iteratorFn = getIteratorFn(node);
            if (typeof iteratorFn === "function") {
              if (iteratorFn !== node.entries) {
                var iterator = iteratorFn.call(node);
                var step;
                while (!(step = iterator.next()).done) {
                  if (isValidElement2(step.value)) {
                    validateExplicitKey(step.value, parentType);
                  }
                }
              }
            }
          }
        }
      }
      function validatePropTypes(element) {
        {
          var type = element.type;
          if (type === null || type === undefined || typeof type === "string") {
            return;
          }
          var propTypes;
          if (typeof type === "function") {
            propTypes = type.propTypes;
          } else if (typeof type === "object" && (type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_MEMO_TYPE)) {
            propTypes = type.propTypes;
          } else {
            return;
          }
          if (propTypes) {
            var name = getComponentNameFromType(type);
            checkPropTypes(propTypes, element.props, "prop", name, element);
          } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {
            propTypesMisspellWarningShown = true;
            var _name = getComponentNameFromType(type);
            error("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", _name || "Unknown");
          }
          if (typeof type.getDefaultProps === "function" && !type.getDefaultProps.isReactClassApproved) {
            error("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
          }
        }
      }
      function validateFragmentProps(fragment2) {
        {
          var keys = Object.keys(fragment2.props);
          for (var i = 0;i < keys.length; i++) {
            var key = keys[i];
            if (key !== "children" && key !== "key") {
              setCurrentlyValidatingElement$1(fragment2);
              error("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", key);
              setCurrentlyValidatingElement$1(null);
              break;
            }
          }
          if (fragment2.ref !== null) {
            setCurrentlyValidatingElement$1(fragment2);
            error("Invalid attribute `ref` supplied to `React.Fragment`.");
            setCurrentlyValidatingElement$1(null);
          }
        }
      }
      function jsxWithValidation(type, props, key, isStaticChildren, source, self2) {
        {
          var validType = isValidElementType(type);
          if (!validType) {
            var info = "";
            if (type === undefined || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
              info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
            }
            var sourceInfo = getSourceInfoErrorAddendum(source);
            if (sourceInfo) {
              info += sourceInfo;
            } else {
              info += getDeclarationErrorAddendum();
            }
            var typeString;
            if (type === null) {
              typeString = "null";
            } else if (isArray(type)) {
              typeString = "array";
            } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {
              typeString = "<" + (getComponentNameFromType(type.type) || "Unknown") + " />";
              info = " Did you accidentally export a JSX literal instead of a component?";
            } else {
              typeString = typeof type;
            }
            error("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", typeString, info);
          }
          var element = jsxDEV(type, props, key, source, self2);
          if (element == null) {
            return element;
          }
          if (validType) {
            var children = props.children;
            if (children !== undefined) {
              if (isStaticChildren) {
                if (isArray(children)) {
                  for (var i = 0;i < children.length; i++) {
                    validateChildKeys(children[i], type);
                  }
                  if (Object.freeze) {
                    Object.freeze(children);
                  }
                } else {
                  error("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
                }
              } else {
                validateChildKeys(children, type);
              }
            }
          }
          if (type === REACT_FRAGMENT_TYPE) {
            validateFragmentProps(element);
          } else {
            validatePropTypes(element);
          }
          return element;
        }
      }
      var jsxDEV$1 = jsxWithValidation;
      exports.Fragment = REACT_FRAGMENT_TYPE;
      exports.jsxDEV = jsxDEV$1;
    })();
  }
});

// node_modules/react/jsx-dev-runtime.js
var require_jsx_dev_runtime = __commonJS((exports, module) => {
  if (false) {
  } else {
    module.exports = require_react_jsx_dev_runtime_development();
  }
});

// node_modules/@sinclair/typebox/typebox.js
var require_typebox = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Type = exports.JsonType = exports.JavaScriptTypeBuilder = exports.JsonTypeBuilder = exports.TypeBuilder = exports.TypeBuilderError = exports.TransformEncodeBuilder = exports.TransformDecodeBuilder = exports.TemplateLiteralDslParser = exports.TemplateLiteralGenerator = exports.TemplateLiteralGeneratorError = exports.TemplateLiteralFinite = exports.TemplateLiteralFiniteError = exports.TemplateLiteralParser = exports.TemplateLiteralParserError = exports.TemplateLiteralResolver = exports.TemplateLiteralPattern = exports.TemplateLiteralPatternError = exports.UnionResolver = exports.KeyArrayResolver = exports.KeyArrayResolverError = exports.KeyResolver = exports.ObjectMap = exports.Intrinsic = exports.IndexedAccessor = exports.TypeClone = exports.TypeExtends = exports.TypeExtendsResult = exports.TypeExtendsError = exports.ExtendsUndefined = exports.TypeGuard = exports.TypeGuardUnknownTypeError = exports.ValueGuard = exports.FormatRegistry = exports.TypeBoxError = exports.TypeRegistry = exports.PatternStringExact = exports.PatternNumberExact = exports.PatternBooleanExact = exports.PatternString = exports.PatternNumber = exports.PatternBoolean = exports.Kind = exports.Hint = exports.Optional = exports.Readonly = exports.Transform = undefined;
  exports.Transform = Symbol.for("TypeBox.Transform");
  exports.Readonly = Symbol.for("TypeBox.Readonly");
  exports.Optional = Symbol.for("TypeBox.Optional");
  exports.Hint = Symbol.for("TypeBox.Hint");
  exports.Kind = Symbol.for("TypeBox.Kind");
  exports.PatternBoolean = "(true|false)";
  exports.PatternNumber = "(0|[1-9][0-9]*)";
  exports.PatternString = "(.*)";
  exports.PatternBooleanExact = `^${exports.PatternBoolean}\$`;
  exports.PatternNumberExact = `^${exports.PatternNumber}\$`;
  exports.PatternStringExact = `^${exports.PatternString}\$`;
  var TypeRegistry;
  (function(TypeRegistry2) {
    const map = new Map;
    function Entries() {
      return new Map(map);
    }
    TypeRegistry2.Entries = Entries;
    function Clear() {
      return map.clear();
    }
    TypeRegistry2.Clear = Clear;
    function Delete(kind) {
      return map.delete(kind);
    }
    TypeRegistry2.Delete = Delete;
    function Has(kind) {
      return map.has(kind);
    }
    TypeRegistry2.Has = Has;
    function Set2(kind, func) {
      map.set(kind, func);
    }
    TypeRegistry2.Set = Set2;
    function Get(kind) {
      return map.get(kind);
    }
    TypeRegistry2.Get = Get;
  })(TypeRegistry || (exports.TypeRegistry = TypeRegistry = {}));

  class TypeBoxError extends Error {
    constructor(message2) {
      super(message2);
    }
  }
  exports.TypeBoxError = TypeBoxError;
  var FormatRegistry;
  (function(FormatRegistry2) {
    const map = new Map;
    function Entries() {
      return new Map(map);
    }
    FormatRegistry2.Entries = Entries;
    function Clear() {
      return map.clear();
    }
    FormatRegistry2.Clear = Clear;
    function Delete(format) {
      return map.delete(format);
    }
    FormatRegistry2.Delete = Delete;
    function Has(format) {
      return map.has(format);
    }
    FormatRegistry2.Has = Has;
    function Set2(format, func) {
      map.set(format, func);
    }
    FormatRegistry2.Set = Set2;
    function Get(format) {
      return map.get(format);
    }
    FormatRegistry2.Get = Get;
  })(FormatRegistry || (exports.FormatRegistry = FormatRegistry = {}));
  var ValueGuard;
  (function(ValueGuard2) {
    function IsArray(value) {
      return Array.isArray(value);
    }
    ValueGuard2.IsArray = IsArray;
    function IsBigInt(value) {
      return typeof value === "bigint";
    }
    ValueGuard2.IsBigInt = IsBigInt;
    function IsBoolean(value) {
      return typeof value === "boolean";
    }
    ValueGuard2.IsBoolean = IsBoolean;
    function IsDate(value) {
      return value instanceof globalThis.Date;
    }
    ValueGuard2.IsDate = IsDate;
    function IsNull(value) {
      return value === null;
    }
    ValueGuard2.IsNull = IsNull;
    function IsNumber(value) {
      return typeof value === "number";
    }
    ValueGuard2.IsNumber = IsNumber;
    function IsObject(value) {
      return typeof value === "object" && value !== null;
    }
    ValueGuard2.IsObject = IsObject;
    function IsString(value) {
      return typeof value === "string";
    }
    ValueGuard2.IsString = IsString;
    function IsUint8Array(value) {
      return value instanceof globalThis.Uint8Array;
    }
    ValueGuard2.IsUint8Array = IsUint8Array;
    function IsUndefined(value) {
      return value === undefined;
    }
    ValueGuard2.IsUndefined = IsUndefined;
  })(ValueGuard || (exports.ValueGuard = ValueGuard = {}));

  class TypeGuardUnknownTypeError extends TypeBoxError {
  }
  exports.TypeGuardUnknownTypeError = TypeGuardUnknownTypeError;
  var TypeGuard;
  (function(TypeGuard2) {
    function IsPattern(value) {
      try {
        new RegExp(value);
        return true;
      } catch {
        return false;
      }
    }
    function IsControlCharacterFree(value) {
      if (!ValueGuard.IsString(value))
        return false;
      for (let i = 0;i < value.length; i++) {
        const code = value.charCodeAt(i);
        if (code >= 7 && code <= 13 || code === 27 || code === 127) {
          return false;
        }
      }
      return true;
    }
    function IsAdditionalProperties(value) {
      return IsOptionalBoolean(value) || TSchema(value);
    }
    function IsOptionalBigInt(value) {
      return ValueGuard.IsUndefined(value) || ValueGuard.IsBigInt(value);
    }
    function IsOptionalNumber(value) {
      return ValueGuard.IsUndefined(value) || ValueGuard.IsNumber(value);
    }
    function IsOptionalBoolean(value) {
      return ValueGuard.IsUndefined(value) || ValueGuard.IsBoolean(value);
    }
    function IsOptionalString(value) {
      return ValueGuard.IsUndefined(value) || ValueGuard.IsString(value);
    }
    function IsOptionalPattern(value) {
      return ValueGuard.IsUndefined(value) || ValueGuard.IsString(value) && IsControlCharacterFree(value) && IsPattern(value);
    }
    function IsOptionalFormat(value) {
      return ValueGuard.IsUndefined(value) || ValueGuard.IsString(value) && IsControlCharacterFree(value);
    }
    function IsOptionalSchema(value) {
      return ValueGuard.IsUndefined(value) || TSchema(value);
    }
    function TAny(schema4) {
      return TKindOf(schema4, "Any") && IsOptionalString(schema4.$id);
    }
    TypeGuard2.TAny = TAny;
    function TArray(schema4) {
      return TKindOf(schema4, "Array") && schema4.type === "array" && IsOptionalString(schema4.$id) && TSchema(schema4.items) && IsOptionalNumber(schema4.minItems) && IsOptionalNumber(schema4.maxItems) && IsOptionalBoolean(schema4.uniqueItems) && IsOptionalSchema(schema4.contains) && IsOptionalNumber(schema4.minContains) && IsOptionalNumber(schema4.maxContains);
    }
    TypeGuard2.TArray = TArray;
    function TAsyncIterator(schema4) {
      return TKindOf(schema4, "AsyncIterator") && schema4.type === "AsyncIterator" && IsOptionalString(schema4.$id) && TSchema(schema4.items);
    }
    TypeGuard2.TAsyncIterator = TAsyncIterator;
    function TBigInt(schema4) {
      return TKindOf(schema4, "BigInt") && schema4.type === "bigint" && IsOptionalString(schema4.$id) && IsOptionalBigInt(schema4.exclusiveMaximum) && IsOptionalBigInt(schema4.exclusiveMinimum) && IsOptionalBigInt(schema4.maximum) && IsOptionalBigInt(schema4.minimum) && IsOptionalBigInt(schema4.multipleOf);
    }
    TypeGuard2.TBigInt = TBigInt;
    function TBoolean(schema4) {
      return TKindOf(schema4, "Boolean") && schema4.type === "boolean" && IsOptionalString(schema4.$id);
    }
    TypeGuard2.TBoolean = TBoolean;
    function TConstructor(schema4) {
      return TKindOf(schema4, "Constructor") && schema4.type === "Constructor" && IsOptionalString(schema4.$id) && ValueGuard.IsArray(schema4.parameters) && schema4.parameters.every((schema5) => TSchema(schema5)) && TSchema(schema4.returns);
    }
    TypeGuard2.TConstructor = TConstructor;
    function TDate(schema4) {
      return TKindOf(schema4, "Date") && schema4.type === "Date" && IsOptionalString(schema4.$id) && IsOptionalNumber(schema4.exclusiveMaximumTimestamp) && IsOptionalNumber(schema4.exclusiveMinimumTimestamp) && IsOptionalNumber(schema4.maximumTimestamp) && IsOptionalNumber(schema4.minimumTimestamp) && IsOptionalNumber(schema4.multipleOfTimestamp);
    }
    TypeGuard2.TDate = TDate;
    function TFunction(schema4) {
      return TKindOf(schema4, "Function") && schema4.type === "Function" && IsOptionalString(schema4.$id) && ValueGuard.IsArray(schema4.parameters) && schema4.parameters.every((schema5) => TSchema(schema5)) && TSchema(schema4.returns);
    }
    TypeGuard2.TFunction = TFunction;
    function TInteger(schema4) {
      return TKindOf(schema4, "Integer") && schema4.type === "integer" && IsOptionalString(schema4.$id) && IsOptionalNumber(schema4.exclusiveMaximum) && IsOptionalNumber(schema4.exclusiveMinimum) && IsOptionalNumber(schema4.maximum) && IsOptionalNumber(schema4.minimum) && IsOptionalNumber(schema4.multipleOf);
    }
    TypeGuard2.TInteger = TInteger;
    function TIntersect(schema4) {
      return TKindOf(schema4, "Intersect") && (ValueGuard.IsString(schema4.type) && schema4.type !== "object" ? false : true) && ValueGuard.IsArray(schema4.allOf) && schema4.allOf.every((schema5) => TSchema(schema5) && !TTransform(schema5)) && IsOptionalString(schema4.type) && (IsOptionalBoolean(schema4.unevaluatedProperties) || IsOptionalSchema(schema4.unevaluatedProperties)) && IsOptionalString(schema4.$id);
    }
    TypeGuard2.TIntersect = TIntersect;
    function TIterator(schema4) {
      return TKindOf(schema4, "Iterator") && schema4.type === "Iterator" && IsOptionalString(schema4.$id) && TSchema(schema4.items);
    }
    TypeGuard2.TIterator = TIterator;
    function TKindOf(schema4, kind) {
      return TKind(schema4) && schema4[exports.Kind] === kind;
    }
    TypeGuard2.TKindOf = TKindOf;
    function TKind(schema4) {
      return ValueGuard.IsObject(schema4) && exports.Kind in schema4 && ValueGuard.IsString(schema4[exports.Kind]);
    }
    TypeGuard2.TKind = TKind;
    function TLiteralString(schema4) {
      return TLiteral(schema4) && ValueGuard.IsString(schema4.const);
    }
    TypeGuard2.TLiteralString = TLiteralString;
    function TLiteralNumber(schema4) {
      return TLiteral(schema4) && ValueGuard.IsNumber(schema4.const);
    }
    TypeGuard2.TLiteralNumber = TLiteralNumber;
    function TLiteralBoolean(schema4) {
      return TLiteral(schema4) && ValueGuard.IsBoolean(schema4.const);
    }
    TypeGuard2.TLiteralBoolean = TLiteralBoolean;
    function TLiteral(schema4) {
      return TKindOf(schema4, "Literal") && IsOptionalString(schema4.$id) && (ValueGuard.IsBoolean(schema4.const) || ValueGuard.IsNumber(schema4.const) || ValueGuard.IsString(schema4.const));
    }
    TypeGuard2.TLiteral = TLiteral;
    function TNever(schema4) {
      return TKindOf(schema4, "Never") && ValueGuard.IsObject(schema4.not) && Object.getOwnPropertyNames(schema4.not).length === 0;
    }
    TypeGuard2.TNever = TNever;
    function TNot(schema4) {
      return TKindOf(schema4, "Not") && TSchema(schema4.not);
    }
    TypeGuard2.TNot = TNot;
    function TNull(schema4) {
      return TKindOf(schema4, "Null") && schema4.type === "null" && IsOptionalString(schema4.$id);
    }
    TypeGuard2.TNull = TNull;
    function TNumber(schema4) {
      return TKindOf(schema4, "Number") && schema4.type === "number" && IsOptionalString(schema4.$id) && IsOptionalNumber(schema4.exclusiveMaximum) && IsOptionalNumber(schema4.exclusiveMinimum) && IsOptionalNumber(schema4.maximum) && IsOptionalNumber(schema4.minimum) && IsOptionalNumber(schema4.multipleOf);
    }
    TypeGuard2.TNumber = TNumber;
    function TObject(schema4) {
      return TKindOf(schema4, "Object") && schema4.type === "object" && IsOptionalString(schema4.$id) && ValueGuard.IsObject(schema4.properties) && IsAdditionalProperties(schema4.additionalProperties) && IsOptionalNumber(schema4.minProperties) && IsOptionalNumber(schema4.maxProperties) && Object.entries(schema4.properties).every(([key, schema5]) => IsControlCharacterFree(key) && TSchema(schema5));
    }
    TypeGuard2.TObject = TObject;
    function TPromise(schema4) {
      return TKindOf(schema4, "Promise") && schema4.type === "Promise" && IsOptionalString(schema4.$id) && TSchema(schema4.item);
    }
    TypeGuard2.TPromise = TPromise;
    function TRecord(schema4) {
      return TKindOf(schema4, "Record") && schema4.type === "object" && IsOptionalString(schema4.$id) && IsAdditionalProperties(schema4.additionalProperties) && ValueGuard.IsObject(schema4.patternProperties) && ((schema5) => {
        const keys = Object.getOwnPropertyNames(schema5.patternProperties);
        return keys.length === 1 && IsPattern(keys[0]) && ValueGuard.IsObject(schema5.patternProperties) && TSchema(schema5.patternProperties[keys[0]]);
      })(schema4);
    }
    TypeGuard2.TRecord = TRecord;
    function TRecursive(schema4) {
      return ValueGuard.IsObject(schema4) && exports.Hint in schema4 && schema4[exports.Hint] === "Recursive";
    }
    TypeGuard2.TRecursive = TRecursive;
    function TRef(schema4) {
      return TKindOf(schema4, "Ref") && IsOptionalString(schema4.$id) && ValueGuard.IsString(schema4.$ref);
    }
    TypeGuard2.TRef = TRef;
    function TString(schema4) {
      return TKindOf(schema4, "String") && schema4.type === "string" && IsOptionalString(schema4.$id) && IsOptionalNumber(schema4.minLength) && IsOptionalNumber(schema4.maxLength) && IsOptionalPattern(schema4.pattern) && IsOptionalFormat(schema4.format);
    }
    TypeGuard2.TString = TString;
    function TSymbol(schema4) {
      return TKindOf(schema4, "Symbol") && schema4.type === "symbol" && IsOptionalString(schema4.$id);
    }
    TypeGuard2.TSymbol = TSymbol;
    function TTemplateLiteral(schema4) {
      return TKindOf(schema4, "TemplateLiteral") && schema4.type === "string" && ValueGuard.IsString(schema4.pattern) && schema4.pattern[0] === "^" && schema4.pattern[schema4.pattern.length - 1] === "$";
    }
    TypeGuard2.TTemplateLiteral = TTemplateLiteral;
    function TThis(schema4) {
      return TKindOf(schema4, "This") && IsOptionalString(schema4.$id) && ValueGuard.IsString(schema4.$ref);
    }
    TypeGuard2.TThis = TThis;
    function TTransform(schema4) {
      return ValueGuard.IsObject(schema4) && exports.Transform in schema4;
    }
    TypeGuard2.TTransform = TTransform;
    function TTuple(schema4) {
      return TKindOf(schema4, "Tuple") && schema4.type === "array" && IsOptionalString(schema4.$id) && ValueGuard.IsNumber(schema4.minItems) && ValueGuard.IsNumber(schema4.maxItems) && schema4.minItems === schema4.maxItems && (ValueGuard.IsUndefined(schema4.items) && ValueGuard.IsUndefined(schema4.additionalItems) && schema4.minItems === 0 || ValueGuard.IsArray(schema4.items) && schema4.items.every((schema5) => TSchema(schema5)));
    }
    TypeGuard2.TTuple = TTuple;
    function TUndefined(schema4) {
      return TKindOf(schema4, "Undefined") && schema4.type === "undefined" && IsOptionalString(schema4.$id);
    }
    TypeGuard2.TUndefined = TUndefined;
    function TUnionLiteral(schema4) {
      return TUnion(schema4) && schema4.anyOf.every((schema5) => TLiteralString(schema5) || TLiteralNumber(schema5));
    }
    TypeGuard2.TUnionLiteral = TUnionLiteral;
    function TUnion(schema4) {
      return TKindOf(schema4, "Union") && IsOptionalString(schema4.$id) && ValueGuard.IsObject(schema4) && ValueGuard.IsArray(schema4.anyOf) && schema4.anyOf.every((schema5) => TSchema(schema5));
    }
    TypeGuard2.TUnion = TUnion;
    function TUint8Array(schema4) {
      return TKindOf(schema4, "Uint8Array") && schema4.type === "Uint8Array" && IsOptionalString(schema4.$id) && IsOptionalNumber(schema4.minByteLength) && IsOptionalNumber(schema4.maxByteLength);
    }
    TypeGuard2.TUint8Array = TUint8Array;
    function TUnknown(schema4) {
      return TKindOf(schema4, "Unknown") && IsOptionalString(schema4.$id);
    }
    TypeGuard2.TUnknown = TUnknown;
    function TUnsafe(schema4) {
      return TKindOf(schema4, "Unsafe");
    }
    TypeGuard2.TUnsafe = TUnsafe;
    function TVoid(schema4) {
      return TKindOf(schema4, "Void") && schema4.type === "void" && IsOptionalString(schema4.$id);
    }
    TypeGuard2.TVoid = TVoid;
    function TReadonly(schema4) {
      return ValueGuard.IsObject(schema4) && schema4[exports.Readonly] === "Readonly";
    }
    TypeGuard2.TReadonly = TReadonly;
    function TOptional(schema4) {
      return ValueGuard.IsObject(schema4) && schema4[exports.Optional] === "Optional";
    }
    TypeGuard2.TOptional = TOptional;
    function TSchema(schema4) {
      return ValueGuard.IsObject(schema4) && (TAny(schema4) || TArray(schema4) || TBoolean(schema4) || TBigInt(schema4) || TAsyncIterator(schema4) || TConstructor(schema4) || TDate(schema4) || TFunction(schema4) || TInteger(schema4) || TIntersect(schema4) || TIterator(schema4) || TLiteral(schema4) || TNever(schema4) || TNot(schema4) || TNull(schema4) || TNumber(schema4) || TObject(schema4) || TPromise(schema4) || TRecord(schema4) || TRef(schema4) || TString(schema4) || TSymbol(schema4) || TTemplateLiteral(schema4) || TThis(schema4) || TTuple(schema4) || TUndefined(schema4) || TUnion(schema4) || TUint8Array(schema4) || TUnknown(schema4) || TUnsafe(schema4) || TVoid(schema4) || TKind(schema4) && TypeRegistry.Has(schema4[exports.Kind]));
    }
    TypeGuard2.TSchema = TSchema;
  })(TypeGuard || (exports.TypeGuard = TypeGuard = {}));
  var ExtendsUndefined;
  (function(ExtendsUndefined2) {
    function Check(schema4) {
      return schema4[exports.Kind] === "Intersect" ? schema4.allOf.every((schema5) => Check(schema5)) : schema4[exports.Kind] === "Union" ? schema4.anyOf.some((schema5) => Check(schema5)) : schema4[exports.Kind] === "Undefined" ? true : schema4[exports.Kind] === "Not" ? !Check(schema4.not) : false;
    }
    ExtendsUndefined2.Check = Check;
  })(ExtendsUndefined || (exports.ExtendsUndefined = ExtendsUndefined = {}));

  class TypeExtendsError extends TypeBoxError {
  }
  exports.TypeExtendsError = TypeExtendsError;
  var TypeExtendsResult;
  (function(TypeExtendsResult2) {
    TypeExtendsResult2[TypeExtendsResult2["Union"] = 0] = "Union";
    TypeExtendsResult2[TypeExtendsResult2["True"] = 1] = "True";
    TypeExtendsResult2[TypeExtendsResult2["False"] = 2] = "False";
  })(TypeExtendsResult || (exports.TypeExtendsResult = TypeExtendsResult = {}));
  var TypeExtends;
  (function(TypeExtends2) {
    function IntoBooleanResult(result2) {
      return result2 === TypeExtendsResult.False ? result2 : TypeExtendsResult.True;
    }
    function Throw(message2) {
      throw new TypeExtendsError(message2);
    }
    function IsStructuralRight(right) {
      return TypeGuard.TNever(right) || TypeGuard.TIntersect(right) || TypeGuard.TUnion(right) || TypeGuard.TUnknown(right) || TypeGuard.TAny(right);
    }
    function StructuralRight(left, right) {
      return TypeGuard.TNever(right) ? TNeverRight(left, right) : TypeGuard.TIntersect(right) ? TIntersectRight(left, right) : TypeGuard.TUnion(right) ? TUnionRight(left, right) : TypeGuard.TUnknown(right) ? TUnknownRight(left, right) : TypeGuard.TAny(right) ? TAnyRight(left, right) : Throw("StructuralRight");
    }
    function TAnyRight(left, right) {
      return TypeExtendsResult.True;
    }
    function TAny(left, right) {
      return TypeGuard.TIntersect(right) ? TIntersectRight(left, right) : TypeGuard.TUnion(right) && right.anyOf.some((schema4) => TypeGuard.TAny(schema4) || TypeGuard.TUnknown(schema4)) ? TypeExtendsResult.True : TypeGuard.TUnion(right) ? TypeExtendsResult.Union : TypeGuard.TUnknown(right) ? TypeExtendsResult.True : TypeGuard.TAny(right) ? TypeExtendsResult.True : TypeExtendsResult.Union;
    }
    function TArrayRight(left, right) {
      return TypeGuard.TUnknown(left) ? TypeExtendsResult.False : TypeGuard.TAny(left) ? TypeExtendsResult.Union : TypeGuard.TNever(left) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function TArray(left, right) {
      return TypeGuard.TObject(right) && IsObjectArrayLike(right) ? TypeExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : !TypeGuard.TArray(right) ? TypeExtendsResult.False : IntoBooleanResult(Visit(left.items, right.items));
    }
    function TAsyncIterator(left, right) {
      return IsStructuralRight(right) ? StructuralRight(left, right) : !TypeGuard.TAsyncIterator(right) ? TypeExtendsResult.False : IntoBooleanResult(Visit(left.items, right.items));
    }
    function TBigInt(left, right) {
      return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TBigInt(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function TBooleanRight(left, right) {
      return TypeGuard.TLiteral(left) && ValueGuard.IsBoolean(left.const) ? TypeExtendsResult.True : TypeGuard.TBoolean(left) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function TBoolean(left, right) {
      return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TBoolean(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function TConstructor(left, right) {
      return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : !TypeGuard.TConstructor(right) ? TypeExtendsResult.False : left.parameters.length > right.parameters.length ? TypeExtendsResult.False : !left.parameters.every((schema4, index) => IntoBooleanResult(Visit(right.parameters[index], schema4)) === TypeExtendsResult.True) ? TypeExtendsResult.False : IntoBooleanResult(Visit(left.returns, right.returns));
    }
    function TDate(left, right) {
      return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TDate(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function TFunction(left, right) {
      return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : !TypeGuard.TFunction(right) ? TypeExtendsResult.False : left.parameters.length > right.parameters.length ? TypeExtendsResult.False : !left.parameters.every((schema4, index) => IntoBooleanResult(Visit(right.parameters[index], schema4)) === TypeExtendsResult.True) ? TypeExtendsResult.False : IntoBooleanResult(Visit(left.returns, right.returns));
    }
    function TIntegerRight(left, right) {
      return TypeGuard.TLiteral(left) && ValueGuard.IsNumber(left.const) ? TypeExtendsResult.True : TypeGuard.TNumber(left) || TypeGuard.TInteger(left) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function TInteger(left, right) {
      return TypeGuard.TInteger(right) || TypeGuard.TNumber(right) ? TypeExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeExtendsResult.False;
    }
    function TIntersectRight(left, right) {
      return right.allOf.every((schema4) => Visit(left, schema4) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function TIntersect(left, right) {
      return left.allOf.some((schema4) => Visit(schema4, right) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function TIterator(left, right) {
      return IsStructuralRight(right) ? StructuralRight(left, right) : !TypeGuard.TIterator(right) ? TypeExtendsResult.False : IntoBooleanResult(Visit(left.items, right.items));
    }
    function TLiteral(left, right) {
      return TypeGuard.TLiteral(right) && right.const === left.const ? TypeExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TString(right) ? TStringRight(left, right) : TypeGuard.TNumber(right) ? TNumberRight(left, right) : TypeGuard.TInteger(right) ? TIntegerRight(left, right) : TypeGuard.TBoolean(right) ? TBooleanRight(left, right) : TypeExtendsResult.False;
    }
    function TNeverRight(left, right) {
      return TypeExtendsResult.False;
    }
    function TNever(left, right) {
      return TypeExtendsResult.True;
    }
    function UnwrapTNot(schema4) {
      let [current, depth] = [schema4, 0];
      while (true) {
        if (!TypeGuard.TNot(current))
          break;
        current = current.not;
        depth += 1;
      }
      return depth % 2 === 0 ? current : exports.Type.Unknown();
    }
    function TNot(left, right) {
      return TypeGuard.TNot(left) ? Visit(UnwrapTNot(left), right) : TypeGuard.TNot(right) ? Visit(left, UnwrapTNot(right)) : Throw("Invalid fallthrough for Not");
    }
    function TNull(left, right) {
      return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TNull(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function TNumberRight(left, right) {
      return TypeGuard.TLiteralNumber(left) ? TypeExtendsResult.True : TypeGuard.TNumber(left) || TypeGuard.TInteger(left) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function TNumber(left, right) {
      return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TInteger(right) || TypeGuard.TNumber(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function IsObjectPropertyCount(schema4, count2) {
      return Object.getOwnPropertyNames(schema4.properties).length === count2;
    }
    function IsObjectStringLike(schema4) {
      return IsObjectArrayLike(schema4);
    }
    function IsObjectSymbolLike(schema4) {
      return IsObjectPropertyCount(schema4, 0) || IsObjectPropertyCount(schema4, 1) && "description" in schema4.properties && TypeGuard.TUnion(schema4.properties.description) && schema4.properties.description.anyOf.length === 2 && (TypeGuard.TString(schema4.properties.description.anyOf[0]) && TypeGuard.TUndefined(schema4.properties.description.anyOf[1]) || TypeGuard.TString(schema4.properties.description.anyOf[1]) && TypeGuard.TUndefined(schema4.properties.description.anyOf[0]));
    }
    function IsObjectNumberLike(schema4) {
      return IsObjectPropertyCount(schema4, 0);
    }
    function IsObjectBooleanLike(schema4) {
      return IsObjectPropertyCount(schema4, 0);
    }
    function IsObjectBigIntLike(schema4) {
      return IsObjectPropertyCount(schema4, 0);
    }
    function IsObjectDateLike(schema4) {
      return IsObjectPropertyCount(schema4, 0);
    }
    function IsObjectUint8ArrayLike(schema4) {
      return IsObjectArrayLike(schema4);
    }
    function IsObjectFunctionLike(schema4) {
      const length = exports.Type.Number();
      return IsObjectPropertyCount(schema4, 0) || IsObjectPropertyCount(schema4, 1) && "length" in schema4.properties && IntoBooleanResult(Visit(schema4.properties["length"], length)) === TypeExtendsResult.True;
    }
    function IsObjectConstructorLike(schema4) {
      return IsObjectPropertyCount(schema4, 0);
    }
    function IsObjectArrayLike(schema4) {
      const length = exports.Type.Number();
      return IsObjectPropertyCount(schema4, 0) || IsObjectPropertyCount(schema4, 1) && "length" in schema4.properties && IntoBooleanResult(Visit(schema4.properties["length"], length)) === TypeExtendsResult.True;
    }
    function IsObjectPromiseLike(schema4) {
      const then = exports.Type.Function([exports.Type.Any()], exports.Type.Any());
      return IsObjectPropertyCount(schema4, 0) || IsObjectPropertyCount(schema4, 1) && "then" in schema4.properties && IntoBooleanResult(Visit(schema4.properties["then"], then)) === TypeExtendsResult.True;
    }
    function Property(left, right) {
      return Visit(left, right) === TypeExtendsResult.False ? TypeExtendsResult.False : TypeGuard.TOptional(left) && !TypeGuard.TOptional(right) ? TypeExtendsResult.False : TypeExtendsResult.True;
    }
    function TObjectRight(left, right) {
      return TypeGuard.TUnknown(left) ? TypeExtendsResult.False : TypeGuard.TAny(left) ? TypeExtendsResult.Union : TypeGuard.TNever(left) || TypeGuard.TLiteralString(left) && IsObjectStringLike(right) || TypeGuard.TLiteralNumber(left) && IsObjectNumberLike(right) || TypeGuard.TLiteralBoolean(left) && IsObjectBooleanLike(right) || TypeGuard.TSymbol(left) && IsObjectSymbolLike(right) || TypeGuard.TBigInt(left) && IsObjectBigIntLike(right) || TypeGuard.TString(left) && IsObjectStringLike(right) || TypeGuard.TSymbol(left) && IsObjectSymbolLike(right) || TypeGuard.TNumber(left) && IsObjectNumberLike(right) || TypeGuard.TInteger(left) && IsObjectNumberLike(right) || TypeGuard.TBoolean(left) && IsObjectBooleanLike(right) || TypeGuard.TUint8Array(left) && IsObjectUint8ArrayLike(right) || TypeGuard.TDate(left) && IsObjectDateLike(right) || TypeGuard.TConstructor(left) && IsObjectConstructorLike(right) || TypeGuard.TFunction(left) && IsObjectFunctionLike(right) ? TypeExtendsResult.True : TypeGuard.TRecord(left) && TypeGuard.TString(RecordKey(left)) ? (() => {
        return right[exports.Hint] === "Record" ? TypeExtendsResult.True : TypeExtendsResult.False;
      })() : TypeGuard.TRecord(left) && TypeGuard.TNumber(RecordKey(left)) ? (() => {
        return IsObjectPropertyCount(right, 0) ? TypeExtendsResult.True : TypeExtendsResult.False;
      })() : TypeExtendsResult.False;
    }
    function TObject(left, right) {
      return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : !TypeGuard.TObject(right) ? TypeExtendsResult.False : (() => {
        for (const key of Object.getOwnPropertyNames(right.properties)) {
          if (!(key in left.properties) && !TypeGuard.TOptional(right.properties[key])) {
            return TypeExtendsResult.False;
          }
          if (TypeGuard.TOptional(right.properties[key])) {
            return TypeExtendsResult.True;
          }
          if (Property(left.properties[key], right.properties[key]) === TypeExtendsResult.False) {
            return TypeExtendsResult.False;
          }
        }
        return TypeExtendsResult.True;
      })();
    }
    function TPromise(left, right) {
      return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) && IsObjectPromiseLike(right) ? TypeExtendsResult.True : !TypeGuard.TPromise(right) ? TypeExtendsResult.False : IntoBooleanResult(Visit(left.item, right.item));
    }
    function RecordKey(schema4) {
      return exports.PatternNumberExact in schema4.patternProperties ? exports.Type.Number() : (exports.PatternStringExact in schema4.patternProperties) ? exports.Type.String() : Throw("Unknown record key pattern");
    }
    function RecordValue(schema4) {
      return exports.PatternNumberExact in schema4.patternProperties ? schema4.patternProperties[exports.PatternNumberExact] : (exports.PatternStringExact in schema4.patternProperties) ? schema4.patternProperties[exports.PatternStringExact] : Throw("Unable to get record value schema");
    }
    function TRecordRight(left, right) {
      const [Key, Value] = [RecordKey(right), RecordValue(right)];
      return TypeGuard.TLiteralString(left) && TypeGuard.TNumber(Key) && IntoBooleanResult(Visit(left, Value)) === TypeExtendsResult.True ? TypeExtendsResult.True : TypeGuard.TUint8Array(left) && TypeGuard.TNumber(Key) ? Visit(left, Value) : TypeGuard.TString(left) && TypeGuard.TNumber(Key) ? Visit(left, Value) : TypeGuard.TArray(left) && TypeGuard.TNumber(Key) ? Visit(left, Value) : TypeGuard.TObject(left) ? (() => {
        for (const key of Object.getOwnPropertyNames(left.properties)) {
          if (Property(Value, left.properties[key]) === TypeExtendsResult.False) {
            return TypeExtendsResult.False;
          }
        }
        return TypeExtendsResult.True;
      })() : TypeExtendsResult.False;
    }
    function TRecord(left, right) {
      return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : !TypeGuard.TRecord(right) ? TypeExtendsResult.False : Visit(RecordValue(left), RecordValue(right));
    }
    function TStringRight(left, right) {
      return TypeGuard.TLiteral(left) && ValueGuard.IsString(left.const) ? TypeExtendsResult.True : TypeGuard.TString(left) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function TString(left, right) {
      return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TString(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function TSymbol(left, right) {
      return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TSymbol(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function TTemplateLiteral(left, right) {
      return TypeGuard.TTemplateLiteral(left) ? Visit(TemplateLiteralResolver.Resolve(left), right) : TypeGuard.TTemplateLiteral(right) ? Visit(left, TemplateLiteralResolver.Resolve(right)) : Throw("Invalid fallthrough for TemplateLiteral");
    }
    function IsArrayOfTuple(left, right) {
      return TypeGuard.TArray(right) && left.items !== undefined && left.items.every((schema4) => Visit(schema4, right.items) === TypeExtendsResult.True);
    }
    function TTupleRight(left, right) {
      return TypeGuard.TNever(left) ? TypeExtendsResult.True : TypeGuard.TUnknown(left) ? TypeExtendsResult.False : TypeGuard.TAny(left) ? TypeExtendsResult.Union : TypeExtendsResult.False;
    }
    function TTuple(left, right) {
      return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) && IsObjectArrayLike(right) ? TypeExtendsResult.True : TypeGuard.TArray(right) && IsArrayOfTuple(left, right) ? TypeExtendsResult.True : !TypeGuard.TTuple(right) ? TypeExtendsResult.False : ValueGuard.IsUndefined(left.items) && !ValueGuard.IsUndefined(right.items) || !ValueGuard.IsUndefined(left.items) && ValueGuard.IsUndefined(right.items) ? TypeExtendsResult.False : ValueGuard.IsUndefined(left.items) && !ValueGuard.IsUndefined(right.items) ? TypeExtendsResult.True : left.items.every((schema4, index) => Visit(schema4, right.items[index]) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function TUint8Array(left, right) {
      return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TUint8Array(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function TUndefined(left, right) {
      return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TVoid(right) ? VoidRight(left, right) : TypeGuard.TUndefined(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function TUnionRight(left, right) {
      return right.anyOf.some((schema4) => Visit(left, schema4) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function TUnion(left, right) {
      return left.anyOf.every((schema4) => Visit(schema4, right) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function TUnknownRight(left, right) {
      return TypeExtendsResult.True;
    }
    function TUnknown(left, right) {
      return TypeGuard.TNever(right) ? TNeverRight(left, right) : TypeGuard.TIntersect(right) ? TIntersectRight(left, right) : TypeGuard.TUnion(right) ? TUnionRight(left, right) : TypeGuard.TAny(right) ? TAnyRight(left, right) : TypeGuard.TString(right) ? TStringRight(left, right) : TypeGuard.TNumber(right) ? TNumberRight(left, right) : TypeGuard.TInteger(right) ? TIntegerRight(left, right) : TypeGuard.TBoolean(right) ? TBooleanRight(left, right) : TypeGuard.TArray(right) ? TArrayRight(left, right) : TypeGuard.TTuple(right) ? TTupleRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TUnknown(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function VoidRight(left, right) {
      return TypeGuard.TUndefined(left) ? TypeExtendsResult.True : TypeGuard.TUndefined(left) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function TVoid(left, right) {
      return TypeGuard.TIntersect(right) ? TIntersectRight(left, right) : TypeGuard.TUnion(right) ? TUnionRight(left, right) : TypeGuard.TUnknown(right) ? TUnknownRight(left, right) : TypeGuard.TAny(right) ? TAnyRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TVoid(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function Visit(left, right) {
      return TypeGuard.TTemplateLiteral(left) || TypeGuard.TTemplateLiteral(right) ? TTemplateLiteral(left, right) : TypeGuard.TNot(left) || TypeGuard.TNot(right) ? TNot(left, right) : TypeGuard.TAny(left) ? TAny(left, right) : TypeGuard.TArray(left) ? TArray(left, right) : TypeGuard.TBigInt(left) ? TBigInt(left, right) : TypeGuard.TBoolean(left) ? TBoolean(left, right) : TypeGuard.TAsyncIterator(left) ? TAsyncIterator(left, right) : TypeGuard.TConstructor(left) ? TConstructor(left, right) : TypeGuard.TDate(left) ? TDate(left, right) : TypeGuard.TFunction(left) ? TFunction(left, right) : TypeGuard.TInteger(left) ? TInteger(left, right) : TypeGuard.TIntersect(left) ? TIntersect(left, right) : TypeGuard.TIterator(left) ? TIterator(left, right) : TypeGuard.TLiteral(left) ? TLiteral(left, right) : TypeGuard.TNever(left) ? TNever(left, right) : TypeGuard.TNull(left) ? TNull(left, right) : TypeGuard.TNumber(left) ? TNumber(left, right) : TypeGuard.TObject(left) ? TObject(left, right) : TypeGuard.TRecord(left) ? TRecord(left, right) : TypeGuard.TString(left) ? TString(left, right) : TypeGuard.TSymbol(left) ? TSymbol(left, right) : TypeGuard.TTuple(left) ? TTuple(left, right) : TypeGuard.TPromise(left) ? TPromise(left, right) : TypeGuard.TUint8Array(left) ? TUint8Array(left, right) : TypeGuard.TUndefined(left) ? TUndefined(left, right) : TypeGuard.TUnion(left) ? TUnion(left, right) : TypeGuard.TUnknown(left) ? TUnknown(left, right) : TypeGuard.TVoid(left) ? TVoid(left, right) : Throw(`Unknown left type operand '${left[exports.Kind]}'`);
    }
    function Extends(left, right) {
      return Visit(left, right);
    }
    TypeExtends2.Extends = Extends;
  })(TypeExtends || (exports.TypeExtends = TypeExtends = {}));
  var TypeClone;
  (function(TypeClone2) {
    function ArrayType(value) {
      return value.map((value2) => Visit(value2));
    }
    function DateType(value) {
      return new Date(value.getTime());
    }
    function Uint8ArrayType(value) {
      return new Uint8Array(value);
    }
    function ObjectType(value) {
      const clonedProperties = Object.getOwnPropertyNames(value).reduce((acc, key) => ({ ...acc, [key]: Visit(value[key]) }), {});
      const clonedSymbols = Object.getOwnPropertySymbols(value).reduce((acc, key) => ({ ...acc, [key]: Visit(value[key]) }), {});
      return { ...clonedProperties, ...clonedSymbols };
    }
    function Visit(value) {
      return ValueGuard.IsArray(value) ? ArrayType(value) : ValueGuard.IsDate(value) ? DateType(value) : ValueGuard.IsUint8Array(value) ? Uint8ArrayType(value) : ValueGuard.IsObject(value) ? ObjectType(value) : value;
    }
    function Rest(schemas) {
      return schemas.map((schema4) => Type(schema4));
    }
    TypeClone2.Rest = Rest;
    function Type(schema4, options = {}) {
      return { ...Visit(schema4), ...options };
    }
    TypeClone2.Type = Type;
  })(TypeClone || (exports.TypeClone = TypeClone = {}));
  var IndexedAccessor;
  (function(IndexedAccessor2) {
    function OptionalUnwrap(schema4) {
      return schema4.map((schema5) => {
        const { [exports.Optional]: _, ...clone } = TypeClone.Type(schema5);
        return clone;
      });
    }
    function IsIntersectOptional(schema4) {
      return schema4.every((schema5) => TypeGuard.TOptional(schema5));
    }
    function IsUnionOptional(schema4) {
      return schema4.some((schema5) => TypeGuard.TOptional(schema5));
    }
    function ResolveIntersect(schema4) {
      return IsIntersectOptional(schema4.allOf) ? exports.Type.Optional(exports.Type.Intersect(OptionalUnwrap(schema4.allOf))) : schema4;
    }
    function ResolveUnion(schema4) {
      return IsUnionOptional(schema4.anyOf) ? exports.Type.Optional(exports.Type.Union(OptionalUnwrap(schema4.anyOf))) : schema4;
    }
    function ResolveOptional(schema4) {
      return schema4[exports.Kind] === "Intersect" ? ResolveIntersect(schema4) : schema4[exports.Kind] === "Union" ? ResolveUnion(schema4) : schema4;
    }
    function TIntersect(schema4, key) {
      const resolved = schema4.allOf.reduce((acc, schema5) => {
        const indexed = Visit(schema5, key);
        return indexed[exports.Kind] === "Never" ? acc : [...acc, indexed];
      }, []);
      return ResolveOptional(exports.Type.Intersect(resolved));
    }
    function TUnion(schema4, key) {
      const resolved = schema4.anyOf.map((schema5) => Visit(schema5, key));
      return ResolveOptional(exports.Type.Union(resolved));
    }
    function TObject(schema4, key) {
      const property = schema4.properties[key];
      return ValueGuard.IsUndefined(property) ? exports.Type.Never() : exports.Type.Union([property]);
    }
    function TTuple(schema4, key) {
      const items = schema4.items;
      if (ValueGuard.IsUndefined(items))
        return exports.Type.Never();
      const element = items[key];
      if (ValueGuard.IsUndefined(element))
        return exports.Type.Never();
      return element;
    }
    function Visit(schema4, key) {
      return schema4[exports.Kind] === "Intersect" ? TIntersect(schema4, key) : schema4[exports.Kind] === "Union" ? TUnion(schema4, key) : schema4[exports.Kind] === "Object" ? TObject(schema4, key) : schema4[exports.Kind] === "Tuple" ? TTuple(schema4, key) : exports.Type.Never();
    }
    function Resolve(schema4, keys, options = {}) {
      const resolved = keys.map((key) => Visit(schema4, key.toString()));
      return ResolveOptional(exports.Type.Union(resolved, options));
    }
    IndexedAccessor2.Resolve = Resolve;
  })(IndexedAccessor || (exports.IndexedAccessor = IndexedAccessor = {}));
  var Intrinsic;
  (function(Intrinsic2) {
    function Uncapitalize(value) {
      const [first, rest] = [value.slice(0, 1), value.slice(1)];
      return `${first.toLowerCase()}${rest}`;
    }
    function Capitalize(value) {
      const [first, rest] = [value.slice(0, 1), value.slice(1)];
      return `${first.toUpperCase()}${rest}`;
    }
    function Uppercase(value) {
      return value.toUpperCase();
    }
    function Lowercase(value) {
      return value.toLowerCase();
    }
    function IntrinsicTemplateLiteral(schema4, mode) {
      const expression = TemplateLiteralParser.ParseExact(schema4.pattern);
      const finite = TemplateLiteralFinite.Check(expression);
      if (!finite)
        return { ...schema4, pattern: IntrinsicLiteral(schema4.pattern, mode) };
      const strings = [...TemplateLiteralGenerator.Generate(expression)];
      const literals = strings.map((value) => exports.Type.Literal(value));
      const mapped = IntrinsicRest(literals, mode);
      const union2 = exports.Type.Union(mapped);
      return exports.Type.TemplateLiteral([union2]);
    }
    function IntrinsicLiteral(value, mode) {
      return typeof value === "string" ? mode === "Uncapitalize" ? Uncapitalize(value) : mode === "Capitalize" ? Capitalize(value) : mode === "Uppercase" ? Uppercase(value) : mode === "Lowercase" ? Lowercase(value) : value : value.toString();
    }
    function IntrinsicRest(schema4, mode) {
      if (schema4.length === 0)
        return [];
      const [L2, ...R2] = schema4;
      return [Map2(L2, mode), ...IntrinsicRest(R2, mode)];
    }
    function Visit(schema4, mode) {
      return TypeGuard.TTemplateLiteral(schema4) ? IntrinsicTemplateLiteral(schema4, mode) : TypeGuard.TUnion(schema4) ? exports.Type.Union(IntrinsicRest(schema4.anyOf, mode)) : TypeGuard.TLiteral(schema4) ? exports.Type.Literal(IntrinsicLiteral(schema4.const, mode)) : schema4;
    }
    function Map2(schema4, mode) {
      return Visit(schema4, mode);
    }
    Intrinsic2.Map = Map2;
  })(Intrinsic || (exports.Intrinsic = Intrinsic = {}));
  var ObjectMap;
  (function(ObjectMap2) {
    function TIntersect(schema4, callback) {
      return exports.Type.Intersect(schema4.allOf.map((inner) => Visit(inner, callback)), { ...schema4 });
    }
    function TUnion(schema4, callback) {
      return exports.Type.Union(schema4.anyOf.map((inner) => Visit(inner, callback)), { ...schema4 });
    }
    function TObject(schema4, callback) {
      return callback(schema4);
    }
    function Visit(schema4, callback) {
      return schema4[exports.Kind] === "Intersect" ? TIntersect(schema4, callback) : schema4[exports.Kind] === "Union" ? TUnion(schema4, callback) : schema4[exports.Kind] === "Object" ? TObject(schema4, callback) : schema4;
    }
    function Map2(schema4, callback, options) {
      return { ...Visit(TypeClone.Type(schema4), callback), ...options };
    }
    ObjectMap2.Map = Map2;
  })(ObjectMap || (exports.ObjectMap = ObjectMap = {}));
  var KeyResolver;
  (function(KeyResolver2) {
    function UnwrapPattern(key) {
      return key[0] === "^" && key[key.length - 1] === "$" ? key.slice(1, key.length - 1) : key;
    }
    function TIntersect(schema4, options) {
      return schema4.allOf.reduce((acc, schema5) => [...acc, ...Visit(schema5, options)], []);
    }
    function TUnion(schema4, options) {
      const sets = schema4.anyOf.map((inner) => Visit(inner, options));
      return [...sets.reduce((set, outer) => outer.map((key) => sets.every((inner) => inner.includes(key)) ? set.add(key) : set)[0], new Set)];
    }
    function TObject(schema4, options) {
      return Object.getOwnPropertyNames(schema4.properties);
    }
    function TRecord(schema4, options) {
      return options.includePatterns ? Object.getOwnPropertyNames(schema4.patternProperties) : [];
    }
    function Visit(schema4, options) {
      return TypeGuard.TIntersect(schema4) ? TIntersect(schema4, options) : TypeGuard.TUnion(schema4) ? TUnion(schema4, options) : TypeGuard.TObject(schema4) ? TObject(schema4, options) : TypeGuard.TRecord(schema4) ? TRecord(schema4, options) : [];
    }
    function ResolveKeys(schema4, options) {
      return [...new Set(Visit(schema4, options))];
    }
    KeyResolver2.ResolveKeys = ResolveKeys;
    function ResolvePattern(schema4) {
      const keys = ResolveKeys(schema4, { includePatterns: true });
      const pattern = keys.map((key) => `(${UnwrapPattern(key)})`);
      return `^(${pattern.join("|")})\$`;
    }
    KeyResolver2.ResolvePattern = ResolvePattern;
  })(KeyResolver || (exports.KeyResolver = KeyResolver = {}));

  class KeyArrayResolverError extends TypeBoxError {
  }
  exports.KeyArrayResolverError = KeyArrayResolverError;
  var KeyArrayResolver;
  (function(KeyArrayResolver2) {
    function Resolve(schema4) {
      return Array.isArray(schema4) ? schema4 : TypeGuard.TUnionLiteral(schema4) ? schema4.anyOf.map((schema5) => schema5.const.toString()) : TypeGuard.TLiteral(schema4) ? [schema4.const] : TypeGuard.TTemplateLiteral(schema4) ? (() => {
        const expression = TemplateLiteralParser.ParseExact(schema4.pattern);
        if (!TemplateLiteralFinite.Check(expression))
          throw new KeyArrayResolverError("Cannot resolve keys from infinite template expression");
        return [...TemplateLiteralGenerator.Generate(expression)];
      })() : [];
    }
    KeyArrayResolver2.Resolve = Resolve;
  })(KeyArrayResolver || (exports.KeyArrayResolver = KeyArrayResolver = {}));
  var UnionResolver;
  (function(UnionResolver2) {
    function* TUnion(union2) {
      for (const schema4 of union2.anyOf) {
        if (schema4[exports.Kind] === "Union") {
          yield* TUnion(schema4);
        } else {
          yield schema4;
        }
      }
    }
    function Resolve(union2) {
      return exports.Type.Union([...TUnion(union2)], { ...union2 });
    }
    UnionResolver2.Resolve = Resolve;
  })(UnionResolver || (exports.UnionResolver = UnionResolver = {}));

  class TemplateLiteralPatternError extends TypeBoxError {
  }
  exports.TemplateLiteralPatternError = TemplateLiteralPatternError;
  var TemplateLiteralPattern;
  (function(TemplateLiteralPattern2) {
    function Throw(message2) {
      throw new TemplateLiteralPatternError(message2);
    }
    function Escape(value) {
      return value.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }
    function Visit(schema4, acc) {
      return TypeGuard.TTemplateLiteral(schema4) ? schema4.pattern.slice(1, schema4.pattern.length - 1) : TypeGuard.TUnion(schema4) ? `(${schema4.anyOf.map((schema5) => Visit(schema5, acc)).join("|")})` : TypeGuard.TNumber(schema4) ? `${acc}${exports.PatternNumber}` : TypeGuard.TInteger(schema4) ? `${acc}${exports.PatternNumber}` : TypeGuard.TBigInt(schema4) ? `${acc}${exports.PatternNumber}` : TypeGuard.TString(schema4) ? `${acc}${exports.PatternString}` : TypeGuard.TLiteral(schema4) ? `${acc}${Escape(schema4.const.toString())}` : TypeGuard.TBoolean(schema4) ? `${acc}${exports.PatternBoolean}` : Throw(`Unexpected Kind '${schema4[exports.Kind]}'`);
    }
    function Create(kinds) {
      return `^${kinds.map((schema4) => Visit(schema4, "")).join("")}$`;
    }
    TemplateLiteralPattern2.Create = Create;
  })(TemplateLiteralPattern || (exports.TemplateLiteralPattern = TemplateLiteralPattern = {}));
  var TemplateLiteralResolver;
  (function(TemplateLiteralResolver2) {
    function Resolve(template) {
      const expression = TemplateLiteralParser.ParseExact(template.pattern);
      if (!TemplateLiteralFinite.Check(expression))
        return exports.Type.String();
      const literals = [...TemplateLiteralGenerator.Generate(expression)].map((value) => exports.Type.Literal(value));
      return exports.Type.Union(literals);
    }
    TemplateLiteralResolver2.Resolve = Resolve;
  })(TemplateLiteralResolver || (exports.TemplateLiteralResolver = TemplateLiteralResolver = {}));

  class TemplateLiteralParserError extends TypeBoxError {
  }
  exports.TemplateLiteralParserError = TemplateLiteralParserError;
  var TemplateLiteralParser;
  (function(TemplateLiteralParser2) {
    function IsNonEscaped(pattern, index, char) {
      return pattern[index] === char && pattern.charCodeAt(index - 1) !== 92;
    }
    function IsOpenParen(pattern, index) {
      return IsNonEscaped(pattern, index, "(");
    }
    function IsCloseParen(pattern, index) {
      return IsNonEscaped(pattern, index, ")");
    }
    function IsSeparator(pattern, index) {
      return IsNonEscaped(pattern, index, "|");
    }
    function IsGroup(pattern) {
      if (!(IsOpenParen(pattern, 0) && IsCloseParen(pattern, pattern.length - 1)))
        return false;
      let count2 = 0;
      for (let index = 0;index < pattern.length; index++) {
        if (IsOpenParen(pattern, index))
          count2 += 1;
        if (IsCloseParen(pattern, index))
          count2 -= 1;
        if (count2 === 0 && index !== pattern.length - 1)
          return false;
      }
      return true;
    }
    function InGroup(pattern) {
      return pattern.slice(1, pattern.length - 1);
    }
    function IsPrecedenceOr(pattern) {
      let count2 = 0;
      for (let index = 0;index < pattern.length; index++) {
        if (IsOpenParen(pattern, index))
          count2 += 1;
        if (IsCloseParen(pattern, index))
          count2 -= 1;
        if (IsSeparator(pattern, index) && count2 === 0)
          return true;
      }
      return false;
    }
    function IsPrecedenceAnd(pattern) {
      for (let index = 0;index < pattern.length; index++) {
        if (IsOpenParen(pattern, index))
          return true;
      }
      return false;
    }
    function Or(pattern) {
      let [count2, start] = [0, 0];
      const expressions2 = [];
      for (let index = 0;index < pattern.length; index++) {
        if (IsOpenParen(pattern, index))
          count2 += 1;
        if (IsCloseParen(pattern, index))
          count2 -= 1;
        if (IsSeparator(pattern, index) && count2 === 0) {
          const range2 = pattern.slice(start, index);
          if (range2.length > 0)
            expressions2.push(Parse(range2));
          start = index + 1;
        }
      }
      const range = pattern.slice(start);
      if (range.length > 0)
        expressions2.push(Parse(range));
      if (expressions2.length === 0)
        return { type: "const", const: "" };
      if (expressions2.length === 1)
        return expressions2[0];
      return { type: "or", expr: expressions2 };
    }
    function And(pattern) {
      function Group(value, index) {
        if (!IsOpenParen(value, index))
          throw new TemplateLiteralParserError(`TemplateLiteralParser: Index must point to open parens`);
        let count2 = 0;
        for (let scan = index;scan < value.length; scan++) {
          if (IsOpenParen(value, scan))
            count2 += 1;
          if (IsCloseParen(value, scan))
            count2 -= 1;
          if (count2 === 0)
            return [index, scan];
        }
        throw new TemplateLiteralParserError(`TemplateLiteralParser: Unclosed group parens in expression`);
      }
      function Range(pattern2, index) {
        for (let scan = index;scan < pattern2.length; scan++) {
          if (IsOpenParen(pattern2, scan))
            return [index, scan];
        }
        return [index, pattern2.length];
      }
      const expressions2 = [];
      for (let index = 0;index < pattern.length; index++) {
        if (IsOpenParen(pattern, index)) {
          const [start, end] = Group(pattern, index);
          const range = pattern.slice(start, end + 1);
          expressions2.push(Parse(range));
          index = end;
        } else {
          const [start, end] = Range(pattern, index);
          const range = pattern.slice(start, end);
          if (range.length > 0)
            expressions2.push(Parse(range));
          index = end - 1;
        }
      }
      return expressions2.length === 0 ? { type: "const", const: "" } : expressions2.length === 1 ? expressions2[0] : { type: "and", expr: expressions2 };
    }
    function Parse(pattern) {
      return IsGroup(pattern) ? Parse(InGroup(pattern)) : IsPrecedenceOr(pattern) ? Or(pattern) : IsPrecedenceAnd(pattern) ? And(pattern) : { type: "const", const: pattern };
    }
    TemplateLiteralParser2.Parse = Parse;
    function ParseExact(pattern) {
      return Parse(pattern.slice(1, pattern.length - 1));
    }
    TemplateLiteralParser2.ParseExact = ParseExact;
  })(TemplateLiteralParser || (exports.TemplateLiteralParser = TemplateLiteralParser = {}));

  class TemplateLiteralFiniteError extends TypeBoxError {
  }
  exports.TemplateLiteralFiniteError = TemplateLiteralFiniteError;
  var TemplateLiteralFinite;
  (function(TemplateLiteralFinite2) {
    function Throw(message2) {
      throw new TemplateLiteralFiniteError(message2);
    }
    function IsNumber(expression) {
      return expression.type === "or" && expression.expr.length === 2 && expression.expr[0].type === "const" && expression.expr[0].const === "0" && expression.expr[1].type === "const" && expression.expr[1].const === "[1-9][0-9]*";
    }
    function IsBoolean(expression) {
      return expression.type === "or" && expression.expr.length === 2 && expression.expr[0].type === "const" && expression.expr[0].const === "true" && expression.expr[1].type === "const" && expression.expr[1].const === "false";
    }
    function IsString(expression) {
      return expression.type === "const" && expression.const === ".*";
    }
    function Check(expression) {
      return IsBoolean(expression) ? true : IsNumber(expression) || IsString(expression) ? false : expression.type === "and" ? expression.expr.every((expr) => Check(expr)) : expression.type === "or" ? expression.expr.every((expr) => Check(expr)) : expression.type === "const" ? true : Throw(`Unknown expression type`);
    }
    TemplateLiteralFinite2.Check = Check;
  })(TemplateLiteralFinite || (exports.TemplateLiteralFinite = TemplateLiteralFinite = {}));

  class TemplateLiteralGeneratorError extends TypeBoxError {
  }
  exports.TemplateLiteralGeneratorError = TemplateLiteralGeneratorError;
  var TemplateLiteralGenerator;
  (function(TemplateLiteralGenerator2) {
    function* Reduce(buffer2) {
      if (buffer2.length === 1)
        return yield* buffer2[0];
      for (const left of buffer2[0]) {
        for (const right of Reduce(buffer2.slice(1))) {
          yield `${left}${right}`;
        }
      }
    }
    function* And(expression) {
      return yield* Reduce(expression.expr.map((expr) => [...Generate(expr)]));
    }
    function* Or(expression) {
      for (const expr of expression.expr)
        yield* Generate(expr);
    }
    function* Const(expression) {
      return yield expression.const;
    }
    function* Generate(expression) {
      return expression.type === "and" ? yield* And(expression) : expression.type === "or" ? yield* Or(expression) : expression.type === "const" ? yield* Const(expression) : (() => {
        throw new TemplateLiteralGeneratorError("Unknown expression");
      })();
    }
    TemplateLiteralGenerator2.Generate = Generate;
  })(TemplateLiteralGenerator || (exports.TemplateLiteralGenerator = TemplateLiteralGenerator = {}));
  var TemplateLiteralDslParser;
  (function(TemplateLiteralDslParser2) {
    function* ParseUnion(template) {
      const trim = template.trim().replace(/"|'/g, "");
      return trim === "boolean" ? yield exports.Type.Boolean() : trim === "number" ? yield exports.Type.Number() : trim === "bigint" ? yield exports.Type.BigInt() : trim === "string" ? yield exports.Type.String() : yield (() => {
        const literals = trim.split("|").map((literal) => exports.Type.Literal(literal.trim()));
        return literals.length === 0 ? exports.Type.Never() : literals.length === 1 ? literals[0] : exports.Type.Union(literals);
      })();
    }
    function* ParseTerminal(template) {
      if (template[1] !== "{") {
        const L2 = exports.Type.Literal("$");
        const R2 = ParseLiteral(template.slice(1));
        return yield* [L2, ...R2];
      }
      for (let i = 2;i < template.length; i++) {
        if (template[i] === "}") {
          const L2 = ParseUnion(template.slice(2, i));
          const R2 = ParseLiteral(template.slice(i + 1));
          return yield* [...L2, ...R2];
        }
      }
      yield exports.Type.Literal(template);
    }
    function* ParseLiteral(template) {
      for (let i = 0;i < template.length; i++) {
        if (template[i] === "$") {
          const L2 = exports.Type.Literal(template.slice(0, i));
          const R2 = ParseTerminal(template.slice(i));
          return yield* [L2, ...R2];
        }
      }
      yield exports.Type.Literal(template);
    }
    function Parse(template_dsl) {
      return [...ParseLiteral(template_dsl)];
    }
    TemplateLiteralDslParser2.Parse = Parse;
  })(TemplateLiteralDslParser || (exports.TemplateLiteralDslParser = TemplateLiteralDslParser = {}));

  class TransformDecodeBuilder {
    constructor(schema4) {
      this.schema = schema4;
    }
    Decode(decode3) {
      return new TransformEncodeBuilder(this.schema, decode3);
    }
  }
  exports.TransformDecodeBuilder = TransformDecodeBuilder;

  class TransformEncodeBuilder {
    constructor(schema4, decode3) {
      this.schema = schema4;
      this.decode = decode3;
    }
    Encode(encode3) {
      const schema4 = TypeClone.Type(this.schema);
      return TypeGuard.TTransform(schema4) ? (() => {
        const Encode = (value) => schema4[exports.Transform].Encode(encode3(value));
        const Decode = (value) => this.decode(schema4[exports.Transform].Decode(value));
        const Codec = { Encode, Decode };
        return { ...schema4, [exports.Transform]: Codec };
      })() : (() => {
        const Codec = { Decode: this.decode, Encode: encode3 };
        return { ...schema4, [exports.Transform]: Codec };
      })();
    }
  }
  exports.TransformEncodeBuilder = TransformEncodeBuilder;
  var TypeOrdinal = 0;

  class TypeBuilderError extends TypeBoxError {
  }
  exports.TypeBuilderError = TypeBuilderError;

  class TypeBuilder {
    Create(schema4) {
      return schema4;
    }
    Throw(message2) {
      throw new TypeBuilderError(message2);
    }
    Discard(record, keys) {
      return keys.reduce((acc, key) => {
        const { [key]: _, ...rest } = acc;
        return rest;
      }, record);
    }
    Strict(schema4) {
      return JSON.parse(JSON.stringify(schema4));
    }
  }
  exports.TypeBuilder = TypeBuilder;

  class JsonTypeBuilder extends TypeBuilder {
    ReadonlyOptional(schema4) {
      return this.Readonly(this.Optional(schema4));
    }
    Readonly(schema4) {
      return { ...TypeClone.Type(schema4), [exports.Readonly]: "Readonly" };
    }
    Optional(schema4) {
      return { ...TypeClone.Type(schema4), [exports.Optional]: "Optional" };
    }
    Any(options = {}) {
      return this.Create({ ...options, [exports.Kind]: "Any" });
    }
    Array(schema4, options = {}) {
      return this.Create({ ...options, [exports.Kind]: "Array", type: "array", items: TypeClone.Type(schema4) });
    }
    Boolean(options = {}) {
      return this.Create({ ...options, [exports.Kind]: "Boolean", type: "boolean" });
    }
    Capitalize(schema4, options = {}) {
      return { ...Intrinsic.Map(TypeClone.Type(schema4), "Capitalize"), ...options };
    }
    Composite(objects, options) {
      const intersect2 = exports.Type.Intersect(objects, {});
      const keys = KeyResolver.ResolveKeys(intersect2, { includePatterns: false });
      const properties = keys.reduce((acc, key) => ({ ...acc, [key]: exports.Type.Index(intersect2, [key]) }), {});
      return exports.Type.Object(properties, options);
    }
    Enum(item, options = {}) {
      if (ValueGuard.IsUndefined(item))
        return this.Throw("Enum undefined or empty");
      const values1 = Object.getOwnPropertyNames(item).filter((key) => isNaN(key)).map((key) => item[key]);
      const values2 = [...new Set(values1)];
      const anyOf = values2.map((value) => exports.Type.Literal(value));
      return this.Union(anyOf, { ...options, [exports.Hint]: "Enum" });
    }
    Extends(left, right, trueType, falseType, options = {}) {
      switch (TypeExtends.Extends(left, right)) {
        case TypeExtendsResult.Union:
          return this.Union([TypeClone.Type(trueType, options), TypeClone.Type(falseType, options)]);
        case TypeExtendsResult.True:
          return TypeClone.Type(trueType, options);
        case TypeExtendsResult.False:
          return TypeClone.Type(falseType, options);
      }
    }
    Exclude(unionType2, excludedMembers, options = {}) {
      return TypeGuard.TTemplateLiteral(unionType2) ? this.Exclude(TemplateLiteralResolver.Resolve(unionType2), excludedMembers, options) : TypeGuard.TTemplateLiteral(excludedMembers) ? this.Exclude(unionType2, TemplateLiteralResolver.Resolve(excludedMembers), options) : TypeGuard.TUnion(unionType2) ? (() => {
        const narrowed = unionType2.anyOf.filter((inner) => TypeExtends.Extends(inner, excludedMembers) === TypeExtendsResult.False);
        return narrowed.length === 1 ? TypeClone.Type(narrowed[0], options) : this.Union(narrowed, options);
      })() : TypeExtends.Extends(unionType2, excludedMembers) !== TypeExtendsResult.False ? this.Never(options) : TypeClone.Type(unionType2, options);
    }
    Extract(type, union2, options = {}) {
      return TypeGuard.TTemplateLiteral(type) ? this.Extract(TemplateLiteralResolver.Resolve(type), union2, options) : TypeGuard.TTemplateLiteral(union2) ? this.Extract(type, TemplateLiteralResolver.Resolve(union2), options) : TypeGuard.TUnion(type) ? (() => {
        const narrowed = type.anyOf.filter((inner) => TypeExtends.Extends(inner, union2) !== TypeExtendsResult.False);
        return narrowed.length === 1 ? TypeClone.Type(narrowed[0], options) : this.Union(narrowed, options);
      })() : TypeExtends.Extends(type, union2) !== TypeExtendsResult.False ? TypeClone.Type(type, options) : this.Never(options);
    }
    Index(schema4, unresolved, options = {}) {
      return TypeGuard.TArray(schema4) && TypeGuard.TNumber(unresolved) ? (() => {
        return TypeClone.Type(schema4.items, options);
      })() : TypeGuard.TTuple(schema4) && TypeGuard.TNumber(unresolved) ? (() => {
        const items = ValueGuard.IsUndefined(schema4.items) ? [] : schema4.items;
        const cloned = items.map((schema5) => TypeClone.Type(schema5));
        return this.Union(cloned, options);
      })() : (() => {
        const keys = KeyArrayResolver.Resolve(unresolved);
        const clone = TypeClone.Type(schema4);
        return IndexedAccessor.Resolve(clone, keys, options);
      })();
    }
    Integer(options = {}) {
      return this.Create({ ...options, [exports.Kind]: "Integer", type: "integer" });
    }
    Intersect(allOf, options = {}) {
      if (allOf.length === 0)
        return exports.Type.Never();
      if (allOf.length === 1)
        return TypeClone.Type(allOf[0], options);
      if (allOf.some((schema4) => TypeGuard.TTransform(schema4)))
        this.Throw("Cannot intersect transform types");
      const objects = allOf.every((schema4) => TypeGuard.TObject(schema4));
      const cloned = TypeClone.Rest(allOf);
      const clonedUnevaluatedProperties = TypeGuard.TSchema(options.unevaluatedProperties) ? { unevaluatedProperties: TypeClone.Type(options.unevaluatedProperties) } : {};
      return options.unevaluatedProperties === false || TypeGuard.TSchema(options.unevaluatedProperties) || objects ? this.Create({ ...options, ...clonedUnevaluatedProperties, [exports.Kind]: "Intersect", type: "object", allOf: cloned }) : this.Create({ ...options, ...clonedUnevaluatedProperties, [exports.Kind]: "Intersect", allOf: cloned });
    }
    KeyOf(schema4, options = {}) {
      return TypeGuard.TRecord(schema4) ? (() => {
        const pattern = Object.getOwnPropertyNames(schema4.patternProperties)[0];
        return pattern === exports.PatternNumberExact ? this.Number(options) : pattern === exports.PatternStringExact ? this.String(options) : this.Throw("Unable to resolve key type from Record key pattern");
      })() : TypeGuard.TTuple(schema4) ? (() => {
        const items = ValueGuard.IsUndefined(schema4.items) ? [] : schema4.items;
        const literals = items.map((_, index) => exports.Type.Literal(index.toString()));
        return this.Union(literals, options);
      })() : TypeGuard.TArray(schema4) ? (() => {
        return this.Number(options);
      })() : (() => {
        const keys = KeyResolver.ResolveKeys(schema4, { includePatterns: false });
        if (keys.length === 0)
          return this.Never(options);
        const literals = keys.map((key) => this.Literal(key));
        return this.Union(literals, options);
      })();
    }
    Literal(value, options = {}) {
      return this.Create({ ...options, [exports.Kind]: "Literal", const: value, type: typeof value });
    }
    Lowercase(schema4, options = {}) {
      return { ...Intrinsic.Map(TypeClone.Type(schema4), "Lowercase"), ...options };
    }
    Never(options = {}) {
      return this.Create({ ...options, [exports.Kind]: "Never", not: {} });
    }
    Not(schema4, options) {
      return this.Create({ ...options, [exports.Kind]: "Not", not: TypeClone.Type(schema4) });
    }
    Null(options = {}) {
      return this.Create({ ...options, [exports.Kind]: "Null", type: "null" });
    }
    Number(options = {}) {
      return this.Create({ ...options, [exports.Kind]: "Number", type: "number" });
    }
    Object(properties, options = {}) {
      const propertyKeys = Object.getOwnPropertyNames(properties);
      const optionalKeys = propertyKeys.filter((key) => TypeGuard.TOptional(properties[key]));
      const requiredKeys = propertyKeys.filter((name) => !optionalKeys.includes(name));
      const clonedAdditionalProperties = TypeGuard.TSchema(options.additionalProperties) ? { additionalProperties: TypeClone.Type(options.additionalProperties) } : {};
      const clonedProperties = propertyKeys.reduce((acc, key) => ({ ...acc, [key]: TypeClone.Type(properties[key]) }), {});
      return requiredKeys.length > 0 ? this.Create({ ...options, ...clonedAdditionalProperties, [exports.Kind]: "Object", type: "object", properties: clonedProperties, required: requiredKeys }) : this.Create({ ...options, ...clonedAdditionalProperties, [exports.Kind]: "Object", type: "object", properties: clonedProperties });
    }
    Omit(schema4, unresolved, options = {}) {
      const keys = KeyArrayResolver.Resolve(unresolved);
      return ObjectMap.Map(this.Discard(TypeClone.Type(schema4), ["$id", exports.Transform]), (object) => {
        if (ValueGuard.IsArray(object.required)) {
          object.required = object.required.filter((key) => !keys.includes(key));
          if (object.required.length === 0)
            delete object.required;
        }
        for (const key of Object.getOwnPropertyNames(object.properties)) {
          if (keys.includes(key))
            delete object.properties[key];
        }
        return this.Create(object);
      }, options);
    }
    Partial(schema4, options = {}) {
      return ObjectMap.Map(this.Discard(TypeClone.Type(schema4), ["$id", exports.Transform]), (object) => {
        const properties = Object.getOwnPropertyNames(object.properties).reduce((acc, key) => {
          return { ...acc, [key]: this.Optional(object.properties[key]) };
        }, {});
        return this.Object(properties, this.Discard(object, ["required"]));
      }, options);
    }
    Pick(schema4, unresolved, options = {}) {
      const keys = KeyArrayResolver.Resolve(unresolved);
      return ObjectMap.Map(this.Discard(TypeClone.Type(schema4), ["$id", exports.Transform]), (object) => {
        if (ValueGuard.IsArray(object.required)) {
          object.required = object.required.filter((key) => keys.includes(key));
          if (object.required.length === 0)
            delete object.required;
        }
        for (const key of Object.getOwnPropertyNames(object.properties)) {
          if (!keys.includes(key))
            delete object.properties[key];
        }
        return this.Create(object);
      }, options);
    }
    Record(key, schema4, options = {}) {
      return TypeGuard.TTemplateLiteral(key) ? (() => {
        const expression = TemplateLiteralParser.ParseExact(key.pattern);
        return TemplateLiteralFinite.Check(expression) ? this.Object([...TemplateLiteralGenerator.Generate(expression)].reduce((acc, key2) => ({ ...acc, [key2]: TypeClone.Type(schema4) }), {}), options) : this.Create({ ...options, [exports.Kind]: "Record", type: "object", patternProperties: { [key.pattern]: TypeClone.Type(schema4) } });
      })() : TypeGuard.TUnion(key) ? (() => {
        const union2 = UnionResolver.Resolve(key);
        if (TypeGuard.TUnionLiteral(union2)) {
          const properties = union2.anyOf.reduce((acc, literal) => ({ ...acc, [literal.const]: TypeClone.Type(schema4) }), {});
          return this.Object(properties, { ...options, [exports.Hint]: "Record" });
        } else
          this.Throw("Record key of type union contains non-literal types");
      })() : TypeGuard.TLiteral(key) ? (() => {
        return ValueGuard.IsString(key.const) || ValueGuard.IsNumber(key.const) ? this.Object({ [key.const]: TypeClone.Type(schema4) }, options) : this.Throw("Record key of type literal is not of type string or number");
      })() : TypeGuard.TInteger(key) || TypeGuard.TNumber(key) ? (() => {
        return this.Create({ ...options, [exports.Kind]: "Record", type: "object", patternProperties: { [exports.PatternNumberExact]: TypeClone.Type(schema4) } });
      })() : TypeGuard.TString(key) ? (() => {
        const pattern = ValueGuard.IsUndefined(key.pattern) ? exports.PatternStringExact : key.pattern;
        return this.Create({ ...options, [exports.Kind]: "Record", type: "object", patternProperties: { [pattern]: TypeClone.Type(schema4) } });
      })() : this.Never();
    }
    Recursive(callback, options = {}) {
      if (ValueGuard.IsUndefined(options.$id))
        options.$id = `T${TypeOrdinal++}`;
      const thisType = callback({ [exports.Kind]: "This", $ref: `${options.$id}` });
      thisType.$id = options.$id;
      return this.Create({ ...options, [exports.Hint]: "Recursive", ...thisType });
    }
    Ref(unresolved, options = {}) {
      if (ValueGuard.IsString(unresolved))
        return this.Create({ ...options, [exports.Kind]: "Ref", $ref: unresolved });
      if (ValueGuard.IsUndefined(unresolved.$id))
        this.Throw("Reference target type must specify an $id");
      return this.Create({ ...options, [exports.Kind]: "Ref", $ref: unresolved.$id });
    }
    Required(schema4, options = {}) {
      return ObjectMap.Map(this.Discard(TypeClone.Type(schema4), ["$id", exports.Transform]), (object) => {
        const properties = Object.getOwnPropertyNames(object.properties).reduce((acc, key) => {
          return { ...acc, [key]: this.Discard(object.properties[key], [exports.Optional]) };
        }, {});
        return this.Object(properties, object);
      }, options);
    }
    Rest(schema4) {
      return TypeGuard.TTuple(schema4) && !ValueGuard.IsUndefined(schema4.items) ? TypeClone.Rest(schema4.items) : TypeGuard.TIntersect(schema4) ? TypeClone.Rest(schema4.allOf) : TypeGuard.TUnion(schema4) ? TypeClone.Rest(schema4.anyOf) : [];
    }
    String(options = {}) {
      return this.Create({ ...options, [exports.Kind]: "String", type: "string" });
    }
    TemplateLiteral(unresolved, options = {}) {
      const pattern = ValueGuard.IsString(unresolved) ? TemplateLiteralPattern.Create(TemplateLiteralDslParser.Parse(unresolved)) : TemplateLiteralPattern.Create(unresolved);
      return this.Create({ ...options, [exports.Kind]: "TemplateLiteral", type: "string", pattern });
    }
    Transform(schema4) {
      return new TransformDecodeBuilder(schema4);
    }
    Tuple(items, options = {}) {
      const [additionalItems, minItems, maxItems] = [false, items.length, items.length];
      const clonedItems = TypeClone.Rest(items);
      const schema4 = items.length > 0 ? { ...options, [exports.Kind]: "Tuple", type: "array", items: clonedItems, additionalItems, minItems, maxItems } : { ...options, [exports.Kind]: "Tuple", type: "array", minItems, maxItems };
      return this.Create(schema4);
    }
    Uncapitalize(schema4, options = {}) {
      return { ...Intrinsic.Map(TypeClone.Type(schema4), "Uncapitalize"), ...options };
    }
    Union(union2, options = {}) {
      return TypeGuard.TTemplateLiteral(union2) ? TemplateLiteralResolver.Resolve(union2) : (() => {
        const anyOf = union2;
        if (anyOf.length === 0)
          return this.Never(options);
        if (anyOf.length === 1)
          return this.Create(TypeClone.Type(anyOf[0], options));
        const clonedAnyOf = TypeClone.Rest(anyOf);
        return this.Create({ ...options, [exports.Kind]: "Union", anyOf: clonedAnyOf });
      })();
    }
    Unknown(options = {}) {
      return this.Create({ ...options, [exports.Kind]: "Unknown" });
    }
    Unsafe(options = {}) {
      return this.Create({ ...options, [exports.Kind]: options[exports.Kind] || "Unsafe" });
    }
    Uppercase(schema4, options = {}) {
      return { ...Intrinsic.Map(TypeClone.Type(schema4), "Uppercase"), ...options };
    }
  }
  exports.JsonTypeBuilder = JsonTypeBuilder;

  class JavaScriptTypeBuilder extends JsonTypeBuilder {
    AsyncIterator(items, options = {}) {
      return this.Create({ ...options, [exports.Kind]: "AsyncIterator", type: "AsyncIterator", items: TypeClone.Type(items) });
    }
    Awaited(schema4, options = {}) {
      const Unwrap = (rest) => rest.length > 0 ? (() => {
        const [L2, ...R2] = rest;
        return [this.Awaited(L2), ...Unwrap(R2)];
      })() : rest;
      return TypeGuard.TIntersect(schema4) ? exports.Type.Intersect(Unwrap(schema4.allOf)) : TypeGuard.TUnion(schema4) ? exports.Type.Union(Unwrap(schema4.anyOf)) : TypeGuard.TPromise(schema4) ? this.Awaited(schema4.item) : TypeClone.Type(schema4, options);
    }
    BigInt(options = {}) {
      return this.Create({ ...options, [exports.Kind]: "BigInt", type: "bigint" });
    }
    ConstructorParameters(schema4, options = {}) {
      return this.Tuple([...schema4.parameters], { ...options });
    }
    Constructor(parameters, returns, options) {
      const [clonedParameters, clonedReturns] = [TypeClone.Rest(parameters), TypeClone.Type(returns)];
      return this.Create({ ...options, [exports.Kind]: "Constructor", type: "Constructor", parameters: clonedParameters, returns: clonedReturns });
    }
    Date(options = {}) {
      return this.Create({ ...options, [exports.Kind]: "Date", type: "Date" });
    }
    Function(parameters, returns, options) {
      const [clonedParameters, clonedReturns] = [TypeClone.Rest(parameters), TypeClone.Type(returns)];
      return this.Create({ ...options, [exports.Kind]: "Function", type: "Function", parameters: clonedParameters, returns: clonedReturns });
    }
    InstanceType(schema4, options = {}) {
      return TypeClone.Type(schema4.returns, options);
    }
    Iterator(items, options = {}) {
      return this.Create({ ...options, [exports.Kind]: "Iterator", type: "Iterator", items: TypeClone.Type(items) });
    }
    Parameters(schema4, options = {}) {
      return this.Tuple(schema4.parameters, { ...options });
    }
    Promise(item, options = {}) {
      return this.Create({ ...options, [exports.Kind]: "Promise", type: "Promise", item: TypeClone.Type(item) });
    }
    RegExp(unresolved, options = {}) {
      const pattern = ValueGuard.IsString(unresolved) ? unresolved : unresolved.source;
      return this.Create({ ...options, [exports.Kind]: "String", type: "string", pattern });
    }
    RegEx(regex, options = {}) {
      return this.RegExp(regex, options);
    }
    ReturnType(schema4, options = {}) {
      return TypeClone.Type(schema4.returns, options);
    }
    Symbol(options) {
      return this.Create({ ...options, [exports.Kind]: "Symbol", type: "symbol" });
    }
    Undefined(options = {}) {
      return this.Create({ ...options, [exports.Kind]: "Undefined", type: "undefined" });
    }
    Uint8Array(options = {}) {
      return this.Create({ ...options, [exports.Kind]: "Uint8Array", type: "Uint8Array" });
    }
    Void(options = {}) {
      return this.Create({ ...options, [exports.Kind]: "Void", type: "void" });
    }
  }
  exports.JavaScriptTypeBuilder = JavaScriptTypeBuilder;
  exports.JsonType = new JsonTypeBuilder;
  exports.Type = new JavaScriptTypeBuilder;
});

// node_modules/dayjs/dayjs.min.js
var require_dayjs_min = __commonJS((exports, module) => {
  (function(t2, e2) {
    typeof exports == "object" && typeof module != "undefined" ? module.exports = e2() : typeof define == "function" && define.amd ? define(e2) : (t2 = typeof globalThis != "undefined" ? globalThis : t2 || self).dayjs = e2();
  })(exports, function() {
    var t2 = 1000, e2 = 60000, n = 3600000, r = "millisecond", i = "second", s = "minute", u2 = "hour", a = "day", o2 = "week", c3 = "month", f2 = "quarter", h = "year", d2 = "date", l = "Invalid Date", $2 = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y2 = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M2 = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(t3) {
      var e3 = ["th", "st", "nd", "rd"], n2 = t3 % 100;
      return "[" + t3 + (e3[(n2 - 20) % 10] || e3[n2] || e3[0]) + "]";
    } }, m = function(t3, e3, n2) {
      var r2 = String(t3);
      return !r2 || r2.length >= e3 ? t3 : "" + Array(e3 + 1 - r2.length).join(n2) + t3;
    }, v = { s: m, z: function(t3) {
      var e3 = -t3.utcOffset(), n2 = Math.abs(e3), r2 = Math.floor(n2 / 60), i2 = n2 % 60;
      return (e3 <= 0 ? "+" : "-") + m(r2, 2, "0") + ":" + m(i2, 2, "0");
    }, m: function t(e3, n2) {
      if (e3.date() < n2.date())
        return -t(n2, e3);
      var r2 = 12 * (n2.year() - e3.year()) + (n2.month() - e3.month()), i2 = e3.clone().add(r2, c3), s2 = n2 - i2 < 0, u3 = e3.clone().add(r2 + (s2 ? -1 : 1), c3);
      return +(-(r2 + (n2 - i2) / (s2 ? i2 - u3 : u3 - i2)) || 0);
    }, a: function(t3) {
      return t3 < 0 ? Math.ceil(t3) || 0 : Math.floor(t3);
    }, p: function(t3) {
      return { M: c3, y: h, w: o2, d: a, D: d2, h: u2, m: s, s: i, ms: r, Q: f2 }[t3] || String(t3 || "").toLowerCase().replace(/s$/, "");
    }, u: function(t3) {
      return t3 === undefined;
    } }, g = "en", D = {};
    D[g] = M2;
    var p = "$isDayjsObject", S2 = function(t3) {
      return t3 instanceof _ || !(!t3 || !t3[p]);
    }, w = function t(e3, n2, r2) {
      var i2;
      if (!e3)
        return g;
      if (typeof e3 == "string") {
        var s2 = e3.toLowerCase();
        D[s2] && (i2 = s2), n2 && (D[s2] = n2, i2 = s2);
        var u3 = e3.split("-");
        if (!i2 && u3.length > 1)
          return t(u3[0]);
      } else {
        var a2 = e3.name;
        D[a2] = e3, i2 = a2;
      }
      return !r2 && i2 && (g = i2), i2 || !r2 && g;
    }, O = function(t3, e3) {
      if (S2(t3))
        return t3.clone();
      var n2 = typeof e3 == "object" ? e3 : {};
      return n2.date = t3, n2.args = arguments, new _(n2);
    }, b3 = v;
    b3.l = w, b3.i = S2, b3.w = function(t3, e3) {
      return O(t3, { locale: e3.$L, utc: e3.$u, x: e3.$x, $offset: e3.$offset });
    };
    var _ = function() {
      function M3(t3) {
        this.$L = w(t3.locale, null, true), this.parse(t3), this.$x = this.$x || t3.x || {}, this[p] = true;
      }
      var m2 = M3.prototype;
      return m2.parse = function(t3) {
        this.$d = function(t4) {
          var { date: e3, utc: n2 } = t4;
          if (e3 === null)
            return new Date(NaN);
          if (b3.u(e3))
            return new Date;
          if (e3 instanceof Date)
            return new Date(e3);
          if (typeof e3 == "string" && !/Z$/i.test(e3)) {
            var r2 = e3.match($2);
            if (r2) {
              var i2 = r2[2] - 1 || 0, s2 = (r2[7] || "0").substring(0, 3);
              return n2 ? new Date(Date.UTC(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s2)) : new Date(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s2);
            }
          }
          return new Date(e3);
        }(t3), this.init();
      }, m2.init = function() {
        var t3 = this.$d;
        this.$y = t3.getFullYear(), this.$M = t3.getMonth(), this.$D = t3.getDate(), this.$W = t3.getDay(), this.$H = t3.getHours(), this.$m = t3.getMinutes(), this.$s = t3.getSeconds(), this.$ms = t3.getMilliseconds();
      }, m2.$utils = function() {
        return b3;
      }, m2.isValid = function() {
        return !(this.$d.toString() === l);
      }, m2.isSame = function(t3, e3) {
        var n2 = O(t3);
        return this.startOf(e3) <= n2 && n2 <= this.endOf(e3);
      }, m2.isAfter = function(t3, e3) {
        return O(t3) < this.startOf(e3);
      }, m2.isBefore = function(t3, e3) {
        return this.endOf(e3) < O(t3);
      }, m2.$g = function(t3, e3, n2) {
        return b3.u(t3) ? this[e3] : this.set(n2, t3);
      }, m2.unix = function() {
        return Math.floor(this.valueOf() / 1000);
      }, m2.valueOf = function() {
        return this.$d.getTime();
      }, m2.startOf = function(t3, e3) {
        var n2 = this, r2 = !!b3.u(e3) || e3, f3 = b3.p(t3), l2 = function(t4, e4) {
          var i2 = b3.w(n2.$u ? Date.UTC(n2.$y, e4, t4) : new Date(n2.$y, e4, t4), n2);
          return r2 ? i2 : i2.endOf(a);
        }, $3 = function(t4, e4) {
          return b3.w(n2.toDate()[t4].apply(n2.toDate("s"), (r2 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e4)), n2);
        }, y3 = this.$W, M4 = this.$M, m3 = this.$D, v2 = "set" + (this.$u ? "UTC" : "");
        switch (f3) {
          case h:
            return r2 ? l2(1, 0) : l2(31, 11);
          case c3:
            return r2 ? l2(1, M4) : l2(0, M4 + 1);
          case o2:
            var g2 = this.$locale().weekStart || 0, D2 = (y3 < g2 ? y3 + 7 : y3) - g2;
            return l2(r2 ? m3 - D2 : m3 + (6 - D2), M4);
          case a:
          case d2:
            return $3(v2 + "Hours", 0);
          case u2:
            return $3(v2 + "Minutes", 1);
          case s:
            return $3(v2 + "Seconds", 2);
          case i:
            return $3(v2 + "Milliseconds", 3);
          default:
            return this.clone();
        }
      }, m2.endOf = function(t3) {
        return this.startOf(t3, false);
      }, m2.$set = function(t3, e3) {
        var n2, o3 = b3.p(t3), f3 = "set" + (this.$u ? "UTC" : ""), l2 = (n2 = {}, n2[a] = f3 + "Date", n2[d2] = f3 + "Date", n2[c3] = f3 + "Month", n2[h] = f3 + "FullYear", n2[u2] = f3 + "Hours", n2[s] = f3 + "Minutes", n2[i] = f3 + "Seconds", n2[r] = f3 + "Milliseconds", n2)[o3], $3 = o3 === a ? this.$D + (e3 - this.$W) : e3;
        if (o3 === c3 || o3 === h) {
          var y3 = this.clone().set(d2, 1);
          y3.$d[l2]($3), y3.init(), this.$d = y3.set(d2, Math.min(this.$D, y3.daysInMonth())).$d;
        } else
          l2 && this.$d[l2]($3);
        return this.init(), this;
      }, m2.set = function(t3, e3) {
        return this.clone().$set(t3, e3);
      }, m2.get = function(t3) {
        return this[b3.p(t3)]();
      }, m2.add = function(r2, f3) {
        var d3, l2 = this;
        r2 = Number(r2);
        var $3 = b3.p(f3), y3 = function(t3) {
          var e3 = O(l2);
          return b3.w(e3.date(e3.date() + Math.round(t3 * r2)), l2);
        };
        if ($3 === c3)
          return this.set(c3, this.$M + r2);
        if ($3 === h)
          return this.set(h, this.$y + r2);
        if ($3 === a)
          return y3(1);
        if ($3 === o2)
          return y3(7);
        var M4 = (d3 = {}, d3[s] = e2, d3[u2] = n, d3[i] = t2, d3)[$3] || 1, m3 = this.$d.getTime() + r2 * M4;
        return b3.w(m3, this);
      }, m2.subtract = function(t3, e3) {
        return this.add(-1 * t3, e3);
      }, m2.format = function(t3) {
        var e3 = this, n2 = this.$locale();
        if (!this.isValid())
          return n2.invalidDate || l;
        var r2 = t3 || "YYYY-MM-DDTHH:mm:ssZ", i2 = b3.z(this), s2 = this.$H, u3 = this.$m, a2 = this.$M, o3 = n2.weekdays, c4 = n2.months, f3 = n2.meridiem, h2 = function(t4, n3, i3, s3) {
          return t4 && (t4[n3] || t4(e3, r2)) || i3[n3].slice(0, s3);
        }, d3 = function(t4) {
          return b3.s(s2 % 12 || 12, t4, "0");
        }, $3 = f3 || function(t4, e4, n3) {
          var r3 = t4 < 12 ? "AM" : "PM";
          return n3 ? r3.toLowerCase() : r3;
        };
        return r2.replace(y2, function(t4, r3) {
          return r3 || function(t5) {
            switch (t5) {
              case "YY":
                return String(e3.$y).slice(-2);
              case "YYYY":
                return b3.s(e3.$y, 4, "0");
              case "M":
                return a2 + 1;
              case "MM":
                return b3.s(a2 + 1, 2, "0");
              case "MMM":
                return h2(n2.monthsShort, a2, c4, 3);
              case "MMMM":
                return h2(c4, a2);
              case "D":
                return e3.$D;
              case "DD":
                return b3.s(e3.$D, 2, "0");
              case "d":
                return String(e3.$W);
              case "dd":
                return h2(n2.weekdaysMin, e3.$W, o3, 2);
              case "ddd":
                return h2(n2.weekdaysShort, e3.$W, o3, 3);
              case "dddd":
                return o3[e3.$W];
              case "H":
                return String(s2);
              case "HH":
                return b3.s(s2, 2, "0");
              case "h":
                return d3(1);
              case "hh":
                return d3(2);
              case "a":
                return $3(s2, u3, true);
              case "A":
                return $3(s2, u3, false);
              case "m":
                return String(u3);
              case "mm":
                return b3.s(u3, 2, "0");
              case "s":
                return String(e3.$s);
              case "ss":
                return b3.s(e3.$s, 2, "0");
              case "SSS":
                return b3.s(e3.$ms, 3, "0");
              case "Z":
                return i2;
            }
            return null;
          }(t4) || i2.replace(":", "");
        });
      }, m2.utcOffset = function() {
        return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
      }, m2.diff = function(r2, d3, l2) {
        var $3, y3 = this, M4 = b3.p(d3), m3 = O(r2), v2 = (m3.utcOffset() - this.utcOffset()) * e2, g2 = this - m3, D2 = function() {
          return b3.m(y3, m3);
        };
        switch (M4) {
          case h:
            $3 = D2() / 12;
            break;
          case c3:
            $3 = D2();
            break;
          case f2:
            $3 = D2() / 3;
            break;
          case o2:
            $3 = (g2 - v2) / 604800000;
            break;
          case a:
            $3 = (g2 - v2) / 86400000;
            break;
          case u2:
            $3 = g2 / n;
            break;
          case s:
            $3 = g2 / e2;
            break;
          case i:
            $3 = g2 / t2;
            break;
          default:
            $3 = g2;
        }
        return l2 ? $3 : b3.a($3);
      }, m2.daysInMonth = function() {
        return this.endOf(c3).$D;
      }, m2.$locale = function() {
        return D[this.$L];
      }, m2.locale = function(t3, e3) {
        if (!t3)
          return this.$L;
        var n2 = this.clone(), r2 = w(t3, e3, true);
        return r2 && (n2.$L = r2), n2;
      }, m2.clone = function() {
        return b3.w(this.$d, this);
      }, m2.toDate = function() {
        return new Date(this.valueOf());
      }, m2.toJSON = function() {
        return this.isValid() ? this.toISOString() : null;
      }, m2.toISOString = function() {
        return this.$d.toISOString();
      }, m2.toString = function() {
        return this.$d.toUTCString();
      }, M3;
    }(), k = _.prototype;
    return O.prototype = k, [["$ms", r], ["$s", i], ["$m", s], ["$H", u2], ["$W", a], ["$M", c3], ["$y", h], ["$D", d2]].forEach(function(t3) {
      k[t3[1]] = function(e3) {
        return this.$g(e3, t3[0], t3[1]);
      };
    }), O.extend = function(t3, e3) {
      return t3.$i || (t3(e3, _, O), t3.$i = true), O;
    }, O.locale = w, O.isDayjs = S2, O.unix = function(t3) {
      return O(1000 * t3);
    }, O.en = D[g], O.Ls = D, O.p = {}, O;
  });
});

// node_modules/elysia/dist/bun/index.js
var qX = Object.create;
var { defineProperty: W$, getPrototypeOf: NX, getOwnPropertyNames: X6 } = Object;
var Z6 = Object.prototype.hasOwnProperty;
var c = ($, Y, W) => {
  for (let X of X6(Y))
    if (!Z6.call($, X) && X !== "default")
      W$($, X, { get: () => Y[X], enumerable: true });
  if (W) {
    for (let X of X6(Y))
      if (!Z6.call(W, X) && X !== "default")
        W$(W, X, { get: () => Y[X], enumerable: true });
    return W;
  }
};
var v0 = ($, Y, W) => {
  W = $ != null ? qX(NX($)) : {};
  const X = Y || !$ || !$.__esModule ? W$(W, "default", { value: $, enumerable: true }) : W;
  for (let Z of X6($))
    if (!Z6.call(X, Z))
      W$(X, Z, { get: () => $[Z], enumerable: true });
  return X;
};
var z0 = ($, Y) => () => (Y || $((Y = { exports: {} }).exports, Y), Y.exports);
var k8 = ($, Y) => {
  for (var W in Y)
    W$($, W, { get: Y[W], enumerable: true, configurable: true, set: (X) => Y[W] = () => X });
};
var d8 = z0((_7, Q6) => {
  var X$ = function() {
  }, AX = function($, Y, W) {
    this.fn = $, this.context = Y, this.once = W || false;
  }, T8 = function($, Y, W, X, Z) {
    if (typeof W !== "function")
      throw new TypeError("The listener must be a function");
    var J = new AX(W, X || $, Z), Q = V0 ? V0 + Y : Y;
    if (!$._events[Q])
      $._events[Q] = J, $._eventsCount++;
    else if (!$._events[Q].fn)
      $._events[Q].push(J);
    else
      $._events[Q] = [$._events[Q], J];
    return $;
  }, b$ = function($, Y) {
    if (--$._eventsCount === 0)
      $._events = new X$;
    else
      delete $._events[Y];
  }, G0 = function() {
    this._events = new X$, this._eventsCount = 0;
  }, MX = Object.prototype.hasOwnProperty, V0 = "~";
  if (Object.create) {
    if (X$.prototype = Object.create(null), !new X$().__proto__)
      V0 = false;
  }
  G0.prototype.eventNames = function $() {
    var Y = [], W, X;
    if (this._eventsCount === 0)
      return Y;
    for (X in W = this._events)
      if (MX.call(W, X))
        Y.push(V0 ? X.slice(1) : X);
    if (Object.getOwnPropertySymbols)
      return Y.concat(Object.getOwnPropertySymbols(W));
    return Y;
  };
  G0.prototype.listeners = function $(Y) {
    var W = V0 ? V0 + Y : Y, X = this._events[W];
    if (!X)
      return [];
    if (X.fn)
      return [X.fn];
    for (var Z = 0, J = X.length, Q = new Array(J);Z < J; Z++)
      Q[Z] = X[Z].fn;
    return Q;
  };
  G0.prototype.listenerCount = function $(Y) {
    var W = V0 ? V0 + Y : Y, X = this._events[W];
    if (!X)
      return 0;
    if (X.fn)
      return 1;
    return X.length;
  };
  G0.prototype.emit = function $(Y, W, X, Z, J, Q) {
    var z = V0 ? V0 + Y : Y;
    if (!this._events[z])
      return false;
    var U = this._events[z], F = arguments.length, D, S;
    if (U.fn) {
      if (U.once)
        this.removeListener(Y, U.fn, undefined, true);
      switch (F) {
        case 1:
          return U.fn.call(U.context), true;
        case 2:
          return U.fn.call(U.context, W), true;
        case 3:
          return U.fn.call(U.context, W, X), true;
        case 4:
          return U.fn.call(U.context, W, X, Z), true;
        case 5:
          return U.fn.call(U.context, W, X, Z, J), true;
        case 6:
          return U.fn.call(U.context, W, X, Z, J, Q), true;
      }
      for (S = 1, D = new Array(F - 1);S < F; S++)
        D[S - 1] = arguments[S];
      U.fn.apply(U.context, D);
    } else {
      var b = U.length, j;
      for (S = 0;S < b; S++) {
        if (U[S].once)
          this.removeListener(Y, U[S].fn, undefined, true);
        switch (F) {
          case 1:
            U[S].fn.call(U[S].context);
            break;
          case 2:
            U[S].fn.call(U[S].context, W);
            break;
          case 3:
            U[S].fn.call(U[S].context, W, X);
            break;
          case 4:
            U[S].fn.call(U[S].context, W, X, Z);
            break;
          default:
            if (!D)
              for (j = 1, D = new Array(F - 1);j < F; j++)
                D[j - 1] = arguments[j];
            U[S].fn.apply(U[S].context, D);
        }
      }
    }
    return true;
  };
  G0.prototype.on = function $(Y, W, X) {
    return T8(this, Y, W, X, false);
  };
  G0.prototype.once = function $(Y, W, X) {
    return T8(this, Y, W, X, true);
  };
  G0.prototype.removeListener = function $(Y, W, X, Z) {
    var J = V0 ? V0 + Y : Y;
    if (!this._events[J])
      return this;
    if (!W)
      return b$(this, J), this;
    var Q = this._events[J];
    if (Q.fn) {
      if (Q.fn === W && (!Z || Q.once) && (!X || Q.context === X))
        b$(this, J);
    } else {
      for (var z = 0, U = [], F = Q.length;z < F; z++)
        if (Q[z].fn !== W || Z && !Q[z].once || X && Q[z].context !== X)
          U.push(Q[z]);
      if (U.length)
        this._events[J] = U.length === 1 ? U[0] : U;
      else
        b$(this, J);
    }
    return this;
  };
  G0.prototype.removeAllListeners = function $(Y) {
    var W;
    if (Y) {
      if (W = V0 ? V0 + Y : Y, this._events[W])
        b$(this, W);
    } else
      this._events = new X$, this._eventsCount = 0;
    return this;
  };
  G0.prototype.off = G0.prototype.removeListener;
  G0.prototype.addListener = G0.prototype.on;
  G0.prefixed = V0;
  G0.EventEmitter = G0;
  if (typeof Q6 !== "undefined")
    Q6.exports = G0;
});
var x0 = z0((l8) => {
  var UX = function($) {
    return G$($) && Symbol.asyncIterator in $;
  }, BX = function($) {
    return G$($) && Symbol.iterator in $;
  }, FX = function($) {
    return ArrayBuffer.isView($);
  }, DX = function($) {
    return $ instanceof Promise;
  }, wX = function($) {
    return $ instanceof Uint8Array;
  }, jX = function($) {
    return $ instanceof Date && Number.isFinite($.getTime());
  }, KX = function($, Y) {
    return Y in $;
  }, PX = function($) {
    return G$($) && o8($.constructor) && $.constructor.name === "Object";
  }, G$ = function($) {
    return $ !== null && typeof $ === "object";
  }, OX = function($) {
    return Array.isArray($) && !ArrayBuffer.isView($);
  }, i8 = function($) {
    return $ === undefined;
  }, m8 = function($) {
    return $ === null;
  }, u8 = function($) {
    return typeof $ === "boolean";
  }, z6 = function($) {
    return typeof $ === "number";
  }, SX = function($) {
    return z6($) && Number.isInteger($);
  }, h8 = function($) {
    return typeof $ === "bigint";
  }, n8 = function($) {
    return typeof $ === "string";
  }, o8 = function($) {
    return typeof $ === "function";
  }, c8 = function($) {
    return typeof $ === "symbol";
  }, LX = function($) {
    return h8($) || u8($) || m8($) || z6($) || n8($) || c8($) || i8($);
  };
  Object.defineProperty(l8, "__esModule", { value: true });
  l8.IsValueType = l8.IsSymbol = l8.IsFunction = l8.IsString = l8.IsBigInt = l8.IsInteger = l8.IsNumber = l8.IsBoolean = l8.IsNull = l8.IsUndefined = l8.IsArray = l8.IsObject = l8.IsPlainObject = l8.HasPropertyKey = l8.IsDate = l8.IsUint8Array = l8.IsPromise = l8.IsTypedArray = l8.IsIterator = l8.IsAsyncIterator = undefined;
  l8.IsAsyncIterator = UX;
  l8.IsIterator = BX;
  l8.IsTypedArray = FX;
  l8.IsPromise = DX;
  l8.IsUint8Array = wX;
  l8.IsDate = jX;
  l8.HasPropertyKey = KX;
  l8.IsPlainObject = PX;
  l8.IsObject = G$;
  l8.IsArray = OX;
  l8.IsUndefined = i8;
  l8.IsNull = m8;
  l8.IsBoolean = u8;
  l8.IsNumber = z6;
  l8.IsInteger = SX;
  l8.IsBigInt = h8;
  l8.IsString = n8;
  l8.IsFunction = o8;
  l8.IsSymbol = c8;
  l8.IsValueType = LX;
});
var g0 = z0((e8) => {
  Object.defineProperty(e8, "__esModule", { value: true });
  e8.Type = e8.JsonType = e8.JavaScriptTypeBuilder = e8.JsonTypeBuilder = e8.TypeBuilder = e8.TypeBuilderError = e8.TransformEncodeBuilder = e8.TransformDecodeBuilder = e8.TemplateLiteralDslParser = e8.TemplateLiteralGenerator = e8.TemplateLiteralGeneratorError = e8.TemplateLiteralFinite = e8.TemplateLiteralFiniteError = e8.TemplateLiteralParser = e8.TemplateLiteralParserError = e8.TemplateLiteralResolver = e8.TemplateLiteralPattern = e8.TemplateLiteralPatternError = e8.UnionResolver = e8.KeyArrayResolver = e8.KeyArrayResolverError = e8.KeyResolver = e8.ObjectMap = e8.Intrinsic = e8.IndexedAccessor = e8.TypeClone = e8.TypeExtends = e8.TypeExtendsResult = e8.TypeExtendsError = e8.ExtendsUndefined = e8.TypeGuard = e8.TypeGuardUnknownTypeError = e8.ValueGuard = e8.FormatRegistry = e8.TypeBoxError = e8.TypeRegistry = e8.PatternStringExact = e8.PatternNumberExact = e8.PatternBooleanExact = e8.PatternString = e8.PatternNumber = e8.PatternBoolean = e8.Kind = e8.Hint = e8.Optional = e8.Readonly = e8.Transform = undefined;
  e8.Transform = Symbol.for("TypeBox.Transform");
  e8.Readonly = Symbol.for("TypeBox.Readonly");
  e8.Optional = Symbol.for("TypeBox.Optional");
  e8.Hint = Symbol.for("TypeBox.Hint");
  e8.Kind = Symbol.for("TypeBox.Kind");
  e8.PatternBoolean = "(true|false)";
  e8.PatternNumber = "(0|[1-9][0-9]*)";
  e8.PatternString = "(.*)";
  e8.PatternBooleanExact = `^${e8.PatternBoolean}$`;
  e8.PatternNumberExact = `^${e8.PatternNumber}$`;
  e8.PatternStringExact = `^${e8.PatternString}$`;
  var H6;
  (function($) {
    const Y = new Map;
    function W() {
      return new Map(Y);
    }
    $.Entries = W;
    function X() {
      return Y.clear();
    }
    $.Clear = X;
    function Z(U) {
      return Y.delete(U);
    }
    $.Delete = Z;
    function J(U) {
      return Y.has(U);
    }
    $.Has = J;
    function Q(U, F) {
      Y.set(U, F);
    }
    $.Set = Q;
    function z(U) {
      return Y.get(U);
    }
    $.Get = z;
  })(H6 || (e8.TypeRegistry = H6 = {}));

  class W1 extends Error {
    constructor($) {
      super($);
    }
  }
  e8.TypeBoxError = W1;
  var s8;
  (function($) {
    const Y = new Map;
    function W() {
      return new Map(Y);
    }
    $.Entries = W;
    function X() {
      return Y.clear();
    }
    $.Clear = X;
    function Z(U) {
      return Y.delete(U);
    }
    $.Delete = Z;
    function J(U) {
      return Y.has(U);
    }
    $.Has = J;
    function Q(U, F) {
      Y.set(U, F);
    }
    $.Set = Q;
    function z(U) {
      return Y.get(U);
    }
    $.Get = z;
  })(s8 || (e8.FormatRegistry = s8 = {}));
  var V;
  (function($) {
    function Y(F) {
      return Array.isArray(F);
    }
    $.IsArray = Y;
    function W(F) {
      return typeof F === "bigint";
    }
    $.IsBigInt = W;
    function X(F) {
      return typeof F === "boolean";
    }
    $.IsBoolean = X;
    function Z(F) {
      return F === null;
    }
    $.IsNull = Z;
    function J(F) {
      return typeof F === "number";
    }
    $.IsNumber = J;
    function Q(F) {
      return typeof F === "object" && F !== null;
    }
    $.IsObject = Q;
    function z(F) {
      return typeof F === "string";
    }
    $.IsString = z;
    function U(F) {
      return F === undefined;
    }
    $.IsUndefined = U;
  })(V || (e8.ValueGuard = V = {}));

  class a8 extends W1 {
  }
  e8.TypeGuardUnknownTypeError = a8;
  var B;
  (function($) {
    function Y(N) {
      try {
        return new RegExp(N), true;
      } catch {
        return false;
      }
    }
    function W(N) {
      if (!V.IsString(N))
        return false;
      for (let t = 0;t < N.length; t++) {
        const L0 = N.charCodeAt(t);
        if (L0 >= 7 && L0 <= 13 || L0 === 27 || L0 === 127)
          return false;
      }
      return true;
    }
    function X(N) {
      return Q(N) || X0(N);
    }
    function Z(N) {
      return V.IsUndefined(N) || V.IsBigInt(N);
    }
    function J(N) {
      return V.IsUndefined(N) || V.IsNumber(N);
    }
    function Q(N) {
      return V.IsUndefined(N) || V.IsBoolean(N);
    }
    function z(N) {
      return V.IsUndefined(N) || V.IsString(N);
    }
    function U(N) {
      return V.IsUndefined(N) || V.IsString(N) && W(N) && Y(N);
    }
    function F(N) {
      return V.IsUndefined(N) || V.IsString(N) && W(N);
    }
    function D(N) {
      return V.IsUndefined(N) || X0(N);
    }
    function S(N) {
      return _(N, "Any") && z(N.$id);
    }
    $.TAny = S;
    function b(N) {
      return _(N, "Array") && N.type === "array" && z(N.$id) && X0(N.items) && J(N.minItems) && J(N.maxItems) && Q(N.uniqueItems) && D(N.contains) && J(N.minContains) && J(N.maxContains);
    }
    $.TArray = b;
    function j(N) {
      return _(N, "AsyncIterator") && N.type === "AsyncIterator" && z(N.$id) && X0(N.items);
    }
    $.TAsyncIterator = j;
    function M(N) {
      return _(N, "BigInt") && N.type === "bigint" && z(N.$id) && Z(N.exclusiveMaximum) && Z(N.exclusiveMinimum) && Z(N.maximum) && Z(N.minimum) && Z(N.multipleOf);
    }
    $.TBigInt = M;
    function P(N) {
      return _(N, "Boolean") && N.type === "boolean" && z(N.$id);
    }
    $.TBoolean = P;
    function O(N) {
      return _(N, "Constructor") && N.type === "Constructor" && z(N.$id) && V.IsArray(N.parameters) && N.parameters.every((t) => X0(t)) && X0(N.returns);
    }
    $.TConstructor = O;
    function A(N) {
      return _(N, "Date") && N.type === "Date" && z(N.$id) && J(N.exclusiveMaximumTimestamp) && J(N.exclusiveMinimumTimestamp) && J(N.maximumTimestamp) && J(N.minimumTimestamp) && J(N.multipleOfTimestamp);
    }
    $.TDate = A;
    function w(N) {
      return _(N, "Function") && N.type === "Function" && z(N.$id) && V.IsArray(N.parameters) && N.parameters.every((t) => X0(t)) && X0(N.returns);
    }
    $.TFunction = w;
    function I(N) {
      return _(N, "Integer") && N.type === "integer" && z(N.$id) && J(N.exclusiveMaximum) && J(N.exclusiveMinimum) && J(N.maximum) && J(N.minimum) && J(N.multipleOf);
    }
    $.TInteger = I;
    function G(N) {
      return _(N, "Intersect") && (V.IsString(N.type) && N.type !== "object" ? false : true) && V.IsArray(N.allOf) && N.allOf.every((t) => X0(t) && !P0(t)) && z(N.type) && (Q(N.unevaluatedProperties) || D(N.unevaluatedProperties)) && z(N.$id);
    }
    $.TIntersect = G;
    function k(N) {
      return _(N, "Iterator") && N.type === "Iterator" && z(N.$id) && X0(N.items);
    }
    $.TIterator = k;
    function _(N, t) {
      return J0(N) && N[e8.Kind] === t;
    }
    $.TKindOf = _;
    function J0(N) {
      return V.IsObject(N) && e8.Kind in N && V.IsString(N[e8.Kind]);
    }
    $.TKind = J0;
    function Y0(N) {
      return u0(N) && V.IsString(N.const);
    }
    $.TLiteralString = Y0;
    function A0(N) {
      return u0(N) && V.IsNumber(N.const);
    }
    $.TLiteralNumber = A0;
    function k1(N) {
      return u0(N) && V.IsBoolean(N.const);
    }
    $.TLiteralBoolean = k1;
    function u0(N) {
      return _(N, "Literal") && z(N.$id) && (V.IsBoolean(N.const) || V.IsNumber(N.const) || V.IsString(N.const));
    }
    $.TLiteral = u0;
    function h0(N) {
      return _(N, "Never") && V.IsObject(N.not) && Object.getOwnPropertyNames(N.not).length === 0;
    }
    $.TNever = h0;
    function N0(N) {
      return _(N, "Not") && X0(N.not);
    }
    $.TNot = N0;
    function H0(N) {
      return _(N, "Null") && N.type === "null" && z(N.$id);
    }
    $.TNull = H0;
    function n0(N) {
      return _(N, "Number") && N.type === "number" && z(N.$id) && J(N.exclusiveMaximum) && J(N.exclusiveMinimum) && J(N.maximum) && J(N.minimum) && J(N.multipleOf);
    }
    $.TNumber = n0;
    function $1(N) {
      return _(N, "Object") && N.type === "object" && z(N.$id) && V.IsObject(N.properties) && X(N.additionalProperties) && J(N.minProperties) && J(N.maxProperties) && Object.entries(N.properties).every(([t, L0]) => W(t) && X0(L0));
    }
    $.TObject = $1;
    function y0(N) {
      return _(N, "Promise") && N.type === "Promise" && z(N.$id) && X0(N.item);
    }
    $.TPromise = y0;
    function R(N) {
      return _(N, "Record") && N.type === "object" && z(N.$id) && X(N.additionalProperties) && V.IsObject(N.patternProperties) && ((t) => {
        const L0 = Object.getOwnPropertyNames(t.patternProperties);
        return L0.length === 1 && Y(L0[0]) && V.IsObject(t.patternProperties) && X0(t.patternProperties[L0[0]]);
      })(N);
    }
    $.TRecord = R;
    function f(N) {
      return V.IsObject(N) && e8.Hint in N && N[e8.Hint] === "Recursive";
    }
    $.TRecursive = f;
    function i(N) {
      return _(N, "Ref") && z(N.$id) && V.IsString(N.$ref);
    }
    $.TRef = i;
    function h(N) {
      return _(N, "String") && N.type === "string" && z(N.$id) && J(N.minLength) && J(N.maxLength) && U(N.pattern) && F(N.format);
    }
    $.TString = h;
    function q0(N) {
      return _(N, "Symbol") && N.type === "symbol" && z(N.$id);
    }
    $.TSymbol = q0;
    function j0(N) {
      return _(N, "TemplateLiteral") && N.type === "string" && V.IsString(N.pattern) && N.pattern[0] === "^" && N.pattern[N.pattern.length - 1] === "$";
    }
    $.TTemplateLiteral = j0;
    function K0(N) {
      return _(N, "This") && z(N.$id) && V.IsString(N.$ref);
    }
    $.TThis = K0;
    function P0(N) {
      return V.IsObject(N) && e8.Transform in N;
    }
    $.TTransform = P0;
    function M0(N) {
      return _(N, "Tuple") && N.type === "array" && z(N.$id) && V.IsNumber(N.minItems) && V.IsNumber(N.maxItems) && N.minItems === N.maxItems && (V.IsUndefined(N.items) && V.IsUndefined(N.additionalItems) && N.minItems === 0 || V.IsArray(N.items) && N.items.every((t) => X0(t)));
    }
    $.TTuple = M0;
    function w1(N) {
      return _(N, "Undefined") && N.type === "undefined" && z(N.$id);
    }
    $.TUndefined = w1;
    function K(N) {
      return E(N) && N.anyOf.every((t) => Y0(t) || A0(t));
    }
    $.TUnionLiteral = K;
    function E(N) {
      return _(N, "Union") && z(N.$id) && V.IsObject(N) && V.IsArray(N.anyOf) && N.anyOf.every((t) => X0(t));
    }
    $.TUnion = E;
    function L(N) {
      return _(N, "Uint8Array") && N.type === "Uint8Array" && z(N.$id) && J(N.minByteLength) && J(N.maxByteLength);
    }
    $.TUint8Array = L;
    function p(N) {
      return _(N, "Unknown") && z(N.$id);
    }
    $.TUnknown = p;
    function T(N) {
      return _(N, "Unsafe");
    }
    $.TUnsafe = T;
    function d(N) {
      return _(N, "Void") && N.type === "void" && z(N.$id);
    }
    $.TVoid = d;
    function W0(N) {
      return V.IsObject(N) && N[e8.Readonly] === "Readonly";
    }
    $.TReadonly = W0;
    function S0(N) {
      return V.IsObject(N) && N[e8.Optional] === "Optional";
    }
    $.TOptional = S0;
    function X0(N) {
      return V.IsObject(N) && (S(N) || b(N) || P(N) || M(N) || j(N) || O(N) || A(N) || w(N) || I(N) || G(N) || k(N) || u0(N) || h0(N) || N0(N) || H0(N) || n0(N) || $1(N) || y0(N) || R(N) || i(N) || h(N) || q0(N) || j0(N) || K0(N) || M0(N) || w1(N) || E(N) || L(N) || p(N) || T(N) || d(N) || J0(N) && H6.Has(N[e8.Kind]));
    }
    $.TSchema = X0;
  })(B || (e8.TypeGuard = B = {}));
  var r8;
  (function($) {
    function Y(W) {
      return W[e8.Kind] === "Intersect" ? W.allOf.every((X) => Y(X)) : W[e8.Kind] === "Union" ? W.anyOf.some((X) => Y(X)) : W[e8.Kind] === "Undefined" ? true : W[e8.Kind] === "Not" ? !Y(W.not) : false;
    }
    $.Check = Y;
  })(r8 || (e8.ExtendsUndefined = r8 = {}));

  class A6 extends W1 {
  }
  e8.TypeExtendsError = A6;
  var C;
  (function($) {
    $[$.Union = 0] = "Union", $[$.True = 1] = "True", $[$.False = 2] = "False";
  })(C || (e8.TypeExtendsResult = C = {}));
  var b1;
  (function($) {
    function Y(H) {
      return H === C.False ? H : C.True;
    }
    function W(H) {
      throw new A6(H);
    }
    function X(H) {
      return B.TNever(H) || B.TIntersect(H) || B.TUnion(H) || B.TUnknown(H) || B.TAny(H);
    }
    function Z(H, q) {
      return B.TNever(q) ? _(H, q) : B.TIntersect(q) ? w(H, q) : B.TUnion(q) ? W6(H, q) : B.TUnknown(q) ? x8(H, q) : B.TAny(q) ? J(H, q) : W("StructuralRight");
    }
    function J(H, q) {
      return C.True;
    }
    function Q(H, q) {
      return B.TIntersect(q) ? w(H, q) : B.TUnion(q) && q.anyOf.some((e) => B.TAny(e) || B.TUnknown(e)) ? C.True : B.TUnion(q) ? C.Union : B.TUnknown(q) ? C.True : B.TAny(q) ? C.True : C.Union;
    }
    function z(H, q) {
      return B.TUnknown(H) ? C.False : B.TAny(H) ? C.Union : B.TNever(H) ? C.True : C.False;
    }
    function U(H, q) {
      return B.TObject(q) && j0(q) ? C.True : X(q) ? Z(H, q) : !B.TArray(q) ? C.False : Y(Q0(H.items, q.items));
    }
    function F(H, q) {
      return X(q) ? Z(H, q) : !B.TAsyncIterator(q) ? C.False : Y(Q0(H.items, q.items));
    }
    function D(H, q) {
      return X(q) ? Z(H, q) : B.TObject(q) ? M0(H, q) : B.TRecord(q) ? p(H, q) : B.TBigInt(q) ? C.True : C.False;
    }
    function S(H, q) {
      return B.TLiteral(H) && V.IsBoolean(H.const) ? C.True : B.TBoolean(H) ? C.True : C.False;
    }
    function b(H, q) {
      return X(q) ? Z(H, q) : B.TObject(q) ? M0(H, q) : B.TRecord(q) ? p(H, q) : B.TBoolean(q) ? C.True : C.False;
    }
    function j(H, q) {
      return X(q) ? Z(H, q) : B.TObject(q) ? M0(H, q) : !B.TConstructor(q) ? C.False : H.parameters.length > q.parameters.length ? C.False : !H.parameters.every((e, o0) => Y(Q0(q.parameters[o0], e)) === C.True) ? C.False : Y(Q0(H.returns, q.returns));
    }
    function M(H, q) {
      return X(q) ? Z(H, q) : B.TObject(q) ? M0(H, q) : B.TRecord(q) ? p(H, q) : B.TDate(q) ? C.True : C.False;
    }
    function P(H, q) {
      return X(q) ? Z(H, q) : B.TObject(q) ? M0(H, q) : !B.TFunction(q) ? C.False : H.parameters.length > q.parameters.length ? C.False : !H.parameters.every((e, o0) => Y(Q0(q.parameters[o0], e)) === C.True) ? C.False : Y(Q0(H.returns, q.returns));
    }
    function O(H, q) {
      return B.TLiteral(H) && V.IsNumber(H.const) ? C.True : B.TNumber(H) || B.TInteger(H) ? C.True : C.False;
    }
    function A(H, q) {
      return B.TInteger(q) || B.TNumber(q) ? C.True : X(q) ? Z(H, q) : B.TObject(q) ? M0(H, q) : B.TRecord(q) ? p(H, q) : C.False;
    }
    function w(H, q) {
      return q.allOf.every((e) => Q0(H, e) === C.True) ? C.True : C.False;
    }
    function I(H, q) {
      return H.allOf.some((e) => Q0(e, q) === C.True) ? C.True : C.False;
    }
    function G(H, q) {
      return X(q) ? Z(H, q) : !B.TIterator(q) ? C.False : Y(Q0(H.items, q.items));
    }
    function k(H, q) {
      return B.TLiteral(q) && q.const === H.const ? C.True : X(q) ? Z(H, q) : B.TObject(q) ? M0(H, q) : B.TRecord(q) ? p(H, q) : B.TString(q) ? d(H, q) : B.TNumber(q) ? u0(H, q) : B.TInteger(q) ? O(H, q) : B.TBoolean(q) ? S(H, q) : C.False;
    }
    function _(H, q) {
      return C.False;
    }
    function J0(H, q) {
      return C.True;
    }
    function Y0(H) {
      let [q, e] = [H, 0];
      while (true) {
        if (!B.TNot(q))
          break;
        q = q.not, e += 1;
      }
      return e % 2 === 0 ? q : e8.Type.Unknown();
    }
    function A0(H, q) {
      return B.TNot(H) ? Q0(Y0(H), q) : B.TNot(q) ? Q0(H, Y0(q)) : W("Invalid fallthrough for Not");
    }
    function k1(H, q) {
      return X(q) ? Z(H, q) : B.TObject(q) ? M0(H, q) : B.TRecord(q) ? p(H, q) : B.TNull(q) ? C.True : C.False;
    }
    function u0(H, q) {
      return B.TLiteralNumber(H) ? C.True : B.TNumber(H) || B.TInteger(H) ? C.True : C.False;
    }
    function h0(H, q) {
      return X(q) ? Z(H, q) : B.TObject(q) ? M0(H, q) : B.TRecord(q) ? p(H, q) : B.TInteger(q) || B.TNumber(q) ? C.True : C.False;
    }
    function N0(H, q) {
      return Object.getOwnPropertyNames(H.properties).length === q;
    }
    function H0(H) {
      return j0(H);
    }
    function n0(H) {
      return N0(H, 0) || N0(H, 1) && "description" in H.properties && B.TUnion(H.properties.description) && H.properties.description.anyOf.length === 2 && (B.TString(H.properties.description.anyOf[0]) && B.TUndefined(H.properties.description.anyOf[1]) || B.TString(H.properties.description.anyOf[1]) && B.TUndefined(H.properties.description.anyOf[0]));
    }
    function $1(H) {
      return N0(H, 0);
    }
    function y0(H) {
      return N0(H, 0);
    }
    function R(H) {
      return N0(H, 0);
    }
    function f(H) {
      return N0(H, 0);
    }
    function i(H) {
      return j0(H);
    }
    function h(H) {
      const q = e8.Type.Number();
      return N0(H, 0) || N0(H, 1) && "length" in H.properties && Y(Q0(H.properties.length, q)) === C.True;
    }
    function q0(H) {
      return N0(H, 0);
    }
    function j0(H) {
      const q = e8.Type.Number();
      return N0(H, 0) || N0(H, 1) && "length" in H.properties && Y(Q0(H.properties.length, q)) === C.True;
    }
    function K0(H) {
      const q = e8.Type.Function([e8.Type.Any()], e8.Type.Any());
      return N0(H, 0) || N0(H, 1) && "then" in H.properties && Y(Q0(H.properties.then, q)) === C.True;
    }
    function P0(H, q) {
      return Q0(H, q) === C.False ? C.False : B.TOptional(H) && !B.TOptional(q) ? C.False : C.True;
    }
    function M0(H, q) {
      return B.TUnknown(H) ? C.False : B.TAny(H) ? C.Union : B.TNever(H) || B.TLiteralString(H) && H0(q) || B.TLiteralNumber(H) && $1(q) || B.TLiteralBoolean(H) && y0(q) || B.TSymbol(H) && n0(q) || B.TBigInt(H) && R(q) || B.TString(H) && H0(q) || B.TSymbol(H) && n0(q) || B.TNumber(H) && $1(q) || B.TInteger(H) && $1(q) || B.TBoolean(H) && y0(q) || B.TUint8Array(H) && i(q) || B.TDate(H) && f(q) || B.TConstructor(H) && q0(q) || B.TFunction(H) && h(q) ? C.True : B.TRecord(H) && B.TString(E(H)) ? (() => {
        return q[e8.Hint] === "Record" ? C.True : C.False;
      })() : B.TRecord(H) && B.TNumber(E(H)) ? (() => {
        return N0(q, 0) ? C.True : C.False;
      })() : C.False;
    }
    function w1(H, q) {
      return X(q) ? Z(H, q) : B.TRecord(q) ? p(H, q) : !B.TObject(q) ? C.False : (() => {
        for (let e of Object.getOwnPropertyNames(q.properties)) {
          if (!(e in H.properties) && !B.TOptional(q.properties[e]))
            return C.False;
          if (B.TOptional(q.properties[e]))
            return C.True;
          if (P0(H.properties[e], q.properties[e]) === C.False)
            return C.False;
        }
        return C.True;
      })();
    }
    function K(H, q) {
      return X(q) ? Z(H, q) : B.TObject(q) && K0(q) ? C.True : !B.TPromise(q) ? C.False : Y(Q0(H.item, q.item));
    }
    function E(H) {
      return e8.PatternNumberExact in H.patternProperties ? e8.Type.Number() : (e8.PatternStringExact in H.patternProperties) ? e8.Type.String() : W("Unknown record key pattern");
    }
    function L(H) {
      return e8.PatternNumberExact in H.patternProperties ? H.patternProperties[e8.PatternNumberExact] : (e8.PatternStringExact in H.patternProperties) ? H.patternProperties[e8.PatternStringExact] : W("Unable to get record value schema");
    }
    function p(H, q) {
      const [e, o0] = [E(q), L(q)];
      return B.TLiteralString(H) && B.TNumber(e) && Y(Q0(H, o0)) === C.True ? C.True : B.TUint8Array(H) && B.TNumber(e) ? Q0(H, o0) : B.TString(H) && B.TNumber(e) ? Q0(H, o0) : B.TArray(H) && B.TNumber(e) ? Q0(H, o0) : B.TObject(H) ? (() => {
        for (let HX of Object.getOwnPropertyNames(H.properties))
          if (P0(o0, H.properties[HX]) === C.False)
            return C.False;
        return C.True;
      })() : C.False;
    }
    function T(H, q) {
      return X(q) ? Z(H, q) : B.TObject(q) ? M0(H, q) : !B.TRecord(q) ? C.False : Q0(L(H), L(q));
    }
    function d(H, q) {
      return B.TLiteral(H) && V.IsString(H.const) ? C.True : B.TString(H) ? C.True : C.False;
    }
    function W0(H, q) {
      return X(q) ? Z(H, q) : B.TObject(q) ? M0(H, q) : B.TRecord(q) ? p(H, q) : B.TString(q) ? C.True : C.False;
    }
    function S0(H, q) {
      return X(q) ? Z(H, q) : B.TObject(q) ? M0(H, q) : B.TRecord(q) ? p(H, q) : B.TSymbol(q) ? C.True : C.False;
    }
    function X0(H, q) {
      return B.TTemplateLiteral(H) ? Q0(H1.Resolve(H), q) : B.TTemplateLiteral(q) ? Q0(H, H1.Resolve(q)) : W("Invalid fallthrough for TemplateLiteral");
    }
    function N(H, q) {
      return B.TArray(q) && H.items !== undefined && H.items.every((e) => Q0(e, q.items) === C.True);
    }
    function t(H, q) {
      return B.TNever(H) ? C.True : B.TUnknown(H) ? C.False : B.TAny(H) ? C.Union : C.False;
    }
    function L0(H, q) {
      return X(q) ? Z(H, q) : B.TObject(q) && j0(q) ? C.True : B.TArray(q) && N(H, q) ? C.True : !B.TTuple(q) ? C.False : V.IsUndefined(H.items) && !V.IsUndefined(q.items) || !V.IsUndefined(H.items) && V.IsUndefined(q.items) ? C.False : V.IsUndefined(H.items) && !V.IsUndefined(q.items) ? C.True : H.items.every((e, o0) => Q0(e, q.items[o0]) === C.True) ? C.True : C.False;
    }
    function $6(H, q) {
      return X(q) ? Z(H, q) : B.TObject(q) ? M0(H, q) : B.TRecord(q) ? p(H, q) : B.TUint8Array(q) ? C.True : C.False;
    }
    function Y6(H, q) {
      return X(q) ? Z(H, q) : B.TObject(q) ? M0(H, q) : B.TRecord(q) ? p(H, q) : B.TVoid(q) ? JX(H, q) : B.TUndefined(q) ? C.True : C.False;
    }
    function W6(H, q) {
      return q.anyOf.some((e) => Q0(H, e) === C.True) ? C.True : C.False;
    }
    function XX(H, q) {
      return H.anyOf.every((e) => Q0(e, q) === C.True) ? C.True : C.False;
    }
    function x8(H, q) {
      return C.True;
    }
    function ZX(H, q) {
      return B.TNever(q) ? _(H, q) : B.TIntersect(q) ? w(H, q) : B.TUnion(q) ? W6(H, q) : B.TAny(q) ? J(H, q) : B.TString(q) ? d(H, q) : B.TNumber(q) ? u0(H, q) : B.TInteger(q) ? O(H, q) : B.TBoolean(q) ? S(H, q) : B.TArray(q) ? z(H, q) : B.TTuple(q) ? t(H, q) : B.TObject(q) ? M0(H, q) : B.TUnknown(q) ? C.True : C.False;
    }
    function JX(H, q) {
      return B.TUndefined(H) ? C.True : B.TUndefined(H) ? C.True : C.False;
    }
    function QX(H, q) {
      return B.TIntersect(q) ? w(H, q) : B.TUnion(q) ? W6(H, q) : B.TUnknown(q) ? x8(H, q) : B.TAny(q) ? J(H, q) : B.TObject(q) ? M0(H, q) : B.TVoid(q) ? C.True : C.False;
    }
    function Q0(H, q) {
      return B.TTemplateLiteral(H) || B.TTemplateLiteral(q) ? X0(H, q) : B.TNot(H) || B.TNot(q) ? A0(H, q) : B.TAny(H) ? Q(H, q) : B.TArray(H) ? U(H, q) : B.TBigInt(H) ? D(H, q) : B.TBoolean(H) ? b(H, q) : B.TAsyncIterator(H) ? F(H, q) : B.TConstructor(H) ? j(H, q) : B.TDate(H) ? M(H, q) : B.TFunction(H) ? P(H, q) : B.TInteger(H) ? A(H, q) : B.TIntersect(H) ? I(H, q) : B.TIterator(H) ? G(H, q) : B.TLiteral(H) ? k(H, q) : B.TNever(H) ? J0(H, q) : B.TNull(H) ? k1(H, q) : B.TNumber(H) ? h0(H, q) : B.TObject(H) ? w1(H, q) : B.TRecord(H) ? T(H, q) : B.TString(H) ? W0(H, q) : B.TSymbol(H) ? S0(H, q) : B.TTuple(H) ? L0(H, q) : B.TPromise(H) ? K(H, q) : B.TUint8Array(H) ? $6(H, q) : B.TUndefined(H) ? Y6(H, q) : B.TUnion(H) ? XX(H, q) : B.TUnknown(H) ? ZX(H, q) : B.TVoid(H) ? QX(H, q) : W(`Unknown left type operand '${H[e8.Kind]}'`);
    }
    function zX(H, q) {
      return Q0(H, q);
    }
    $.Extends = zX;
  })(b1 || (e8.TypeExtends = b1 = {}));
  var m;
  (function($) {
    function Y(Q) {
      const z = Object.getOwnPropertyNames(Q).reduce((F, D) => ({ ...F, [D]: X(Q[D]) }), {}), U = Object.getOwnPropertySymbols(Q).reduce((F, D) => ({ ...F, [D]: X(Q[D]) }), {});
      return { ...z, ...U };
    }
    function W(Q) {
      return Q.map((z) => X(z));
    }
    function X(Q) {
      return V.IsArray(Q) ? W(Q) : V.IsObject(Q) ? Y(Q) : Q;
    }
    function Z(Q) {
      return Q.map((z) => J(z));
    }
    $.Rest = Z;
    function J(Q, z = {}) {
      return { ...X(Q), ...z };
    }
    $.Type = J;
  })(m || (e8.TypeClone = m = {}));
  var q6;
  (function($) {
    function Y(j) {
      return j.map((M) => {
        const { [e8.Optional]: P, ...O } = m.Type(M);
        return O;
      });
    }
    function W(j) {
      return j.every((M) => B.TOptional(M));
    }
    function X(j) {
      return j.some((M) => B.TOptional(M));
    }
    function Z(j) {
      return W(j.allOf) ? e8.Type.Optional(e8.Type.Intersect(Y(j.allOf))) : j;
    }
    function J(j) {
      return X(j.anyOf) ? e8.Type.Optional(e8.Type.Union(Y(j.anyOf))) : j;
    }
    function Q(j) {
      return j[e8.Kind] === "Intersect" ? Z(j) : j[e8.Kind] === "Union" ? J(j) : j;
    }
    function z(j, M) {
      const P = j.allOf.reduce((O, A) => {
        const w = S(A, M);
        return w[e8.Kind] === "Never" ? O : [...O, w];
      }, []);
      return Q(e8.Type.Intersect(P));
    }
    function U(j, M) {
      const P = j.anyOf.map((O) => S(O, M));
      return Q(e8.Type.Union(P));
    }
    function F(j, M) {
      const P = j.properties[M];
      return V.IsUndefined(P) ? e8.Type.Never() : e8.Type.Union([P]);
    }
    function D(j, M) {
      const P = j.items;
      if (V.IsUndefined(P))
        return e8.Type.Never();
      const O = P[M];
      if (V.IsUndefined(O))
        return e8.Type.Never();
      return O;
    }
    function S(j, M) {
      return j[e8.Kind] === "Intersect" ? z(j, M) : j[e8.Kind] === "Union" ? U(j, M) : j[e8.Kind] === "Object" ? F(j, M) : j[e8.Kind] === "Tuple" ? D(j, M) : e8.Type.Never();
    }
    function b(j, M, P = {}) {
      const O = M.map((A) => S(j, A.toString()));
      return Q(e8.Type.Union(O, P));
    }
    $.Resolve = b;
  })(q6 || (e8.IndexedAccessor = q6 = {}));
  var f1;
  (function($) {
    function Y(D) {
      const [S, b] = [D.slice(0, 1), D.slice(1)];
      return `${S.toLowerCase()}${b}`;
    }
    function W(D) {
      const [S, b] = [D.slice(0, 1), D.slice(1)];
      return `${S.toUpperCase()}${b}`;
    }
    function X(D) {
      return D.toUpperCase();
    }
    function Z(D) {
      return D.toLowerCase();
    }
    function J(D, S) {
      const b = v1.ParseExact(D.pattern);
      if (!p1.Check(b))
        return { ...D, pattern: Q(D.pattern, S) };
      const P = [...i1.Generate(b)].map((w) => e8.Type.Literal(w)), O = z(P, S), A = e8.Type.Union(O);
      return e8.Type.TemplateLiteral([A]);
    }
    function Q(D, S) {
      return typeof D === "string" ? S === "Uncapitalize" ? Y(D) : S === "Capitalize" ? W(D) : S === "Uppercase" ? X(D) : S === "Lowercase" ? Z(D) : D : D.toString();
    }
    function z(D, S) {
      if (D.length === 0)
        return [];
      const [b, ...j] = D;
      return [F(b, S), ...z(j, S)];
    }
    function U(D, S) {
      return B.TTemplateLiteral(D) ? J(D, S) : B.TUnion(D) ? e8.Type.Union(z(D.anyOf, S)) : B.TLiteral(D) ? e8.Type.Literal(Q(D.const, S)) : D;
    }
    function F(D, S) {
      return U(D, S);
    }
    $.Map = F;
  })(f1 || (e8.Intrinsic = f1 = {}));
  var T1;
  (function($) {
    function Y(Q, z) {
      return e8.Type.Intersect(Q.allOf.map((U) => Z(U, z)), { ...Q });
    }
    function W(Q, z) {
      return e8.Type.Union(Q.anyOf.map((U) => Z(U, z)), { ...Q });
    }
    function X(Q, z) {
      return z(Q);
    }
    function Z(Q, z) {
      return Q[e8.Kind] === "Intersect" ? Y(Q, z) : Q[e8.Kind] === "Union" ? W(Q, z) : Q[e8.Kind] === "Object" ? X(Q, z) : Q;
    }
    function J(Q, z, U) {
      return { ...Z(m.Type(Q), z), ...U };
    }
    $.Map = J;
  })(T1 || (e8.ObjectMap = T1 = {}));
  var _$;
  (function($) {
    function Y(F) {
      return F[0] === "^" && F[F.length - 1] === "$" ? F.slice(1, F.length - 1) : F;
    }
    function W(F, D) {
      return F.allOf.reduce((S, b) => [...S, ...Q(b, D)], []);
    }
    function X(F, D) {
      const S = F.anyOf.map((b) => Q(b, D));
      return [...S.reduce((b, j) => j.map((M) => S.every((P) => P.includes(M)) ? b.add(M) : b)[0], new Set)];
    }
    function Z(F, D) {
      return Object.getOwnPropertyNames(F.properties);
    }
    function J(F, D) {
      return D.includePatterns ? Object.getOwnPropertyNames(F.patternProperties) : [];
    }
    function Q(F, D) {
      return B.TIntersect(F) ? W(F, D) : B.TUnion(F) ? X(F, D) : B.TObject(F) ? Z(F, D) : B.TRecord(F) ? J(F, D) : [];
    }
    function z(F, D) {
      return [...new Set(Q(F, D))];
    }
    $.ResolveKeys = z;
    function U(F) {
      return `^(${z(F, { includePatterns: true }).map((b) => `(${Y(b)})`).join("|")})$`;
    }
    $.ResolvePattern = U;
  })(_$ || (e8.KeyResolver = _$ = {}));

  class U6 extends W1 {
  }
  e8.KeyArrayResolverError = U6;
  var Z$;
  (function($) {
    function Y(W) {
      return Array.isArray(W) ? W : B.TUnionLiteral(W) ? W.anyOf.map((X) => X.const.toString()) : B.TLiteral(W) ? [W.const] : B.TTemplateLiteral(W) ? (() => {
        const X = v1.ParseExact(W.pattern);
        if (!p1.Check(X))
          throw new U6("Cannot resolve keys from infinite template expression");
        return [...i1.Generate(X)];
      })() : [];
    }
    $.Resolve = Y;
  })(Z$ || (e8.KeyArrayResolver = Z$ = {}));
  var N6;
  (function($) {
    function* Y(X) {
      for (let Z of X.anyOf)
        if (Z[e8.Kind] === "Union")
          yield* Y(Z);
        else
          yield Z;
    }
    function W(X) {
      return e8.Type.Union([...Y(X)], { ...X });
    }
    $.Resolve = W;
  })(N6 || (e8.UnionResolver = N6 = {}));

  class B6 extends W1 {
  }
  e8.TemplateLiteralPatternError = B6;
  var E$;
  (function($) {
    function Y(J) {
      throw new B6(J);
    }
    function W(J) {
      return J.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }
    function X(J, Q) {
      return B.TTemplateLiteral(J) ? J.pattern.slice(1, J.pattern.length - 1) : B.TUnion(J) ? `(${J.anyOf.map((z) => X(z, Q)).join("|")})` : B.TNumber(J) ? `${Q}${e8.PatternNumber}` : B.TInteger(J) ? `${Q}${e8.PatternNumber}` : B.TBigInt(J) ? `${Q}${e8.PatternNumber}` : B.TString(J) ? `${Q}${e8.PatternString}` : B.TLiteral(J) ? `${Q}${W(J.const.toString())}` : B.TBoolean(J) ? `${Q}${e8.PatternBoolean}` : Y(`Unexpected Kind '${J[e8.Kind]}'`);
    }
    function Z(J) {
      return `^${J.map((Q) => X(Q, "")).join("")}\$`;
    }
    $.Create = Z;
  })(E$ || (e8.TemplateLiteralPattern = E$ = {}));
  var H1;
  (function($) {
    function Y(W) {
      const X = v1.ParseExact(W.pattern);
      if (!p1.Check(X))
        return e8.Type.String();
      const Z = [...i1.Generate(X)].map((J) => e8.Type.Literal(J));
      return e8.Type.Union(Z);
    }
    $.Resolve = Y;
  })(H1 || (e8.TemplateLiteralResolver = H1 = {}));

  class V$ extends W1 {
  }
  e8.TemplateLiteralParserError = V$;
  var v1;
  (function($) {
    function Y(j, M, P) {
      return j[M] === P && j.charCodeAt(M - 1) !== 92;
    }
    function W(j, M) {
      return Y(j, M, "(");
    }
    function X(j, M) {
      return Y(j, M, ")");
    }
    function Z(j, M) {
      return Y(j, M, "|");
    }
    function J(j) {
      if (!(W(j, 0) && X(j, j.length - 1)))
        return false;
      let M = 0;
      for (let P = 0;P < j.length; P++) {
        if (W(j, P))
          M += 1;
        if (X(j, P))
          M -= 1;
        if (M === 0 && P !== j.length - 1)
          return false;
      }
      return true;
    }
    function Q(j) {
      return j.slice(1, j.length - 1);
    }
    function z(j) {
      let M = 0;
      for (let P = 0;P < j.length; P++) {
        if (W(j, P))
          M += 1;
        if (X(j, P))
          M -= 1;
        if (Z(j, P) && M === 0)
          return true;
      }
      return false;
    }
    function U(j) {
      for (let M = 0;M < j.length; M++)
        if (W(j, M))
          return true;
      return false;
    }
    function F(j) {
      let [M, P] = [0, 0];
      const O = [];
      for (let w = 0;w < j.length; w++) {
        if (W(j, w))
          M += 1;
        if (X(j, w))
          M -= 1;
        if (Z(j, w) && M === 0) {
          const I = j.slice(P, w);
          if (I.length > 0)
            O.push(S(I));
          P = w + 1;
        }
      }
      const A = j.slice(P);
      if (A.length > 0)
        O.push(S(A));
      if (O.length === 0)
        return { type: "const", const: "" };
      if (O.length === 1)
        return O[0];
      return { type: "or", expr: O };
    }
    function D(j) {
      function M(A, w) {
        if (!W(A, w))
          throw new V$("TemplateLiteralParser: Index must point to open parens");
        let I = 0;
        for (let G = w;G < A.length; G++) {
          if (W(A, G))
            I += 1;
          if (X(A, G))
            I -= 1;
          if (I === 0)
            return [w, G];
        }
        throw new V$("TemplateLiteralParser: Unclosed group parens in expression");
      }
      function P(A, w) {
        for (let I = w;I < A.length; I++)
          if (W(A, I))
            return [w, I];
        return [w, A.length];
      }
      const O = [];
      for (let A = 0;A < j.length; A++)
        if (W(j, A)) {
          const [w, I] = M(j, A), G = j.slice(w, I + 1);
          O.push(S(G)), A = I;
        } else {
          const [w, I] = P(j, A), G = j.slice(w, I);
          if (G.length > 0)
            O.push(S(G));
          A = I - 1;
        }
      return O.length === 0 ? { type: "const", const: "" } : O.length === 1 ? O[0] : { type: "and", expr: O };
    }
    function S(j) {
      return J(j) ? S(Q(j)) : z(j) ? F(j) : U(j) ? D(j) : { type: "const", const: j };
    }
    $.Parse = S;
    function b(j) {
      return S(j.slice(1, j.length - 1));
    }
    $.ParseExact = b;
  })(v1 || (e8.TemplateLiteralParser = v1 = {}));

  class F6 extends W1 {
  }
  e8.TemplateLiteralFiniteError = F6;
  var p1;
  (function($) {
    function Y(Q) {
      throw new F6(Q);
    }
    function W(Q) {
      return Q.type === "or" && Q.expr.length === 2 && Q.expr[0].type === "const" && Q.expr[0].const === "0" && Q.expr[1].type === "const" && Q.expr[1].const === "[1-9][0-9]*";
    }
    function X(Q) {
      return Q.type === "or" && Q.expr.length === 2 && Q.expr[0].type === "const" && Q.expr[0].const === "true" && Q.expr[1].type === "const" && Q.expr[1].const === "false";
    }
    function Z(Q) {
      return Q.type === "const" && Q.const === ".*";
    }
    function J(Q) {
      return X(Q) ? true : W(Q) || Z(Q) ? false : Q.type === "and" ? Q.expr.every((z) => J(z)) : Q.type === "or" ? Q.expr.every((z) => J(z)) : Q.type === "const" ? true : Y("Unknown expression type");
    }
    $.Check = J;
  })(p1 || (e8.TemplateLiteralFinite = p1 = {}));

  class D6 extends W1 {
  }
  e8.TemplateLiteralGeneratorError = D6;
  var i1;
  (function($) {
    function* Y(Q) {
      if (Q.length === 1)
        return yield* Q[0];
      for (let z of Q[0])
        for (let U of Y(Q.slice(1)))
          yield `${z}${U}`;
    }
    function* W(Q) {
      return yield* Y(Q.expr.map((z) => [...J(z)]));
    }
    function* X(Q) {
      for (let z of Q.expr)
        yield* J(z);
    }
    function* Z(Q) {
      return yield Q.const;
    }
    function* J(Q) {
      return Q.type === "and" ? yield* W(Q) : Q.type === "or" ? yield* X(Q) : Q.type === "const" ? yield* Z(Q) : (() => {
        throw new D6("Unknown expression");
      })();
    }
    $.Generate = J;
  })(i1 || (e8.TemplateLiteralGenerator = i1 = {}));
  var M6;
  (function($) {
    function* Y(J) {
      const Q = J.trim().replace(/"|'/g, "");
      return Q === "boolean" ? yield e8.Type.Boolean() : Q === "number" ? yield e8.Type.Number() : Q === "bigint" ? yield e8.Type.BigInt() : Q === "string" ? yield e8.Type.String() : yield (() => {
        const z = Q.split("|").map((U) => e8.Type.Literal(U.trim()));
        return z.length === 0 ? e8.Type.Never() : z.length === 1 ? z[0] : e8.Type.Union(z);
      })();
    }
    function* W(J) {
      if (J[1] !== "{") {
        const Q = e8.Type.Literal("$"), z = X(J.slice(1));
        return yield* [Q, ...z];
      }
      for (let Q = 2;Q < J.length; Q++)
        if (J[Q] === "}") {
          const z = Y(J.slice(2, Q)), U = X(J.slice(Q + 1));
          return yield* [...z, ...U];
        }
      yield e8.Type.Literal(J);
    }
    function* X(J) {
      for (let Q = 0;Q < J.length; Q++)
        if (J[Q] === "$") {
          const z = e8.Type.Literal(J.slice(0, Q)), U = W(J.slice(Q));
          return yield* [z, ...U];
        }
      yield e8.Type.Literal(J);
    }
    function Z(J) {
      return [...X(J)];
    }
    $.Parse = Z;
  })(M6 || (e8.TemplateLiteralDslParser = M6 = {}));

  class w6 {
    constructor($) {
      this.schema = $;
    }
    Decode($) {
      return new j6(this.schema, $);
    }
  }
  e8.TransformDecodeBuilder = w6;

  class j6 {
    constructor($, Y) {
      this.schema = $, this.decode = Y;
    }
    Encode($) {
      const Y = m.Type(this.schema);
      return B.TTransform(Y) ? (() => {
        const Z = { Encode: (J) => Y[e8.Transform].Encode($(J)), Decode: (J) => this.decode(Y[e8.Transform].Decode(J)) };
        return { ...Y, [e8.Transform]: Z };
      })() : (() => {
        const W = { Decode: this.decode, Encode: $ };
        return { ...Y, [e8.Transform]: W };
      })();
    }
  }
  e8.TransformEncodeBuilder = j6;
  var uX = 0;

  class K6 extends W1 {
  }
  e8.TypeBuilderError = K6;

  class P6 {
    Create($) {
      return $;
    }
    Throw($) {
      throw new K6($);
    }
    Discard($, Y) {
      return Y.reduce((W, X) => {
        const { [X]: Z, ...J } = W;
        return J;
      }, $);
    }
    Strict($) {
      return JSON.parse(JSON.stringify($));
    }
  }
  e8.TypeBuilder = P6;

  class x$ extends P6 {
    ReadonlyOptional($) {
      return this.Readonly(this.Optional($));
    }
    Readonly($) {
      return { ...m.Type($), [e8.Readonly]: "Readonly" };
    }
    Optional($) {
      return { ...m.Type($), [e8.Optional]: "Optional" };
    }
    Any($ = {}) {
      return this.Create({ ...$, [e8.Kind]: "Any" });
    }
    Array($, Y = {}) {
      return this.Create({ ...Y, [e8.Kind]: "Array", type: "array", items: m.Type($) });
    }
    Boolean($ = {}) {
      return this.Create({ ...$, [e8.Kind]: "Boolean", type: "boolean" });
    }
    Capitalize($, Y = {}) {
      return { ...f1.Map(m.Type($), "Capitalize"), ...Y };
    }
    Composite($, Y) {
      const W = e8.Type.Intersect($, {}), Z = _$.ResolveKeys(W, { includePatterns: false }).reduce((J, Q) => ({ ...J, [Q]: e8.Type.Index(W, [Q]) }), {});
      return e8.Type.Object(Z, Y);
    }
    Enum($, Y = {}) {
      if (V.IsUndefined($))
        return this.Throw("Enum undefined or empty");
      const W = Object.getOwnPropertyNames($).filter((J) => isNaN(J)).map((J) => $[J]), Z = [...new Set(W)].map((J) => e8.Type.Literal(J));
      return this.Union(Z, { ...Y, [e8.Hint]: "Enum" });
    }
    Extends($, Y, W, X, Z = {}) {
      switch (b1.Extends($, Y)) {
        case C.Union:
          return this.Union([m.Type(W, Z), m.Type(X, Z)]);
        case C.True:
          return m.Type(W, Z);
        case C.False:
          return m.Type(X, Z);
      }
    }
    Exclude($, Y, W = {}) {
      return B.TTemplateLiteral($) ? this.Exclude(H1.Resolve($), Y, W) : B.TTemplateLiteral(Y) ? this.Exclude($, H1.Resolve(Y), W) : B.TUnion($) ? (() => {
        const X = $.anyOf.filter((Z) => b1.Extends(Z, Y) === C.False);
        return X.length === 1 ? m.Type(X[0], W) : this.Union(X, W);
      })() : b1.Extends($, Y) !== C.False ? this.Never(W) : m.Type($, W);
    }
    Extract($, Y, W = {}) {
      return B.TTemplateLiteral($) ? this.Extract(H1.Resolve($), Y, W) : B.TTemplateLiteral(Y) ? this.Extract($, H1.Resolve(Y), W) : B.TUnion($) ? (() => {
        const X = $.anyOf.filter((Z) => b1.Extends(Z, Y) !== C.False);
        return X.length === 1 ? m.Type(X[0], W) : this.Union(X, W);
      })() : b1.Extends($, Y) !== C.False ? m.Type($, W) : this.Never(W);
    }
    Index($, Y, W = {}) {
      return B.TArray($) && B.TNumber(Y) ? (() => {
        return m.Type($.items, W);
      })() : B.TTuple($) && B.TNumber(Y) ? (() => {
        const Z = (V.IsUndefined($.items) ? [] : $.items).map((J) => m.Type(J));
        return this.Union(Z, W);
      })() : (() => {
        const X = Z$.Resolve(Y), Z = m.Type($);
        return q6.Resolve(Z, X, W);
      })();
    }
    Integer($ = {}) {
      return this.Create({ ...$, [e8.Kind]: "Integer", type: "integer" });
    }
    Intersect($, Y = {}) {
      if ($.length === 0)
        return e8.Type.Never();
      if ($.length === 1)
        return m.Type($[0], Y);
      if ($.some((J) => B.TTransform(J)))
        this.Throw("Cannot intersect transform types");
      const W = $.every((J) => B.TObject(J)), X = m.Rest($), Z = B.TSchema(Y.unevaluatedProperties) ? { unevaluatedProperties: m.Type(Y.unevaluatedProperties) } : {};
      return Y.unevaluatedProperties === false || B.TSchema(Y.unevaluatedProperties) || W ? this.Create({ ...Y, ...Z, [e8.Kind]: "Intersect", type: "object", allOf: X }) : this.Create({ ...Y, ...Z, [e8.Kind]: "Intersect", allOf: X });
    }
    KeyOf($, Y = {}) {
      return B.TRecord($) ? (() => {
        const W = Object.getOwnPropertyNames($.patternProperties)[0];
        return W === e8.PatternNumberExact ? this.Number(Y) : W === e8.PatternStringExact ? this.String(Y) : this.Throw("Unable to resolve key type from Record key pattern");
      })() : B.TTuple($) ? (() => {
        const X = (V.IsUndefined($.items) ? [] : $.items).map((Z, J) => e8.Type.Literal(J.toString()));
        return this.Union(X, Y);
      })() : B.TArray($) ? (() => {
        return this.Number(Y);
      })() : (() => {
        const W = _$.ResolveKeys($, { includePatterns: false });
        if (W.length === 0)
          return this.Never(Y);
        const X = W.map((Z) => this.Literal(Z));
        return this.Union(X, Y);
      })();
    }
    Literal($, Y = {}) {
      return this.Create({ ...Y, [e8.Kind]: "Literal", const: $, type: typeof $ });
    }
    Lowercase($, Y = {}) {
      return { ...f1.Map(m.Type($), "Lowercase"), ...Y };
    }
    Never($ = {}) {
      return this.Create({ ...$, [e8.Kind]: "Never", not: {} });
    }
    Not($, Y) {
      return this.Create({ ...Y, [e8.Kind]: "Not", not: m.Type($) });
    }
    Null($ = {}) {
      return this.Create({ ...$, [e8.Kind]: "Null", type: "null" });
    }
    Number($ = {}) {
      return this.Create({ ...$, [e8.Kind]: "Number", type: "number" });
    }
    Object($, Y = {}) {
      const W = Object.getOwnPropertyNames($), X = W.filter((z) => B.TOptional($[z])), Z = W.filter((z) => !X.includes(z)), J = B.TSchema(Y.additionalProperties) ? { additionalProperties: m.Type(Y.additionalProperties) } : {}, Q = W.reduce((z, U) => ({ ...z, [U]: m.Type($[U]) }), {});
      return Z.length > 0 ? this.Create({ ...Y, ...J, [e8.Kind]: "Object", type: "object", properties: Q, required: Z }) : this.Create({ ...Y, ...J, [e8.Kind]: "Object", type: "object", properties: Q });
    }
    Omit($, Y, W = {}) {
      const X = Z$.Resolve(Y);
      return T1.Map(this.Discard(m.Type($), ["$id", e8.Transform]), (Z) => {
        if (V.IsArray(Z.required)) {
          if (Z.required = Z.required.filter((J) => !X.includes(J)), Z.required.length === 0)
            delete Z.required;
        }
        for (let J of Object.getOwnPropertyNames(Z.properties))
          if (X.includes(J))
            delete Z.properties[J];
        return this.Create(Z);
      }, W);
    }
    Partial($, Y = {}) {
      return T1.Map(this.Discard(m.Type($), ["$id", e8.Transform]), (W) => {
        const X = Object.getOwnPropertyNames(W.properties).reduce((Z, J) => {
          return { ...Z, [J]: this.Optional(W.properties[J]) };
        }, {});
        return this.Object(X, this.Discard(W, ["required"]));
      }, Y);
    }
    Pick($, Y, W = {}) {
      const X = Z$.Resolve(Y);
      return T1.Map(this.Discard(m.Type($), ["$id", e8.Transform]), (Z) => {
        if (V.IsArray(Z.required)) {
          if (Z.required = Z.required.filter((J) => X.includes(J)), Z.required.length === 0)
            delete Z.required;
        }
        for (let J of Object.getOwnPropertyNames(Z.properties))
          if (!X.includes(J))
            delete Z.properties[J];
        return this.Create(Z);
      }, W);
    }
    Record($, Y, W = {}) {
      return B.TTemplateLiteral($) ? (() => {
        const X = v1.ParseExact($.pattern);
        return p1.Check(X) ? this.Object([...i1.Generate(X)].reduce((Z, J) => ({ ...Z, [J]: m.Type(Y) }), {}), W) : this.Create({ ...W, [e8.Kind]: "Record", type: "object", patternProperties: { [$.pattern]: m.Type(Y) } });
      })() : B.TUnion($) ? (() => {
        const X = N6.Resolve($);
        if (B.TUnionLiteral(X)) {
          const Z = X.anyOf.reduce((J, Q) => ({ ...J, [Q.const]: m.Type(Y) }), {});
          return this.Object(Z, { ...W, [e8.Hint]: "Record" });
        } else
          this.Throw("Record key of type union contains non-literal types");
      })() : B.TLiteral($) ? (() => {
        return V.IsString($.const) || V.IsNumber($.const) ? this.Object({ [$.const]: m.Type(Y) }, W) : this.Throw("Record key of type literal is not of type string or number");
      })() : B.TInteger($) || B.TNumber($) ? (() => {
        return this.Create({ ...W, [e8.Kind]: "Record", type: "object", patternProperties: { [e8.PatternNumberExact]: m.Type(Y) } });
      })() : B.TString($) ? (() => {
        const X = V.IsUndefined($.pattern) ? e8.PatternStringExact : $.pattern;
        return this.Create({ ...W, [e8.Kind]: "Record", type: "object", patternProperties: { [X]: m.Type(Y) } });
      })() : this.Never();
    }
    Recursive($, Y = {}) {
      if (V.IsUndefined(Y.$id))
        Y.$id = `T${uX++}`;
      const W = $({ [e8.Kind]: "This", $ref: `${Y.$id}` });
      return W.$id = Y.$id, this.Create({ ...Y, [e8.Hint]: "Recursive", ...W });
    }
    Ref($, Y = {}) {
      if (V.IsString($))
        return this.Create({ ...Y, [e8.Kind]: "Ref", $ref: $ });
      if (V.IsUndefined($.$id))
        this.Throw("Reference target type must specify an $id");
      return this.Create({ ...Y, [e8.Kind]: "Ref", $ref: $.$id });
    }
    Required($, Y = {}) {
      return T1.Map(this.Discard(m.Type($), ["$id", e8.Transform]), (W) => {
        const X = Object.getOwnPropertyNames(W.properties).reduce((Z, J) => {
          return { ...Z, [J]: this.Discard(W.properties[J], [e8.Optional]) };
        }, {});
        return this.Object(X, W);
      }, Y);
    }
    Rest($) {
      return B.TTuple($) && !V.IsUndefined($.items) ? m.Rest($.items) : B.TIntersect($) ? m.Rest($.allOf) : B.TUnion($) ? m.Rest($.anyOf) : [];
    }
    String($ = {}) {
      return this.Create({ ...$, [e8.Kind]: "String", type: "string" });
    }
    TemplateLiteral($, Y = {}) {
      const W = V.IsString($) ? E$.Create(M6.Parse($)) : E$.Create($);
      return this.Create({ ...Y, [e8.Kind]: "TemplateLiteral", type: "string", pattern: W });
    }
    Transform($) {
      return new w6($);
    }
    Tuple($, Y = {}) {
      const [W, X, Z] = [false, $.length, $.length], J = m.Rest($), Q = $.length > 0 ? { ...Y, [e8.Kind]: "Tuple", type: "array", items: J, additionalItems: W, minItems: X, maxItems: Z } : { ...Y, [e8.Kind]: "Tuple", type: "array", minItems: X, maxItems: Z };
      return this.Create(Q);
    }
    Uncapitalize($, Y = {}) {
      return { ...f1.Map(m.Type($), "Uncapitalize"), ...Y };
    }
    Union($, Y = {}) {
      return B.TTemplateLiteral($) ? H1.Resolve($) : (() => {
        const W = $;
        if (W.length === 0)
          return this.Never(Y);
        if (W.length === 1)
          return this.Create(m.Type(W[0], Y));
        const X = m.Rest(W);
        return this.Create({ ...Y, [e8.Kind]: "Union", anyOf: X });
      })();
    }
    Unknown($ = {}) {
      return this.Create({ ...$, [e8.Kind]: "Unknown" });
    }
    Unsafe($ = {}) {
      return this.Create({ ...$, [e8.Kind]: $[e8.Kind] || "Unsafe" });
    }
    Uppercase($, Y = {}) {
      return { ...f1.Map(m.Type($), "Uppercase"), ...Y };
    }
  }
  e8.JsonTypeBuilder = x$;

  class O6 extends x$ {
    AsyncIterator($, Y = {}) {
      return this.Create({ ...Y, [e8.Kind]: "AsyncIterator", type: "AsyncIterator", items: m.Type($) });
    }
    Awaited($, Y = {}) {
      const W = (X) => X.length > 0 ? (() => {
        const [Z, ...J] = X;
        return [this.Awaited(Z), ...W(J)];
      })() : X;
      return B.TIntersect($) ? e8.Type.Intersect(W($.allOf)) : B.TUnion($) ? e8.Type.Union(W($.anyOf)) : B.TPromise($) ? this.Awaited($.item) : m.Type($, Y);
    }
    BigInt($ = {}) {
      return this.Create({ ...$, [e8.Kind]: "BigInt", type: "bigint" });
    }
    ConstructorParameters($, Y = {}) {
      return this.Tuple([...$.parameters], { ...Y });
    }
    Constructor($, Y, W) {
      const [X, Z] = [m.Rest($), m.Type(Y)];
      return this.Create({ ...W, [e8.Kind]: "Constructor", type: "Constructor", parameters: X, returns: Z });
    }
    Date($ = {}) {
      return this.Create({ ...$, [e8.Kind]: "Date", type: "Date" });
    }
    Function($, Y, W) {
      const [X, Z] = [m.Rest($), m.Type(Y)];
      return this.Create({ ...W, [e8.Kind]: "Function", type: "Function", parameters: X, returns: Z });
    }
    InstanceType($, Y = {}) {
      return m.Type($.returns, Y);
    }
    Iterator($, Y = {}) {
      return this.Create({ ...Y, [e8.Kind]: "Iterator", type: "Iterator", items: m.Type($) });
    }
    Parameters($, Y = {}) {
      return this.Tuple($.parameters, { ...Y });
    }
    Promise($, Y = {}) {
      return this.Create({ ...Y, [e8.Kind]: "Promise", type: "Promise", item: m.Type($) });
    }
    RegExp($, Y = {}) {
      const W = V.IsString($) ? $ : $.source;
      return this.Create({ ...Y, [e8.Kind]: "String", type: "string", pattern: W });
    }
    RegEx($, Y = {}) {
      return this.RegExp($, Y);
    }
    ReturnType($, Y = {}) {
      return m.Type($.returns, Y);
    }
    Symbol($) {
      return this.Create({ ...$, [e8.Kind]: "Symbol", type: "symbol" });
    }
    Undefined($ = {}) {
      return this.Create({ ...$, [e8.Kind]: "Undefined", type: "undefined" });
    }
    Uint8Array($ = {}) {
      return this.Create({ ...$, [e8.Kind]: "Uint8Array", type: "Uint8Array" });
    }
    Void($ = {}) {
      return this.Create({ ...$, [e8.Kind]: "Void", type: "void" });
    }
  }
  e8.JavaScriptTypeBuilder = O6;
  e8.JsonType = new x$;
  e8.Type = new O6;
});
var G6 = z0((XY) => {
  var I6 = function($, Y) {
    switch (Y) {
      case y.ValueErrorType.ArrayContains:
        return "Expected array to contain at least one matching value";
      case y.ValueErrorType.ArrayMaxContains:
        return `Expected array to contain no more than ${$.maxContains} matching values`;
      case y.ValueErrorType.ArrayMinContains:
        return `Expected array to contain at least ${$.minContains} matching values`;
      case y.ValueErrorType.ArrayMaxItems:
        return `Expected array length to be less or equal to ${$.maxItems}`;
      case y.ValueErrorType.ArrayMinItems:
        return `Expected array length to be greater or equal to ${$.minItems}`;
      case y.ValueErrorType.ArrayUniqueItems:
        return "Expected array elements to be unique";
      case y.ValueErrorType.Array:
        return "Expected array";
      case y.ValueErrorType.AsyncIterator:
        return "Expected AsyncIterator";
      case y.ValueErrorType.BigIntExclusiveMaximum:
        return `Expected bigint to be less than ${$.exclusiveMaximum}`;
      case y.ValueErrorType.BigIntExclusiveMinimum:
        return `Expected bigint to be greater than ${$.exclusiveMinimum}`;
      case y.ValueErrorType.BigIntMaximum:
        return `Expected bigint to be less or equal to ${$.maximum}`;
      case y.ValueErrorType.BigIntMinimum:
        return `Expected bigint to be greater or equal to ${$.minimum}`;
      case y.ValueErrorType.BigIntMultipleOf:
        return `Expected bigint to be a multiple of ${$.multipleOf}`;
      case y.ValueErrorType.BigInt:
        return "Expected bigint";
      case y.ValueErrorType.Boolean:
        return "Expected boolean";
      case y.ValueErrorType.DateExclusiveMinimumTimestamp:
        return `Expected Date timestamp to be greater than ${$.exclusiveMinimumTimestamp}`;
      case y.ValueErrorType.DateExclusiveMaximumTimestamp:
        return `Expected Date timestamp to be less than ${$.exclusiveMaximumTimestamp}`;
      case y.ValueErrorType.DateMinimumTimestamp:
        return `Expected Date timestamp to be greater or equal to ${$.minimumTimestamp}`;
      case y.ValueErrorType.DateMaximumTimestamp:
        return `Expected Date timestamp to be less or equal to ${$.maximumTimestamp}`;
      case y.ValueErrorType.DateMultipleOfTimestamp:
        return `Expected Date timestamp to be a multiple of ${$.multipleOfTimestamp}`;
      case y.ValueErrorType.Date:
        return "Expected Date";
      case y.ValueErrorType.Function:
        return "Expected function";
      case y.ValueErrorType.IntegerExclusiveMaximum:
        return `Expected integer to be less than ${$.exclusiveMaximum}`;
      case y.ValueErrorType.IntegerExclusiveMinimum:
        return `Expected integer to be greater than ${$.exclusiveMinimum}`;
      case y.ValueErrorType.IntegerMaximum:
        return `Expected integer to be less or equal to ${$.maximum}`;
      case y.ValueErrorType.IntegerMinimum:
        return `Expected integer to be greater or equal to ${$.minimum}`;
      case y.ValueErrorType.IntegerMultipleOf:
        return `Expected integer to be a multiple of ${$.multipleOf}`;
      case y.ValueErrorType.Integer:
        return "Expected integer";
      case y.ValueErrorType.IntersectUnevaluatedProperties:
        return "Unexpected property";
      case y.ValueErrorType.Intersect:
        return "Expected all values to match";
      case y.ValueErrorType.Iterator:
        return "Expected Iterator";
      case y.ValueErrorType.Literal:
        return `Expected ${typeof $.const === "string" ? `'${$.const}'` : $.const}`;
      case y.ValueErrorType.Never:
        return "Never";
      case y.ValueErrorType.Not:
        return "Value should not match";
      case y.ValueErrorType.Null:
        return "Expected null";
      case y.ValueErrorType.NumberExclusiveMaximum:
        return `Expected number to be less than ${$.exclusiveMaximum}`;
      case y.ValueErrorType.NumberExclusiveMinimum:
        return `Expected number to be greater than ${$.exclusiveMinimum}`;
      case y.ValueErrorType.NumberMaximum:
        return `Expected number to be less or equal to ${$.maximum}`;
      case y.ValueErrorType.NumberMinimum:
        return `Expected number to be greater or equal to ${$.minimum}`;
      case y.ValueErrorType.NumberMultipleOf:
        return `Expected number to be a multiple of ${$.multipleOf}`;
      case y.ValueErrorType.Number:
        return "Expected number";
      case y.ValueErrorType.Object:
        return "Expected object";
      case y.ValueErrorType.ObjectAdditionalProperties:
        return "Unexpected property";
      case y.ValueErrorType.ObjectMaxProperties:
        return `Expected object to have no more than ${$.maxProperties} properties`;
      case y.ValueErrorType.ObjectMinProperties:
        return `Expected object to have at least ${$.minProperties} properties`;
      case y.ValueErrorType.ObjectRequiredProperty:
        return "Required property";
      case y.ValueErrorType.Promise:
        return "Expected Promise";
      case y.ValueErrorType.StringFormatUnknown:
        return `Unknown format '${$.format}'`;
      case y.ValueErrorType.StringFormat:
        return `Expected string to match '${$.format}' format`;
      case y.ValueErrorType.StringMaxLength:
        return `Expected string length less or equal to ${$.maxLength}`;
      case y.ValueErrorType.StringMinLength:
        return `Expected string length greater or equal to ${$.minLength}`;
      case y.ValueErrorType.StringPattern:
        return `Expected string to match '${$.pattern}'`;
      case y.ValueErrorType.String:
        return "Expected string";
      case y.ValueErrorType.Symbol:
        return "Expected symbol";
      case y.ValueErrorType.TupleLength:
        return `Expected tuple to have ${$.maxItems || 0} elements`;
      case y.ValueErrorType.Tuple:
        return "Expected tuple";
      case y.ValueErrorType.Uint8ArrayMaxByteLength:
        return `Expected byte length less or equal to ${$.maxByteLength}`;
      case y.ValueErrorType.Uint8ArrayMinByteLength:
        return `Expected byte length greater or equal to ${$.minByteLength}`;
      case y.ValueErrorType.Uint8Array:
        return "Expected Uint8Array";
      case y.ValueErrorType.Undefined:
        return "Expected undefined";
      case y.ValueErrorType.Union:
        return "Expected union value";
      case y.ValueErrorType.Void:
        return "Expected void";
      case y.ValueErrorType.Kind:
        return `Expected kind '${$[q1.Kind]}'`;
      default:
        return "Unknown error type";
    }
  };
  Object.defineProperty(XY, "__esModule", { value: true });
  XY.DefaultErrorFunction = XY.TypeSystemPolicy = XY.TypeSystemErrorFunction = XY.TypeSystem = XY.TypeSystemDuplicateFormat = XY.TypeSystemDuplicateTypeKind = undefined;
  var k$ = x0(), y = z$(), q1 = g0();

  class b6 extends q1.TypeBoxError {
    constructor($) {
      super(`Duplicate type kind '${$}' detected`);
    }
  }
  XY.TypeSystemDuplicateTypeKind = b6;

  class R6 extends q1.TypeBoxError {
    constructor($) {
      super(`Duplicate string format '${$}' detected`);
    }
  }
  XY.TypeSystemDuplicateFormat = R6;
  var $Y;
  (function($) {
    function Y(X, Z) {
      if (q1.TypeRegistry.Has(X))
        throw new b6(X);
      return q1.TypeRegistry.Set(X, Z), (J = {}) => q1.Type.Unsafe({ ...J, [q1.Kind]: X });
    }
    $.Type = Y;
    function W(X, Z) {
      if (q1.FormatRegistry.Has(X))
        throw new R6(X);
      return q1.FormatRegistry.Set(X, Z), X;
    }
    $.Format = W;
  })($Y || (XY.TypeSystem = $Y = {}));
  var YY;
  (function($) {
    let Y = I6;
    function W() {
      Y = I6;
    }
    $.Reset = W;
    function X(J) {
      Y = J;
    }
    $.Set = X;
    function Z() {
      return Y;
    }
    $.Get = Z;
  })(YY || (XY.TypeSystemErrorFunction = YY = {}));
  var WY;
  (function($) {
    $.ExactOptionalPropertyTypes = false, $.AllowArrayObject = false, $.AllowNaN = false, $.AllowNullVoid = false;
    function Y(Q, z) {
      return $.ExactOptionalPropertyTypes ? z in Q : Q[z] !== undefined;
    }
    $.IsExactOptionalProperty = Y;
    function W(Q) {
      const z = (0, k$.IsObject)(Q);
      return $.AllowArrayObject ? z : z && !(0, k$.IsArray)(Q);
    }
    $.IsObjectLike = W;
    function X(Q) {
      return W(Q) && !(Q instanceof Date) && !(Q instanceof Uint8Array);
    }
    $.IsRecordLike = X;
    function Z(Q) {
      const z = (0, k$.IsNumber)(Q);
      return $.AllowNaN ? z : z && Number.isFinite(Q);
    }
    $.IsNumberLike = Z;
    function J(Q) {
      const z = (0, k$.IsUndefined)(Q);
      return $.AllowNullVoid ? z || Q === null : z;
    }
    $.IsVoidLike = J;
  })(WY || (XY.TypeSystemPolicy = WY = {}));
  XY.DefaultErrorFunction = I6;
});
var K1 = z0((JY) => {
  var xZ = function($, Y) {
    const W = Y.findIndex((X) => X.$id === $.$ref);
    if (W === -1)
      throw new _6($);
    return Y[W];
  };
  Object.defineProperty(JY, "__esModule", { value: true });
  JY.Deref = JY.TypeDereferenceError = undefined;
  var VZ = g0();

  class _6 extends VZ.TypeBoxError {
    constructor($) {
      super(`Unable to dereference schema with $id '${$.$id}'`);
      this.schema = $;
    }
  }
  JY.TypeDereferenceError = _6;
  JY.Deref = xZ;
});
var H$ = z0((NY) => {
  function* dZ($) {
    const Y = $ === 0 ? 1 : Math.ceil(Math.floor(Math.log2($) + 1) / 8);
    for (let W = 0;W < Y; W++)
      yield $ >> 8 * (Y - 1 - W) & 255;
  }
  var yZ = function($) {
    _0(f0.Array);
    for (let Y of $)
      u1(Y);
  }, vZ = function($) {
    _0(f0.Boolean), _0($ ? 1 : 0);
  }, pZ = function($) {
    _0(f0.BigInt), HY.setBigInt64(0, $);
    for (let Y of qY)
      _0(Y);
  }, iZ = function($) {
    _0(f0.Date), u1($.getTime());
  }, mZ = function($) {
    _0(f0.Null);
  }, uZ = function($) {
    _0(f0.Number), HY.setFloat64(0, $);
    for (let Y of qY)
      _0(Y);
  }, hZ = function($) {
    _0(f0.Object);
    for (let Y of globalThis.Object.keys($).sort())
      u1(Y), u1($[Y]);
  }, nZ = function($) {
    _0(f0.String);
    for (let Y = 0;Y < $.length; Y++)
      for (let W of dZ($.charCodeAt(Y)))
        _0(W);
  }, oZ = function($) {
    _0(f0.Symbol), u1($.description);
  }, cZ = function($) {
    _0(f0.Uint8Array);
    for (let Y = 0;Y < $.length; Y++)
      _0($[Y]);
  }, lZ = function($) {
    return _0(f0.Undefined);
  }, u1 = function($) {
    if ((0, c0.IsArray)($))
      return yZ($);
    if ((0, c0.IsBoolean)($))
      return vZ($);
    if ((0, c0.IsBigInt)($))
      return pZ($);
    if ((0, c0.IsDate)($))
      return iZ($);
    if ((0, c0.IsNull)($))
      return mZ($);
    if ((0, c0.IsNumber)($))
      return uZ($);
    if ((0, c0.IsPlainObject)($))
      return hZ($);
    if ((0, c0.IsString)($))
      return nZ($);
    if ((0, c0.IsSymbol)($))
      return oZ($);
    if ((0, c0.IsUint8Array)($))
      return cZ($);
    if ((0, c0.IsUndefined)($))
      return lZ($);
    throw new E6($);
  }, _0 = function($) {
    m1 = m1 ^ TZ[$], m1 = m1 * gZ % fZ;
  }, tZ = function($) {
    return m1 = BigInt("14695981039346656037"), u1($), m1;
  };
  Object.defineProperty(NY, "__esModule", { value: true });
  NY.Hash = NY.ByteMarker = NY.ValueHashError = undefined;
  var c0 = x0();

  class E6 extends Error {
    constructor($) {
      super("Unable to hash value");
      this.value = $;
    }
  }
  NY.ValueHashError = E6;
  var f0;
  (function($) {
    $[$.Undefined = 0] = "Undefined", $[$.Null = 1] = "Null", $[$.Boolean = 2] = "Boolean", $[$.Number = 3] = "Number", $[$.String = 4] = "String", $[$.Object = 5] = "Object", $[$.Array = 6] = "Array", $[$.Date = 7] = "Date", $[$.Uint8Array = 8] = "Uint8Array", $[$.Symbol = 9] = "Symbol", $[$.BigInt = 10] = "BigInt";
  })(f0 || (NY.ByteMarker = f0 = {}));
  var m1 = BigInt("14695981039346656037"), [gZ, fZ] = [BigInt("1099511628211"), BigInt("2") ** BigInt("64")], TZ = Array.from({ length: 256 }).map(($, Y) => BigInt(Y)), zY = new Float64Array(1), HY = new DataView(zY.buffer), qY = new Uint8Array(zY.buffer);
  NY.Hash = tZ;
});
var z$ = z0((UY) => {
  var X1 = function($) {
    return $.replace(/~/g, "~0").replace(/\//g, "~1");
  }, s = function($) {
    return $ !== undefined;
  }, g = function($, Y, W, X) {
    return { type: $, schema: Y, path: W, value: X, message: h1.TypeSystemErrorFunction.Get()(Y, $) };
  };
  function* eZ($, Y, W, X) {
  }
  function* $J($, Y, W, X) {
    if (!(0, D0.IsArray)(X))
      return yield g(x.Array, $, W, X);
    if (s($.minItems) && !(X.length >= $.minItems))
      yield g(x.ArrayMinItems, $, W, X);
    if (s($.maxItems) && !(X.length <= $.maxItems))
      yield g(x.ArrayMaxItems, $, W, X);
    for (let Q = 0;Q < X.length; Q++)
      yield* C0($.items, Y, `${W}/${Q}`, X[Q]);
    if ($.uniqueItems === true && !function() {
      const Q = new Set;
      for (let z of X) {
        const U = (0, aZ.Hash)(z);
        if (Q.has(U))
          return false;
        else
          Q.add(U);
      }
      return true;
    }())
      yield g(x.ArrayUniqueItems, $, W, X);
    if (!(s($.contains) || s($.minContains) || s($.maxContains)))
      return;
    const Z = s($.contains) ? $.contains : p0.Type.Never(), J = X.reduce((Q, z, U) => C0(Z, Y, `${W}${U}`, z).next().done === true ? Q + 1 : Q, 0);
    if (J === 0)
      yield g(x.ArrayContains, $, W, X);
    if ((0, D0.IsNumber)($.minContains) && J < $.minContains)
      yield g(x.ArrayMinContains, $, W, X);
    if ((0, D0.IsNumber)($.maxContains) && J > $.maxContains)
      yield g(x.ArrayMaxContains, $, W, X);
  }
  function* YJ($, Y, W, X) {
    if (!(0, D0.IsAsyncIterator)(X))
      yield g(x.AsyncIterator, $, W, X);
  }
  function* WJ($, Y, W, X) {
    if (!(0, D0.IsBigInt)(X))
      return yield g(x.BigInt, $, W, X);
    if (s($.exclusiveMaximum) && !(X < $.exclusiveMaximum))
      yield g(x.BigIntExclusiveMaximum, $, W, X);
    if (s($.exclusiveMinimum) && !(X > $.exclusiveMinimum))
      yield g(x.BigIntExclusiveMinimum, $, W, X);
    if (s($.maximum) && !(X <= $.maximum))
      yield g(x.BigIntMaximum, $, W, X);
    if (s($.minimum) && !(X >= $.minimum))
      yield g(x.BigIntMinimum, $, W, X);
    if (s($.multipleOf) && X % $.multipleOf !== BigInt(0))
      yield g(x.BigIntMultipleOf, $, W, X);
  }
  function* XJ($, Y, W, X) {
    if (!(0, D0.IsBoolean)(X))
      yield g(x.Boolean, $, W, X);
  }
  function* ZJ($, Y, W, X) {
    yield* C0($.returns, Y, W, X.prototype);
  }
  function* JJ($, Y, W, X) {
    if (!(0, D0.IsDate)(X))
      return yield g(x.Date, $, W, X);
    if (s($.exclusiveMaximumTimestamp) && !(X.getTime() < $.exclusiveMaximumTimestamp))
      yield g(x.DateExclusiveMaximumTimestamp, $, W, X);
    if (s($.exclusiveMinimumTimestamp) && !(X.getTime() > $.exclusiveMinimumTimestamp))
      yield g(x.DateExclusiveMinimumTimestamp, $, W, X);
    if (s($.maximumTimestamp) && !(X.getTime() <= $.maximumTimestamp))
      yield g(x.DateMaximumTimestamp, $, W, X);
    if (s($.minimumTimestamp) && !(X.getTime() >= $.minimumTimestamp))
      yield g(x.DateMinimumTimestamp, $, W, X);
    if (s($.multipleOfTimestamp) && X.getTime() % $.multipleOfTimestamp !== 0)
      yield g(x.DateMultipleOfTimestamp, $, W, X);
  }
  function* QJ($, Y, W, X) {
    if (!(0, D0.IsFunction)(X))
      yield g(x.Function, $, W, X);
  }
  function* zJ($, Y, W, X) {
    if (!(0, D0.IsInteger)(X))
      return yield g(x.Integer, $, W, X);
    if (s($.exclusiveMaximum) && !(X < $.exclusiveMaximum))
      yield g(x.IntegerExclusiveMaximum, $, W, X);
    if (s($.exclusiveMinimum) && !(X > $.exclusiveMinimum))
      yield g(x.IntegerExclusiveMinimum, $, W, X);
    if (s($.maximum) && !(X <= $.maximum))
      yield g(x.IntegerMaximum, $, W, X);
    if (s($.minimum) && !(X >= $.minimum))
      yield g(x.IntegerMinimum, $, W, X);
    if (s($.multipleOf) && X % $.multipleOf !== 0)
      yield g(x.IntegerMultipleOf, $, W, X);
  }
  function* HJ($, Y, W, X) {
    for (let Z of $.allOf) {
      const J = C0(Z, Y, W, X).next();
      if (!J.done)
        yield g(x.Intersect, $, W, X), yield J.value;
    }
    if ($.unevaluatedProperties === false) {
      const Z = new RegExp(p0.KeyResolver.ResolvePattern($));
      for (let J of Object.getOwnPropertyNames(X))
        if (!Z.test(J))
          yield g(x.IntersectUnevaluatedProperties, $, `${W}/${J}`, X);
    }
    if (typeof $.unevaluatedProperties === "object") {
      const Z = new RegExp(p0.KeyResolver.ResolvePattern($));
      for (let J of Object.getOwnPropertyNames(X))
        if (!Z.test(J)) {
          const Q = C0($.unevaluatedProperties, Y, `${W}/${J}`, X[J]).next();
          if (!Q.done)
            yield Q.value;
        }
    }
  }
  function* qJ($, Y, W, X) {
    if (!(0, D0.IsIterator)(X))
      yield g(x.Iterator, $, W, X);
  }
  function* NJ($, Y, W, X) {
    if (X !== $.const)
      yield g(x.Literal, $, W, X);
  }
  function* MJ($, Y, W, X) {
    yield g(x.Never, $, W, X);
  }
  function* AJ($, Y, W, X) {
    if (C0($.not, Y, W, X).next().done === true)
      yield g(x.Not, $, W, X);
  }
  function* UJ($, Y, W, X) {
    if (!(0, D0.IsNull)(X))
      yield g(x.Null, $, W, X);
  }
  function* BJ($, Y, W, X) {
    if (!h1.TypeSystemPolicy.IsNumberLike(X))
      return yield g(x.Number, $, W, X);
    if (s($.exclusiveMaximum) && !(X < $.exclusiveMaximum))
      yield g(x.NumberExclusiveMaximum, $, W, X);
    if (s($.exclusiveMinimum) && !(X > $.exclusiveMinimum))
      yield g(x.NumberExclusiveMinimum, $, W, X);
    if (s($.maximum) && !(X <= $.maximum))
      yield g(x.NumberMaximum, $, W, X);
    if (s($.minimum) && !(X >= $.minimum))
      yield g(x.NumberMinimum, $, W, X);
    if (s($.multipleOf) && X % $.multipleOf !== 0)
      yield g(x.NumberMultipleOf, $, W, X);
  }
  function* FJ($, Y, W, X) {
    if (!h1.TypeSystemPolicy.IsObjectLike(X))
      return yield g(x.Object, $, W, X);
    if (s($.minProperties) && !(Object.getOwnPropertyNames(X).length >= $.minProperties))
      yield g(x.ObjectMinProperties, $, W, X);
    if (s($.maxProperties) && !(Object.getOwnPropertyNames(X).length <= $.maxProperties))
      yield g(x.ObjectMaxProperties, $, W, X);
    const Z = Array.isArray($.required) ? $.required : [], J = Object.getOwnPropertyNames($.properties), Q = Object.getOwnPropertyNames(X);
    for (let z of Z) {
      if (Q.includes(z))
        continue;
      yield g(x.ObjectRequiredProperty, $.properties[z], `${W}/${X1(z)}`, undefined);
    }
    if ($.additionalProperties === false) {
      for (let z of Q)
        if (!J.includes(z))
          yield g(x.ObjectAdditionalProperties, $, `${W}/${X1(z)}`, X[z]);
    }
    if (typeof $.additionalProperties === "object")
      for (let z of Q) {
        if (J.includes(z))
          continue;
        yield* C0($.additionalProperties, Y, `${W}/${X1(z)}`, X[z]);
      }
    for (let z of J) {
      const U = $.properties[z];
      if ($.required && $.required.includes(z)) {
        if (yield* C0(U, Y, `${W}/${X1(z)}`, X[z]), p0.ExtendsUndefined.Check($) && !(z in X))
          yield g(x.ObjectRequiredProperty, U, `${W}/${X1(z)}`, undefined);
      } else if (h1.TypeSystemPolicy.IsExactOptionalProperty(X, z))
        yield* C0(U, Y, `${W}/${X1(z)}`, X[z]);
    }
  }
  function* DJ($, Y, W, X) {
    if (!(0, D0.IsPromise)(X))
      yield g(x.Promise, $, W, X);
  }
  function* wJ($, Y, W, X) {
    if (!h1.TypeSystemPolicy.IsRecordLike(X))
      return yield g(x.Object, $, W, X);
    if (s($.minProperties) && !(Object.getOwnPropertyNames(X).length >= $.minProperties))
      yield g(x.ObjectMinProperties, $, W, X);
    if (s($.maxProperties) && !(Object.getOwnPropertyNames(X).length <= $.maxProperties))
      yield g(x.ObjectMaxProperties, $, W, X);
    const [Z, J] = Object.entries($.patternProperties)[0], Q = new RegExp(Z);
    for (let [z, U] of Object.entries(X))
      if (Q.test(z))
        yield* C0(J, Y, `${W}/${X1(z)}`, U);
    if (typeof $.additionalProperties === "object") {
      for (let [z, U] of Object.entries(X))
        if (!Q.test(z))
          yield* C0($.additionalProperties, Y, `${W}/${X1(z)}`, U);
    }
    if ($.additionalProperties === false)
      for (let [z, U] of Object.entries(X)) {
        if (Q.test(z))
          continue;
        return yield g(x.ObjectAdditionalProperties, $, `${W}/${X1(z)}`, U);
      }
  }
  function* jJ($, Y, W, X) {
    yield* C0((0, AY.Deref)($, Y), Y, W, X);
  }
  function* KJ($, Y, W, X) {
    if (!(0, D0.IsString)(X))
      return yield g(x.String, $, W, X);
    if (s($.minLength) && !(X.length >= $.minLength))
      yield g(x.StringMinLength, $, W, X);
    if (s($.maxLength) && !(X.length <= $.maxLength))
      yield g(x.StringMaxLength, $, W, X);
    if ((0, D0.IsString)($.pattern)) {
      if (!new RegExp($.pattern).test(X))
        yield g(x.StringPattern, $, W, X);
    }
    if ((0, D0.IsString)($.format)) {
      if (!p0.FormatRegistry.Has($.format))
        yield g(x.StringFormatUnknown, $, W, X);
      else if (!p0.FormatRegistry.Get($.format)(X))
        yield g(x.StringFormat, $, W, X);
    }
  }
  function* PJ($, Y, W, X) {
    if (!(0, D0.IsSymbol)(X))
      yield g(x.Symbol, $, W, X);
  }
  function* OJ($, Y, W, X) {
    if (!(0, D0.IsString)(X))
      return yield g(x.String, $, W, X);
    if (!new RegExp($.pattern).test(X))
      yield g(x.StringPattern, $, W, X);
  }
  function* SJ($, Y, W, X) {
    yield* C0((0, AY.Deref)($, Y), Y, W, X);
  }
  function* LJ($, Y, W, X) {
    if (!(0, D0.IsArray)(X))
      return yield g(x.Tuple, $, W, X);
    if ($.items === undefined && X.length !== 0)
      return yield g(x.TupleLength, $, W, X);
    if (X.length !== $.maxItems)
      return yield g(x.TupleLength, $, W, X);
    if (!$.items)
      return;
    for (let Z = 0;Z < $.items.length; Z++)
      yield* C0($.items[Z], Y, `${W}/${Z}`, X[Z]);
  }
  function* CJ($, Y, W, X) {
    if (!(0, D0.IsUndefined)(X))
      yield g(x.Undefined, $, W, X);
  }
  function* IJ($, Y, W, X) {
    let Z = 0;
    for (let J of $.anyOf) {
      const Q = [...C0(J, Y, W, X)];
      if (Q.length === 0)
        return;
      Z += Q.length;
    }
    if (Z > 0)
      yield g(x.Union, $, W, X);
  }
  function* bJ($, Y, W, X) {
    if (!(0, D0.IsUint8Array)(X))
      return yield g(x.Uint8Array, $, W, X);
    if (s($.maxByteLength) && !(X.length <= $.maxByteLength))
      yield g(x.Uint8ArrayMaxByteLength, $, W, X);
    if (s($.minByteLength) && !(X.length >= $.minByteLength))
      yield g(x.Uint8ArrayMinByteLength, $, W, X);
  }
  function* RJ($, Y, W, X) {
  }
  function* GJ($, Y, W, X) {
    if (!h1.TypeSystemPolicy.IsVoidLike(X))
      yield g(x.Void, $, W, X);
  }
  function* _J($, Y, W, X) {
    if (!p0.TypeRegistry.Get($[p0.Kind])($, X))
      yield g(x.Kind, $, W, X);
  }
  function* C0($, Y, W, X) {
    const Z = s($.$id) ? [...Y, $] : Y, J = $;
    switch (J[p0.Kind]) {
      case "Any":
        return yield* eZ(J, Z, W, X);
      case "Array":
        return yield* $J(J, Z, W, X);
      case "AsyncIterator":
        return yield* YJ(J, Z, W, X);
      case "BigInt":
        return yield* WJ(J, Z, W, X);
      case "Boolean":
        return yield* XJ(J, Z, W, X);
      case "Constructor":
        return yield* ZJ(J, Z, W, X);
      case "Date":
        return yield* JJ(J, Z, W, X);
      case "Function":
        return yield* QJ(J, Z, W, X);
      case "Integer":
        return yield* zJ(J, Z, W, X);
      case "Intersect":
        return yield* HJ(J, Z, W, X);
      case "Iterator":
        return yield* qJ(J, Z, W, X);
      case "Literal":
        return yield* NJ(J, Z, W, X);
      case "Never":
        return yield* MJ(J, Z, W, X);
      case "Not":
        return yield* AJ(J, Z, W, X);
      case "Null":
        return yield* UJ(J, Z, W, X);
      case "Number":
        return yield* BJ(J, Z, W, X);
      case "Object":
        return yield* FJ(J, Z, W, X);
      case "Promise":
        return yield* DJ(J, Z, W, X);
      case "Record":
        return yield* wJ(J, Z, W, X);
      case "Ref":
        return yield* jJ(J, Z, W, X);
      case "String":
        return yield* KJ(J, Z, W, X);
      case "Symbol":
        return yield* PJ(J, Z, W, X);
      case "TemplateLiteral":
        return yield* OJ(J, Z, W, X);
      case "This":
        return yield* SJ(J, Z, W, X);
      case "Tuple":
        return yield* LJ(J, Z, W, X);
      case "Undefined":
        return yield* CJ(J, Z, W, X);
      case "Union":
        return yield* IJ(J, Z, W, X);
      case "Uint8Array":
        return yield* bJ(J, Z, W, X);
      case "Unknown":
        return yield* RJ(J, Z, W, X);
      case "Void":
        return yield* GJ(J, Z, W, X);
      default:
        if (!p0.TypeRegistry.Has(J[p0.Kind]))
          throw new V6($);
        return yield* _J(J, Z, W, X);
    }
  }
  var EJ = function(...$) {
    const Y = $.length === 3 ? C0($[0], $[1], "", $[2]) : C0($[0], [], "", $[1]);
    return new x6(Y);
  };
  Object.defineProperty(UY, "__esModule", { value: true });
  UY.Errors = UY.ValueErrorIterator = UY.EscapeKey = UY.ValueErrorsUnknownTypeError = UY.ValueErrorType = undefined;
  var D0 = x0(), h1 = G6(), AY = K1(), aZ = H$(), p0 = g0(), x;
  (function($) {
    $[$.ArrayContains = 0] = "ArrayContains", $[$.ArrayMaxContains = 1] = "ArrayMaxContains", $[$.ArrayMaxItems = 2] = "ArrayMaxItems", $[$.ArrayMinContains = 3] = "ArrayMinContains", $[$.ArrayMinItems = 4] = "ArrayMinItems", $[$.ArrayUniqueItems = 5] = "ArrayUniqueItems", $[$.Array = 6] = "Array", $[$.AsyncIterator = 7] = "AsyncIterator", $[$.BigIntExclusiveMaximum = 8] = "BigIntExclusiveMaximum", $[$.BigIntExclusiveMinimum = 9] = "BigIntExclusiveMinimum", $[$.BigIntMaximum = 10] = "BigIntMaximum", $[$.BigIntMinimum = 11] = "BigIntMinimum", $[$.BigIntMultipleOf = 12] = "BigIntMultipleOf", $[$.BigInt = 13] = "BigInt", $[$.Boolean = 14] = "Boolean", $[$.DateExclusiveMaximumTimestamp = 15] = "DateExclusiveMaximumTimestamp", $[$.DateExclusiveMinimumTimestamp = 16] = "DateExclusiveMinimumTimestamp", $[$.DateMaximumTimestamp = 17] = "DateMaximumTimestamp", $[$.DateMinimumTimestamp = 18] = "DateMinimumTimestamp", $[$.DateMultipleOfTimestamp = 19] = "DateMultipleOfTimestamp", $[$.Date = 20] = "Date", $[$.Function = 21] = "Function", $[$.IntegerExclusiveMaximum = 22] = "IntegerExclusiveMaximum", $[$.IntegerExclusiveMinimum = 23] = "IntegerExclusiveMinimum", $[$.IntegerMaximum = 24] = "IntegerMaximum", $[$.IntegerMinimum = 25] = "IntegerMinimum", $[$.IntegerMultipleOf = 26] = "IntegerMultipleOf", $[$.Integer = 27] = "Integer", $[$.IntersectUnevaluatedProperties = 28] = "IntersectUnevaluatedProperties", $[$.Intersect = 29] = "Intersect", $[$.Iterator = 30] = "Iterator", $[$.Kind = 31] = "Kind", $[$.Literal = 32] = "Literal", $[$.Never = 33] = "Never", $[$.Not = 34] = "Not", $[$.Null = 35] = "Null", $[$.NumberExclusiveMaximum = 36] = "NumberExclusiveMaximum", $[$.NumberExclusiveMinimum = 37] = "NumberExclusiveMinimum", $[$.NumberMaximum = 38] = "NumberMaximum", $[$.NumberMinimum = 39] = "NumberMinimum", $[$.NumberMultipleOf = 40] = "NumberMultipleOf", $[$.Number = 41] = "Number", $[$.ObjectAdditionalProperties = 42] = "ObjectAdditionalProperties", $[$.ObjectMaxProperties = 43] = "ObjectMaxProperties", $[$.ObjectMinProperties = 44] = "ObjectMinProperties", $[$.ObjectRequiredProperty = 45] = "ObjectRequiredProperty", $[$.Object = 46] = "Object", $[$.Promise = 47] = "Promise", $[$.StringFormatUnknown = 48] = "StringFormatUnknown", $[$.StringFormat = 49] = "StringFormat", $[$.StringMaxLength = 50] = "StringMaxLength", $[$.StringMinLength = 51] = "StringMinLength", $[$.StringPattern = 52] = "StringPattern", $[$.String = 53] = "String", $[$.Symbol = 54] = "Symbol", $[$.TupleLength = 55] = "TupleLength", $[$.Tuple = 56] = "Tuple", $[$.Uint8ArrayMaxByteLength = 57] = "Uint8ArrayMaxByteLength", $[$.Uint8ArrayMinByteLength = 58] = "Uint8ArrayMinByteLength", $[$.Uint8Array = 59] = "Uint8Array", $[$.Undefined = 60] = "Undefined", $[$.Union = 61] = "Union", $[$.Void = 62] = "Void";
  })(x || (UY.ValueErrorType = x = {}));

  class V6 extends p0.TypeBoxError {
    constructor($) {
      super("Unknown type");
      this.schema = $;
    }
  }
  UY.ValueErrorsUnknownTypeError = V6;
  UY.EscapeKey = X1;

  class x6 {
    constructor($) {
      this.iterator = $;
    }
    [Symbol.iterator]() {
      return this.iterator;
    }
    First() {
      const $ = this.iterator.next();
      return $.done ? undefined : $.value;
    }
  }
  UY.ValueErrorIterator = x6;
  UY.Errors = EJ;
});
var g$ = z0((G1) => {
  var fJ = G1 && G1.__createBinding || (Object.create ? function($, Y, W, X) {
    if (X === undefined)
      X = W;
    var Z = Object.getOwnPropertyDescriptor(Y, W);
    if (!Z || ("get" in Z ? !Y.__esModule : Z.writable || Z.configurable))
      Z = { enumerable: true, get: function() {
        return Y[W];
      } };
    Object.defineProperty($, X, Z);
  } : function($, Y, W, X) {
    if (X === undefined)
      X = W;
    $[X] = Y[W];
  }), TJ = G1 && G1.__exportStar || function($, Y) {
    for (var W in $)
      if (W !== "default" && !Object.prototype.hasOwnProperty.call(Y, W))
        fJ(Y, $, W);
  };
  Object.defineProperty(G1, "__esModule", { value: true });
  TJ(z$(), G1);
});
var f$ = z0((DY) => {
  Object.defineProperty(DY, "__esModule", { value: true });
  DY.ValuePointer = DY.ValuePointerRootDeleteError = DY.ValuePointerRootSetError = undefined;

  class k6 extends Error {
    constructor($, Y, W) {
      super("Cannot set root value");
      this.value = $, this.path = Y, this.update = W;
    }
  }
  DY.ValuePointerRootSetError = k6;

  class g6 extends Error {
    constructor($, Y) {
      super("Cannot delete root value");
      this.value = $, this.path = Y;
    }
  }
  DY.ValuePointerRootDeleteError = g6;
  var FY;
  (function($) {
    function Y(z) {
      return z.indexOf("~") === -1 ? z : z.replace(/~1/g, "/").replace(/~0/g, "~");
    }
    function* W(z) {
      if (z === "")
        return;
      let [U, F] = [0, 0];
      for (let D = 0;D < z.length; D++)
        if (z.charAt(D) === "/")
          if (D === 0)
            U = D + 1;
          else
            F = D, yield Y(z.slice(U, F)), U = D + 1;
        else
          F = D;
      yield Y(z.slice(U));
    }
    $.Format = W;
    function X(z, U, F) {
      if (U === "")
        throw new k6(z, U, F);
      let [D, S, b] = [null, z, ""];
      for (let j of W(U)) {
        if (S[j] === undefined)
          S[j] = {};
        D = S, S = S[j], b = j;
      }
      D[b] = F;
    }
    $.Set = X;
    function Z(z, U) {
      if (U === "")
        throw new g6(z, U);
      let [F, D, S] = [null, z, ""];
      for (let b of W(U)) {
        if (D[b] === undefined || D[b] === null)
          return;
        F = D, D = D[b], S = b;
      }
      if (Array.isArray(F)) {
        const b = parseInt(S);
        F.splice(b, 1);
      } else
        delete F[S];
    }
    $.Delete = Z;
    function J(z, U) {
      if (U === "")
        return true;
      let [F, D, S] = [null, z, ""];
      for (let b of W(U)) {
        if (D[b] === undefined)
          return false;
        F = D, D = D[b], S = b;
      }
      return Object.getOwnPropertyNames(F).includes(S);
    }
    $.Has = J;
    function Q(z, U) {
      if (U === "")
        return z;
      let F = z;
      for (let D of W(U)) {
        if (F[D] === undefined)
          return;
        F = F[D];
      }
      return F;
    }
    $.Get = Q;
  })(FY || (DY.ValuePointer = FY = {}));
});
var n1 = z0((jY) => {
  var vJ = function($) {
    return [...Object.getOwnPropertyNames($), ...Object.getOwnPropertySymbols($)].reduce((W, X) => ({ ...W, [X]: f6($[X]) }), {});
  }, pJ = function($) {
    return $.map((Y) => f6(Y));
  }, iJ = function($) {
    return $.slice();
  }, mJ = function($) {
    return new Date($.toISOString());
  }, uJ = function($) {
    return $;
  }, f6 = function($) {
    if ((0, q$.IsArray)($))
      return pJ($);
    if ((0, q$.IsDate)($))
      return mJ($);
    if ((0, q$.IsPlainObject)($))
      return vJ($);
    if ((0, q$.IsTypedArray)($))
      return iJ($);
    if ((0, q$.IsValueType)($))
      return uJ($);
    throw new Error("ValueClone: Unable to clone value");
  };
  Object.defineProperty(jY, "__esModule", { value: true });
  jY.Clone = undefined;
  var q$ = x0();
  jY.Clone = f6;
});
var v6 = z0((SY) => {
  var N$ = function($, Y) {
    return { type: "update", path: $, value: Y };
  }, PY = function($, Y) {
    return { type: "insert", path: $, value: Y };
  }, OY = function($) {
    return { type: "delete", path: $ };
  };
  function* hJ($, Y, W) {
    if (!(0, E0.IsPlainObject)(W))
      return yield N$($, W);
    const X = [...Object.keys(Y), ...Object.getOwnPropertySymbols(Y)], Z = [...Object.keys(W), ...Object.getOwnPropertySymbols(W)];
    for (let J of X) {
      if ((0, E0.IsSymbol)(J))
        throw new o1(J);
      if ((0, E0.IsUndefined)(W[J]) && Z.includes(J))
        yield N$(`${$}/${String(J)}`, undefined);
    }
    for (let J of Z) {
      if ((0, E0.IsUndefined)(Y[J]) || (0, E0.IsUndefined)(W[J]))
        continue;
      if ((0, E0.IsSymbol)(J))
        throw new o1(J);
      yield* T$(`${$}/${String(J)}`, Y[J], W[J]);
    }
    for (let J of Z) {
      if ((0, E0.IsSymbol)(J))
        throw new o1(J);
      if ((0, E0.IsUndefined)(Y[J]))
        yield PY(`${$}/${String(J)}`, W[J]);
    }
    for (let J of X.reverse()) {
      if ((0, E0.IsSymbol)(J))
        throw new o1(J);
      if ((0, E0.IsUndefined)(W[J]) && !Z.includes(J))
        yield OY(`${$}/${String(J)}`);
    }
  }
  function* nJ($, Y, W) {
    if (!(0, E0.IsArray)(W))
      return yield N$($, W);
    for (let X = 0;X < Math.min(Y.length, W.length); X++)
      yield* T$(`${$}/${X}`, Y[X], W[X]);
    for (let X = 0;X < W.length; X++) {
      if (X < Y.length)
        continue;
      yield PY(`${$}/${X}`, W[X]);
    }
    for (let X = Y.length - 1;X >= 0; X--) {
      if (X < W.length)
        continue;
      yield OY(`${$}/${X}`);
    }
  }
  function* oJ($, Y, W) {
    if (!(0, E0.IsTypedArray)(W) || Y.length !== W.length || Object.getPrototypeOf(Y).constructor.name !== Object.getPrototypeOf(W).constructor.name)
      return yield N$($, W);
    for (let X = 0;X < Math.min(Y.length, W.length); X++)
      yield* T$(`${$}/${X}`, Y[X], W[X]);
  }
  function* cJ($, Y, W) {
    if (Y === W)
      return;
    yield N$($, W);
  }
  function* T$($, Y, W) {
    if ((0, E0.IsPlainObject)(Y))
      return yield* hJ($, Y, W);
    if ((0, E0.IsArray)(Y))
      return yield* nJ($, Y, W);
    if ((0, E0.IsTypedArray)(Y))
      return yield* oJ($, Y, W);
    if ((0, E0.IsValueType)(Y))
      return yield* cJ($, Y, W);
    throw new y6(Y);
  }
  var lJ = function($, Y) {
    return [...T$("", $, Y)];
  }, tJ = function($) {
    return $.length > 0 && $[0].path === "" && $[0].type === "update";
  }, sJ = function($) {
    return $.length === 0;
  }, rJ = function($, Y) {
    if (tJ(Y))
      return (0, d6.Clone)(Y[0].value);
    if (sJ(Y))
      return (0, d6.Clone)($);
    const W = (0, d6.Clone)($);
    for (let X of Y)
      switch (X.type) {
        case "insert": {
          T6.ValuePointer.Set(W, X.path, X.value);
          break;
        }
        case "update": {
          T6.ValuePointer.Set(W, X.path, X.value);
          break;
        }
        case "delete": {
          T6.ValuePointer.Delete(W, X.path);
          break;
        }
      }
    return W;
  };
  Object.defineProperty(SY, "__esModule", { value: true });
  SY.Patch = SY.Diff = SY.ValueDeltaUnableToDiffUnknownValue = SY.ValueDeltaObjectWithSymbolKeyError = SY.Edit = SY.Delete = SY.Update = SY.Insert = undefined;
  var E0 = x0(), i0 = g0(), T6 = f$(), d6 = n1();
  SY.Insert = i0.Type.Object({ type: i0.Type.Literal("insert"), path: i0.Type.String(), value: i0.Type.Unknown() });
  SY.Update = i0.Type.Object({ type: i0.Type.Literal("update"), path: i0.Type.String(), value: i0.Type.Unknown() });
  SY.Delete = i0.Type.Object({ type: i0.Type.Literal("delete"), path: i0.Type.String() });
  SY.Edit = i0.Type.Union([SY.Insert, SY.Update, SY.Delete]);

  class o1 extends Error {
    constructor($) {
      super("Cannot diff objects with symbol keys");
      this.key = $;
    }
  }
  SY.ValueDeltaObjectWithSymbolKeyError = o1;

  class y6 extends Error {
    constructor($) {
      super("Unable to create diff edits for unknown value");
      this.value = $;
    }
  }
  SY.ValueDeltaUnableToDiffUnknownValue = y6;
  SY.Diff = lJ;
  SY.Patch = rJ;
});
var EY = z0((GY) => {
  var WQ = function($, Y, W, X) {
    if (!(0, T0.IsPlainObject)(W))
      d$.ValuePointer.Set($, Y, (0, p6.Clone)(X));
    else {
      const Z = Object.keys(W), J = Object.keys(X);
      for (let Q of Z)
        if (!J.includes(Q))
          delete W[Q];
      for (let Q of J)
        if (!Z.includes(Q))
          W[Q] = null;
      for (let Q of J)
        u6($, `${Y}/${Q}`, W[Q], X[Q]);
    }
  }, XQ = function($, Y, W, X) {
    if (!(0, T0.IsArray)(W))
      d$.ValuePointer.Set($, Y, (0, p6.Clone)(X));
    else {
      for (let Z = 0;Z < X.length; Z++)
        u6($, `${Y}/${Z}`, W[Z], X[Z]);
      W.splice(X.length);
    }
  }, ZQ = function($, Y, W, X) {
    if ((0, T0.IsTypedArray)(W) && W.length === X.length)
      for (let Z = 0;Z < W.length; Z++)
        W[Z] = X[Z];
    else
      d$.ValuePointer.Set($, Y, (0, p6.Clone)(X));
  }, JQ = function($, Y, W, X) {
    if (W === X)
      return;
    d$.ValuePointer.Set($, Y, X);
  }, u6 = function($, Y, W, X) {
    if ((0, T0.IsArray)(X))
      return XQ($, Y, W, X);
    if ((0, T0.IsTypedArray)(X))
      return ZQ($, Y, W, X);
    if ((0, T0.IsPlainObject)(X))
      return WQ($, Y, W, X);
    if ((0, T0.IsValueType)(X))
      return JQ($, Y, W, X);
  }, RY = function($) {
    return (0, T0.IsTypedArray)($) || (0, T0.IsValueType)($);
  }, QQ = function($, Y) {
    return (0, T0.IsPlainObject)($) && (0, T0.IsArray)(Y) || (0, T0.IsArray)($) && (0, T0.IsPlainObject)(Y);
  }, zQ = function($, Y) {
    if (RY($) || RY(Y))
      throw new m6;
    if (QQ($, Y))
      throw new i6;
    u6($, "", $, Y);
  };
  Object.defineProperty(GY, "__esModule", { value: true });
  GY.Mutate = GY.ValueMutateInvalidRootMutationError = GY.ValueMutateTypeMismatchError = undefined;
  var T0 = x0(), d$ = f$(), p6 = n1();

  class i6 extends Error {
    constructor() {
      super("Cannot assign due type mismatch of assignable values");
    }
  }
  GY.ValueMutateTypeMismatchError = i6;

  class m6 extends Error {
    constructor() {
      super("Only object and array types can be mutated at the root level");
    }
  }
  GY.ValueMutateInvalidRootMutationError = m6;
  GY.Mutate = zQ;
});
var kY = z0((VY) => {
  var NQ = function($, Y) {
    if (!(0, N1.IsPlainObject)(Y))
      return false;
    const W = [...Object.keys($), ...Object.getOwnPropertySymbols($)], X = [...Object.keys(Y), ...Object.getOwnPropertySymbols(Y)];
    if (W.length !== X.length)
      return false;
    return W.every((Z) => y$($[Z], Y[Z]));
  }, MQ = function($, Y) {
    return (0, N1.IsDate)(Y) && $.getTime() === Y.getTime();
  }, AQ = function($, Y) {
    if (!(0, N1.IsArray)(Y) || $.length !== Y.length)
      return false;
    return $.every((W, X) => y$(W, Y[X]));
  }, UQ = function($, Y) {
    if (!(0, N1.IsTypedArray)(Y) || $.length !== Y.length || Object.getPrototypeOf($).constructor.name !== Object.getPrototypeOf(Y).constructor.name)
      return false;
    return $.every((W, X) => y$(W, Y[X]));
  }, BQ = function($, Y) {
    return $ === Y;
  }, y$ = function($, Y) {
    if ((0, N1.IsPlainObject)($))
      return NQ($, Y);
    if ((0, N1.IsDate)($))
      return MQ($, Y);
    if ((0, N1.IsTypedArray)($))
      return UQ($, Y);
    if ((0, N1.IsArray)($))
      return AQ($, Y);
    if ((0, N1.IsValueType)($))
      return BQ($, Y);
    throw new Error("ValueEquals: Unable to compare value");
  };
  Object.defineProperty(VY, "__esModule", { value: true });
  VY.Equal = undefined;
  var N1 = x0();
  VY.Equal = y$;
});
var M$ = z0((M1) => {
  var FQ = M1 && M1.__createBinding || (Object.create ? function($, Y, W, X) {
    if (X === undefined)
      X = W;
    var Z = Object.getOwnPropertyDescriptor(Y, W);
    if (!Z || ("get" in Z ? !Y.__esModule : Z.writable || Z.configurable))
      Z = { enumerable: true, get: function() {
        return Y[W];
      } };
    Object.defineProperty($, X, Z);
  } : function($, Y, W, X) {
    if (X === undefined)
      X = W;
    $[X] = Y[W];
  }), DQ = M1 && M1.__exportStar || function($, Y) {
    for (var W in $)
      if (W !== "default" && !Object.prototype.hasOwnProperty.call(Y, W))
        FQ(Y, $, W);
  };
  Object.defineProperty(M1, "__esModule", { value: true });
  M1.ValueErrorType = undefined;
  var wQ = z$();
  Object.defineProperty(M1, "ValueErrorType", { enumerable: true, get: function() {
    return wQ.ValueErrorType;
  } });
  DQ(G6(), M1);
});
var U$ = z0((fY) => {
  var KQ = function($) {
    return $[I0.Kind] === "Any" || $[I0.Kind] === "Unknown";
  }, r = function($) {
    return $ !== undefined;
  }, PQ = function($, Y, W) {
    return true;
  }, OQ = function($, Y, W) {
    if (!(0, w0.IsArray)(W))
      return false;
    if (r($.minItems) && !(W.length >= $.minItems))
      return false;
    if (r($.maxItems) && !(W.length <= $.maxItems))
      return false;
    if (!W.every((J) => b0($.items, Y, J)))
      return false;
    if ($.uniqueItems === true && !function() {
      const J = new Set;
      for (let Q of W) {
        const z = (0, jQ.Hash)(Q);
        if (J.has(z))
          return false;
        else
          J.add(z);
      }
      return true;
    }())
      return false;
    if (!(r($.contains) || (0, w0.IsNumber)($.minContains) || (0, w0.IsNumber)($.maxContains)))
      return true;
    const X = r($.contains) ? $.contains : I0.Type.Never(), Z = W.reduce((J, Q) => b0(X, Y, Q) ? J + 1 : J, 0);
    if (Z === 0)
      return false;
    if ((0, w0.IsNumber)($.minContains) && Z < $.minContains)
      return false;
    if ((0, w0.IsNumber)($.maxContains) && Z > $.maxContains)
      return false;
    return true;
  }, SQ = function($, Y, W) {
    return (0, w0.IsAsyncIterator)(W);
  }, LQ = function($, Y, W) {
    if (!(0, w0.IsBigInt)(W))
      return false;
    if (r($.exclusiveMaximum) && !(W < $.exclusiveMaximum))
      return false;
    if (r($.exclusiveMinimum) && !(W > $.exclusiveMinimum))
      return false;
    if (r($.maximum) && !(W <= $.maximum))
      return false;
    if (r($.minimum) && !(W >= $.minimum))
      return false;
    if (r($.multipleOf) && W % $.multipleOf !== BigInt(0))
      return false;
    return true;
  }, CQ = function($, Y, W) {
    return (0, w0.IsBoolean)(W);
  }, IQ = function($, Y, W) {
    return b0($.returns, Y, W.prototype);
  }, bQ = function($, Y, W) {
    if (!(0, w0.IsDate)(W))
      return false;
    if (r($.exclusiveMaximumTimestamp) && !(W.getTime() < $.exclusiveMaximumTimestamp))
      return false;
    if (r($.exclusiveMinimumTimestamp) && !(W.getTime() > $.exclusiveMinimumTimestamp))
      return false;
    if (r($.maximumTimestamp) && !(W.getTime() <= $.maximumTimestamp))
      return false;
    if (r($.minimumTimestamp) && !(W.getTime() >= $.minimumTimestamp))
      return false;
    if (r($.multipleOfTimestamp) && W.getTime() % $.multipleOfTimestamp !== 0)
      return false;
    return true;
  }, RQ = function($, Y, W) {
    return (0, w0.IsFunction)(W);
  }, GQ = function($, Y, W) {
    if (!(0, w0.IsInteger)(W))
      return false;
    if (r($.exclusiveMaximum) && !(W < $.exclusiveMaximum))
      return false;
    if (r($.exclusiveMinimum) && !(W > $.exclusiveMinimum))
      return false;
    if (r($.maximum) && !(W <= $.maximum))
      return false;
    if (r($.minimum) && !(W >= $.minimum))
      return false;
    if (r($.multipleOf) && W % $.multipleOf !== 0)
      return false;
    return true;
  }, _Q = function($, Y, W) {
    const X = $.allOf.every((Z) => b0(Z, Y, W));
    if ($.unevaluatedProperties === false) {
      const Z = new RegExp(I0.KeyResolver.ResolvePattern($)), J = Object.getOwnPropertyNames(W).every((Q) => Z.test(Q));
      return X && J;
    } else if (I0.TypeGuard.TSchema($.unevaluatedProperties)) {
      const Z = new RegExp(I0.KeyResolver.ResolvePattern($)), J = Object.getOwnPropertyNames(W).every((Q) => Z.test(Q) || b0($.unevaluatedProperties, Y, W[Q]));
      return X && J;
    } else
      return X;
  }, EQ = function($, Y, W) {
    return (0, w0.IsIterator)(W);
  }, VQ = function($, Y, W) {
    return W === $.const;
  }, xQ = function($, Y, W) {
    return false;
  }, kQ = function($, Y, W) {
    return !b0($.not, Y, W);
  }, gQ = function($, Y, W) {
    return (0, w0.IsNull)(W);
  }, fQ = function($, Y, W) {
    if (!A$.TypeSystemPolicy.IsNumberLike(W))
      return false;
    if (r($.exclusiveMaximum) && !(W < $.exclusiveMaximum))
      return false;
    if (r($.exclusiveMinimum) && !(W > $.exclusiveMinimum))
      return false;
    if (r($.minimum) && !(W >= $.minimum))
      return false;
    if (r($.maximum) && !(W <= $.maximum))
      return false;
    if (r($.multipleOf) && W % $.multipleOf !== 0)
      return false;
    return true;
  }, TQ = function($, Y, W) {
    if (!A$.TypeSystemPolicy.IsObjectLike(W))
      return false;
    if (r($.minProperties) && !(Object.getOwnPropertyNames(W).length >= $.minProperties))
      return false;
    if (r($.maxProperties) && !(Object.getOwnPropertyNames(W).length <= $.maxProperties))
      return false;
    const X = Object.getOwnPropertyNames($.properties);
    for (let Z of X) {
      const J = $.properties[Z];
      if ($.required && $.required.includes(Z)) {
        if (!b0(J, Y, W[Z]))
          return false;
        if ((I0.ExtendsUndefined.Check(J) || KQ(J)) && !(Z in W))
          return false;
      } else if (A$.TypeSystemPolicy.IsExactOptionalProperty(W, Z) && !b0(J, Y, W[Z]))
        return false;
    }
    if ($.additionalProperties === false) {
      const Z = Object.getOwnPropertyNames(W);
      if ($.required && $.required.length === X.length && Z.length === X.length)
        return true;
      else
        return Z.every((J) => X.includes(J));
    } else if (typeof $.additionalProperties === "object")
      return Object.getOwnPropertyNames(W).every((J) => X.includes(J) || b0($.additionalProperties, Y, W[J]));
    else
      return true;
  }, dQ = function($, Y, W) {
    return (0, w0.IsPromise)(W);
  }, yQ = function($, Y, W) {
    if (!A$.TypeSystemPolicy.IsRecordLike(W))
      return false;
    if (r($.minProperties) && !(Object.getOwnPropertyNames(W).length >= $.minProperties))
      return false;
    if (r($.maxProperties) && !(Object.getOwnPropertyNames(W).length <= $.maxProperties))
      return false;
    const [X, Z] = Object.entries($.patternProperties)[0], J = new RegExp(X), Q = Object.entries(W).every(([F, D]) => {
      return J.test(F) ? b0(Z, Y, D) : true;
    }), z = typeof $.additionalProperties === "object" ? Object.entries(W).every(([F, D]) => {
      return !J.test(F) ? b0($.additionalProperties, Y, D) : true;
    }) : true, U = $.additionalProperties === false ? Object.getOwnPropertyNames(W).every((F) => {
      return J.test(F);
    }) : true;
    return Q && z && U;
  }, vQ = function($, Y, W) {
    return b0((0, gY.Deref)($, Y), Y, W);
  }, pQ = function($, Y, W) {
    if (!(0, w0.IsString)(W))
      return false;
    if (r($.minLength)) {
      if (!(W.length >= $.minLength))
        return false;
    }
    if (r($.maxLength)) {
      if (!(W.length <= $.maxLength))
        return false;
    }
    if (r($.pattern)) {
      if (!new RegExp($.pattern).test(W))
        return false;
    }
    if (r($.format)) {
      if (!I0.FormatRegistry.Has($.format))
        return false;
      return I0.FormatRegistry.Get($.format)(W);
    }
    return true;
  }, iQ = function($, Y, W) {
    return (0, w0.IsSymbol)(W);
  }, mQ = function($, Y, W) {
    return (0, w0.IsString)(W) && new RegExp($.pattern).test(W);
  }, uQ = function($, Y, W) {
    return b0((0, gY.Deref)($, Y), Y, W);
  }, hQ = function($, Y, W) {
    if (!(0, w0.IsArray)(W))
      return false;
    if ($.items === undefined && W.length !== 0)
      return false;
    if (W.length !== $.maxItems)
      return false;
    if (!$.items)
      return true;
    for (let X = 0;X < $.items.length; X++)
      if (!b0($.items[X], Y, W[X]))
        return false;
    return true;
  }, nQ = function($, Y, W) {
    return (0, w0.IsUndefined)(W);
  }, oQ = function($, Y, W) {
    return $.anyOf.some((X) => b0(X, Y, W));
  }, cQ = function($, Y, W) {
    if (!(0, w0.IsUint8Array)(W))
      return false;
    if (r($.maxByteLength) && !(W.length <= $.maxByteLength))
      return false;
    if (r($.minByteLength) && !(W.length >= $.minByteLength))
      return false;
    return true;
  }, lQ = function($, Y, W) {
    return true;
  }, tQ = function($, Y, W) {
    return A$.TypeSystemPolicy.IsVoidLike(W);
  }, sQ = function($, Y, W) {
    if (!I0.TypeRegistry.Has($[I0.Kind]))
      return false;
    return I0.TypeRegistry.Get($[I0.Kind])($, W);
  }, b0 = function($, Y, W) {
    const X = r($.$id) ? [...Y, $] : Y, Z = $;
    switch (Z[I0.Kind]) {
      case "Any":
        return PQ(Z, X, W);
      case "Array":
        return OQ(Z, X, W);
      case "AsyncIterator":
        return SQ(Z, X, W);
      case "BigInt":
        return LQ(Z, X, W);
      case "Boolean":
        return CQ(Z, X, W);
      case "Constructor":
        return IQ(Z, X, W);
      case "Date":
        return bQ(Z, X, W);
      case "Function":
        return RQ(Z, X, W);
      case "Integer":
        return GQ(Z, X, W);
      case "Intersect":
        return _Q(Z, X, W);
      case "Iterator":
        return EQ(Z, X, W);
      case "Literal":
        return VQ(Z, X, W);
      case "Never":
        return xQ(Z, X, W);
      case "Not":
        return kQ(Z, X, W);
      case "Null":
        return gQ(Z, X, W);
      case "Number":
        return fQ(Z, X, W);
      case "Object":
        return TQ(Z, X, W);
      case "Promise":
        return dQ(Z, X, W);
      case "Record":
        return yQ(Z, X, W);
      case "Ref":
        return vQ(Z, X, W);
      case "String":
        return pQ(Z, X, W);
      case "Symbol":
        return iQ(Z, X, W);
      case "TemplateLiteral":
        return mQ(Z, X, W);
      case "This":
        return uQ(Z, X, W);
      case "Tuple":
        return hQ(Z, X, W);
      case "Undefined":
        return nQ(Z, X, W);
      case "Union":
        return oQ(Z, X, W);
      case "Uint8Array":
        return cQ(Z, X, W);
      case "Unknown":
        return lQ(Z, X, W);
      case "Void":
        return tQ(Z, X, W);
      default:
        if (!I0.TypeRegistry.Has(Z[I0.Kind]))
          throw new h6(Z);
        return sQ(Z, X, W);
    }
  }, rQ = function(...$) {
    return $.length === 3 ? b0($[0], $[1], $[2]) : b0($[0], [], $[1]);
  };
  Object.defineProperty(fY, "__esModule", { value: true });
  fY.Check = fY.ValueCheckUnknownTypeError = undefined;
  var w0 = x0(), A$ = M$(), gY = K1(), jQ = H$(), I0 = g0();

  class h6 extends I0.TypeBoxError {
    constructor($) {
      super("Unknown type");
      this.schema = $;
    }
  }
  fY.ValueCheckUnknownTypeError = h6;
  fY.Check = rQ;
});
var r6 = z0((pY) => {
  var $4 = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else
      return {};
  }, Y4 = function($, Y) {
    if ($.uniqueItems === true && !(0, a.HasPropertyKey)($, "default"))
      throw new Error("ValueCreate.Array: Array with the uniqueItems constraint requires a default value");
    else if ("contains" in $ && !(0, a.HasPropertyKey)($, "default"))
      throw new Error("ValueCreate.Array: Array with the contains constraint requires a default value");
    else if ("default" in $)
      return $.default;
    else if ($.minItems !== undefined)
      return Array.from({ length: $.minItems }).map((W) => {
        return d0($.items, Y);
      });
    else
      return [];
  }, W4 = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else
      return async function* () {
      }();
  }, X4 = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else
      return BigInt(0);
  }, Z4 = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else
      return false;
  }, J4 = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else {
      const W = d0($.returns, Y);
      if (typeof W === "object" && !Array.isArray(W))
        return class {
          constructor() {
            for (let [X, Z] of Object.entries(W)) {
              const J = this;
              J[X] = Z;
            }
          }
        };
      else
        return class {
        };
    }
  }, Q4 = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else if ($.minimumTimestamp !== undefined)
      return new Date($.minimumTimestamp);
    else
      return new Date(0);
  }, z4 = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else
      return () => d0($.returns, Y);
  }, H4 = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else if ($.minimum !== undefined)
      return $.minimum;
    else
      return 0;
  }, q4 = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else {
      const W = $.allOf.reduce((X, Z) => {
        const J = d0(Z, Y);
        return typeof J === "object" ? { ...X, ...J } : J;
      }, {});
      if (!(0, eQ.Check)($, Y, W))
        throw new l6($);
      return W;
    }
  }, N4 = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else
      return function* () {
      }();
  }, M4 = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else
      return $.const;
  }, A4 = function($, Y) {
    throw new o6($);
  }, U4 = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else
      throw new c6($);
  }, B4 = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else
      return null;
  }, F4 = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else if ($.minimum !== undefined)
      return $.minimum;
    else
      return 0;
  }, D4 = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else {
      const W = new Set($.required);
      return $.default || Object.entries($.properties).reduce((X, [Z, J]) => {
        return W.has(Z) ? { ...X, [Z]: d0(J, Y) } : { ...X };
      }, {});
    }
  }, w4 = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else
      return Promise.resolve(d0($.item, Y));
  }, j4 = function($, Y) {
    const [W, X] = Object.entries($.patternProperties)[0];
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else if (!(W === k0.PatternStringExact || W === k0.PatternNumberExact))
      return W.slice(1, W.length - 1).split("|").reduce((J, Q) => {
        return { ...J, [Q]: d0(X, Y) };
      }, {});
    else
      return {};
  }, K4 = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else
      return d0((0, yY.Deref)($, Y), Y);
  }, P4 = function($, Y) {
    if ($.pattern !== undefined)
      if (!(0, a.HasPropertyKey)($, "default"))
        throw new Error("ValueCreate.String: String types with patterns must specify a default value");
      else
        return $.default;
    else if ($.format !== undefined)
      if (!(0, a.HasPropertyKey)($, "default"))
        throw new Error("ValueCreate.String: String types with formats must specify a default value");
      else
        return $.default;
    else if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else if ($.minLength !== undefined)
      return Array.from({ length: $.minLength }).map(() => ".").join("");
    else
      return "";
  }, O4 = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else if ("value" in $)
      return Symbol.for($.value);
    else
      return Symbol();
  }, S4 = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    const W = k0.TemplateLiteralParser.ParseExact($.pattern);
    if (!k0.TemplateLiteralFinite.Check(W))
      throw new t6($);
    return k0.TemplateLiteralGenerator.Generate(W).next().value;
  }, L4 = function($, Y) {
    if (vY++ > dY)
      throw new s6($, dY);
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else
      return d0((0, yY.Deref)($, Y), Y);
  }, C4 = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    if ($.items === undefined)
      return [];
    else
      return Array.from({ length: $.minItems }).map((W, X) => d0($.items[X], Y));
  }, I4 = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else
      return;
  }, b4 = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else if ($.anyOf.length === 0)
      throw new Error("ValueCreate.Union: Cannot create Union with zero variants");
    else
      return d0($.anyOf[0], Y);
  }, R4 = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else if ($.minByteLength !== undefined)
      return new Uint8Array($.minByteLength);
    else
      return new Uint8Array(0);
  }, G4 = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else
      return {};
  }, _4 = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else
      return;
  }, E4 = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else
      throw new Error("User defined types must specify a default value");
  }, d0 = function($, Y) {
    const W = (0, a.IsString)($.$id) ? [...Y, $] : Y, X = $;
    switch (X[k0.Kind]) {
      case "Any":
        return $4(X, W);
      case "Array":
        return Y4(X, W);
      case "AsyncIterator":
        return W4(X, W);
      case "BigInt":
        return X4(X, W);
      case "Boolean":
        return Z4(X, W);
      case "Constructor":
        return J4(X, W);
      case "Date":
        return Q4(X, W);
      case "Function":
        return z4(X, W);
      case "Integer":
        return H4(X, W);
      case "Intersect":
        return q4(X, W);
      case "Iterator":
        return N4(X, W);
      case "Literal":
        return M4(X, W);
      case "Never":
        return A4(X, W);
      case "Not":
        return U4(X, W);
      case "Null":
        return B4(X, W);
      case "Number":
        return F4(X, W);
      case "Object":
        return D4(X, W);
      case "Promise":
        return w4(X, W);
      case "Record":
        return j4(X, W);
      case "Ref":
        return K4(X, W);
      case "String":
        return P4(X, W);
      case "Symbol":
        return O4(X, W);
      case "TemplateLiteral":
        return S4(X, W);
      case "This":
        return L4(X, W);
      case "Tuple":
        return C4(X, W);
      case "Undefined":
        return I4(X, W);
      case "Union":
        return b4(X, W);
      case "Uint8Array":
        return R4(X, W);
      case "Unknown":
        return G4(X, W);
      case "Void":
        return _4(X, W);
      default:
        if (!k0.TypeRegistry.Has(X[k0.Kind]))
          throw new n6(X);
        return E4(X, W);
    }
  }, V4 = function(...$) {
    return vY = 0, $.length === 2 ? d0($[0], $[1]) : d0($[0], []);
  };
  Object.defineProperty(pY, "__esModule", { value: true });
  pY.Create = pY.ValueCreateRecursiveInstantiationError = pY.ValueCreateTempateLiteralTypeError = pY.ValueCreateIntersectTypeError = pY.ValueCreateNotTypeError = pY.ValueCreateNeverTypeError = pY.ValueCreateUnknownTypeError = undefined;
  var a = x0(), eQ = U$(), yY = K1(), k0 = g0();

  class n6 extends k0.TypeBoxError {
    constructor($) {
      super("Unknown type");
      this.schema = $;
    }
  }
  pY.ValueCreateUnknownTypeError = n6;

  class o6 extends k0.TypeBoxError {
    constructor($) {
      super("Never types cannot be created");
      this.schema = $;
    }
  }
  pY.ValueCreateNeverTypeError = o6;

  class c6 extends k0.TypeBoxError {
    constructor($) {
      super("Not types must have a default value");
      this.schema = $;
    }
  }
  pY.ValueCreateNotTypeError = c6;

  class l6 extends k0.TypeBoxError {
    constructor($) {
      super("Intersect produced invalid value. Consider using a default value.");
      this.schema = $;
    }
  }
  pY.ValueCreateIntersectTypeError = l6;

  class t6 extends k0.TypeBoxError {
    constructor($) {
      super("Can only create template literal values from patterns that produce finite sequences. Consider using a default value.");
      this.schema = $;
    }
  }
  pY.ValueCreateTempateLiteralTypeError = t6;

  class s6 extends k0.TypeBoxError {
    constructor($, Y) {
      super("Value cannot be created as recursive type may produce value of infinite size. Consider using a default.");
      this.schema = $, this.recursiveMaxDepth = Y;
    }
  }
  pY.ValueCreateRecursiveInstantiationError = s6;
  var dY = 512, vY = 0;
  pY.Create = V4;
});
var lY = z0((oY) => {
  var hY = function($, Y, W) {
    return (0, m0.Check)($, Y, W) ? (0, c1.Clone)(W) : (0, U1.Create)($, Y);
  }, e6 = function($, Y, W) {
    return (0, m0.Check)($, Y, W) ? W : (0, U1.Create)($, Y);
  }, y4 = function($, Y, W) {
    if ((0, m0.Check)($, Y, W))
      return (0, c1.Clone)(W);
    const X = (0, P1.IsArray)(W) ? (0, c1.Clone)(W) : (0, U1.Create)($, Y), Z = (0, P1.IsNumber)($.minItems) && X.length < $.minItems ? [...X, ...Array.from({ length: $.minItems - X.length }, () => null)] : X, Q = ((0, P1.IsNumber)($.maxItems) && Z.length > $.maxItems ? Z.slice(0, $.maxItems) : Z).map((U) => Z1($.items, Y, U));
    if ($.uniqueItems !== true)
      return Q;
    const z = [...new Set(Q)];
    if (!(0, m0.Check)($, Y, z))
      throw new $8($, z);
    return z;
  }, v4 = function($, Y, W) {
    if ((0, m0.Check)($, Y, W))
      return (0, U1.Create)($, Y);
    const X = new Set($.returns.required || []), Z = function() {
    };
    for (let [J, Q] of Object.entries($.returns.properties)) {
      if (!X.has(J) && W.prototype[J] === undefined)
        continue;
      Z.prototype[J] = Z1(Q, Y, W.prototype[J]);
    }
    return Z;
  }, p4 = function($, Y, W) {
    const X = (0, U1.Create)($, Y), Z = (0, P1.IsPlainObject)(X) && (0, P1.IsPlainObject)(W) ? { ...X, ...W } : W;
    return (0, m0.Check)($, Y, Z) ? Z : (0, U1.Create)($, Y);
  }, i4 = function($, Y, W) {
    throw new Y8($);
  }, m4 = function($, Y, W) {
    if ((0, m0.Check)($, Y, W))
      return W;
    if (W === null || typeof W !== "object")
      return (0, U1.Create)($, Y);
    const X = new Set($.required || []), Z = {};
    for (let [J, Q] of Object.entries($.properties)) {
      if (!X.has(J) && W[J] === undefined)
        continue;
      Z[J] = Z1(Q, Y, W[J]);
    }
    if (typeof $.additionalProperties === "object") {
      const J = Object.getOwnPropertyNames($.properties);
      for (let Q of Object.getOwnPropertyNames(W)) {
        if (J.includes(Q))
          continue;
        Z[Q] = Z1($.additionalProperties, Y, W[Q]);
      }
    }
    return Z;
  }, u4 = function($, Y, W) {
    if ((0, m0.Check)($, Y, W))
      return (0, c1.Clone)(W);
    if (W === null || typeof W !== "object" || Array.isArray(W) || W instanceof Date)
      return (0, U1.Create)($, Y);
    const X = Object.getOwnPropertyNames($.patternProperties)[0], Z = $.patternProperties[X], J = {};
    for (let [Q, z] of Object.entries(W))
      J[Q] = Z1(Z, Y, z);
    return J;
  }, h4 = function($, Y, W) {
    return Z1((0, mY.Deref)($, Y), Y, W);
  }, n4 = function($, Y, W) {
    return Z1((0, mY.Deref)($, Y), Y, W);
  }, o4 = function($, Y, W) {
    if ((0, m0.Check)($, Y, W))
      return (0, c1.Clone)(W);
    if (!(0, P1.IsArray)(W))
      return (0, U1.Create)($, Y);
    if ($.items === undefined)
      return [];
    return $.items.map((X, Z) => Z1(X, Y, W[Z]));
  }, c4 = function($, Y, W) {
    return (0, m0.Check)($, Y, W) ? (0, c1.Clone)(W) : a6.Create($, Y, W);
  }, Z1 = function($, Y, W) {
    const X = (0, P1.IsString)($.$id) ? [...Y, $] : Y, Z = $;
    switch ($[A1.Kind]) {
      case "Array":
        return y4(Z, X, W);
      case "Constructor":
        return v4(Z, X, W);
      case "Intersect":
        return p4(Z, X, W);
      case "Never":
        return i4(Z, X, W);
      case "Object":
        return m4(Z, X, W);
      case "Record":
        return u4(Z, X, W);
      case "Ref":
        return h4(Z, X, W);
      case "This":
        return n4(Z, X, W);
      case "Tuple":
        return o4(Z, X, W);
      case "Union":
        return c4(Z, X, W);
      case "Date":
      case "Symbol":
      case "Uint8Array":
        return hY($, Y, W);
      case "Any":
      case "AsyncIterator":
      case "BigInt":
      case "Boolean":
      case "Function":
      case "Integer":
      case "Iterator":
      case "Literal":
      case "Not":
      case "Null":
      case "Number":
      case "Promise":
      case "String":
      case "TemplateLiteral":
      case "Undefined":
      case "Unknown":
      case "Void":
        return e6(Z, X, W);
      default:
        if (!A1.TypeRegistry.Has(Z[A1.Kind]))
          throw new W8(Z);
        return e6(Z, X, W);
    }
  }, nY = function(...$) {
    return $.length === 3 ? Z1($[0], $[1], $[2]) : Z1($[0], [], $[1]);
  };
  Object.defineProperty(oY, "__esModule", { value: true });
  oY.Cast = oY.Default = oY.DefaultClone = oY.ValueCastUnknownTypeError = oY.ValueCastRecursiveTypeError = oY.ValueCastNeverTypeError = oY.ValueCastArrayUniqueItemsTypeError = undefined;
  var P1 = x0(), U1 = r6(), m0 = U$(), c1 = n1(), mY = K1(), A1 = g0();

  class $8 extends A1.TypeBoxError {
    constructor($, Y) {
      super("Array cast produced invalid data due to uniqueItems constraint");
      this.schema = $, this.value = Y;
    }
  }
  oY.ValueCastArrayUniqueItemsTypeError = $8;

  class Y8 extends A1.TypeBoxError {
    constructor($) {
      super("Never types cannot be cast");
      this.schema = $;
    }
  }
  oY.ValueCastNeverTypeError = Y8;

  class uY extends A1.TypeBoxError {
    constructor($) {
      super("Cannot cast recursive schemas");
      this.schema = $;
    }
  }
  oY.ValueCastRecursiveTypeError = uY;

  class W8 extends A1.TypeBoxError {
    constructor($) {
      super("Unknown type");
      this.schema = $;
    }
  }
  oY.ValueCastUnknownTypeError = W8;
  var a6;
  (function($) {
    function Y(Z, J, Q) {
      if (Z[A1.Kind] === "Object" && typeof Q === "object" && !(0, P1.IsNull)(Q)) {
        const z = Z, U = Object.getOwnPropertyNames(Q), F = Object.entries(z.properties), [D, S] = [1 / F.length, F.length];
        return F.reduce((b, [j, M]) => {
          const P = M[A1.Kind] === "Literal" && M.const === Q[j] ? S : 0, O = (0, m0.Check)(M, J, Q[j]) ? D : 0, A = U.includes(j) ? D : 0;
          return b + (P + O + A);
        }, 0);
      } else
        return (0, m0.Check)(Z, J, Q) ? 1 : 0;
    }
    function W(Z, J, Q) {
      let [z, U] = [Z.anyOf[0], 0];
      for (let F of Z.anyOf) {
        const D = Y(F, J, Q);
        if (D > U)
          z = F, U = D;
      }
      return z;
    }
    function X(Z, J, Q) {
      if ("default" in Z)
        return Z.default;
      else {
        const z = W(Z, J, Q);
        return nY(z, J, Q);
      }
    }
    $.Create = X;
  })(a6 || (a6 = {}));
  oY.DefaultClone = hY;
  oY.Default = e6;
  oY.Cast = nY;
});
var YW = z0((eY) => {
  var v$ = function($) {
    return (0, Z0.IsString)($) && !isNaN($) && !isNaN(parseFloat($));
  }, W9 = function($) {
    return (0, Z0.IsBigInt)($) || (0, Z0.IsBoolean)($) || (0, Z0.IsNumber)($);
  }, B$ = function($) {
    return $ === true || (0, Z0.IsNumber)($) && $ === 1 || (0, Z0.IsBigInt)($) && $ === BigInt("1") || (0, Z0.IsString)($) && ($.toLowerCase() === "true" || $ === "1");
  }, F$ = function($) {
    return $ === false || (0, Z0.IsNumber)($) && ($ === 0 || Object.is($, -0)) || (0, Z0.IsBigInt)($) && $ === BigInt("0") || (0, Z0.IsString)($) && ($.toLowerCase() === "false" || $ === "0" || $ === "-0");
  }, X9 = function($) {
    return (0, Z0.IsString)($) && /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i.test($);
  }, Z9 = function($) {
    return (0, Z0.IsString)($) && /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)?$/i.test($);
  }, J9 = function($) {
    return (0, Z0.IsString)($) && /^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i.test($);
  }, Q9 = function($) {
    return (0, Z0.IsString)($) && /^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)?$/i.test($);
  }, z9 = function($) {
    return (0, Z0.IsString)($) && /^\d\d\d\d-[0-1]\d-[0-3]\d$/i.test($);
  }, H9 = function($, Y) {
    const W = rY($);
    return W === Y ? W : $;
  }, q9 = function($, Y) {
    const W = aY($);
    return W === Y ? W : $;
  }, N9 = function($, Y) {
    const W = sY($);
    return W === Y ? W : $;
  }, M9 = function($, Y) {
    if (typeof $.const === "string")
      return H9(Y, $.const);
    else if (typeof $.const === "number")
      return q9(Y, $.const);
    else if (typeof $.const === "boolean")
      return N9(Y, $.const);
    else
      return (0, $9.Clone)(Y);
  }, sY = function($) {
    return B$($) ? true : F$($) ? false : $;
  }, A9 = function($) {
    return v$($) ? BigInt(parseInt($)) : (0, Z0.IsNumber)($) ? BigInt($ | 0) : F$($) ? BigInt(0) : B$($) ? BigInt(1) : $;
  }, rY = function($) {
    return W9($) ? $.toString() : (0, Z0.IsSymbol)($) && $.description !== undefined ? $.description.toString() : $;
  }, aY = function($) {
    return v$($) ? parseFloat($) : B$($) ? 1 : F$($) ? 0 : $;
  }, U9 = function($) {
    return v$($) ? parseInt($) : (0, Z0.IsNumber)($) ? $ | 0 : B$($) ? 1 : F$($) ? 0 : $;
  }, B9 = function($) {
    return (0, Z0.IsString)($) && $.toLowerCase() === "null" ? null : $;
  }, F9 = function($) {
    return (0, Z0.IsString)($) && $ === "undefined" ? undefined : $;
  }, D9 = function($) {
    return (0, Z0.IsDate)($) ? $ : (0, Z0.IsNumber)($) ? new Date($) : B$($) ? new Date(1) : F$($) ? new Date(0) : v$($) ? new Date(parseInt($)) : Z9($) ? new Date(`1970-01-01T${$}.000Z`) : X9($) ? new Date(`1970-01-01T${$}`) : Q9($) ? new Date(`${$}.000Z`) : J9($) ? new Date($) : z9($) ? new Date(`${$}T00:00:00.000Z`) : $;
  }, X8 = function($) {
    return $;
  }, w9 = function($, Y, W) {
    if ((0, Z0.IsArray)(W))
      return W.map((X) => l0($.items, Y, X));
    return W;
  }, j9 = function($, Y, W) {
    return A9(W);
  }, K9 = function($, Y, W) {
    return sY(W);
  }, P9 = function($, Y, W) {
    return D9(W);
  }, O9 = function($, Y, W) {
    return U9(W);
  }, S9 = function($, Y, W) {
    return $.allOf.every((X) => l1.TypeGuard.TObject(X)) ? l0(l1.Type.Composite($.allOf), Y, W) : l0($.allOf[0], Y, W);
  }, L9 = function($, Y, W) {
    return M9($, W);
  }, C9 = function($, Y, W) {
    return B9(W);
  }, I9 = function($, Y, W) {
    return aY(W);
  }, b9 = function($, Y, W) {
    if ((0, Z0.IsObject)(W))
      return Object.getOwnPropertyNames($.properties).reduce((X, Z) => {
        return W[Z] !== undefined ? { ...X, [Z]: l0($.properties[Z], Y, W[Z]) } : { ...X };
      }, W);
    return W;
  }, R9 = function($, Y, W) {
    const X = Object.getOwnPropertyNames($.patternProperties)[0], Z = $.patternProperties[X], J = {};
    for (let [Q, z] of Object.entries(W))
      J[Q] = l0(Z, Y, z);
    return J;
  }, G9 = function($, Y, W) {
    return l0((0, tY.Deref)($, Y), Y, W);
  }, _9 = function($, Y, W) {
    return rY(W);
  }, E9 = function($, Y, W) {
    return (0, Z0.IsString)(W) || (0, Z0.IsNumber)(W) ? Symbol(W) : W;
  }, V9 = function($, Y, W) {
    return l0((0, tY.Deref)($, Y), Y, W);
  }, x9 = function($, Y, W) {
    if ((0, Z0.IsArray)(W) && !(0, Z0.IsUndefined)($.items))
      return W.map((X, Z) => {
        return Z < $.items.length ? l0($.items[Z], Y, X) : X;
      });
    return W;
  }, k9 = function($, Y, W) {
    return F9(W);
  }, g9 = function($, Y, W) {
    for (let X of $.anyOf) {
      const Z = l0(X, Y, W);
      if ((0, Y9.Check)(X, Y, Z))
        return Z;
    }
    return W;
  }, l0 = function($, Y, W) {
    const X = (0, Z0.IsString)($.$id) ? [...Y, $] : Y, Z = $;
    switch ($[l1.Kind]) {
      case "Array":
        return w9(Z, X, W);
      case "BigInt":
        return j9(Z, X, W);
      case "Boolean":
        return K9(Z, X, W);
      case "Date":
        return P9(Z, X, W);
      case "Integer":
        return O9(Z, X, W);
      case "Intersect":
        return S9(Z, X, W);
      case "Literal":
        return L9(Z, X, W);
      case "Null":
        return C9(Z, X, W);
      case "Number":
        return I9(Z, X, W);
      case "Object":
        return b9(Z, X, W);
      case "Record":
        return R9(Z, X, W);
      case "Ref":
        return G9(Z, X, W);
      case "String":
        return _9(Z, X, W);
      case "Symbol":
        return E9(Z, X, W);
      case "This":
        return V9(Z, X, W);
      case "Tuple":
        return x9(Z, X, W);
      case "Undefined":
        return k9(Z, X, W);
      case "Union":
        return g9(Z, X, W);
      case "Any":
      case "AsyncIterator":
      case "Constructor":
      case "Function":
      case "Iterator":
      case "Never":
      case "Promise":
      case "TemplateLiteral":
      case "Uint8Array":
      case "Unknown":
      case "Void":
        return X8(W);
      default:
        if (!l1.TypeRegistry.Has(Z[l1.Kind]))
          throw new Z8(Z);
        return X8(W);
    }
  }, f9 = function(...$) {
    return $.length === 3 ? l0($[0], $[1], $[2]) : l0($[0], [], $[1]);
  };
  Object.defineProperty(eY, "__esModule", { value: true });
  eY.Convert = eY.Default = eY.ValueConvertUnknownTypeError = undefined;
  var Z0 = x0(), $9 = n1(), Y9 = U$(), tY = K1(), l1 = g0();

  class Z8 extends l1.TypeBoxError {
    constructor($) {
      super("Unknown type");
      this.schema = $;
    }
  }
  eY.ValueConvertUnknownTypeError = Z8;
  eY.Default = X8;
  eY.Convert = f9;
});
var z8 = z0((zW) => {
  Object.defineProperty(zW, "__esModule", { value: true });
  zW.EncodeTransform = zW.DecodeTransform = zW.HasTransform = zW.TransformEncodeError = zW.TransformDecodeError = zW.TransformEncodeCheckError = zW.TransformDecodeCheckError = zW.TransformUnknownTypeError = undefined;
  var t0 = x0(), t1 = K1(), n = g0();

  class D$ extends n.TypeBoxError {
    constructor($) {
      super("Unknown type");
      this.schema = $;
    }
  }
  zW.TransformUnknownTypeError = D$;

  class JW extends n.TypeBoxError {
    constructor($, Y, W) {
      super("Unable to decode due to invalid value");
      this.schema = $, this.value = Y, this.error = W;
    }
  }
  zW.TransformDecodeCheckError = JW;

  class QW extends n.TypeBoxError {
    constructor($, Y, W) {
      super("Unable to encode due to invalid value");
      this.schema = $, this.value = Y, this.error = W;
    }
  }
  zW.TransformEncodeCheckError = QW;

  class J8 extends n.TypeBoxError {
    constructor($, Y, W) {
      super(`${W instanceof Error ? W.message : "Unknown error"}`);
      this.schema = $, this.value = Y;
    }
  }
  zW.TransformDecodeError = J8;

  class Q8 extends n.TypeBoxError {
    constructor($, Y, W) {
      super(`${W instanceof Error ? W.message : "Unknown error"}`);
      this.schema = $, this.value = Y;
    }
  }
  zW.TransformEncodeError = Q8;
  var WW;
  (function($) {
    function Y(w, I) {
      return n.TypeGuard.TTransform(w) || P(w.items, I);
    }
    function W(w, I) {
      return n.TypeGuard.TTransform(w) || P(w.items, I);
    }
    function X(w, I) {
      return n.TypeGuard.TTransform(w) || P(w.returns, I) || w.parameters.some((G) => P(G, I));
    }
    function Z(w, I) {
      return n.TypeGuard.TTransform(w) || P(w.returns, I) || w.parameters.some((G) => P(G, I));
    }
    function J(w, I) {
      return n.TypeGuard.TTransform(w) || n.TypeGuard.TTransform(w.unevaluatedProperties) || w.allOf.some((G) => P(G, I));
    }
    function Q(w, I) {
      return n.TypeGuard.TTransform(w) || P(w.items, I);
    }
    function z(w, I) {
      return n.TypeGuard.TTransform(w) || P(w.not, I);
    }
    function U(w, I) {
      return n.TypeGuard.TTransform(w) || Object.values(w.properties).some((G) => P(G, I)) || n.TypeGuard.TSchema(w.additionalProperties) && P(w.additionalProperties, I);
    }
    function F(w, I) {
      return n.TypeGuard.TTransform(w) || P(w.item, I);
    }
    function D(w, I) {
      const G = Object.getOwnPropertyNames(w.patternProperties)[0], k = w.patternProperties[G];
      return n.TypeGuard.TTransform(w) || P(k, I) || n.TypeGuard.TSchema(w.additionalProperties) && n.TypeGuard.TTransform(w.additionalProperties);
    }
    function S(w, I) {
      if (n.TypeGuard.TTransform(w))
        return true;
      return P((0, t1.Deref)(w, I), I);
    }
    function b(w, I) {
      if (n.TypeGuard.TTransform(w))
        return true;
      return P((0, t1.Deref)(w, I), I);
    }
    function j(w, I) {
      return n.TypeGuard.TTransform(w) || n.TypeGuard.TSchema(w.items) && w.items.some((G) => P(G, I));
    }
    function M(w, I) {
      return n.TypeGuard.TTransform(w) || w.anyOf.some((G) => P(G, I));
    }
    function P(w, I) {
      const G = (0, t0.IsString)(w.$id) ? [...I, w] : I, k = w;
      if (w.$id && O.has(w.$id))
        return false;
      if (w.$id)
        O.add(w.$id);
      switch (w[n.Kind]) {
        case "Array":
          return Y(k, G);
        case "AsyncIterator":
          return W(k, G);
        case "Constructor":
          return X(k, G);
        case "Function":
          return Z(k, G);
        case "Intersect":
          return J(k, G);
        case "Iterator":
          return Q(k, G);
        case "Not":
          return z(k, G);
        case "Object":
          return U(k, G);
        case "Promise":
          return F(k, G);
        case "Record":
          return D(k, G);
        case "Ref":
          return S(k, G);
        case "This":
          return b(k, G);
        case "Tuple":
          return j(k, G);
        case "Union":
          return M(k, G);
        case "Any":
        case "BigInt":
        case "Boolean":
        case "Date":
        case "Integer":
        case "Literal":
        case "Never":
        case "Null":
        case "Number":
        case "String":
        case "Symbol":
        case "TemplateLiteral":
        case "Undefined":
        case "Uint8Array":
        case "Unknown":
        case "Void":
          return n.TypeGuard.TTransform(w);
        default:
          if (!n.TypeRegistry.Has(k[n.Kind]))
            throw new D$(k);
          return n.TypeGuard.TTransform(w);
      }
    }
    const O = new Set;
    function A(w, I) {
      return O.clear(), P(w, I);
    }
    $.Has = A;
  })(WW || (zW.HasTransform = WW = {}));
  var XW;
  (function($) {
    function Y(M, P) {
      try {
        return n.TypeGuard.TTransform(M) ? M[n.Transform].Decode(P) : P;
      } catch (O) {
        throw new J8(M, P, O);
      }
    }
    function W(M, P, O) {
      const A = O.map((w) => S(M.items, P, w));
      return Y(M, A);
    }
    function X(M, P, O) {
      if (!(0, t0.IsPlainObject)(O) || (0, t0.IsValueType)(O))
        return Y(M, O);
      const A = n.KeyResolver.ResolveKeys(M, { includePatterns: false }), w = Object.entries(O).reduce((G, [k, _]) => {
        return !A.includes(k) ? { ...G, [k]: _ } : { ...G, [k]: Y(n.IndexedAccessor.Resolve(M, [k]), _) };
      }, {});
      if (!n.TypeGuard.TTransform(M.unevaluatedProperties))
        return Y(M, w);
      const I = Object.entries(w).reduce((G, [k, _]) => {
        return A.includes(k) ? { ...G, [k]: _ } : { ...G, [k]: Y(M.unevaluatedProperties, _) };
      }, {});
      return Y(M, I);
    }
    function Z(M, P, O) {
      const A = S(M.not, P, O);
      return Y(M, A);
    }
    function J(M, P, O) {
      if (!(0, t0.IsPlainObject)(O))
        return Y(M, O);
      const A = Object.entries(O).reduce((G, [k, _]) => {
        return !(k in M.properties) ? { ...G, [k]: _ } : { ...G, [k]: S(M.properties[k], P, _) };
      }, {});
      if (!n.TypeGuard.TSchema(M.additionalProperties))
        return Y(M, A);
      const w = M.additionalProperties, I = Object.entries(A).reduce((G, [k, _]) => {
        return k in M.properties ? { ...G, [k]: _ } : { ...G, [k]: S(w, P, _) };
      }, {});
      return Y(M, I);
    }
    function Q(M, P, O) {
      if (!(0, t0.IsPlainObject)(O))
        return Y(M, O);
      const A = Object.getOwnPropertyNames(M.patternProperties)[0], w = M.patternProperties[A], I = new RegExp(A), G = Object.entries(O).reduce((J0, [Y0, A0]) => {
        return !I.test(Y0) ? { ...J0, [Y0]: A0 } : { ...J0, [Y0]: S(w, P, A0) };
      }, {});
      if (!n.TypeGuard.TSchema(M.additionalProperties))
        return Y(M, G);
      const k = M.additionalProperties, _ = Object.entries(G).reduce((J0, [Y0, A0]) => {
        return I.test(Y0) ? { ...J0, [Y0]: A0 } : { ...J0, [Y0]: S(k, P, A0) };
      }, {});
      return Y(M, _);
    }
    function z(M, P, O) {
      const A = (0, t1.Deref)(M, P), w = S(A, P, O);
      return Y(M, w);
    }
    function U(M, P, O) {
      const A = (0, t1.Deref)(M, P), w = S(A, P, O);
      return Y(M, w);
    }
    function F(M, P, O) {
      const A = (0, t0.IsArray)(M.items) ? M.items.map((w, I) => S(w, P, O[I])) : [];
      return Y(M, A);
    }
    function D(M, P, O) {
      const A = Y(M, O);
      for (let w of M.anyOf) {
        if (!b(w, P, A))
          continue;
        return S(w, P, A);
      }
      return A;
    }
    function S(M, P, O) {
      const A = typeof M.$id === "string" ? [...P, M] : P, w = M;
      switch (M[n.Kind]) {
        case "Array":
          return W(w, A, O);
        case "Intersect":
          return X(w, A, O);
        case "Not":
          return Z(w, A, O);
        case "Object":
          return J(w, A, O);
        case "Record":
          return Q(w, A, O);
        case "Ref":
          return z(w, A, O);
        case "Symbol":
          return Y(w, O);
        case "This":
          return U(w, A, O);
        case "Tuple":
          return F(w, A, O);
        case "Union":
          return D(w, A, O);
        case "Any":
        case "AsyncIterator":
        case "BigInt":
        case "Boolean":
        case "Constructor":
        case "Date":
        case "Function":
        case "Integer":
        case "Iterator":
        case "Literal":
        case "Never":
        case "Null":
        case "Number":
        case "Promise":
        case "String":
        case "TemplateLiteral":
        case "Undefined":
        case "Uint8Array":
        case "Unknown":
        case "Void":
          return Y(w, O);
        default:
          if (!n.TypeRegistry.Has(w[n.Kind]))
            throw new D$(w);
          return Y(w, O);
      }
    }
    let b = () => false;
    function j(M, P, O, A) {
      return b = A, S(M, P, O);
    }
    $.Decode = j;
  })(XW || (zW.DecodeTransform = XW = {}));
  var ZW;
  (function($) {
    function Y(M, P) {
      try {
        return n.TypeGuard.TTransform(M) ? M[n.Transform].Encode(P) : P;
      } catch (O) {
        throw new Q8(M, P, O);
      }
    }
    function W(M, P, O) {
      return Y(M, O).map((w) => S(M.items, P, w));
    }
    function X(M, P, O) {
      const A = Y(M, O);
      if (!(0, t0.IsPlainObject)(O) || (0, t0.IsValueType)(O))
        return A;
      const w = n.KeyResolver.ResolveKeys(M, { includePatterns: false }), I = Object.entries(A).reduce((G, [k, _]) => {
        return !w.includes(k) ? { ...G, [k]: _ } : { ...G, [k]: Y(n.IndexedAccessor.Resolve(M, [k]), _) };
      }, {});
      if (!n.TypeGuard.TTransform(M.unevaluatedProperties))
        return Y(M, I);
      return Object.entries(I).reduce((G, [k, _]) => {
        return w.includes(k) ? { ...G, [k]: _ } : { ...G, [k]: Y(M.unevaluatedProperties, _) };
      }, {});
    }
    function Z(M, P, O) {
      const A = Y(M, O);
      return Y(M.not, A);
    }
    function J(M, P, O) {
      const A = Y(M, O);
      if (!(0, t0.IsPlainObject)(O))
        return A;
      const w = Object.entries(A).reduce((G, [k, _]) => {
        return !(k in M.properties) ? { ...G, [k]: _ } : { ...G, [k]: S(M.properties[k], P, _) };
      }, {});
      if (!n.TypeGuard.TSchema(M.additionalProperties))
        return w;
      const I = M.additionalProperties;
      return Object.entries(w).reduce((G, [k, _]) => {
        return k in M.properties ? { ...G, [k]: _ } : { ...G, [k]: S(I, P, _) };
      }, {});
    }
    function Q(M, P, O) {
      const A = Y(M, O);
      if (!(0, t0.IsPlainObject)(O))
        return A;
      const w = Object.getOwnPropertyNames(M.patternProperties)[0], I = M.patternProperties[w], G = new RegExp(w), k = Object.entries(A).reduce((J0, [Y0, A0]) => {
        return !G.test(Y0) ? { ...J0, [Y0]: A0 } : { ...J0, [Y0]: S(I, P, A0) };
      }, {});
      if (!n.TypeGuard.TSchema(M.additionalProperties))
        return Y(M, k);
      const _ = M.additionalProperties;
      return Object.entries(k).reduce((J0, [Y0, A0]) => {
        return G.test(Y0) ? { ...J0, [Y0]: A0 } : { ...J0, [Y0]: S(_, P, A0) };
      }, {});
    }
    function z(M, P, O) {
      const A = (0, t1.Deref)(M, P), w = S(A, P, O);
      return Y(M, w);
    }
    function U(M, P, O) {
      const A = (0, t1.Deref)(M, P), w = S(A, P, O);
      return Y(M, w);
    }
    function F(M, P, O) {
      const A = Y(M, O);
      return (0, t0.IsArray)(M.items) ? M.items.map((w, I) => S(w, P, A[I])) : [];
    }
    function D(M, P, O) {
      for (let A of M.anyOf) {
        if (!b(A, P, O))
          continue;
        const w = S(A, P, O);
        return Y(M, w);
      }
      for (let A of M.anyOf) {
        const w = S(A, P, O);
        if (!b(M, P, w))
          continue;
        return Y(M, w);
      }
      return Y(M, O);
    }
    function S(M, P, O) {
      const A = typeof M.$id === "string" ? [...P, M] : P, w = M;
      switch (M[n.Kind]) {
        case "Array":
          return W(w, A, O);
        case "Intersect":
          return X(w, A, O);
        case "Not":
          return Z(w, A, O);
        case "Object":
          return J(w, A, O);
        case "Record":
          return Q(w, A, O);
        case "Ref":
          return z(w, A, O);
        case "This":
          return U(w, A, O);
        case "Tuple":
          return F(w, A, O);
        case "Union":
          return D(w, A, O);
        case "Any":
        case "AsyncIterator":
        case "BigInt":
        case "Boolean":
        case "Constructor":
        case "Date":
        case "Function":
        case "Integer":
        case "Iterator":
        case "Literal":
        case "Never":
        case "Null":
        case "Number":
        case "Promise":
        case "String":
        case "Symbol":
        case "TemplateLiteral":
        case "Undefined":
        case "Uint8Array":
        case "Unknown":
        case "Void":
          return Y(w, O);
        default:
          if (!n.TypeRegistry.Has(w[n.Kind]))
            throw new D$(w);
          return Y(w, O);
      }
    }
    let b = () => false;
    function j(M, P, O, A) {
      return b = A, S(M, P, O);
    }
    $.Encode = j;
  })(ZW || (zW.EncodeTransform = ZW = {}));
});
var wW = z0((FW) => {
  Object.defineProperty(FW, "__esModule", { value: true });
  FW.Value = undefined;
  var qW = g$(), n9 = EY(), o9 = H$(), c9 = kY(), NW = lY(), l9 = n1(), MW = YW(), AW = r6(), p$ = U$(), UW = v6(), i$ = z8(), BW;
  (function($) {
    function Y(...M) {
      return NW.Cast.apply(NW, M);
    }
    $.Cast = Y;
    function W(...M) {
      return AW.Create.apply(AW, M);
    }
    $.Create = W;
    function X(...M) {
      return p$.Check.apply(p$, M);
    }
    $.Check = X;
    function Z(...M) {
      return MW.Convert.apply(MW, M);
    }
    $.Convert = Z;
    function J(M) {
      return l9.Clone(M);
    }
    $.Clone = J;
    function Q(...M) {
      const [P, O, A] = M.length === 3 ? [M[0], M[1], M[2]] : [M[0], [], M[1]];
      if (!X(P, O, A))
        throw new i$.TransformDecodeCheckError(P, A, U(P, O, A).First());
      return i$.DecodeTransform.Decode(P, O, A, p$.Check);
    }
    $.Decode = Q;
    function z(...M) {
      const [P, O, A] = M.length === 3 ? [M[0], M[1], M[2]] : [M[0], [], M[1]], w = i$.EncodeTransform.Encode(P, O, A, p$.Check);
      if (!X(P, O, w))
        throw new i$.TransformEncodeCheckError(P, A, U(P, O, A).First());
      return w;
    }
    $.Encode = z;
    function U(...M) {
      return qW.Errors.apply(qW, M);
    }
    $.Errors = U;
    function F(M, P) {
      return c9.Equal(M, P);
    }
    $.Equal = F;
    function D(M, P) {
      return UW.Diff(M, P);
    }
    $.Diff = D;
    function S(M) {
      return o9.Hash(M);
    }
    $.Hash = S;
    function b(M, P) {
      return UW.Patch(M, P);
    }
    $.Patch = b;
    function j(M, P) {
      n9.Mutate(M, P);
    }
    $.Mutate = j;
  })(BW || (FW.Value = BW = {}));
});
var u$ = z0((J1) => {
  Object.defineProperty(J1, "__esModule", { value: true });
  J1.Value = J1.ValuePointer = J1.Delete = J1.Update = J1.Insert = J1.Edit = J1.ValueErrorIterator = J1.ValueErrorType = undefined;
  var jW = g$();
  Object.defineProperty(J1, "ValueErrorType", { enumerable: true, get: function() {
    return jW.ValueErrorType;
  } });
  Object.defineProperty(J1, "ValueErrorIterator", { enumerable: true, get: function() {
    return jW.ValueErrorIterator;
  } });
  var m$ = v6();
  Object.defineProperty(J1, "Edit", { enumerable: true, get: function() {
    return m$.Edit;
  } });
  Object.defineProperty(J1, "Insert", { enumerable: true, get: function() {
    return m$.Insert;
  } });
  Object.defineProperty(J1, "Update", { enumerable: true, get: function() {
    return m$.Update;
  } });
  Object.defineProperty(J1, "Delete", { enumerable: true, get: function() {
    return m$.Delete;
  } });
  var t9 = f$();
  Object.defineProperty(J1, "ValuePointer", { enumerable: true, get: function() {
    return t9.ValuePointer;
  } });
  var s9 = wW();
  Object.defineProperty(J1, "Value", { enumerable: true, get: function() {
    return s9.Value;
  } });
});
var CW = z0((SW) => {
  Object.defineProperty(SW, "__esModule", { value: true });
  SW.TypeCompiler = SW.Policy = SW.TypeCompilerTypeGuardError = SW.TypeCompilerUnknownTypeError = SW.TypeCheck = undefined;
  var j$ = z8(), l = x0(), J7 = z$(), K$ = M$(), Q7 = K1(), z7 = H$(), F0 = g0();

  class U8 {
    constructor($, Y, W, X) {
      this.schema = $, this.references = Y, this.checkFunc = W, this.code = X, this.hasTransform = j$.HasTransform.Has($, Y);
    }
    Code() {
      return this.code;
    }
    Errors($) {
      return (0, J7.Errors)(this.schema, this.references, $);
    }
    Check($) {
      return this.checkFunc($);
    }
    Decode($) {
      if (!this.checkFunc($))
        throw new j$.TransformDecodeCheckError(this.schema, $, this.Errors($).First());
      return this.hasTransform ? j$.DecodeTransform.Decode(this.schema, this.references, $, (Y, W, X) => this.Check(X)) : $;
    }
    Encode($) {
      const Y = this.hasTransform ? j$.EncodeTransform.Encode(this.schema, this.references, $, (W, X, Z) => this.Check(Z)) : $;
      if (!this.checkFunc(Y))
        throw new j$.TransformEncodeCheckError(this.schema, $, this.Errors($).First());
      return Y;
    }
  }
  SW.TypeCheck = U8;
  var B1;
  (function($) {
    function Y(J) {
      return J === 36;
    }
    $.DollarSign = Y;
    function W(J) {
      return J === 95;
    }
    $.IsUnderscore = W;
    function X(J) {
      return J >= 65 && J <= 90 || J >= 97 && J <= 122;
    }
    $.IsAlpha = X;
    function Z(J) {
      return J >= 48 && J <= 57;
    }
    $.IsNumeric = Z;
  })(B1 || (B1 = {}));
  var c$;
  (function($) {
    function Y(J) {
      if (J.length === 0)
        return false;
      return B1.IsNumeric(J.charCodeAt(0));
    }
    function W(J) {
      if (Y(J))
        return false;
      for (let Q = 0;Q < J.length; Q++) {
        const z = J.charCodeAt(Q);
        if (!(B1.IsAlpha(z) || B1.IsNumeric(z) || B1.DollarSign(z) || B1.IsUnderscore(z)))
          return false;
      }
      return true;
    }
    function X(J) {
      return J.replace(/'/g, "\\'");
    }
    function Z(J, Q) {
      return W(Q) ? `${J}.${Q}` : `${J}['${X(Q)}']`;
    }
    $.Encode = Z;
  })(c$ || (c$ = {}));
  var M8;
  (function($) {
    function Y(W) {
      const X = [];
      for (let Z = 0;Z < W.length; Z++) {
        const J = W.charCodeAt(Z);
        if (B1.IsNumeric(J) || B1.IsAlpha(J))
          X.push(W.charAt(Z));
        else
          X.push(`_${J}_`);
      }
      return X.join("").replace(/__/g, "_");
    }
    $.Encode = Y;
  })(M8 || (M8 = {}));
  var A8;
  (function($) {
    function Y(W) {
      return W.replace(/'/g, "\\'");
    }
    $.Escape = Y;
  })(A8 || (A8 = {}));

  class B8 extends F0.TypeBoxError {
    constructor($) {
      super("Unknown type");
      this.schema = $;
    }
  }
  SW.TypeCompilerUnknownTypeError = B8;

  class l$ extends F0.TypeBoxError {
    constructor($) {
      super("Preflight validation check failed to guard for the given schema");
      this.schema = $;
    }
  }
  SW.TypeCompilerTypeGuardError = l$;
  var E1;
  (function($) {
    function Y(Q, z, U) {
      return K$.TypeSystemPolicy.ExactOptionalPropertyTypes ? `('${z}' in ${Q} ? ${U} : true)` : `(${c$.Encode(Q, z)} !== undefined ? ${U} : true)`;
    }
    $.IsExactOptionalProperty = Y;
    function W(Q) {
      return !K$.TypeSystemPolicy.AllowArrayObject ? `(typeof ${Q} === 'object' && ${Q} !== null && !Array.isArray(${Q}))` : `(typeof ${Q} === 'object' && ${Q} !== null)`;
    }
    $.IsObjectLike = W;
    function X(Q) {
      return !K$.TypeSystemPolicy.AllowArrayObject ? `(typeof ${Q} === 'object' && ${Q} !== null && !Array.isArray(${Q}) && !(${Q} instanceof Date) && !(${Q} instanceof Uint8Array))` : `(typeof ${Q} === 'object' && ${Q} !== null && !(${Q} instanceof Date) && !(${Q} instanceof Uint8Array))`;
    }
    $.IsRecordLike = X;
    function Z(Q) {
      return !K$.TypeSystemPolicy.AllowNaN ? `(typeof ${Q} === 'number' && Number.isFinite(${Q}))` : `typeof ${Q} === 'number'`;
    }
    $.IsNumberLike = Z;
    function J(Q) {
      return K$.TypeSystemPolicy.AllowNullVoid ? `(${Q} === undefined || ${Q} === null)` : `${Q} === undefined`;
    }
    $.IsVoidLike = J;
  })(E1 || (SW.Policy = E1 = {}));
  var OW;
  (function($) {
    function Y(K) {
      return K[F0.Kind] === "Any" || K[F0.Kind] === "Unknown";
    }
    function* W(K, E, L) {
      yield "true";
    }
    function* X(K, E, L) {
      yield `Array.isArray(${L})`;
      const [p, T] = [j0("value", "any"), j0("acc", "number")];
      if ((0, l.IsNumber)(K.maxItems))
        yield `${L}.length <= ${K.maxItems}`;
      if ((0, l.IsNumber)(K.minItems))
        yield `${L}.length >= ${K.minItems}`;
      const d = f(K.items, E, "value");
      if (yield `${L}.every((${p}) => ${d})`, F0.TypeGuard.TSchema(K.contains) || (0, l.IsNumber)(K.minContains) || (0, l.IsNumber)(K.maxContains)) {
        const W0 = F0.TypeGuard.TSchema(K.contains) ? K.contains : F0.Type.Never(), S0 = f(W0, E, "value"), X0 = (0, l.IsNumber)(K.minContains) ? [`(count >= ${K.minContains})`] : [], N = (0, l.IsNumber)(K.maxContains) ? [`(count <= ${K.maxContains})`] : [], t = `const count = value.reduce((${T}, ${p}) => ${S0} ? acc + 1 : acc, 0)`, L0 = ["(count > 0)", ...X0, ...N].join(" && ");
        yield `((${p}) => { ${t}; return ${L0}})(${L})`;
      }
      if (K.uniqueItems === true)
        yield `((${p}) => { const set = new Set(); for(const element of value) { const hashed = hash(element); if(set.has(hashed)) { return false } else { set.add(hashed) } } return true } )(${L})`;
    }
    function* Z(K, E, L) {
      yield `(typeof value === 'object' && Symbol.asyncIterator in ${L})`;
    }
    function* J(K, E, L) {
      if (yield `(typeof ${L} === 'bigint')`, (0, l.IsBigInt)(K.exclusiveMaximum))
        yield `${L} < BigInt(${K.exclusiveMaximum})`;
      if ((0, l.IsBigInt)(K.exclusiveMinimum))
        yield `${L} > BigInt(${K.exclusiveMinimum})`;
      if ((0, l.IsBigInt)(K.maximum))
        yield `${L} <= BigInt(${K.maximum})`;
      if ((0, l.IsBigInt)(K.minimum))
        yield `${L} >= BigInt(${K.minimum})`;
      if ((0, l.IsBigInt)(K.multipleOf))
        yield `(${L} % BigInt(${K.multipleOf})) === 0`;
    }
    function* Q(K, E, L) {
      yield `(typeof ${L} === 'boolean')`;
    }
    function* z(K, E, L) {
      yield* y0(K.returns, E, `${L}.prototype`);
    }
    function* U(K, E, L) {
      if (yield `(${L} instanceof Date) && Number.isFinite(${L}.getTime())`, (0, l.IsNumber)(K.exclusiveMaximumTimestamp))
        yield `${L}.getTime() < ${K.exclusiveMaximumTimestamp}`;
      if ((0, l.IsNumber)(K.exclusiveMinimumTimestamp))
        yield `${L}.getTime() > ${K.exclusiveMinimumTimestamp}`;
      if ((0, l.IsNumber)(K.maximumTimestamp))
        yield `${L}.getTime() <= ${K.maximumTimestamp}`;
      if ((0, l.IsNumber)(K.minimumTimestamp))
        yield `${L}.getTime() >= ${K.minimumTimestamp}`;
      if ((0, l.IsNumber)(K.multipleOfTimestamp))
        yield `(${L}.getTime() % ${K.multipleOfTimestamp}) === 0`;
    }
    function* F(K, E, L) {
      yield `(typeof ${L} === 'function')`;
    }
    function* D(K, E, L) {
      if (yield `(typeof ${L} === 'number' && Number.isInteger(${L}))`, (0, l.IsNumber)(K.exclusiveMaximum))
        yield `${L} < ${K.exclusiveMaximum}`;
      if ((0, l.IsNumber)(K.exclusiveMinimum))
        yield `${L} > ${K.exclusiveMinimum}`;
      if ((0, l.IsNumber)(K.maximum))
        yield `${L} <= ${K.maximum}`;
      if ((0, l.IsNumber)(K.minimum))
        yield `${L} >= ${K.minimum}`;
      if ((0, l.IsNumber)(K.multipleOf))
        yield `(${L} % ${K.multipleOf}) === 0`;
    }
    function* S(K, E, L) {
      const p = K.allOf.map((T) => f(T, E, L)).join(" && ");
      if (K.unevaluatedProperties === false) {
        const T = h(`${new RegExp(F0.KeyResolver.ResolvePattern(K))};`), d = `Object.getOwnPropertyNames(${L}).every(key => ${T}.test(key))`;
        yield `(${p} && ${d})`;
      } else if (F0.TypeGuard.TSchema(K.unevaluatedProperties)) {
        const T = h(`${new RegExp(F0.KeyResolver.ResolvePattern(K))};`), d = `Object.getOwnPropertyNames(${L}).every(key => ${T}.test(key) || ${f(K.unevaluatedProperties, E, `${L}[key]`)})`;
        yield `(${p} && ${d})`;
      } else
        yield `(${p})`;
    }
    function* b(K, E, L) {
      yield `(typeof value === 'object' && Symbol.iterator in ${L})`;
    }
    function* j(K, E, L) {
      if (typeof K.const === "number" || typeof K.const === "boolean")
        yield `(${L} === ${K.const})`;
      else
        yield `(${L} === '${A8.Escape(K.const)}')`;
    }
    function* M(K, E, L) {
      yield "false";
    }
    function* P(K, E, L) {
      yield `(!${f(K.not, E, L)})`;
    }
    function* O(K, E, L) {
      yield `(${L} === null)`;
    }
    function* A(K, E, L) {
      if (yield E1.IsNumberLike(L), (0, l.IsNumber)(K.exclusiveMaximum))
        yield `${L} < ${K.exclusiveMaximum}`;
      if ((0, l.IsNumber)(K.exclusiveMinimum))
        yield `${L} > ${K.exclusiveMinimum}`;
      if ((0, l.IsNumber)(K.maximum))
        yield `${L} <= ${K.maximum}`;
      if ((0, l.IsNumber)(K.minimum))
        yield `${L} >= ${K.minimum}`;
      if ((0, l.IsNumber)(K.multipleOf))
        yield `(${L} % ${K.multipleOf}) === 0`;
    }
    function* w(K, E, L) {
      if (yield E1.IsObjectLike(L), (0, l.IsNumber)(K.minProperties))
        yield `Object.getOwnPropertyNames(${L}).length >= ${K.minProperties}`;
      if ((0, l.IsNumber)(K.maxProperties))
        yield `Object.getOwnPropertyNames(${L}).length <= ${K.maxProperties}`;
      const p = Object.getOwnPropertyNames(K.properties);
      for (let T of p) {
        const d = c$.Encode(L, T), W0 = K.properties[T];
        if (K.required && K.required.includes(T)) {
          if (yield* y0(W0, E, d), F0.ExtendsUndefined.Check(W0) || Y(W0))
            yield `('${T}' in ${L})`;
        } else {
          const S0 = f(W0, E, d);
          yield E1.IsExactOptionalProperty(L, T, S0);
        }
      }
      if (K.additionalProperties === false)
        if (K.required && K.required.length === p.length)
          yield `Object.getOwnPropertyNames(${L}).length === ${p.length}`;
        else {
          const T = `[${p.map((d) => `'${d}'`).join(", ")}]`;
          yield `Object.getOwnPropertyNames(${L}).every(key => ${T}.includes(key))`;
        }
      if (typeof K.additionalProperties === "object") {
        const T = f(K.additionalProperties, E, `${L}[key]`), d = `[${p.map((W0) => `'${W0}'`).join(", ")}]`;
        yield `(Object.getOwnPropertyNames(${L}).every(key => ${d}.includes(key) || ${T}))`;
      }
    }
    function* I(K, E, L) {
      yield `(typeof value === 'object' && typeof ${L}.then === 'function')`;
    }
    function* G(K, E, L) {
      if (yield E1.IsRecordLike(L), (0, l.IsNumber)(K.minProperties))
        yield `Object.getOwnPropertyNames(${L}).length >= ${K.minProperties}`;
      if ((0, l.IsNumber)(K.maxProperties))
        yield `Object.getOwnPropertyNames(${L}).length <= ${K.maxProperties}`;
      const [p, T] = Object.entries(K.patternProperties)[0], d = h(`${new RegExp(p)}`), W0 = f(T, E, "value"), S0 = F0.TypeGuard.TSchema(K.additionalProperties) ? f(K.additionalProperties, E, L) : K.additionalProperties === false ? "false" : "true", X0 = `(${d}.test(key) ? ${W0} : ${S0})`;
      yield `(Object.entries(${L}).every(([key, value]) => ${X0}))`;
    }
    function* k(K, E, L) {
      const p = (0, Q7.Deref)(K, E);
      if (R.functions.has(K.$ref))
        return yield `${i(K.$ref)}(${L})`;
      yield* y0(p, E, L);
    }
    function* _(K, E, L) {
      if (yield `(typeof ${L} === 'string')`, (0, l.IsNumber)(K.maxLength))
        yield `${L}.length <= ${K.maxLength}`;
      if ((0, l.IsNumber)(K.minLength))
        yield `${L}.length >= ${K.minLength}`;
      if (K.pattern !== undefined)
        yield `${h(`${new RegExp(K.pattern)};`)}.test(${L})`;
      if (K.format !== undefined)
        yield `format('${K.format}', ${L})`;
    }
    function* J0(K, E, L) {
      yield `(typeof ${L} === 'symbol')`;
    }
    function* Y0(K, E, L) {
      yield `(typeof ${L} === 'string')`, yield `${h(`${new RegExp(K.pattern)};`)}.test(${L})`;
    }
    function* A0(K, E, L) {
      yield `${i(K.$ref)}(${L})`;
    }
    function* k1(K, E, L) {
      if (yield `Array.isArray(${L})`, K.items === undefined)
        return yield `${L}.length === 0`;
      yield `(${L}.length === ${K.maxItems})`;
      for (let p = 0;p < K.items.length; p++)
        yield `${f(K.items[p], E, `${L}[${p}]`)}`;
    }
    function* u0(K, E, L) {
      yield `${L} === undefined`;
    }
    function* h0(K, E, L) {
      yield `(${K.anyOf.map((T) => f(T, E, L)).join(" || ")})`;
    }
    function* N0(K, E, L) {
      if (yield `${L} instanceof Uint8Array`, (0, l.IsNumber)(K.maxByteLength))
        yield `(${L}.length <= ${K.maxByteLength})`;
      if ((0, l.IsNumber)(K.minByteLength))
        yield `(${L}.length >= ${K.minByteLength})`;
    }
    function* H0(K, E, L) {
      yield "true";
    }
    function* n0(K, E, L) {
      yield E1.IsVoidLike(L);
    }
    function* $1(K, E, L) {
      const p = R.instances.size;
      R.instances.set(p, K), yield `kind('${K[F0.Kind]}', ${p}, ${L})`;
    }
    function* y0(K, E, L, p = true) {
      const T = (0, l.IsString)(K.$id) ? [...E, K] : E, d = K;
      if (p && (0, l.IsString)(K.$id)) {
        const W0 = i(K.$id);
        if (R.functions.has(W0))
          return yield `${W0}(${L})`;
        else {
          const S0 = q0(W0, K, E, "value", false);
          return R.functions.set(W0, S0), yield `${W0}(${L})`;
        }
      }
      switch (d[F0.Kind]) {
        case "Any":
          return yield* W(d, T, L);
        case "Array":
          return yield* X(d, T, L);
        case "AsyncIterator":
          return yield* Z(d, T, L);
        case "BigInt":
          return yield* J(d, T, L);
        case "Boolean":
          return yield* Q(d, T, L);
        case "Constructor":
          return yield* z(d, T, L);
        case "Date":
          return yield* U(d, T, L);
        case "Function":
          return yield* F(d, T, L);
        case "Integer":
          return yield* D(d, T, L);
        case "Intersect":
          return yield* S(d, T, L);
        case "Iterator":
          return yield* b(d, T, L);
        case "Literal":
          return yield* j(d, T, L);
        case "Never":
          return yield* M(d, T, L);
        case "Not":
          return yield* P(d, T, L);
        case "Null":
          return yield* O(d, T, L);
        case "Number":
          return yield* A(d, T, L);
        case "Object":
          return yield* w(d, T, L);
        case "Promise":
          return yield* I(d, T, L);
        case "Record":
          return yield* G(d, T, L);
        case "Ref":
          return yield* k(d, T, L);
        case "String":
          return yield* _(d, T, L);
        case "Symbol":
          return yield* J0(d, T, L);
        case "TemplateLiteral":
          return yield* Y0(d, T, L);
        case "This":
          return yield* A0(d, T, L);
        case "Tuple":
          return yield* k1(d, T, L);
        case "Undefined":
          return yield* u0(d, T, L);
        case "Union":
          return yield* h0(d, T, L);
        case "Uint8Array":
          return yield* N0(d, T, L);
        case "Unknown":
          return yield* H0(d, T, L);
        case "Void":
          return yield* n0(d, T, L);
        default:
          if (!F0.TypeRegistry.Has(d[F0.Kind]))
            throw new B8(K);
          return yield* $1(d, T, L);
      }
    }
    const R = { language: "javascript", functions: new Map, variables: new Map, instances: new Map };
    function f(K, E, L, p = true) {
      return `(${[...y0(K, E, L, p)].join(" && ")})`;
    }
    function i(K) {
      return `check_${M8.Encode(K)}`;
    }
    function h(K) {
      const E = `local_${R.variables.size}`;
      return R.variables.set(E, `const ${E} = ${K}`), E;
    }
    function q0(K, E, L, p, T = true) {
      const [d, W0] = ["\n", (t) => "".padStart(t, " ")], S0 = j0("value", "any"), X0 = K0("boolean"), N = [...y0(E, L, p, T)].map((t) => `${W0(4)}${t}`).join(` &&${d}`);
      return `function ${K}(${S0})${X0} {${d}${W0(2)}return (${d}${N}${d}${W0(2)})\n}`;
    }
    function j0(K, E) {
      const L = R.language === "typescript" ? `: ${E}` : "";
      return `${K}${L}`;
    }
    function K0(K) {
      return R.language === "typescript" ? `: ${K}` : "";
    }
    function P0(K, E, L) {
      const p = q0("check", K, E, "value"), T = j0("value", "any"), d = K0("boolean"), W0 = [...R.functions.values()], S0 = [...R.variables.values()], X0 = (0, l.IsString)(K.$id) ? `return function check(${T})${d} {\n  return ${i(K.$id)}(value)\n}` : `return ${p}`;
      return [...S0, ...W0, X0].join("\n");
    }
    function M0(...K) {
      const E = { language: "javascript" }, [L, p, T] = K.length === 2 && (0, l.IsArray)(K[1]) ? [K[0], K[1], E] : K.length === 2 && !(0, l.IsArray)(K[1]) ? [K[0], [], K[1]] : K.length === 3 ? [K[0], K[1], K[2]] : K.length === 1 ? [K[0], [], E] : [null, [], E];
      if (R.language = T.language, R.variables.clear(), R.functions.clear(), R.instances.clear(), !F0.TypeGuard.TSchema(L))
        throw new l$(L);
      for (let d of p)
        if (!F0.TypeGuard.TSchema(d))
          throw new l$(d);
      return P0(L, p, T);
    }
    $.Code = M0;
    function w1(K, E = []) {
      const L = M0(K, E, { language: "javascript" }), p = globalThis.Function("kind", "format", "hash", L), T = new Map(R.instances);
      function d(N, t, L0) {
        if (!F0.TypeRegistry.Has(N) || !T.has(t))
          return false;
        const $6 = F0.TypeRegistry.Get(N), Y6 = T.get(t);
        return $6(Y6, L0);
      }
      function W0(N, t) {
        if (!F0.FormatRegistry.Has(N))
          return false;
        return F0.FormatRegistry.Get(N)(t);
      }
      function S0(N) {
        return (0, z7.Hash)(N);
      }
      const X0 = p(d, W0, S0);
      return new U8(K, E, X0, L);
    }
    $.Compile = w1;
  })(OW || (SW.TypeCompiler = OW = {}));
});
var F8 = z0((s0) => {
  var A7 = s0 && s0.__createBinding || (Object.create ? function($, Y, W, X) {
    if (X === undefined)
      X = W;
    var Z = Object.getOwnPropertyDescriptor(Y, W);
    if (!Z || ("get" in Z ? !Y.__esModule : Z.writable || Z.configurable))
      Z = { enumerable: true, get: function() {
        return Y[W];
      } };
    Object.defineProperty($, X, Z);
  } : function($, Y, W, X) {
    if (X === undefined)
      X = W;
    $[X] = Y[W];
  }), U7 = s0 && s0.__exportStar || function($, Y) {
    for (var W in $)
      if (W !== "default" && !Object.prototype.hasOwnProperty.call(Y, W))
        A7(Y, $, W);
  };
  Object.defineProperty(s0, "__esModule", { value: true });
  s0.ValueErrorIterator = s0.ValueErrorType = undefined;
  var IW = g$();
  Object.defineProperty(s0, "ValueErrorType", { enumerable: true, get: function() {
    return IW.ValueErrorType;
  } });
  Object.defineProperty(s0, "ValueErrorIterator", { enumerable: true, get: function() {
    return IW.ValueErrorIterator;
  } });
  U7(CW(), s0);
});
var fW = z0((Cz, gW) => {
  var D7 = function($) {
    var Y = $.indexOf("%");
    if (Y === -1)
      return $;
    var W = $.length, X = "", Z = 0, J = 0, Q = Y, z = xW;
    while (Y > -1 && Y < W) {
      var U = kW($[Y + 1], 4), F = kW($[Y + 2], 0), D = U | F, S = C8[D];
      if (z = C8[256 + z + S], J = J << 6 | D & C8[364 + S], z === xW)
        X += $.slice(Z, Q), X += J <= 65535 ? String.fromCharCode(J) : String.fromCharCode(55232 + (J >> 10), 56320 + (J & 1023)), J = 0, Z = Y + 3, Y = Q = $.indexOf("%", Z);
      else if (z === F7)
        return null;
      else {
        if (Y += 3, Y < W && $.charCodeAt(Y) === 37)
          continue;
        return null;
      }
    }
    return X + $.slice(Z);
  }, kW = function($, Y) {
    var W = w7[$];
    return W === undefined ? 255 : W << Y;
  }, xW = 12, F7 = 0, C8 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 7, 7, 10, 9, 9, 9, 11, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 0, 24, 36, 48, 60, 72, 84, 96, 0, 12, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 24, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 48, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127, 63, 63, 63, 0, 31, 15, 15, 15, 7, 7, 7], w7 = { "0": 0, "1": 1, "2": 2, "3": 3, "4": 4, "5": 5, "6": 6, "7": 7, "8": 8, "9": 9, a: 10, A: 10, b: 11, B: 11, c: 12, C: 12, d: 13, D: 13, e: 14, E: 14, f: 15, F: 15 };
  gW.exports = D7;
});
var pW = z0((Iz, vW) => {
  var j7 = function($) {
    const Y = new yW;
    if (typeof $ !== "string")
      return Y;
    let W = $.length, X = "", Z = "", J = -1, Q = -1, z = false, U = false, F = false, D = false, S = false, b = 0;
    for (let j = 0;j < W + 1; j++)
      if (b = j !== W ? $.charCodeAt(j) : 38, b === 38) {
        if (S = Q > J, !S)
          Q = j;
        if (X = $.slice(J + 1, Q), S || X.length > 0) {
          if (F)
            X = X.replace(dW, " ");
          if (z)
            X = TW(X) || X;
          if (S) {
            if (Z = $.slice(Q + 1, j), D)
              Z = Z.replace(dW, " ");
            if (U)
              Z = TW(Z) || Z;
          }
          const M = Y[X];
          if (M === undefined)
            Y[X] = Z;
          else if (M.pop)
            M.push(Z);
          else
            Y[X] = [M, Z];
        }
        Z = "", J = j, Q = j, z = false, U = false, F = false, D = false;
      } else if (b === 61)
        if (Q <= J)
          Q = j;
        else
          U = true;
      else if (b === 43)
        if (Q > J)
          D = true;
        else
          F = true;
      else if (b === 37)
        if (Q > J)
          U = true;
        else
          z = true;
    return Y;
  }, TW = fW(), dW = /\+/g, yW = function() {
  };
  yW.prototype = Object.create(null);
  vW.exports = j7;
});
var mW = z0((bz, iW) => {
  var P7 = function($) {
    const Y = $.length;
    if (Y === 0)
      return "";
    let W = "", X = 0, Z = 0;
    $:
      for (;Z < Y; Z++) {
        let J = $.charCodeAt(Z);
        while (J < 128) {
          if (K7[J] !== 1) {
            if (X < Z)
              W += $.slice(X, Z);
            X = Z + 1, W += z1[J];
          }
          if (++Z === Y)
            break $;
          J = $.charCodeAt(Z);
        }
        if (X < Z)
          W += $.slice(X, Z);
        if (J < 2048) {
          X = Z + 1, W += z1[192 | J >> 6] + z1[128 | J & 63];
          continue;
        }
        if (J < 55296 || J >= 57344) {
          X = Z + 1, W += z1[224 | J >> 12] + z1[128 | J >> 6 & 63] + z1[128 | J & 63];
          continue;
        }
        if (++Z, Z >= Y)
          throw new Error("URI malformed");
        const Q = $.charCodeAt(Z) & 1023;
        X = Z + 1, J = 65536 + ((J & 1023) << 10 | Q), W += z1[240 | J >> 18] + z1[128 | J >> 12 & 63] + z1[128 | J >> 6 & 63] + z1[128 | J & 63];
      }
    if (X === 0)
      return $;
    if (X < Y)
      return W + $.slice(X);
    return W;
  }, z1 = Array.from({ length: 256 }, ($, Y) => "%" + ((Y < 16 ? "0" : "") + Y.toString(16)).toUpperCase()), K7 = new Int8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0]);
  iW.exports = { encodeString: P7 };
});
var nW = z0((Rz, hW) => {
  var uW = function($) {
    const Y = typeof $;
    if (Y === "string")
      return I8($);
    else if (Y === "bigint")
      return $.toString();
    else if (Y === "boolean")
      return $ ? "true" : "false";
    else if (Y === "number" && Number.isFinite($))
      return $ < 1000000000000000000000 ? "" + $ : I8("" + $);
    return "";
  }, O7 = function($) {
    let Y = "";
    if ($ === null || typeof $ !== "object")
      return Y;
    const W = "&", X = Object.keys($), Z = X.length;
    let J = 0;
    for (let Q = 0;Q < Z; Q++) {
      const z = X[Q], U = $[z], F = I8(z) + "=";
      if (Q)
        Y += W;
      if (Array.isArray(U)) {
        J = U.length;
        for (let D = 0;D < J; D++) {
          if (D)
            Y += W;
          Y += F, Y += uW(U[D]);
        }
      } else
        Y += F, Y += uW(U);
    }
    return Y;
  }, { encodeString: I8 } = mW();
  hW.exports = O7;
});
var b8 = z0((Gz, S$) => {
  var oW = pW(), cW = nW(), lW = { parse: oW, stringify: cW };
  S$.exports = lW;
  S$.exports.default = lW;
  S$.exports.parse = oW;
  S$.exports.stringify = cW;
});
var g1 = ($, Y) => ({ part: $, store: null, inert: Y !== undefined ? new Map(Y.map((W) => [W.part.charCodeAt(0), W])) : null, params: null, wildcardStore: null });
var g8 = ($, Y) => ({ ...$, part: Y });
var f8 = ($) => ({ paramName: $, store: null, inert: null });

class I1 {
  root = {};
  history = [];
  static regex = { static: /:.+?(?=\/|$)/, params: /:.+?(?=\/|$)/g };
  add($, Y, W) {
    let X;
    if (typeof Y != "string")
      throw TypeError("Route path must be a string");
    Y === "" ? Y = "/" : Y[0] !== "/" && (Y = `/${Y}`), this.history.push([$, Y, W]);
    let Z = Y[Y.length - 1] === "*";
    Z && (Y = Y.slice(0, -1));
    let J = Y.split(I1.regex.static), Q = Y.match(I1.regex.params) || [];
    J[J.length - 1] === "" && J.pop(), X = this.root[$] ? this.root[$] : this.root[$] = g1("/");
    let z = 0;
    for (let U = 0;U < J.length; ++U) {
      let F = J[U];
      if (U > 0) {
        let D = Q[z++].slice(1);
        if (X.params === null)
          X.params = f8(D);
        else if (X.params.paramName !== D)
          throw Error(`Cannot create route "${Y}" with parameter "${D}" because a route already exists with a different parameter name ("${X.params.paramName}") in the same location`);
        let S = X.params;
        if (S.inert === null) {
          X = S.inert = g1(F);
          continue;
        }
        X = S.inert;
      }
      for (let D = 0;; ) {
        if (D === F.length) {
          if (D < X.part.length) {
            let S = g8(X, X.part.slice(D));
            Object.assign(X, g1(F, [S]));
          }
          break;
        }
        if (D === X.part.length) {
          if (X.inert === null)
            X.inert = new Map;
          else if (X.inert.has(F.charCodeAt(D))) {
            X = X.inert.get(F.charCodeAt(D)), F = F.slice(D), D = 0;
            continue;
          }
          let S = g1(F.slice(D));
          X.inert.set(F.charCodeAt(D), S), X = S;
          break;
        }
        if (F[D] !== X.part[D]) {
          let S = g8(X, X.part.slice(D)), b = g1(F.slice(D));
          Object.assign(X, g1(X.part.slice(0, D), [S, b])), X = b;
          break;
        }
        ++D;
      }
    }
    if (z < Q.length) {
      let U = Q[z], F = U.slice(1);
      if (X.params === null)
        X.params = f8(F);
      else if (X.params.paramName !== F)
        throw Error(`Cannot create route "${Y}" with parameter "${F}" because a route already exists with a different parameter name ("${X.params.paramName}") in the same location`);
      return X.params.store === null && (X.params.store = W), X.params.store;
    }
    return Z ? (X.wildcardStore === null && (X.wildcardStore = W), X.wildcardStore) : (X.store === null && (X.store = W), X.store);
  }
  find($, Y) {
    let W = this.root[$];
    return W ? J6(Y, Y.length, W, 0) : null;
  }
}
var J6 = ($, Y, W, X) => {
  let Z = W?.part, J = X + Z.length;
  if (Z.length > 1) {
    if (J > Y)
      return null;
    if (Z.length < 15) {
      for (let Q = 1, z = X + 1;Q < Z.length; ++Q, ++z)
        if (Z.charCodeAt(Q) !== $.charCodeAt(z))
          return null;
    } else if ($.substring(X, J) !== Z)
      return null;
  }
  if (J === Y)
    return W.store !== null ? { store: W.store, params: {} } : W.wildcardStore !== null ? { store: W.wildcardStore, params: { "*": "" } } : null;
  if (W.inert !== null) {
    let Q = W.inert.get($.charCodeAt(J));
    if (Q !== undefined) {
      let z = J6($, Y, Q, J);
      if (z !== null)
        return z;
    }
  }
  if (W.params !== null) {
    let Q = W.params, z = $.indexOf("/", J);
    if (z !== J) {
      if (z === -1 || z >= Y) {
        if (Q.store !== null) {
          let U = {};
          return U[Q.paramName] = $.substring(J, Y), { store: Q.store, params: U };
        }
      } else if (Q.inert !== null) {
        let U = J6($, Y, Q.inert, z);
        if (U !== null)
          return U.params[Q.paramName] = $.substring(J, z), U;
      }
    }
  }
  return W.wildcardStore !== null ? { store: W.wildcardStore, params: { "*": $.substring(J, Y) } } : null;
};
var y8 = v0(d8(), 1);
var v8 = y8.default;
var R$ = () => {
  let $;
  return [new Promise((W) => {
    $ = W;
  }), $];
};
var j1 = () => {
  const [$, Y] = R$(), [W, X] = R$(), Z = [], J = [];
  return { signal: $, consume: (Q) => {
    switch (Q.type) {
      case "begin":
        if (Q.unit && Z.length === 0)
          for (let z = 0;z < Q.unit; z++) {
            const [U, F] = R$(), [D, S] = R$();
            Z.push(U), J.push([(b) => {
              F({ children: [], end: D, name: b.name ?? "", skip: false, time: b.time });
            }, (b) => {
              S(b);
            }]);
          }
        Y({ children: Z, end: W, name: Q.name ?? "", skip: false, time: Q.time });
        break;
      case "end":
        X(Q.time);
        break;
    }
  }, consumeChild(Q) {
    switch (Q.type) {
      case "begin":
        if (!J[0])
          return;
        const [z] = J[0];
        z({ children: [], end: W, name: Q.name ?? "", skip: false, time: Q.time });
        break;
      case "end":
        const U = J.shift();
        if (!U)
          return;
        U[1](Q.time);
    }
  }, resolve() {
    Y({ children: [], end: new Promise((Q) => Q(0)), name: "", skip: true, time: 0 });
    for (let [Q, z] of J)
      Q({ children: [], end: new Promise((U) => U(0)), name: "", skip: true, time: 0 }), z(0);
    X(0);
  } };
};
var p8 = ($, Y, W) => {
  return async function X(X) {
    if (X.event !== "request" || X.type !== "begin")
      return;
    const Z = X.id, J = $(), Q = j1(), z = j1(), U = j1(), F = j1(), D = j1(), S = j1(), b = j1(), j = j1();
    Q.consume(X);
    const M = (P) => {
      if (P.id === Z)
        switch (P.event) {
          case "request":
            Q.consume(P);
            break;
          case "request.unit":
            Q.consumeChild(P);
            break;
          case "parse":
            z.consume(P);
            break;
          case "parse.unit":
            z.consumeChild(P);
            break;
          case "transform":
            U.consume(P);
            break;
          case "transform.unit":
            U.consumeChild(P);
            break;
          case "beforeHandle":
            F.consume(P);
            break;
          case "beforeHandle.unit":
            F.consumeChild(P);
            break;
          case "handle":
            D.consume(P);
            break;
          case "afterHandle":
            S.consume(P);
            break;
          case "afterHandle.unit":
            S.consumeChild(P);
            break;
          case "error":
            b.consume(P);
            break;
          case "error.unit":
            b.consumeChild(P);
            break;
          case "response":
            if (P.type === "begin")
              Q.resolve(), z.resolve(), U.resolve(), F.resolve(), D.resolve(), S.resolve(), b.resolve();
            else
              J.off("event", M);
            j.consume(P);
            break;
          case "response.unit":
            j.consumeChild(P);
            break;
          case "exit":
            Q.resolve(), z.resolve(), U.resolve(), F.resolve(), D.resolve(), S.resolve(), b.resolve();
            break;
        }
    };
    J.on("event", M), await W({ id: Z, context: X.ctx, set: X.ctx?.set, store: X.ctx?.store, time: X.time, request: Q.signal, parse: z.signal, transform: U.signal, beforeHandle: F.signal, handle: D.signal, afterHandle: S.signal, error: b.signal, response: j.signal }), J.emit(`res${Z}.${Y}`, undefined);
  };
};
var PW = {};
k8(PW, { isProduction: () => {
  {
    return s1;
  }
}, ValidationError: () => {
  {
    return U0;
  }
}, ParseError: () => {
  {
    return q8;
  }
}, NotFoundError: () => {
  {
    return O1;
  }
}, InvalidCookieSignature: () => {
  {
    return r1;
  }
}, InternalServerError: () => {
  {
    return w$;
  }
}, ERROR_CODE: () => {
  {
    return _1;
  }
} });
var H8 = v0(u$(), 1);
var KW = typeof Bun !== "undefined" ? Bun.env : typeof process !== "undefined" ? process?.env : undefined;
var _1 = Symbol("ErrorCode");
var s1 = (KW?.NODE_ENV ?? KW?.ENV) === "production";

class w$ extends Error {
  code = "INTERNAL_SERVER_ERROR";
  status = 500;
  constructor($) {
    super($ ?? "INTERNAL_SERVER_ERROR");
  }
}

class O1 extends Error {
  code = "NOT_FOUND";
  status = 404;
  constructor($) {
    super($ ?? "NOT_FOUND");
  }
}

class q8 extends Error {
  code = "PARSE";
  status = 400;
  constructor($) {
    super($ ?? "PARSE");
  }
}

class r1 extends Error {
  $;
  code = "INVALID_COOKIE_SIGNATURE";
  status = 400;
  constructor($, Y) {
    super(Y ?? `"${$}" has invalid cookie signature`);
    this.key = $;
  }
}

class U0 extends Error {
  $;
  Y;
  W;
  code = "VALIDATION";
  status = 400;
  constructor($, Y, W) {
    const X = s1 ? undefined : ("Errors" in Y) ? Y.Errors(W).First() : H8.Value.Errors(Y, W).First(), Z = X?.schema.error ? typeof X.schema.error === "function" ? X.schema.error($, Y, W) : X.schema.error : undefined, J = s1 ? Z ?? `Invalid ${$ ?? X?.schema.error ?? X?.message}` : Z ?? `Invalid ${$}, '${X?.path?.slice(1) || "type"}': ${X?.message}` + "\n\nExpected: " + JSON.stringify(U0.simplifyModel(Y), null, 2) + "\n\nFound: " + JSON.stringify(W, null, 2);
    super(J);
    this.type = $;
    this.validator = Y;
    this.value = W;
    Object.setPrototypeOf(this, U0.prototype);
  }
  get all() {
    return [...this.validator.Errors(this.value)];
  }
  static simplifyModel($) {
    const Y = "schema" in $ ? $.schema : $;
    try {
      return H8.Value.Create(Y);
    } catch {
      return Y;
    }
  }
  get model() {
    return U0.simplifyModel(this.validator);
  }
  toResponse($) {
    return new Response(this.message, { status: 400, headers: $ });
  }
}
var N8 = { open($) {
  $.data.open?.($);
}, message($, Y) {
  $.data.message?.($, Y);
}, drain($) {
  $.data.drain?.($);
}, close($, Y, W) {
  $.data.close?.($, Y, W);
} };

class a1 {
  $;
  Y;
  id;
  validator;
  constructor($, Y) {
    this.raw = $;
    this.data = Y;
    this.validator = $.data.validator, this.id = Date.now();
  }
  get publish() {
    return ($, Y = undefined, W) => {
      if (this.validator?.Check(Y) === false)
        throw new U0("message", this.validator, Y);
      if (typeof Y === "object")
        Y = JSON.stringify(Y);
      return this.raw.publish($, Y, W), this;
    };
  }
  get send() {
    return ($) => {
      if (this.validator?.Check($) === false)
        throw new U0("message", this.validator, $);
      if (Buffer.isBuffer($))
        return this.raw.send($), this;
      if (typeof $ === "object")
        $ = JSON.stringify($);
      return this.raw.send($), this;
    };
  }
  get subscribe() {
    return ($) => {
      return this.raw.subscribe($), this;
    };
  }
  get unsubscribe() {
    return ($) => {
      return this.raw.unsubscribe($), this;
    };
  }
  get cork() {
    return ($) => {
      return this.raw.cork($), this;
    };
  }
  get close() {
    return () => {
      return this.raw.close(), this;
    };
  }
  get terminate() {
    return this.raw.terminate.bind(this.raw);
  }
  get isSubscribed() {
    return this.raw.isSubscribed.bind(this.raw);
  }
  get remoteAddress() {
    return this.raw.remoteAddress;
  }
}
var e9 = function($, Y) {
  if (typeof $ !== "string")
    throw new TypeError("argument str must be a string");
  var W = {}, X = Y || {}, Z = X.decode || Y7, J = 0;
  while (J < $.length) {
    var Q = $.indexOf("=", J);
    if (Q === -1)
      break;
    var z = $.indexOf(";", J);
    if (z === -1)
      z = $.length;
    else if (z < Q) {
      J = $.lastIndexOf(";", Q - 1) + 1;
      continue;
    }
    var U = $.slice(J, Q).trim();
    if (W[U] === undefined) {
      var F = $.slice(Q + 1, z).trim();
      if (F.charCodeAt(0) === 34)
        F = F.slice(1, -1);
      W[U] = Z7(F, Z);
    }
    J = z + 1;
  }
  return W;
};
var $7 = function($, Y, W) {
  var X = W || {}, Z = X.encode || W7;
  if (typeof Z !== "function")
    throw new TypeError("option encode is invalid");
  if (!h$.test($))
    throw new TypeError("argument name is invalid");
  var J = Z(Y);
  if (J && !h$.test(J))
    throw new TypeError("argument val is invalid");
  var Q = $ + "=" + J;
  if (X.maxAge != null) {
    var z = X.maxAge - 0;
    if (isNaN(z) || !isFinite(z))
      throw new TypeError("option maxAge is invalid");
    Q += "; Max-Age=" + Math.floor(z);
  }
  if (X.domain) {
    if (!h$.test(X.domain))
      throw new TypeError("option domain is invalid");
    Q += "; Domain=" + X.domain;
  }
  if (X.path) {
    if (!h$.test(X.path))
      throw new TypeError("option path is invalid");
    Q += "; Path=" + X.path;
  }
  if (X.expires) {
    var U = X.expires;
    if (!X7(U) || isNaN(U.valueOf()))
      throw new TypeError("option expires is invalid");
    Q += "; Expires=" + U.toUTCString();
  }
  if (X.httpOnly)
    Q += "; HttpOnly";
  if (X.secure)
    Q += "; Secure";
  if (X.priority) {
    var F = typeof X.priority === "string" ? X.priority.toLowerCase() : X.priority;
    switch (F) {
      case "low":
        Q += "; Priority=Low";
        break;
      case "medium":
        Q += "; Priority=Medium";
        break;
      case "high":
        Q += "; Priority=High";
        break;
      default:
        throw new TypeError("option priority is invalid");
    }
  }
  if (X.sameSite) {
    var D = typeof X.sameSite === "string" ? X.sameSite.toLowerCase() : X.sameSite;
    switch (D) {
      case true:
        Q += "; SameSite=Strict";
        break;
      case "lax":
        Q += "; SameSite=Lax";
        break;
      case "strict":
        Q += "; SameSite=Strict";
        break;
      case "none":
        Q += "; SameSite=None";
        break;
      default:
        throw new TypeError("option sameSite is invalid");
    }
  }
  return Q;
};
var Y7 = function($) {
  return $.indexOf("%") !== -1 ? decodeURIComponent($) : $;
};
var W7 = function($) {
  return encodeURIComponent($);
};
var X7 = function($) {
  return a9.call($) === "[object Date]" || $ instanceof Date;
};
var Z7 = function($, Y) {
  try {
    return Y($);
  } catch (W) {
    return $;
  }
};
/*!
 * cookie
 * Copyright(c) 2012-2014 Roman Shtylman
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var n$ = e9;
var o$ = $7;
var a9 = Object.prototype.toString;
var h$ = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
var t$ = v0(g0(), 1);
var P$ = v0(u$(), 1);
var w8 = v0(F8(), 1);
var D8 = ($) => $ && typeof $ === "object" && !Array.isArray($);
var j8 = ($) => $.slice(0, $.indexOf("/", 11));
var B7 = ($) => typeof $ === "function" && /^\s*class\s+/.test($.toString()) || $.toString().startsWith("[object ") || r0(Object.getPrototypeOf($));
var F1 = ($, Y, { skipKeys: W } = {}) => {
  if (D8($) && D8(Y))
    for (let [X, Z] of Object.entries(Y)) {
      if (W?.includes(X))
        continue;
      if (!D8(Z)) {
        $[X] = Z;
        continue;
      }
      if (!(X in $)) {
        $[X] = Z;
        continue;
      }
      if (B7(Z)) {
        $[X] = Z;
        continue;
      }
      $[X] = F1($[X], Z);
    }
  return $;
};
var bW = ($, Y) => F1($, Y, { skipKeys: ["properties"] });
var R0 = ($, Y) => {
  const W = [...Array.isArray($) ? $ : [$]], X = [];
  for (let Z of W)
    if (Z.$elysiaChecksum)
      X.push(Z.$elysiaChecksum);
  for (let Z of Array.isArray(Y) ? Y : [Y])
    if (!X.includes(Z?.$elysiaChecksum))
      W.push(Z);
  return W;
};
var S1 = ($, Y) => {
  return { body: Y?.body ?? $?.body, headers: Y?.headers ?? $?.headers, params: Y?.params ?? $?.params, query: Y?.query ?? $?.query, response: Y?.response ?? $?.response, type: $?.type || Y?.type, detail: F1(Y?.detail ?? {}, $?.detail ?? {}), parse: R0($?.parse ?? [], Y?.parse ?? []), transform: R0($?.transform ?? [], Y?.transform ?? []), beforeHandle: R0($?.beforeHandle ?? [], Y?.beforeHandle ?? []), afterHandle: R0($?.afterHandle ?? [], Y?.afterHandle ?? []), onResponse: R0($?.onResponse ?? [], Y?.onResponse ?? []), trace: R0($?.trace ?? [], Y?.trace ?? []), error: R0($?.error ?? [], Y?.error ?? []) };
};
var Q1 = ($, { models: Y = {}, additionalProperties: W = false, dynamic: X = false }) => {
  if (!$)
    return;
  if (typeof $ === "string" && !($ in Y))
    return;
  const Z = typeof $ === "string" ? Y[$] : $;
  if (Z.type === "object" && "additionalProperties" in Z === false)
    Z.additionalProperties = W;
  if (X)
    return { schema: Z, references: "", checkFunc: () => {
    }, code: "", Check: (J) => P$.Value.Check(Z, J), Errors: (J) => P$.Value.Errors(Z, J), Code: () => "" };
  return w8.TypeCompiler.Compile(Z, Object.values(Y));
};
var K8 = ($, { models: Y = {}, additionalProperties: W = false, dynamic: X = false }) => {
  if (!$)
    return;
  if (typeof $ === "string" && !($ in Y))
    return;
  const Z = typeof $ === "string" ? Y[$] : $, J = (z, U) => {
    if (X)
      return { schema: z, references: "", checkFunc: () => {
      }, code: "", Check: (F) => P$.Value.Check(z, F), Errors: (F) => P$.Value.Errors(z, F), Code: () => "" };
    return w8.TypeCompiler.Compile(z, U);
  };
  if (t$.Kind in Z) {
    if ("additionalProperties" in Z === false)
      Z.additionalProperties = W;
    return { 200: J(Z, Object.values(Y)) };
  }
  const Q = {};
  return Object.keys(Z).forEach((z) => {
    const U = Z[+z];
    if (typeof U === "string") {
      if (U in Y) {
        const F = Y[U];
        F.type === "object" && "additionalProperties" in F, Q[+z] = t$.Kind in F ? J(F, Object.values(Y)) : F;
      }
      return;
    }
    if (U.type === "object" && "additionalProperties" in U === false)
      U.additionalProperties = W;
    Q[+z] = t$.Kind in U ? J(U, Object.values(Y)) : U;
  }), Q;
};
var P8 = ($) => {
  let Y = 9;
  for (let W = 0;W < $.length; )
    Y = Math.imul(Y ^ $.charCodeAt(W++), 387420489);
  return Y = Y ^ Y >>> 9;
};
var s$ = ($, Y, W) => {
  const X = (Z) => {
    if (W && !Z.$elysiaChecksum)
      Z.$elysiaChecksum = W;
    return Z;
  };
  return { start: R0($.start, ("start" in Y ? Y.start ?? [] : []).map(X)), request: R0($.request, ("request" in Y ? Y.request ?? [] : []).map(X)), parse: R0($.parse, "parse" in Y ? Y?.parse ?? [] : []).map(X), transform: R0($.transform, (Y?.transform ?? []).map(X)), beforeHandle: R0($.beforeHandle, (Y?.beforeHandle ?? []).map(X)), afterHandle: R0($.afterHandle, (Y?.afterHandle ?? []).map(X)), onResponse: R0($.onResponse, (Y?.onResponse ?? []).map(X)), trace: $.trace, error: R0($.error, (Y?.error ?? []).map(X)), stop: R0($.stop, ("stop" in Y ? Y.stop ?? [] : []).map(X)) };
};
var RW = ($, Y = true) => {
  if (!$)
    return $;
  if (typeof $ === "function") {
    if (Y)
      $.$elysiaHookType = "global";
    else
      $.$elysiaHookType = undefined;
    return $;
  }
  return $.map((W) => {
    if (Y)
      W.$elysiaHookType = "global";
    else
      W.$elysiaHookType = undefined;
    return W;
  });
};
var e1 = ($) => {
  if (!$)
    return $;
  if (typeof $ === "function")
    return $.$elysiaHookType === "global" ? $ : undefined;
  return $.filter((Y) => Y.$elysiaHookType === "global");
};
var O8 = ($) => {
  return { ...$, type: $?.type, detail: $?.detail, parse: e1($?.parse), transform: e1($?.transform), beforeHandle: e1($?.beforeHandle), afterHandle: e1($?.afterHandle), onResponse: e1($?.onResponse), error: e1($?.error) };
};
var S8 = { Continue: 100, "Switching Protocols": 101, Processing: 102, "Early Hints": 103, OK: 200, Created: 201, Accepted: 202, "Non-Authoritative Information": 203, "No Content": 204, "Reset Content": 205, "Partial Content": 206, "Multi-Status": 207, "Already Reported": 208, "Multiple Choices": 300, "Moved Permanently": 301, Found: 302, "See Other": 303, "Not Modified": 304, "Temporary Redirect": 307, "Permanent Redirect": 308, "Bad Request": 400, Unauthorized: 401, "Payment Required": 402, Forbidden: 403, "Not Found": 404, "Method Not Allowed": 405, "Not Acceptable": 406, "Proxy Authentication Required": 407, "Request Timeout": 408, Conflict: 409, Gone: 410, "Length Required": 411, "Precondition Failed": 412, "Payload Too Large": 413, "URI Too Long": 414, "Unsupported Media Type": 415, "Range Not Satisfiable": 416, "Expectation Failed": 417, "I'm a teapot": 418, "Misdirected Request": 421, "Unprocessable Content": 422, Locked: 423, "Failed Dependency": 424, "Too Early": 425, "Upgrade Required": 426, "Precondition Required": 428, "Too Many Requests": 429, "Request Header Fields Too Large": 431, "Unavailable For Legal Reasons": 451, "Internal Server Error": 500, "Not Implemented": 501, "Bad Gateway": 502, "Service Unavailable": 503, "Gateway Timeout": 504, "HTTP Version Not Supported": 505, "Variant Also Negotiates": 506, "Insufficient Storage": 507, "Loop Detected": 508, "Not Extended": 510, "Network Authentication Required": 511 };
var $$ = async ($, Y) => {
  if (typeof $ !== "string")
    throw new TypeError("Cookie value must be provided as a string.");
  if (Y === null)
    throw new TypeError("Secret key must be provided.");
  const W = new TextEncoder, X = await crypto.subtle.importKey("raw", W.encode(Y), { name: "HMAC", hash: "SHA-256" }, false, ["sign"]), Z = await crypto.subtle.sign("HMAC", X, W.encode($)), J = Array.from(new Uint8Array(Z)), Q = btoa(String.fromCharCode(...J));
  return `${$}.${Q.replace(/=+$/, "")}`;
};
var L8 = async ($, Y) => {
  if (typeof $ !== "string")
    throw new TypeError("Signed cookie string must be provided.");
  if (Y === null)
    throw new TypeError("Secret key must be provided.");
  const W = $.slice(0, $.lastIndexOf("."));
  return await $$(W, Y) === $ ? W : false;
};

class a0 {
  $;
  Y;
  name;
  setter;
  constructor($, Y = {}) {
    this._value = $;
    this.property = Y;
  }
  get() {
    return this._value;
  }
  get value() {
    return this._value;
  }
  set value($) {
    if (typeof $ === "object") {
      if (JSON.stringify(this.value) === JSON.stringify($))
        return;
    } else if (this.value === $)
      return;
    this._value = $, this.sync();
  }
  add($) {
    const Y = Object.assign(this.property, typeof $ === "function" ? $(Object.assign(this.property, this.value)) : $);
    if ("value" in Y)
      this._value = Y.value, delete Y.value;
    return this.property = Y, this.sync();
  }
  set($) {
    const Y = typeof $ === "function" ? $(Object.assign(this.property, this.value)) : $;
    if ("value" in Y)
      this._value = Y.value, delete Y.value;
    return this.property = Y, this.sync();
  }
  remove($) {
    if (this.value === undefined)
      return;
    this.set({ domain: $?.domain, expires: new Date(0), maxAge: 0, path: $?.path, sameSite: $?.sameSite, secure: $?.secure, value: "" });
  }
  get domain() {
    return this.property.domain;
  }
  set domain($) {
    if (this.property.domain === $)
      return;
    this.property.domain = $, this.sync();
  }
  get expires() {
    return this.property.expires;
  }
  set expires($) {
    if (this.property.expires?.getTime() === $?.getTime())
      return;
    this.property.expires = $, this.sync();
  }
  get httpOnly() {
    return this.property.httpOnly;
  }
  set httpOnly($) {
    if (this.property.domain === $)
      return;
    this.property.httpOnly = $, this.sync();
  }
  get maxAge() {
    return this.property.maxAge;
  }
  set maxAge($) {
    if (this.property.maxAge === $)
      return;
    this.property.maxAge = $, this.sync();
  }
  get path() {
    return this.property.path;
  }
  set path($) {
    if (this.property.path === $)
      return;
    this.property.path = $, this.sync();
  }
  get priority() {
    return this.property.priority;
  }
  set priority($) {
    if (this.property.priority === $)
      return;
    this.property.priority = $, this.sync();
  }
  get sameSite() {
    return this.property.sameSite;
  }
  set sameSite($) {
    if (this.property.sameSite === $)
      return;
    this.property.sameSite = $, this.sync();
  }
  get secure() {
    return this.property.secure;
  }
  set secure($) {
    if (this.property.secure === $)
      return;
    this.property.secure = $, this.sync();
  }
  toString() {
    return typeof this.value === "object" ? JSON.stringify(this.value) : this.value?.toString() ?? "";
  }
  sync() {
    if (!this.name || !this.setter)
      return this;
    if (!this.setter.cookie)
      this.setter.cookie = { [this.name]: Object.assign(this.property, { value: this.toString() }) };
    else
      this.setter.cookie[this.name] = Object.assign(this.property, { value: this.toString() });
    return this;
  }
}
var GW = ($, Y, W) => new Proxy($, { get(X, Z) {
  if (Z in X)
    return X[Z];
  const J = new a0(undefined, W ? { ...W } : undefined);
  return J.setter = Y, J.name = Z, J;
}, set(X, Z, J) {
  if (!(J instanceof a0))
    return false;
  if (!Y.cookie)
    Y.cookie = {};
  return J.setter = Y, J.name = Z, J.sync(), X[Z] = J, true;
} });
var r$ = async ($, Y, { secret: W, sign: X, ...Z } = {}) => {
  if (!Y)
    return GW({}, $, Z);
  const J = {}, Q = typeof W === "string";
  if (X && X !== true && !Array.isArray(X))
    X = [X];
  const z = Object.keys(n$(Y));
  for (let U = 0;U < z.length; U++) {
    const F = z[U];
    let D = n$(Y)[F];
    if (X === true || X?.includes(F)) {
      if (!W)
        throw new Error("No secret is provided to cookie plugin");
      if (Q) {
        if (D = await L8(D, W), D === false)
          throw new r1(F);
      } else {
        let j = true;
        for (let M = 0;M < W.length; M++) {
          const P = await L8(D, W[M]);
          if (P !== false) {
            D = P, j = false;
            break;
          }
        }
        if (j)
          throw new r1(F);
      }
    }
    if (D === undefined)
      continue;
    const S = D.charCodeAt(0);
    if (S === 123 || S === 91)
      try {
        const j = new a0(JSON.parse(D));
        j.setter = $, j.name = F, J[F] = j;
        continue;
      } catch {
      }
    if (!Number.isNaN(+D))
      D = +D;
    else if (D === "true")
      D = true;
    else if (D === "false")
      D = false;
    const b = new a0(D, Z);
    b.setter = $, b.name = F, J[F] = b;
  }
  return GW(J, $);
};
var _W = "toJSON" in new Headers;
var r0 = ($) => {
  for (let Y in $)
    return true;
  return false;
};
var EW = ($, Y) => {
  if (!$ || !Array.isArray(Y))
    return $;
  $.delete("Set-Cookie");
  for (let W = 0;W < Y.length; W++) {
    const X = Y[W].indexOf("=");
    $.append("Set-Cookie", `${Y[W].slice(0, X)}=${Y[W].slice(X + 1)}`);
  }
  return $;
};
var VW = ($) => {
  if (!$ || typeof $ !== "object" || !r0($))
    return;
  const Y = [];
  for (let [W, X] of Object.entries($)) {
    if (!W || !X)
      continue;
    if (Array.isArray(X.value))
      for (let Z = 0;Z < X.value.length; Z++) {
        let J = X.value[Z];
        if (J === undefined || J === null)
          continue;
        if (typeof J === "object")
          J = JSON.stringify(J);
        Y.push(o$(W, J, X));
      }
    else {
      let Z = X.value;
      if (Z === undefined || Z === null)
        continue;
      if (typeof Z === "object")
        Z = JSON.stringify(Z);
      Y.push(o$(W, X.value, X));
    }
  }
  if (Y.length === 0)
    return;
  if (Y.length === 1)
    return Y[0];
  return Y;
};
var D1 = ($, Y) => {
  if ($?.$passthrough)
    $ = $[$.$passthrough];
  if (r0(Y.headers) || Y.status !== 200 || Y.redirect || Y.cookie) {
    if (typeof Y.status === "string")
      Y.status = S8[Y.status];
    if (Y.redirect) {
      if (Y.headers.Location = Y.redirect, !Y.status || Y.status < 300 || Y.status >= 400)
        Y.status = 302;
    }
    if (Y.cookie && r0(Y.cookie))
      Y.headers["Set-Cookie"] = VW(Y.cookie);
    if (Y.headers["Set-Cookie"] && Array.isArray(Y.headers["Set-Cookie"]))
      Y.headers = EW(new Headers(Y.headers), Y.headers["Set-Cookie"]);
    switch ($?.constructor?.name) {
      case "String":
      case "Blob":
        return new Response($, { status: Y.status, headers: Y.headers });
      case "Object":
      case "Array":
        return Response.json($, Y);
      case "ReadableStream":
        if (!Y.headers["content-type"]?.startsWith("text/event-stream"))
          Y.headers["content-type"] = "text/event-stream; charset=utf-8";
        return new Response($, Y);
      case undefined:
        if (!$)
          return new Response("", Y);
        return Response.json($, Y);
      case "Response":
        const W = { ...Y.headers };
        if (_W)
          Y.headers = $.headers.toJSON();
        else
          for (let [Z, J] of $.headers.entries())
            if (Z in Y.headers)
              Y.headers[Z] = J;
        for (let Z in W)
          $.headers.append(Z, W[Z]);
        return $;
      case "Error":
        return O$($, Y);
      case "Promise":
        return $.then((Z) => D1(Z, Y));
      case "Function":
        return D1($(), Y);
      case "Number":
      case "Boolean":
        return new Response($.toString(), Y);
      case "Cookie":
        if ($ instanceof a0)
          return new Response($.value, Y);
        return new Response($?.toString(), Y);
      default:
        const X = JSON.stringify($);
        if (X.charCodeAt(0) === 123) {
          if (!Y.headers["Content-Type"])
            Y.headers["Content-Type"] = "application/json";
          return new Response(JSON.stringify($), Y);
        }
        return new Response(X, Y);
    }
  } else
    switch ($?.constructor?.name) {
      case "String":
      case "Blob":
        return new Response($);
      case "Object":
      case "Array":
        return new Response(JSON.stringify($), { headers: { "content-type": "application/json" } });
      case "ReadableStream":
        return new Response($, { headers: { "Content-Type": "text/event-stream; charset=utf-8" } });
      case undefined:
        if (!$)
          return new Response("");
        return new Response(JSON.stringify($), { headers: { "content-type": "application/json" } });
      case "Response":
        return $;
      case "Error":
        return O$($, Y);
      case "Promise":
        return $.then((X) => {
          const Z = L1(X);
          if (Z !== undefined)
            return Z;
          return new Response("");
        });
      case "Function":
        return L1($());
      case "Number":
      case "Boolean":
        return new Response($.toString());
      case "Cookie":
        if ($ instanceof a0)
          return new Response($.value, Y);
        return new Response($?.toString(), Y);
      default:
        const W = JSON.stringify($);
        if (W.charCodeAt(0) === 123)
          return new Response(JSON.stringify($), { headers: { "Content-Type": "application/json" } });
        return new Response(W);
    }
};
var e0 = ($, Y) => {
  if ($ === undefined || $ === null)
    return;
  if ($?.$passthrough)
    $ = $[$.$passthrough];
  if (r0(Y.headers) || Y.status !== 200 || Y.redirect || Y.cookie) {
    if (typeof Y.status === "string")
      Y.status = S8[Y.status];
    if (Y.redirect) {
      if (Y.headers.Location = Y.redirect, !Y.status || Y.status < 300 || Y.status >= 400)
        Y.status = 302;
    }
    if (Y.cookie && r0(Y.cookie))
      Y.headers["Set-Cookie"] = VW(Y.cookie);
    if (Y.headers["Set-Cookie"] && Array.isArray(Y.headers["Set-Cookie"]))
      Y.headers = EW(new Headers(Y.headers), Y.headers["Set-Cookie"]);
    switch ($?.constructor?.name) {
      case "String":
      case "Blob":
        return new Response($, Y);
      case "Object":
      case "Array":
        return Response.json($, Y);
      case "ReadableStream":
        if (!Y.headers["content-type"]?.startsWith("text/event-stream"))
          Y.headers["content-type"] = "text/event-stream; charset=utf-8";
        return new Response($, Y);
      case undefined:
        if (!$)
          return;
        return Response.json($, Y);
      case "Response":
        const W = Object.assign({}, Y.headers);
        if (_W)
          Y.headers = $.headers.toJSON();
        else
          for (let [Z, J] of $.headers.entries())
            if (!(Z in Y.headers))
              Y.headers[Z] = J;
        for (let Z in W)
          $.headers.append(Z, W[Z]);
        if ($.status !== Y.status)
          Y.status = $.status;
        return $;
      case "Promise":
        return $.then((Z) => {
          const J = e0(Z, Y);
          if (J !== undefined)
            return J;
          return;
        });
      case "Error":
        return O$($, Y);
      case "Function":
        return e0($(), Y);
      case "Number":
      case "Boolean":
        return new Response($.toString(), Y);
      case "Cookie":
        if ($ instanceof a0)
          return new Response($.value, Y);
        return new Response($?.toString(), Y);
      default:
        const X = JSON.stringify($);
        if (X.charCodeAt(0) === 123) {
          if (!Y.headers["Content-Type"])
            Y.headers["Content-Type"] = "application/json";
          return new Response(JSON.stringify($), Y);
        }
        return new Response(X, Y);
    }
  } else
    switch ($?.constructor?.name) {
      case "String":
      case "Blob":
        return new Response($);
      case "Object":
      case "Array":
        return new Response(JSON.stringify($), { headers: { "content-type": "application/json" } });
      case "ReadableStream":
        return new Response($, { headers: { "Content-Type": "text/event-stream; charset=utf-8" } });
      case undefined:
        if (!$)
          return new Response("");
        return new Response(JSON.stringify($), { headers: { "content-type": "application/json" } });
      case "Response":
        return $;
      case "Promise":
        return $.then((X) => {
          const Z = e0(X, Y);
          if (Z !== undefined)
            return Z;
          return;
        });
      case "Error":
        return O$($, Y);
      case "Function":
        return L1($());
      case "Number":
      case "Boolean":
        return new Response($.toString());
      case "Cookie":
        if ($ instanceof a0)
          return new Response($.value, Y);
        return new Response($?.toString(), Y);
      default:
        const W = JSON.stringify($);
        if (W.charCodeAt(0) === 123)
          return new Response(JSON.stringify($), { headers: { "Content-Type": "application/json" } });
        return new Response(W);
    }
};
var L1 = ($) => {
  if ($?.$passthrough)
    $ = $[$.$passthrough];
  switch ($?.constructor?.name) {
    case "String":
    case "Blob":
      return new Response($);
    case "Object":
    case "Array":
      return new Response(JSON.stringify($), { headers: { "content-type": "application/json" } });
    case "ReadableStream":
      return new Response($, { headers: { "Content-Type": "text/event-stream; charset=utf-8" } });
    case undefined:
      if (!$)
        return new Response("");
      return new Response(JSON.stringify($), { headers: { "content-type": "application/json" } });
    case "Response":
      return $;
    case "Error":
      return O$($);
    case "Promise":
      return $.then((W) => {
        const X = L1(W);
        if (X !== undefined)
          return X;
        return new Response("");
      });
    case "Function":
      return L1($());
    case "Number":
    case "Boolean":
      return new Response($.toString());
    default:
      const Y = JSON.stringify($);
      if (Y.charCodeAt(0) === 123)
        return new Response(JSON.stringify($), { headers: { "Content-Type": "application/json" } });
      return new Response(Y);
  }
};
var O$ = ($, Y) => new Response(JSON.stringify({ name: $?.name, message: $?.message, cause: $?.cause }), { status: Y?.status !== 200 ? Y?.status ?? 500 : 500, headers: Y?.headers });
var tW = v0(b8(), 1);
var S7 = new Headers().toJSON;
var sW = new RegExp(" (\\w+) = context", "g");
var rW = { value: 0 };
var aW = ({ hasTrace: $, hasTraceSet: Y = false, addFn: W, condition: X = {} }) => {
  if (W("\nconst reporter = getReporter()\n"), $)
    return (Z, { name: J, attribute: Q = "", unit: z = 0 } = {}) => {
      const U = Z.indexOf("."), F = U === -1;
      if (Z !== "request" && Z !== "response" && !X[F ? Z : Z.slice(0, U)])
        return () => {
          if (Y && Z === "afterHandle")
            W("reporter.emit('event',{id,event:'exit',type:'begin',time:0})"), W("\nawait traceDone\n");
        };
      if (F)
        J ||= Z;
      else
        J ||= "anonymous";
      W("\n" + `reporter.emit('event', { 
					id,
					event: '${Z}',
					type: 'begin',
					name: '${J}',
					time: performance.now(),
					${F ? `unit: ${z},` : ""}
					${Q}
				})`.replace(/(\t| |\n)/g, "") + "\n");
      let D = false;
      return () => {
        if (D)
          return;
        if (D = true, W("\n" + `reporter.emit('event', {
							id,
							event: '${Z}',
							type: 'end',
							time: performance.now()
						})`.replace(/(\t| |\n)/g, "") + "\n"), Y && Z === "afterHandle")
          W("\nreporter.emit('event',{id,event:'exit',type:'begin',time:0})\n"), W("\nawait traceDone\n");
      };
    };
  else
    return () => () => {
    };
};
var L$ = ($) => {
  const Y = $.indexOf(")");
  if ($.charCodeAt(Y + 2) === 61 && $.charCodeAt(Y + 5) !== 123)
    return true;
  return $.includes("return");
};
var L7 = ($, { injectResponse: Y = "" } = {}) => ({ composeValidation: (W, X = `c.${W}`) => $ ? `c.set.status = 400; throw new ValidationError(
'${W}',
${W},
${X}
)` : `c.set.status = 400; return new ValidationError(
	'${W}',
	${W},
	${X}
).toResponse(c.set.headers)`, composeResponseValidation: (W = "r") => {
  const X = $ ? `throw new ValidationError(
'response',
response[c.set.status],
${W}
)` : `return new ValidationError(
'response',
response[c.set.status],
${W}
).toResponse(c.set.headers)`;
  return `\n${Y}
		if(response[c.set.status]?.Check(${W}) === false) { 
	if(!(response instanceof Error))
		${X}
}\n`;
} });
var O0 = ($, Y) => {
  if (Y = Y.trimStart(), Y = Y.replaceAll(/^async /g, ""), /^(\w+)\(/g.test(Y))
    Y = Y.slice(Y.indexOf("("));
  const W = Y.charCodeAt(0) === 40 || Y.startsWith("function") ? Y.slice(Y.indexOf("(") + 1, Y.indexOf(")")) : Y.slice(0, Y.indexOf("=") - 1);
  if (W === "")
    return false;
  const X = W.charCodeAt(0) === 123 ? W.indexOf("...") : -1;
  if (W.charCodeAt(0) === 123) {
    if (W.includes($))
      return true;
    if (X === -1)
      return false;
  }
  if (Y.match(new RegExp(`${W}(.${$}|\\["${$}"\\])`)))
    return true;
  const Z = X !== -1 ? W.slice(X + 3, W.indexOf(" ", X + 3)) : undefined;
  if (Y.match(new RegExp(`${Z}(.${$}|\\["${$}"\\])`)))
    return true;
  const J = [W];
  if (Z)
    J.push(Z);
  for (let z of Y.matchAll(sW))
    J.push(z[1]);
  const Q = new RegExp(`{.*?} = (${J.join("|")})`, "g");
  for (let [z] of Y.matchAll(Q))
    if (z.includes(`{ ${$}`) || z.includes(`, ${$}`))
      return true;
  return false;
};
var C$ = ($) => {
  if ($ = $.trimStart(), $ = $.replaceAll(/^async /g, ""), /^(\w+)\(/g.test($))
    $ = $.slice($.indexOf("("));
  const Y = $.charCodeAt(0) === 40 || $.startsWith("function") ? $.slice($.indexOf("(") + 1, $.indexOf(")")) : $.slice(0, $.indexOf("=") - 1);
  if (Y === "")
    return false;
  const W = Y.charCodeAt(0) === 123 ? Y.indexOf("...") : -1, X = W !== -1 ? Y.slice(W + 3, Y.indexOf(" ", W + 3)) : undefined, Z = [Y];
  if (X)
    Z.push(X);
  for (let Q of $.matchAll(sW))
    Z.push(Q[1]);
  for (let Q of Z)
    if (new RegExp(`\\b\\w+\\([^)]*\\b${Q}\\b[^)]*\\)`).test($))
      return true;
  const J = new RegExp(`{.*?} = (${Z.join("|")})`, "g");
  for (let [Q] of $.matchAll(J))
    if (new RegExp(`\\b\\w+\\([^)]*\\b${Q}\\b[^)]*\\)`).test($))
      return true;
  return false;
};
var Y$ = Symbol.for("TypeBox.Kind");
var a$ = ($, Y) => {
  if (!Y)
    return;
  if (Y$ in Y && Y[Y$] === $)
    return true;
  if (Y.type === "object") {
    const W = Y.properties;
    for (let X of Object.keys(W)) {
      const Z = W[X];
      if (Z.type === "object") {
        if (a$($, Z))
          return true;
      } else if (Z.anyOf) {
        for (let J = 0;J < Z.anyOf.length; J++)
          if (a$($, Z.anyOf[J]))
            return true;
      }
      if (Y$ in Z && Z[Y$] === $)
        return true;
    }
    return false;
  }
  return Y.properties && Y$ in Y.properties && Y.properties[Y$] === $;
};
var R8 = Symbol.for("TypeBox.Transform");
var V1 = ($) => {
  if (!$)
    return;
  if ($.type === "object" && $.properties) {
    const Y = $.properties;
    for (let W of Object.keys(Y)) {
      const X = Y[W];
      if (X.type === "object") {
        if (V1(X))
          return true;
      } else if (X.anyOf) {
        for (let J = 0;J < X.anyOf.length; J++)
          if (V1(X.anyOf[J]))
            return true;
      }
      if (R8 in X)
        return true;
    }
    return false;
  }
  return R8 in $ || $.properties && R8 in $.properties;
};
var C7 = ($) => {
  if (!$)
    return;
  const Y = $?.schema;
  if (Y && "anyOf" in Y) {
    let W = false;
    const X = Y.anyOf[0].type;
    for (let Z of Y.anyOf)
      if (Z.type !== X) {
        W = true;
        break;
      }
    if (!W)
      return X;
  }
  return $.schema?.type;
};
var I7 = /(?:return|=>) \S*\(/g;
var B0 = ($) => {
  if ($.constructor.name === "AsyncFunction")
    return true;
  return $.toString().match(I7);
};
var eW = ({ path: $, method: Y, hooks: W, validator: X, handler: Z, handleError: J, definitions: Q, schema: z, onRequest: U, config: F, getReporter: D }) => {
  const S = F.forceErrorEncapsulation || W.error.length > 0 || typeof Bun === "undefined" || W.onResponse.length > 0 || !!W.trace.length, b = W.onResponse.length ? `\n;(async () => {${W.onResponse.map((R, f) => `await res${f}(c)`).join(";")}})();\n` : "", j = W.trace.map((R) => R.toString());
  let M = false;
  if (C$(Z.toString()))
    M = true;
  if (!M)
    for (let [R, f] of Object.entries(W)) {
      if (!Array.isArray(f) || !f.length || !["parse", "transform", "beforeHandle", "afterHandle", "onResponse"].includes(R))
        continue;
      for (let i of f) {
        if (typeof i !== "function")
          continue;
        if (C$(i.toString())) {
          M = true;
          break;
        }
      }
      if (M)
        break;
    }
  const P = { parse: j.some((R) => O0("parse", R)), transform: j.some((R) => O0("transform", R)), handle: j.some((R) => O0("handle", R)), beforeHandle: j.some((R) => O0("beforeHandle", R)), afterHandle: j.some((R) => O0("afterHandle", R)), error: S || j.some((R) => O0("error", R)) }, O = W.trace.length > 0;
  let A = "";
  const w = X || Y !== "GET" && Y !== "HEAD" ? [Z, ...W.transform, ...W.beforeHandle, ...W.afterHandle].map((R) => R.toString()) : [], I = Y !== "GET" && Y !== "HEAD" && (M || W.type !== "none" && (!!X.body || !!W.type || w.some((R) => O0("body", R)))), G = M || X.headers || w.some((R) => O0("headers", R)), k = M || X.cookie || w.some((R) => O0("cookie", R)), _ = X?.cookie?.schema;
  let J0 = "";
  if (_?.sign) {
    if (!_.secrets)
      throw new Error(`t.Cookie required secret which is not set in (${Y}) ${$}.`);
    const R = !_.secrets ? undefined : typeof _.secrets === "string" ? _.secrets : _.secrets[0];
    if (J0 += `const _setCookie = c.set.cookie
		if(_setCookie) {`, _.sign === true)
      J0 += `for(const [key, cookie] of Object.entries(_setCookie)) {
				c.set.cookie[key].value = await signCookie(cookie.value, '${R}')
			}`;
    else
      for (let f of _.sign)
        J0 += `if(_setCookie['${f}']?.value) { c.set.cookie['${f}'].value = await signCookie(_setCookie['${f}'].value, '${R}') }\n`;
    J0 += "}\n";
  }
  const { composeValidation: Y0, composeResponseValidation: A0 } = L7(S);
  if (G)
    A += S7 ? "c.headers = c.request.headers.toJSON()\n" : `c.headers = {}
                for (const [key, value] of c.request.headers.entries())
					c.headers[key] = value
				`;
  if (k) {
    const R = (i, h) => {
      const q0 = _?.[i] ?? h;
      if (!q0)
        return typeof h === "string" ? `${i}: "${h}",` : `${i}: ${h},`;
      if (typeof q0 === "string")
        return `${i}: '${q0}',`;
      if (q0 instanceof Date)
        return `${i}: new Date(${q0.getTime()}),`;
      return `${i}: ${q0},`;
    }, f = _ ? `{
			secret: ${_.secrets !== undefined ? typeof _.secrets === "string" ? `'${_.secrets}'` : "[" + _.secrets.reduce((i, h) => i + `'${h}',`, "") + "]" : "undefined"},
			sign: ${_.sign === true ? true : _.sign !== undefined ? "[" + _.sign.reduce((i, h) => i + `'${h}',`, "") + "]" : "undefined"},
			${R("domain")}
			${R("expires")}
			${R("httpOnly")}
			${R("maxAge")}
			${R("path", "/")}
			${R("priority")}
			${R("sameSite")}
			${R("secure")}
		}` : "undefined";
    if (G)
      A += `\nc.cookie = await parseCookie(c.set, c.headers.cookie, ${f})\n`;
    else
      A += `\nc.cookie = await parseCookie(c.set, c.request.headers.get('cookie'), ${f})\n`;
  }
  if (M || X.query || w.some((R) => O0("query", R)))
    A += `const url = c.request.url

		if(c.qi !== -1) {
			c.query ??= parseQuery(url.substring(c.qi + 1))
		} else {
			c.query ??= {}
		}
		`;
  const h0 = W.trace.map((R) => R.toString()).some((R) => O0("set", R) || C$(R));
  M || W.trace.some((R) => O0("set", R.toString()));
  const N0 = h0 || k || w.some((R) => O0("set", R)) || U.some((R) => O0("set", R.toString()));
  if (O)
    A += "\nconst id = c.$$requestId\n";
  const H0 = aW({ hasTrace: O, hasTraceSet: h0, condition: P, addFn: (R) => {
    A += R;
  } });
  if (A += S ? "try {\n" : "", O) {
    A += "\nconst traceDone = Promise.all([";
    for (let R = 0;R < W.trace.length; R++)
      A += `new Promise(r => { reporter.once(\`res\${id}.${R}\`, r) }),`;
    A += "])\n";
  }
  const n0 = k || I || h0 || B0(Z) || W.parse.length > 0 || W.afterHandle.some(B0) || W.beforeHandle.some(B0) || W.transform.some(B0), $1 = H0("parse", { unit: W.parse.length });
  if (I) {
    const R = C7(X?.body);
    if (W.type && !Array.isArray(W.type)) {
      if (W.type)
        switch (W.type) {
          case "json":
          case "application/json":
            A += "c.body = await c.request.json()\n";
            break;
          case "text":
          case "text/plain":
            A += "c.body = await c.request.text()\n";
            break;
          case "urlencoded":
          case "application/x-www-form-urlencoded":
            A += "c.body = parseQuery(await c.request.text())\n";
            break;
          case "arrayBuffer":
          case "application/octet-stream":
            A += "c.body = await c.request.arrayBuffer()\n";
            break;
          case "formdata":
          case "multipart/form-data":
            A += `c.body = {}

						const form = await c.request.formData()
						for (const key of form.keys()) {
							if (c.body[key])
								continue

							const value = form.getAll(key)
							if (value.length === 1)
								c.body[key] = value[0]
							else c.body[key] = value
						}\n`;
            break;
        }
      if (W.parse.length)
        A += "}}";
    } else {
      const i = (() => {
        if (W.parse.length && R && !Array.isArray(W.type)) {
          const h = X?.body?.schema;
          switch (R) {
            case "object":
              if (a$("File", h) || a$("Files", h))
                return `c.body = {}
		
								const form = await c.request.formData()
								for (const key of form.keys()) {
									if (c.body[key])
										continue
			
									const value = form.getAll(key)
									if (value.length === 1)
										c.body[key] = value[0]
									else c.body[key] = value
								}`;
              break;
            default:
              break;
          }
        }
      })();
      if (i)
        A += i;
      else {
        if (A += "\n", A += G ? "let contentType = c.headers['content-type']" : "let contentType = c.request.headers.get('content-type')", A += `
				if (contentType) {
					const index = contentType.indexOf(';')
					if (index !== -1) contentType = contentType.substring(0, index)\n`, W.parse.length) {
          A += "let used = false\n";
          const h = H0("parse", { unit: W.parse.length });
          for (let q0 = 0;q0 < W.parse.length; q0++) {
            const j0 = H0("parse.unit", { name: W.parse[q0].name }), K0 = `bo${q0}`;
            if (q0 !== 0)
              A += "if(!used) {\n";
            if (A += `let ${K0} = parse[${q0}](c, contentType)\n`, A += `if(${K0} instanceof Promise) ${K0} = await ${K0}\n`, A += `if(${K0} !== undefined) { c.body = ${K0}; used = true }\n`, j0(), q0 !== 0)
              A += "}";
          }
          h();
        }
        if (W.parse.length)
          A += "if (!used)";
        A += `
				switch (contentType) {
					case 'application/json':
						c.body = await c.request.json()
						break
				
					case 'text/plain':
						c.body = await c.request.text()
						break
				
					case 'application/x-www-form-urlencoded':
						c.body = parseQuery(await c.request.text())
						break
				
					case 'application/octet-stream':
						c.body = await c.request.arrayBuffer();
						break
				
					case 'multipart/form-data':
						c.body = {}
				
						const form = await c.request.formData()
						for (const key of form.keys()) {
							if (c.body[key])
								continue
				
							const value = form.getAll(key)
							if (value.length === 1)
								c.body[key] = value[0]
							else c.body[key] = value
						}
				
						break
					}\n`, A += "}\n";
      }
    }
    A += "\n";
  }
  if ($1(), W?.transform) {
    const R = H0("transform", { unit: W.transform.length });
    for (let f = 0;f < W.transform.length; f++) {
      const i = W.transform[f], h = H0("transform.unit", { name: i.name });
      if (i.$elysia === "derive")
        A += B0(W.transform[f]) ? `Object.assign(c, await transform[${f}](c));` : `Object.assign(c, transform[${f}](c));`;
      else
        A += B0(W.transform[f]) ? `await transform[${f}](c);` : `transform[${f}](c);`;
      h();
    }
    R();
  }
  if (X) {
    if (A += "\n", X.headers) {
      if (A += `if(headers.Check(c.headers) === false) {
				${Y0("headers")}
			}`, V1(X.headers.schema))
        A += "\nc.headers = headers.Decode(c.headers)\n";
    }
    if (X.params) {
      if (A += `if(params.Check(c.params) === false) {
				${Y0("params")}
			}`, V1(X.params.schema))
        A += "\nc.params = params.Decode(c.params)\n";
    }
    if (X.query) {
      if (A += `if(query.Check(c.query) === false) {
				${Y0("query")} 
			}`, V1(X.query.schema))
        A += "\nc.query = query.Decode(Object.assign({}, c.query))\n";
    }
    if (X.body) {
      if (A += `if(body.Check(c.body) === false) { 
				${Y0("body")}
			}`, V1(X.body.schema))
        A += "\nc.body = body.Decode(c.body)\n";
    }
    if (r0(X.cookie?.schema.properties ?? {})) {
      if (A += `const cookieValue = {}
			for(const [key, value] of Object.entries(c.cookie))
				cookieValue[key] = value.value

			if(cookie.Check(cookieValue) === false) {
				${Y0("cookie", "cookieValue")}
			}`, V1(X.cookie.schema))
        A += "\nc.cookie = params.Decode(c.cookie)\n";
    }
  }
  if (W?.beforeHandle) {
    const R = H0("beforeHandle", { unit: W.beforeHandle.length });
    for (let f = 0;f < W.beforeHandle.length; f++) {
      const i = H0("beforeHandle.unit", { name: W.beforeHandle[f].name }), h = `be${f}`;
      if (!L$(W.beforeHandle[f].toString()))
        A += B0(W.beforeHandle[f]) ? `await beforeHandle[${f}](c);\n` : `beforeHandle[${f}](c);\n`, i();
      else {
        A += B0(W.beforeHandle[f]) ? `let ${h} = await beforeHandle[${f}](c);\n` : `let ${h} = beforeHandle[${f}](c);\n`, i(), A += `if(${h} !== undefined) {\n`;
        const j0 = H0("afterHandle", { unit: W.transform.length });
        if (W.afterHandle) {
          const K0 = h;
          for (let P0 = 0;P0 < W.afterHandle.length; P0++) {
            const M0 = L$(W.afterHandle[P0].toString()), w1 = H0("afterHandle.unit", { name: W.afterHandle[P0].name });
            if (A += `c.response = ${K0}\n`, !M0)
              A += B0(W.afterHandle[P0]) ? `await afterHandle[${P0}](c, ${K0});\n` : `afterHandle[${P0}](c, ${K0});\n`;
            else {
              const K = `af${P0}`;
              A += B0(W.afterHandle[P0]) ? `const ${K} = await afterHandle[${P0}](c);\n` : `const ${K} = afterHandle[${P0}](c);\n`, A += `if(${K} !== undefined) { c.response = ${K0} = ${K} }\n`;
            }
            w1();
          }
        }
        if (j0(), X.response)
          A += A0(h);
        A += J0, A += `return mapEarlyResponse(${h}, c.set)}\n`;
      }
    }
    R();
  }
  if (W?.afterHandle.length) {
    const R = H0("handle", { name: Z.name });
    if (W.afterHandle.length)
      A += B0(Z) ? "let r = c.response = await handler(c);\n" : "let r = c.response = handler(c);\n";
    else
      A += B0(Z) ? "let r = await handler(c);\n" : "let r = handler(c);\n";
    R();
    const f = H0("afterHandle", { unit: W.afterHandle.length });
    for (let i = 0;i < W.afterHandle.length; i++) {
      const h = `af${i}`, q0 = L$(W.afterHandle[i].toString()), j0 = H0("afterHandle.unit", { name: W.afterHandle[i].name });
      if (!q0)
        A += B0(W.afterHandle[i]) ? `await afterHandle[${i}](c)\n` : `afterHandle[${i}](c)\n`, j0();
      else {
        if (X.response)
          A += B0(W.afterHandle[i]) ? `let ${h} = await afterHandle[${i}](c)\n` : `let ${h} = afterHandle[${i}](c)\n`;
        else
          A += B0(W.afterHandle[i]) ? `let ${h} = mapEarlyResponse(await afterHandle[${i}](c), c.set)\n` : `let ${h} = mapEarlyResponse(afterHandle[${i}](c), c.set)\n`;
        if (j0(), X.response) {
          if (A += `if(${h} !== undefined) {`, A += A0(h), A += `${h} = mapEarlyResponse(${h}, c.set)\n`, A += `if(${h}) {`, f(), h0)
            A += `${h} = mapEarlyResponse(${h}, c.set)\n`;
          A += `return ${h} } }`;
        } else
          A += `if(${h}) {`, f(), A += `return ${h}}\n`;
      }
    }
    if (f(), A += "r = c.response\n", X.response)
      A += A0();
    if (A += J0, N0)
      A += "return mapResponse(r, c.set)\n";
    else
      A += "return mapCompactResponse(r)\n";
  } else {
    const R = H0("handle", { name: Z.name });
    if (X.response)
      if (A += B0(Z) ? "const r = await handler(c);\n" : "const r = handler(c);\n", R(), A += A0(), H0("afterHandle")(), A += J0, N0)
        A += "return mapResponse(r, c.set)\n";
      else
        A += "return mapCompactResponse(r)\n";
    else if (P.handle || k)
      if (A += B0(Z) ? "let r = await handler(c);\n" : "let r = handler(c);\n", R(), H0("afterHandle")(), A += J0, N0)
        A += "return mapResponse(r, c.set)\n";
      else
        A += "return mapCompactResponse(r)\n";
    else {
      R();
      const f = B0(Z) ? "await handler(c) " : "handler(c)";
      if (H0("afterHandle")(), N0)
        A += `return mapResponse(${f}, c.set)\n`;
      else
        A += `return mapCompactResponse(${f})\n`;
    }
  }
  if (S || b) {
    if (A += `
} catch(error) {`, !n0)
      A += "return (async () => {";
    A += `const set = c.set

		if (!set.status || set.status < 300) set.status = error?.status || 500
	`;
    const R = H0("error", { unit: W.error.length });
    if (W.error.length) {
      A += `
				c.error = error
				c.code = error.code ?? error[ERROR_CODE] ?? "UNKNOWN"
			`;
      for (let f = 0;f < W.error.length; f++) {
        const i = `er${f}`, h = H0("error.unit", { name: W.error[f].name });
        if (A += `\nlet ${i} = handleErrors[${f}](c)\n`, B0(W.error[f]))
          A += `if (${i} instanceof Promise) ${i} = await ${i}\n`;
        h(), A += `${i} = mapEarlyResponse(${i}, set)\n`, A += `if (${i}) {`, A += `return ${i} }\n`;
      }
    }
    if (R(), A += "return handleError(c, error)\n\n", !n0)
      A += "})()";
    if (A += "}", b || O) {
      A += " finally { ";
      const f = H0("response", { unit: W.onResponse.length });
      A += b, f(), A += "}";
    }
  }
  return A = `const { 
		handler,
		handleError,
		hooks: {
			transform,
			beforeHandle,
			afterHandle,
			parse,
			error: handleErrors,
			onResponse
		},
		validator: {
			body,
			headers,
			params,
			query,
			response,
			cookie
		},
		utils: {
			mapResponse,
			mapCompactResponse,
			mapEarlyResponse,
			parseQuery
		},
		error: {
			NotFoundError,
			ValidationError,
			InternalServerError
		},
		schema,
		definitions,
		ERROR_CODE,
		getReporter,
		requestId,
		parseCookie,
		signCookie
	} = hooks

	${W.onResponse.length ? `const ${W.onResponse.map((R, f) => `res${f} = onResponse[${f}]`).join(",")}` : ""}

	return ${n0 ? "async" : ""} function(c) {
		${z && Q ? "c.schema = schema; c.defs = definitions;" : ""}
		${A}
	}`, Function("hooks", A)({ handler: Z, hooks: W, validator: X, handleError: J, utils: { mapResponse: D1, mapCompactResponse: L1, mapEarlyResponse: e0, parseQuery: tW.parse }, error: { NotFoundError: O1, ValidationError: U0, InternalServerError: w$ }, schema: z, definitions: Q, ERROR_CODE: _1, getReporter: D, requestId: rW, parseCookie: r$, signCookie: $$ });
};
var G8 = ($) => {
  let Y = "", W = "";
  for (let j of Object.keys($.decorators))
    Y += `,${j}: app.decorators.${j}`;
  const { router: X, staticRouter: Z } = $, J = $.event.trace.length > 0, Q = `
	const route = find(request.method, path) ${X.root.ALL ? '?? find("ALL", path)' : ""}
	if (route === null)
		return ${$.event.error.length ? "app.handleError(ctx, notFound)" : `new Response(error404, {
					status: ctx.set.status === 200 ? 404 : ctx.set.status,
					headers: ctx.set.headers
				})`}

	ctx.params = route.params

	return route.store(ctx)`;
  let z = "";
  for (let [j, { code: M, all: P }] of Object.entries(Z.map))
    z += `case '${j}':\nswitch(request.method) {\n${M}\n${P ?? "default: break map"}}\n\n`;
  const U = $.event.request.some(B0);
  W += `const {
		app,
		app: { store, router, staticRouter, wsRouter },
		mapEarlyResponse,
		NotFoundError,
		requestId,
		getReporter
	} = data

	const notFound = new NotFoundError()

	${$.event.request.length ? "const onRequest = app.event.request" : ""}

	${Z.variables}

	const find = router.find.bind(router)
	const findWs = wsRouter.find.bind(wsRouter)
	const handleError = app.handleError.bind(this)

	${$.event.error.length ? "" : "const error404 = notFound.message.toString()"}

	return ${U ? "async" : ""} function map(request) {
	`;
  const F = $.event.trace.map((j) => j.toString()), D = aW({ hasTrace: J, hasTraceSet: $.event.trace.some((j) => {
    const M = j.toString();
    return O0("set", M) || C$(M);
  }), condition: { request: F.some((j) => O0("request", j) || C$(j)) }, addFn: (j) => {
    W += j;
  } });
  if ($.event.request.length) {
    W += `
			${J ? "const id = +requestId.value++" : ""}

			const ctx = {
				request,
				store,
				set: {
					cookie: {},
					headers: {},
					status: 200
				}
				${J ? ",$$requestId: +id" : ""}
				${Y}
			}
		`;
    const j = D("request", { attribute: "ctx", unit: $.event.request.length });
    W += "try {\n";
    for (let M = 0;M < $.event.request.length; M++) {
      const P = $.event.request[M], O = L$(P.toString()), A = B0(P), w = D("request.unit", { name: $.event.request[M].name }), I = `re${M}`;
      if (O)
        W += `const ${I} = mapEarlyResponse(
					${A ? "await" : ""} onRequest[${M}](ctx),
					ctx.set
				)\n`, w(), W += `if(${I}) return ${I}\n`;
      else
        W += `${A ? "await" : ""} onRequest[${M}](ctx)\n`, w();
    }
    W += `} catch (error) {
			return app.handleError(ctx, error)
		}`, j(), W += `
		const url = request.url,
		s = url.indexOf('/', 11),
		i = ctx.qi = url.indexOf('?', s + 1),
		path = ctx.path = i === -1 ? url.substring(s) : url.substring(s, i);`;
  } else
    W += `
		const url = request.url,
			s = url.indexOf('/', 11),
			qi = url.indexOf('?', s + 1),
			path = qi === -1
				? url.substring(s)
				: url.substring(s, qi)

		${J ? "const id = +requestId.value++" : ""}

		const ctx = {
			request,
			store,
			qi,
			path,
			set: {
				headers: {},
				status: 200
			}
			${J ? ",$$requestId: id" : ""}
			${Y}
		}`, D("request", { unit: $.event.request.length, attribute: F.some((j) => O0("context", j)) || F.some((j) => O0("store", j)) || F.some((j) => O0("set", j)) ? "ctx" : "" })();
  const { wsPaths: S, wsRouter: b } = $;
  if (Object.keys(S).length || b.history.length) {
    W += `
			if(request.method === 'GET') {
				switch(path) {`;
    for (let [j, M] of Object.entries(S))
      W += `
					case '${j}':
						if(request.headers.get('upgrade') === 'websocket')
							return st${M}(ctx)
							
						break`;
    W += `
				default:
					if(request.headers.get('upgrade') === 'websocket') {
						const route = findWs('ws', path)

						if(route) {
							ctx.params = route.params

							return route.store(ctx)
						}
					}

					break
			}
		}\n`;
  }
  return W += `
		map: switch(path) {
			${z}

			default:
				break
		}

		${Q}
	}`, $.handleError = _8($), Function("data", W)({ app: $, mapEarlyResponse: e0, NotFoundError: O1, getReporter: () => $.reporter, requestId: rW });
};
var _8 = ($) => {
  let Y = `const {
		app: { event: { error: onError, onResponse: res } },
		mapResponse,
		ERROR_CODE
	} = inject

	return ${$.event.error.find(B0) ? "async" : ""} function(context, error) {
		const { set } = context

		context.code = error.code
		context.error = error
		`;
  for (let W = 0;W < $.event.error.length; W++) {
    const X = $.event.error[W], Z = `${B0(X) ? "await " : ""}onError[${W}](context)`;
    if (L$(X.toString()))
      Y += `const r${W} = ${Z}; if(r${W} !== undefined) {
				if(set.status === 200) set.status = error.status
				return mapResponse(r${W}, set)
			}\n`;
    else
      Y += Z + "\n";
  }
  return Y += `if(error.constructor.name === "ValidationError" || error.constructor.name === "TransformDecodeError") {
		set.status = error.status ?? 400
		return new Response(
			error.message, 
			{ headers: set.headers, status: set.status }
		)
	} else {
		return new Response(error.message, { headers: set.headers, status: error.status ?? 500 })
	}
}`, Function("inject", Y)({ app: $, mapResponse: D1, ERROR_CODE: _1 });
};
var e$ = v0(b8(), 1);
var E8 = ($) => async (Y) => {
  const W = { cookie: {}, status: 200, headers: {} };
  let X;
  if ($.decorators)
    X = $.decorators, X.request = Y, X.set = W, X.store = $.store;
  else
    X = { set: W, store: $.store, request: Y };
  const Z = Y.url, J = Z.indexOf("/", 11), Q = Z.indexOf("?", J + 1), z = Q === -1 ? Z.substring(J) : Z.substring(J, Q);
  try {
    for (let O = 0;O < $.event.request.length; O++) {
      const A = $.event.request[O];
      let w = A(X);
      if (w instanceof Promise)
        w = await w;
      if (w = e0(w, W), w)
        return w;
    }
    const U = $.dynamicRouter.find(Y.method, z) ?? $.dynamicRouter.find("ALL", z);
    if (!U)
      throw new O1;
    const { handle: F, hooks: D, validator: S, content: b } = U.store;
    let j;
    if (Y.method !== "GET" && Y.method !== "HEAD")
      if (b)
        switch (b) {
          case "application/json":
            j = await Y.json();
            break;
          case "text/plain":
            j = await Y.text();
            break;
          case "application/x-www-form-urlencoded":
            j = e$.parse(await Y.text());
            break;
          case "application/octet-stream":
            j = await Y.arrayBuffer();
            break;
          case "multipart/form-data":
            j = {};
            const O = await Y.formData();
            for (let A of O.keys()) {
              if (j[A])
                continue;
              const w = O.getAll(A);
              if (w.length === 1)
                j[A] = w[0];
              else
                j[A] = w;
            }
            break;
        }
      else {
        let O = Y.headers.get("content-type");
        if (O) {
          const A = O.indexOf(";");
          if (A !== -1)
            O = O.slice(0, A);
          for (let w = 0;w < $.event.parse.length; w++) {
            let I = $.event.parse[w](X, O);
            if (I instanceof Promise)
              I = await I;
            if (I) {
              j = I;
              break;
            }
          }
          if (j === undefined)
            switch (O) {
              case "application/json":
                j = await Y.json();
                break;
              case "text/plain":
                j = await Y.text();
                break;
              case "application/x-www-form-urlencoded":
                j = e$.parse(await Y.text());
                break;
              case "application/octet-stream":
                j = await Y.arrayBuffer();
                break;
              case "multipart/form-data":
                j = {};
                const w = await Y.formData();
                for (let I of w.keys()) {
                  if (j[I])
                    continue;
                  const G = w.getAll(I);
                  if (G.length === 1)
                    j[I] = G[0];
                  else
                    j[I] = G;
                }
                break;
            }
        }
      }
    X.body = j, X.params = U?.params || undefined, X.query = Q === -1 ? {} : e$.parse(Z.substring(Q + 1)), X.headers = {};
    for (let [O, A] of Y.headers.entries())
      X.headers[O] = A;
    const M = S?.cookie?.schema;
    X.cookie = await r$(X.set, X.headers.cookie, M ? { secret: M.secrets !== undefined ? typeof M.secrets === "string" ? M.secrets : M.secrets.join(",") : undefined, sign: M.sign === true ? true : M.sign !== undefined ? typeof M.sign === "string" ? M.sign : M.sign.join(",") : undefined } : undefined);
    for (let O = 0;O < D.transform.length; O++) {
      const A = D.transform[O](X);
      if (D.transform[O].$elysia === "derive")
        if (A instanceof Promise)
          Object.assign(X, await A);
        else
          Object.assign(X, A);
      else if (A instanceof Promise)
        await A;
    }
    if (S) {
      if (S.headers) {
        const O = {};
        for (let A in Y.headers)
          O[A] = Y.headers.get(A);
        if (S.headers.Check(O) === false)
          throw new U0("header", S.headers, O);
      }
      if (S.params?.Check(X.params) === false)
        throw new U0("params", S.params, X.params);
      if (S.query?.Check(X.query) === false)
        throw new U0("query", S.query, X.query);
      if (S.cookie) {
        const O = {};
        for (let [A, w] of Object.entries(X.cookie))
          O[A] = w.value;
        if (S.cookie?.Check(O) === false)
          throw new U0("cookie", S.cookie, O);
      }
      if (S.body?.Check(j) === false)
        throw new U0("body", S.body, j);
    }
    for (let O = 0;O < D.beforeHandle.length; O++) {
      let A = D.beforeHandle[O](X);
      if (A instanceof Promise)
        A = await A;
      if (A !== undefined) {
        X.response = A;
        for (let I = 0;I < D.afterHandle.length; I++) {
          let G = D.afterHandle[I](X);
          if (G instanceof Promise)
            G = await G;
          if (G)
            A = G;
        }
        const w = e0(A, X.set);
        if (w)
          return w;
      }
    }
    let P = F(X);
    if (P instanceof Promise)
      P = await P;
    if (!D.afterHandle.length) {
      const O = S?.response?.[P.status];
      if (O?.Check(P) === false)
        throw new U0("response", O, P);
    } else {
      X.response = P;
      for (let O = 0;O < D.afterHandle.length; O++) {
        let A = D.afterHandle[O](X);
        if (A instanceof Promise)
          A = await A;
        const w = e0(A, X.set);
        if (w !== undefined) {
          const I = S?.response?.[P.status];
          if (I?.Check(w) === false)
            throw new U0("response", I, w);
          return w;
        }
      }
    }
    if (X.set.cookie && M?.sign) {
      const O = !M.secrets ? undefined : typeof M.secrets === "string" ? M.secrets : M.secrets[0];
      if (M.sign === true)
        for (let [A, w] of Object.entries(X.set.cookie))
          X.set.cookie[A].value = await $$(w.value, "${secret}");
      else
        for (let A of M.sign) {
          if (!(A in M.properties))
            continue;
          if (X.set.cookie[A]?.value)
            X.set.cookie[A].value = await $$(X.set.cookie[A].value, O);
        }
    }
    return D1(P, X.set);
  } catch (U) {
    if (U.status)
      W.status = U.status;
    return $.handleError(X, U);
  } finally {
    for (let U of $.event.onResponse)
      await U(X);
  }
};
var $X = ($) => async (Y, W) => {
  const X = Object.assign(Y, { error: W, code: W.code });
  X.set = Y.set;
  for (let Z = 0;Z < $.event.error.length; Z++) {
    let J = $.event.error[Z](X);
    if (J instanceof Promise)
      J = await J;
    if (J !== undefined && J !== null)
      return D1(J, Y.set);
  }
  return new Response(typeof W.cause === "string" ? W.cause : W.message, { headers: Y.set.headers, status: W.status ?? 500 });
};
var o = {};
k8(o, { t: () => {
  {
    return $0.Type;
  }
}, ElysiaType: () => {
  {
    return C1;
  }
} });
var x1 = v0(M$(), 1);
var $0 = v0(g0(), 1);
var WX = v0(u$(), 1);
c(o, v0(M$(), 1));
c(o, v0(F8(), 1));
try {
  x1.TypeSystem.Format("email", ($) => /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i.test($)), x1.TypeSystem.Format("uuid", ($) => /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test($)), x1.TypeSystem.Format("date", ($) => !Number.isNaN(new Date($).getTime())), x1.TypeSystem.Format("date-time", ($) => !Number.isNaN(new Date($).getTime()));
} catch ($) {
}
var YX = ($) => {
  if (typeof $ === "string")
    switch ($.slice(-1)) {
      case "k":
        return +$.slice(0, $.length - 1) * 1024;
      case "m":
        return +$.slice(0, $.length - 1) * 1048576;
      default:
        return +$;
    }
  return $;
};
var V8 = ($, Y) => {
  if (!(Y instanceof Blob))
    return false;
  if ($.minSize && Y.size < YX($.minSize))
    return false;
  if ($.maxSize && Y.size > YX($.maxSize))
    return false;
  if ($.extension)
    if (typeof $.extension === "string") {
      if (!Y.type.startsWith($.extension))
        return false;
    } else {
      for (let W = 0;W < $.extension.length; W++)
        if (Y.type.startsWith($.extension[W]))
          return true;
      return false;
    }
  return true;
};
var b7 = x1.TypeSystem.Type("Files", ($, Y) => {
  if (!Array.isArray(Y))
    return V8($, Y);
  if ($.minItems && Y.length < $.minItems)
    return false;
  if ($.maxItems && Y.length > $.maxItems)
    return false;
  for (let W = 0;W < Y.length; W++)
    if (!V8($, Y[W]))
      return false;
  return true;
});
$0.FormatRegistry.Set("numeric", ($) => !!$ && !isNaN(+$));
$0.FormatRegistry.Set("ObjectString", ($) => {
  let Y = $.charCodeAt(0);
  if (Y === 9 || Y === 10 || Y === 32)
    Y = $.trimStart().charCodeAt(0);
  if (Y !== 123 && Y !== 91)
    return false;
  try {
    return JSON.parse($), true;
  } catch {
    return false;
  }
});
var C1 = { Numeric: ($) => {
  const Y = $0.Type.Number($);
  return $0.Type.Transform($0.Type.Union([$0.Type.String({ format: "numeric", default: 0 }), Y])).Decode((W) => {
    const X = +W;
    if (isNaN(X))
      return W;
    if ($ && !WX.Value.Check(Y, X))
      throw new U0("property", Y, X);
    return X;
  }).Encode((W) => W);
}, ObjectString: ($, Y) => $0.Type.Transform($0.Type.Union([$0.Type.String({ format: "ObjectString", default: "" }), $0.Type.Object($, Y)])).Decode((W) => {
  if (typeof W === "string")
    try {
      return JSON.parse(W);
    } catch {
      return W;
    }
  return W;
}).Encode((W) => JSON.stringify(W)), File: x1.TypeSystem.Type("File", V8), Files: ($ = {}) => $0.Type.Transform(b7($)).Decode((Y) => {
  if (Array.isArray(Y))
    return Y;
  return [Y];
}).Encode((Y) => Y), Nullable: ($) => $0.Type.Union([$0.Type.Null(), $]), MaybeEmpty: ($) => $0.Type.Union([$0.Type.Null(), $0.Type.Undefined(), $]), Cookie: ($, Y) => $0.Type.Object($, Y) };
$0.Type.ObjectString = C1.ObjectString;
$0.Type.Numeric = C1.Numeric;
$0.Type.File = ($ = {}) => C1.File({ default: "File", ...$, extension: $?.type, type: "string", format: "binary" });
$0.Type.Files = ($ = {}) => C1.Files({ ...$, elysiaMeta: "Files", default: "Files", extension: $?.type, type: "array", items: { ...$, default: "Files", type: "string", format: "binary" } });
$0.Type.Nullable = ($) => C1.Nullable($);
$0.Type.MaybeEmpty = C1.MaybeEmpty;
$0.Type.Cookie = C1.Cookie;

class I$ {
  config;
  dependencies = {};
  store = {};
  decorators = {};
  definitions = { type: {}, error: {} };
  schema = {};
  event = { start: [], request: [], parse: [], transform: [], beforeHandle: [], afterHandle: [], onResponse: [], trace: [], error: [], stop: [] };
  reporter = new v8;
  server = null;
  getServer() {
    return this.server;
  }
  validator = null;
  router = new I1;
  wsRouter = new I1;
  routes = [];
  staticRouter = { handlers: [], variables: "", map: {}, all: "" };
  wsPaths = {};
  dynamicRouter = new I1;
  lazyLoadModules = [];
  path = "";
  constructor($) {
    this.config = { forceErrorEncapsulation: true, prefix: "", aot: true, strictPath: false, scoped: false, cookie: {}, ...$, seed: $?.seed === undefined ? "" : $?.seed };
  }
  add($, Y, W, X, { allowMeta: Z = false, skipPrefix: J = false } = { allowMeta: false, skipPrefix: false }) {
    if (typeof Y === "string")
      Y = [Y];
    for (let Q of Y) {
      if (Q = Q === "" ? Q : Q.charCodeAt(0) === 47 ? Q : `/${Q}`, this.config.prefix && !J)
        Q = this.config.prefix + Q;
      if (X?.type)
        switch (X.type) {
          case "text":
            X.type = "text/plain";
            break;
          case "json":
            X.type = "application/json";
            break;
          case "formdata":
            X.type = "multipart/form-data";
            break;
          case "urlencoded":
            X.type = "application/x-www-form-urlencoded";
            break;
          case "arrayBuffer":
            X.type = "application/octet-stream";
            break;
          default:
            break;
        }
      const z = this.definitions.type;
      let U = Q1(X?.cookie ?? this.validator?.cookie, { dynamic: !this.config.aot, models: z, additionalProperties: true });
      if (r0(this.config.cookie ?? {}))
        if (U)
          U.schema = bW(U.schema, this.config.cookie ?? {});
        else
          U = Q1($0.Type.Cookie({}, this.config.cookie), { dynamic: !this.config.aot, models: z, additionalProperties: true });
      const F = { body: Q1(X?.body ?? this.validator?.body, { dynamic: !this.config.aot, models: z }), headers: Q1(X?.headers ?? this.validator?.headers, { dynamic: !this.config.aot, models: z, additionalProperties: true }), params: Q1(X?.params ?? this.validator?.params, { dynamic: !this.config.aot, models: z }), query: Q1(X?.query ?? this.validator?.query, { dynamic: !this.config.aot, models: z }), cookie: U, response: K8(X?.response ?? this.validator?.response, { dynamic: !this.config.aot, models: z }) }, D = S1(this.event, X), S = Q.endsWith("/") ? Q.slice(0, Q.length - 1) : Q + "/";
      if (this.config.aot === false) {
        if (this.dynamicRouter.add($, Q, { validator: F, hooks: D, content: X?.type, handle: W }), this.config.strictPath === false)
          this.dynamicRouter.add($, S, { validator: F, hooks: D, content: X?.type, handle: W });
        this.routes.push({ method: $, path: Q, composed: null, handler: W, hooks: D });
        return;
      }
      const b = eW({ path: Q, method: $, hooks: D, validator: F, handler: W, handleError: this.handleError, onRequest: this.event.request, config: this.config, definitions: Z ? this.definitions.type : undefined, schema: Z ? this.schema : undefined, getReporter: () => this.reporter }), j = this.routes.findIndex((M) => M.path === Q && M.method === $);
      if (j !== -1)
        this.routes.splice(j, 1);
      if (this.routes.push({ method: $, path: Q, composed: b, handler: W, hooks: D }), $ === "$INTERNALWS") {
        const M = this.config.strictPath ? undefined : Q.endsWith("/") ? Q.slice(0, Q.length - 1) : Q + "/";
        if (Q.indexOf(":") === -1 && Q.indexOf("*") === -1) {
          const P = this.staticRouter.handlers.length;
          if (this.staticRouter.handlers.push(b), this.staticRouter.variables += `const st${P} = staticRouter.handlers[${P}]\n`, this.wsPaths[Q] = P, M)
            this.wsPaths[M] = P;
        } else if (this.wsRouter.add("ws", Q, b), M)
          this.wsRouter.add("ws", M, b);
        return;
      }
      if (Q.indexOf(":") === -1 && Q.indexOf("*") === -1) {
        const M = this.staticRouter.handlers.length;
        if (this.staticRouter.handlers.push(b), this.staticRouter.variables += `const st${M} = staticRouter.handlers[${M}]\n`, !this.staticRouter.map[Q])
          this.staticRouter.map[Q] = { code: "" };
        if ($ === "ALL")
          this.staticRouter.map[Q].all = `default: return st${M}(ctx)\n`;
        else
          this.staticRouter.map[Q].code = `case '${$}': return st${M}(ctx)\n${this.staticRouter.map[Q].code}`;
        if (!this.config.strictPath) {
          if (!this.staticRouter.map[S])
            this.staticRouter.map[S] = { code: "" };
          if ($ === "ALL")
            this.staticRouter.map[S].all = `default: return st${M}(ctx)\n`;
          else
            this.staticRouter.map[S].code = `case '${$}': return st${M}(ctx)\n${this.staticRouter.map[S].code}`;
        }
      } else if (this.router.add($, Q, b), !this.config.strictPath)
        this.router.add($, Q.endsWith("/") ? Q.slice(0, Q.length - 1) : Q + "/", b);
    }
  }
  onStart($) {
    return this.on("start", $), this;
  }
  onRequest($) {
    return this.on("request", $), this;
  }
  onParse($) {
    return this.on("parse", $), this;
  }
  onTransform($) {
    return this.on("transform", $), this;
  }
  onBeforeHandle($) {
    return this.on("beforeHandle", $), this;
  }
  onAfterHandle($) {
    return this.on("afterHandle", $), this;
  }
  onResponse($) {
    return this.on("response", $), this;
  }
  trace($) {
    return this.reporter.on("event", p8(() => this.reporter, this.event.trace.length, $)), this.on("trace", $), this;
  }
  addError($, Y) {
    return this.error($, Y);
  }
  error($, Y) {
    switch (typeof $) {
      case "string":
        return Y.prototype[_1] = $, this.definitions.error[$] = Y, this;
      case "function":
        return this.definitions.error = $(this.definitions.error), this;
    }
    for (let [W, X] of Object.entries($))
      X.prototype[_1] = W, this.definitions.error[W] = X;
    return this;
  }
  onError($) {
    return this.on("error", $), this;
  }
  onStop($) {
    return this.on("stop", $), this;
  }
  on($, Y) {
    for (let W of Array.isArray(Y) ? Y : [Y])
      switch (W = RW(W), $) {
        case "start":
          this.event.start.push(W);
          break;
        case "request":
          this.event.request.push(W);
          break;
        case "response":
          this.event.onResponse.push(W);
          break;
        case "parse":
          this.event.parse.splice(this.event.parse.length - 1, 0, W);
          break;
        case "transform":
          this.event.transform.push(W);
          break;
        case "beforeHandle":
          this.event.beforeHandle.push(W);
          break;
        case "afterHandle":
          this.event.afterHandle.push(W);
          break;
        case "trace":
          this.event.trace.push(W);
          break;
        case "error":
          this.event.error.push(W);
          break;
        case "stop":
          this.event.stop.push(W);
          break;
      }
    return this;
  }
  group($, Y, W) {
    const X = new I$({ ...this.config, prefix: "" });
    X.store = this.store, X.getServer = () => this.server;
    const Z = typeof Y === "object", J = (Z ? W : Y)(X);
    if (this.decorators = F1(this.decorators, X.decorators), J.event.request.length)
      this.event.request = [...this.event.request, ...J.event.request];
    if (J.event.onResponse.length)
      this.event.onResponse = [...this.event.onResponse, ...J.event.onResponse];
    return this.model(J.definitions.type), Object.values(X.routes).forEach(({ method: Q, path: z, handler: U, hooks: F }) => {
      if (z = (Z ? "" : this.config.prefix) + $ + z, Z) {
        const D = Y, S = F;
        this.add(Q, z, U, S1(D, { ...S, error: !S.error ? J.event.error : Array.isArray(S.error) ? [...S.error, ...J.event.error] : [S.error, ...J.event.error] }));
      } else
        this.add(Q, z, U, S1(F, { error: J.event.error }), { skipPrefix: true });
    }), this;
  }
  guard($, Y) {
    if (!Y)
      return this.event = s$(this.event, $), this.validator = { body: $.body, headers: $.headers, params: $.params, query: $.query, response: $.response }, this;
    const W = new I$;
    W.store = this.store;
    const X = Y(W);
    if (this.decorators = F1(this.decorators, W.decorators), X.event.request.length)
      this.event.request = [...this.event.request, ...X.event.request];
    if (X.event.onResponse.length)
      this.event.onResponse = [...this.event.onResponse, ...X.event.onResponse];
    return this.model(X.definitions.type), Object.values(W.routes).forEach(({ method: Z, path: J, handler: Q, hooks: z }) => {
      this.add(Z, J, Q, S1($, { ...z, error: !z.error ? X.event.error : Array.isArray(z.error) ? [...z.error, ...X.event.error] : [z.error, ...X.event.error] }));
    }), this;
  }
  use($) {
    if ($ instanceof Promise)
      return this.lazyLoadModules.push($.then((Y) => {
        if (typeof Y === "function")
          return Y(this);
        if (typeof Y.default === "function")
          return Y.default(this);
        return this._use(Y);
      }).then((Y) => Y.compile())), this;
    else
      return this._use($);
    return this;
  }
  _use($) {
    if (typeof $ === "function") {
      const Z = $(this);
      if (Z instanceof Promise)
        return this.lazyLoadModules.push(Z.then((J) => {
          if (J instanceof I$) {
            this.compile();
            for (let { method: Q, path: z, handler: U, hooks: F } of Object.values(J.routes))
              this.add(Q, z, U, S1(F, { error: J.event.error }));
            return J;
          }
          if (typeof J === "function")
            return J(this);
          if (typeof J.default === "function")
            return J.default(this);
          return this._use(J);
        }).then((J) => J.compile())), this;
      return Z;
    }
    const { name: Y, seed: W } = $.config;
    $.getServer = () => this.getServer();
    const X = $.config.scoped;
    if (X) {
      if (Y) {
        if (!(Y in this.dependencies))
          this.dependencies[Y] = [];
        const J = W !== undefined ? P8(Y + JSON.stringify(W)) : 0;
        if (this.dependencies[Y].some((Q) => J === Q))
          return this;
        this.dependencies[Y].push(J);
      }
      if ($.model(this.definitions.type), $.error(this.definitions.error), $.onRequest((J) => {
        Object.assign(J, this.decorators), Object.assign(J.store, this.store);
      }), $.event.trace = [...this.event.trace, ...$.event.trace], $.config.aot)
        $.compile();
      const Z = this.mount($.fetch);
      return this.routes = this.routes.concat(Z.routes), this;
    } else {
      $.reporter = this.reporter;
      for (let Z of $.event.trace)
        this.trace(Z);
    }
    this.decorate($.decorators), this.state($.store), this.model($.definitions.type), this.error($.definitions.error);
    for (let { method: Z, path: J, handler: Q, hooks: z } of Object.values($.routes))
      this.add(Z, J, Q, S1(z, { error: $.event.error }));
    if (!X)
      if (Y) {
        if (!(Y in this.dependencies))
          this.dependencies[Y] = [];
        const Z = W !== undefined ? P8(Y + JSON.stringify(W)) : 0;
        if (this.dependencies[Y].some((J) => Z === J))
          return this;
        this.dependencies[Y].push(Z), this.event = s$(this.event, O8($.event), Z);
      } else
        this.event = s$(this.event, O8($.event));
    return this;
  }
  mount($, Y) {
    if (typeof $ === "function" || $.length === 0 || $ === "/") {
      const Z = typeof $ === "function" ? $ : Y, J = async ({ request: Q, path: z }) => Z(new Request(j8(Q.url) + z || "/", Q));
      return this.all("/", J, { type: "none" }), this.all("/*", J, { type: "none" }), this;
    }
    const W = $.length, X = async ({ request: Z, path: J }) => Y(new Request(j8(Z.url) + J.slice(W) || "/", Z));
    return this.all($, X, { type: "none" }), this.all($ + ($.endsWith("/") ? "*" : "/*"), X, { type: "none" }), this;
  }
  get($, Y, W) {
    return this.add("GET", $, Y, W), this;
  }
  post($, Y, W) {
    return this.add("POST", $, Y, W), this;
  }
  put($, Y, W) {
    return this.add("PUT", $, Y, W), this;
  }
  patch($, Y, W) {
    return this.add("PATCH", $, Y, W), this;
  }
  delete($, Y, W) {
    return this.add("DELETE", $, Y, W), this;
  }
  options($, Y, W) {
    return this.add("OPTIONS", $, Y, W), this;
  }
  all($, Y, W) {
    return this.add("ALL", $, Y, W), this;
  }
  head($, Y, W) {
    return this.add("HEAD", $, Y, W), this;
  }
  connect($, Y, W) {
    return this.add("CONNECT", $, Y, W), this;
  }
  ws($, Y) {
    const W = Y.transformMessage ? Array.isArray(Y.transformMessage) ? Y.transformMessage : [Y.transformMessage] : undefined;
    let X = null;
    const Z = Q1(Y?.body, { models: this.definitions.type }), J = Q1(Y?.response, { models: this.definitions.type }), Q = (z) => {
      if (typeof z === "string") {
        const U = z?.charCodeAt(0);
        if (U === 47 || U === 123)
          try {
            z = JSON.parse(z);
          } catch {
          }
        else if (!Number.isNaN(+z))
          z = +z;
      }
      if (W?.length)
        for (let U = 0;U < W.length; U++) {
          const F = W[U](z);
          if (F !== undefined)
            z = F;
        }
      return z;
    };
    return this.route("$INTERNALWS", $, (z) => {
      const { set: U, path: F, qi: D, headers: S, query: b, params: j } = z;
      if (X === null)
        X = this.getServer();
      if (X?.upgrade(z.request, { headers: typeof Y.upgrade === "function" ? Y.upgrade(z) : Y.upgrade, data: { validator: J, open(M) {
        Y.open?.(new a1(M, z));
      }, message: (M, P) => {
        const O = Q(P);
        if (Z?.Check(O) === false)
          return void M.send(new U0("message", Z, O).message);
        Y.message?.(new a1(M, z), O);
      }, drain(M) {
        Y.drain?.(new a1(M, z));
      }, close(M, P, O) {
        Y.close?.(new a1(M, z), P, O);
      } } }))
        return;
      return U.status = 400, "Expected a websocket connection";
    }, { beforeHandle: Y.beforeHandle, transform: Y.transform, headers: Y.headers, params: Y.params, query: Y.query }), this;
  }
  route($, Y, W, { config: X, ...Z } = { config: { allowMeta: false } }) {
    return this.add($, Y, W, Z, X), this;
  }
  state($, Y) {
    switch (typeof $) {
      case "object":
        return this.store = F1(this.store, $), this;
      case "function":
        return this.store = $(this.store), this;
    }
    if (!($ in this.store))
      this.store[$] = Y;
    return this;
  }
  decorate($, Y) {
    switch (typeof $) {
      case "object":
        return this.decorators = F1(this.decorators, $), this;
      case "function":
        return this.decorators = $(this.decorators), this;
    }
    if (!($ in this.decorators))
      this.decorators[$] = Y;
    return this;
  }
  derive($) {
    return $.$elysia = "derive", this.onTransform($);
  }
  model($, Y) {
    switch (typeof $) {
      case "object":
        return Object.entries($).forEach(([W, X]) => {
          if (!(W in this.definitions.type))
            this.definitions.type[W] = X;
        }), this;
      case "function":
        return this.definitions.type = $(this.definitions.type), this;
    }
    return this.definitions.type[$] = Y, this;
  }
  mapDerive($) {
    return $.$elysia = "derive", this.onTransform($);
  }
  affix($, Y, W) {
    if (W === "")
      return this;
    const X = ["_", "-", " "], Z = (U) => U[0].toUpperCase() + U.slice(1), J = $ === "prefix" ? (U, F) => X.includes(U.at(-1) ?? "") ? U + F : U + Z(F) : X.includes(W.at(-1) ?? "") ? (U, F) => F + U : (U, F) => F + Z(U), Q = (U) => {
      const F = {};
      switch (U) {
        case "decorator":
          for (let D in this.decorators)
            F[J(W, D)] = this.decorators[D];
          this.decorators = F;
          break;
        case "state":
          for (let D in this.store)
            F[J(W, D)] = this.store[D];
          this.store = F;
          break;
        case "model":
          for (let D in this.definitions.type)
            F[J(W, D)] = this.definitions.type[D];
          this.definitions.type = F;
          break;
        case "error":
          for (let D in this.definitions.error)
            F[J(W, D)] = this.definitions.error[D];
          this.definitions.error = F;
          break;
      }
    }, z = Array.isArray(Y) ? Y : [Y];
    for (let U of z.some((F) => F === "all") ? ["decorator", "state", "model", "error"] : z)
      Q(U);
    return this;
  }
  prefix($, Y) {
    return this.affix("prefix", $, Y);
  }
  suffix($, Y) {
    return this.affix("suffix", $, Y);
  }
  compile() {
    if (this.fetch = this.config.aot ? G8(this) : E8(this), typeof this.server?.reload === "function")
      this.server.reload({ ...this.server, fetch: this.fetch });
    return this;
  }
  handle = async ($) => this.fetch($);
  fetch = ($) => (this.fetch = this.config.aot ? G8(this) : E8(this))($);
  handleError = async ($, Y) => (this.handleError = this.config.aot ? _8(this) : $X(this))($, Y);
  outerErrorHandler = ($) => new Response($.message || $.name || "Error", { status: $?.status ?? 500 });
  listen = ($, Y) => {
    if (!Bun)
      throw new Error("Bun to run");
    if (this.compile(), typeof $ === "string") {
      if ($ = +$.trim(), Number.isNaN($))
        throw new Error("Port must be a numeric value");
    }
    const W = this.fetch, X = typeof $ === "object" ? { development: !s1, ...this.config.serve, ...$, websocket: { ...this.config.websocket, ...N8 }, fetch: W, error: this.outerErrorHandler } : { development: !s1, ...this.config.serve, websocket: { ...this.config.websocket, ...N8 }, port: $, fetch: W, error: this.outerErrorHandler };
    if (typeof Bun === "undefined")
      throw new Error(".listen() is designed to run on Bun only. If you are running Elysia in other environment please use a dedicated plugin or export the handler via Elysia.fetch");
    if (this.server = Bun?.serve(X), this.event.start.length)
      (async () => {
        const Z = Object.assign(this.decorators, { store: this.store, app: this });
        for (let J = 0;J < this.event.transform.length; J++) {
          const Q = this.event.transform[J](Z);
          if (this.event.transform[J].$elysia === "derive")
            if (Q instanceof Promise)
              Object.assign(Z, await Q);
            else
              Object.assign(Z, Q);
        }
        for (let J = 0;J < this.event.start.length; J++)
          this.event.start[J](Z);
      })();
    if (Y)
      Y(this.server);
    return Promise.all(this.lazyLoadModules).then(() => {
      Bun?.gc(false);
    }), this;
  };
  stop = async () => {
    if (!this.server)
      throw new Error("Elysia isn't running. Call `app.listen` to start the server.");
    if (this.server.stop(), this.event.stop.length)
      (async () => {
        const $ = Object.assign(this.decorators, { store: this.store, app: this });
        for (let Y = 0;Y < this.event.transform.length; Y++) {
          const W = this.event.transform[Y]($);
          if (this.event.transform[Y].$elysia === "derive")
            if (W instanceof Promise)
              Object.assign($, await W);
            else
              Object.assign($, W);
        }
        for (let Y = 0;Y < this.event.stop.length; Y++)
          this.event.stop[Y]($);
      })();
  };
  get modules() {
    return Promise.all(this.lazyLoadModules);
  }
}
var export_t = $0.Type;

// node_modules/@elysiajs/cors/dist/index.js
var cors = (config = {
  origin: true,
  methods: "*",
  allowedHeaders: "*",
  exposedHeaders: "*",
  credentials: false,
  maxAge: 5,
  preflight: true
}) => {
  const { origin = true, methods = "*", allowedHeaders = "*", exposedHeaders = "*", credentials = false, maxAge = 5, preflight = true } = config;
  const app = new I$({
    name: "@elysiajs/cors",
    seed: config
  });
  const origins = typeof origin === "boolean" ? undefined : Array.isArray(origin) ? origin : [origin];
  const processOrigin = (origin2, request, from) => {
    switch (typeof origin2) {
      case "string":
        const protocolStart = from.indexOf("://");
        if (protocolStart === -1)
          return false;
        return origin2 === from.slice(protocolStart + 3);
      case "function":
        return origin2(request);
      case "object":
        return origin2.test(from);
    }
  };
  const handleOrigin = (set, request) => {
    if (origin === true) {
      set.headers["Vary"] = "*";
      set.headers["Access-Control-Allow-Origin"] = request.headers.get("Origin") || "*";
      return;
    }
    if (!origins?.length)
      return;
    const headers = [];
    if (origins.length) {
      const from = request.headers.get("Origin") ?? "";
      for (let i = 0;i < origins.length; i++) {
        const value = processOrigin(origins[i], request, from);
        if (value === true) {
          set.headers["Vary"] = origin ? "Origin" : "*";
          set.headers["Access-Control-Allow-Origin"] = request.headers.get("Origin") || "*";
          return;
        }
        if (value)
          headers.push(value);
      }
    }
    set.headers["Vary"] = "Origin";
    set.headers["Access-Control-Allow-Origin"] = headers.join(", ");
  };
  const handleMethod = (set) => {
    if (!methods?.length)
      return;
    if (methods === "*")
      return set.headers["Access-Control-Allow-Methods"] = "*";
    if (!Array.isArray(methods))
      return set.headers["Access-Control-Allow-Methods"] = methods;
    set.headers["Access-Control-Allow-Methods"] = methods.join(", ");
  };
  if (preflight)
    app.options("/", ({ set, request }) => {
      handleOrigin(set, request);
      handleMethod(set);
      if (exposedHeaders.length)
        set.headers["Access-Control-Allow-Headers"] = typeof allowedHeaders === "string" ? allowedHeaders : allowedHeaders.join(", ");
      if (maxAge)
        set.headers["Access-Control-Max-Age"] = maxAge.toString();
      return new Response("", {
        status: 204
      });
    }).options("/*", ({ set, request }) => {
      handleOrigin(set, request);
      handleMethod(set);
      if (exposedHeaders.length)
        set.headers["Access-Control-Allow-Headers"] = typeof allowedHeaders === "string" ? allowedHeaders : allowedHeaders.join(", ");
      if (maxAge)
        set.headers["Access-Control-Max-Age"] = maxAge.toString();
      return new Response("", {
        status: 204
      });
    });
  return app.onRequest(({ set, request }) => {
    handleOrigin(set, request);
    handleMethod(set);
    if (allowedHeaders.length)
      set.headers["Access-Control-Allow-Headers"] = typeof allowedHeaders === "string" ? allowedHeaders : allowedHeaders.join(", ");
    if (exposedHeaders.length)
      set.headers["Access-Control-Exposed-Headers"] = typeof exposedHeaders === "string" ? exposedHeaders : exposedHeaders.join(", ");
    if (credentials)
      set.headers["Access-Control-Allow-Credentials"] = "true";
  });
};

// src/db/schema/index.ts
var exports_schema = {};
__export(exports_schema, {
  usersRelations: () => {
    {
      return usersRelations;
    }
  },
  users: () => {
    {
      return users;
    }
  },
  userRoleEnum: () => {
    {
      return userRoleEnum;
    }
  },
  restaurantsRelations: () => {
    {
      return restaurantsRelations;
    }
  },
  restaurants: () => {
    {
      return restaurants;
    }
  },
  productsRelations: () => {
    {
      return productsRelations;
    }
  },
  products: () => {
    {
      return products;
    }
  },
  ordersRelations: () => {
    {
      return ordersRelations;
    }
  },
  orders: () => {
    {
      return orders;
    }
  },
  orderStatusEnum: () => {
    {
      return orderStatusEnum;
    }
  },
  orderItemsRelations: () => {
    {
      return orderItemsRelations;
    }
  },
  orderItems: () => {
    {
      return orderItems;
    }
  },
  evaluationsRelations: () => {
    {
      return evaluationsRelations;
    }
  },
  evaluations: () => {
    {
      return evaluations;
    }
  },
  authLinks: () => {
    {
      return authLinks;
    }
  }
});

// node_modules/@paralleldrive/cuid2/index.js
var { createId, init, getConstants, isCuid } = require_src();
var $createId = createId;

// node_modules/drizzle-orm/entity.js
var is = function(value, type) {
  if (!value || typeof value !== "object") {
    return false;
  }
  if (value instanceof type) {
    return true;
  }
  if (!Object.prototype.hasOwnProperty.call(type, entityKind)) {
    throw new Error(`Class "${type.name ?? "<unknown>"}" doesn't look like a Drizzle entity. If this is incorrect and the class is provided by Drizzle, please report this as a bug.`);
  }
  let cls = value.constructor;
  if (cls) {
    while (cls) {
      if (entityKind in cls && cls[entityKind] === type[entityKind]) {
        return true;
      }
      cls = Object.getPrototypeOf(cls);
    }
  }
  return false;
};
var entityKind = Symbol.for("drizzle:entityKind");
var hasOwnEntityKind = Symbol.for("drizzle:hasOwnEntityKind");

// node_modules/drizzle-orm/column.js
class Column {
  constructor(table, config) {
    this.table = table;
    this.config = config;
    this.name = config.name;
    this.notNull = config.notNull;
    this.default = config.default;
    this.defaultFn = config.defaultFn;
    this.hasDefault = config.hasDefault;
    this.primary = config.primaryKey;
    this.isUnique = config.isUnique;
    this.uniqueName = config.uniqueName;
    this.uniqueType = config.uniqueType;
    this.dataType = config.dataType;
    this.columnType = config.columnType;
  }
  static [entityKind] = "Column";
  name;
  primary;
  notNull;
  default;
  defaultFn;
  hasDefault;
  isUnique;
  uniqueName;
  uniqueType;
  dataType;
  columnType;
  enumValues = undefined;
  config;
  mapFromDriverValue(value) {
    return value;
  }
  mapToDriverValue(value) {
    return value;
  }
}

// node_modules/drizzle-orm/table.js
var isTable = function(table) {
  return typeof table === "object" && table !== null && IsDrizzleTable in table;
};
var getTableName = function(table) {
  return table[TableName];
};
var TableName = Symbol.for("drizzle:Name");
var Schema = Symbol.for("drizzle:Schema");
var Columns = Symbol.for("drizzle:Columns");
var OriginalName = Symbol.for("drizzle:OriginalName");
var BaseName = Symbol.for("drizzle:BaseName");
var IsAlias = Symbol.for("drizzle:IsAlias");
var ExtraConfigBuilder = Symbol.for("drizzle:ExtraConfigBuilder");
var IsDrizzleTable = Symbol.for("drizzle:IsDrizzleTable");

class Table {
  static [entityKind] = "Table";
  static Symbol = {
    Name: TableName,
    Schema,
    OriginalName,
    Columns,
    BaseName,
    IsAlias,
    ExtraConfigBuilder
  };
  [TableName];
  [OriginalName];
  [Schema];
  [Columns];
  [BaseName];
  [IsAlias] = false;
  [ExtraConfigBuilder] = undefined;
  [IsDrizzleTable] = true;
  constructor(name, schema, baseName) {
    this[TableName] = this[OriginalName] = name;
    this[Schema] = schema;
    this[BaseName] = baseName;
  }
}

// node_modules/drizzle-orm/pg-core/table.js
var pgTableWithSchema = function(name, columns, extraConfig, schema, baseName = name) {
  const rawTable = new PgTable(name, schema, baseName);
  const builtColumns = Object.fromEntries(Object.entries(columns).map(([name2, colBuilderBase]) => {
    const colBuilder = colBuilderBase;
    const column = colBuilder.build(rawTable);
    rawTable[InlineForeignKeys].push(...colBuilder.buildForeignKeys(column, rawTable));
    return [name2, column];
  }));
  const table2 = Object.assign(rawTable, builtColumns);
  table2[Table.Symbol.Columns] = builtColumns;
  if (extraConfig) {
    table2[PgTable.Symbol.ExtraConfigBuilder] = extraConfig;
  }
  return table2;
};
var InlineForeignKeys = Symbol.for("drizzle:PgInlineForeignKeys");

class PgTable extends Table {
  static [entityKind] = "PgTable";
  static Symbol = Object.assign({}, Table.Symbol, {
    InlineForeignKeys
  });
  [InlineForeignKeys] = [];
  [Table.Symbol.ExtraConfigBuilder] = undefined;
}
var pgTable = (name, columns, extraConfig) => {
  return pgTableWithSchema(name, columns, extraConfig, undefined);
};

// node_modules/drizzle-orm/pg-core/primary-keys.js
class PrimaryKeyBuilder {
  static [entityKind] = "PgPrimaryKeyBuilder";
  columns;
  name;
  constructor(columns, name) {
    this.columns = columns;
    this.name = name;
  }
  build(table3) {
    return new PrimaryKey(table3, this.columns, this.name);
  }
}

class PrimaryKey {
  constructor(table3, columns, name) {
    this.table = table3;
    this.columns = columns;
    this.name = name;
  }
  static [entityKind] = "PgPrimaryKey";
  columns;
  name;
  getName() {
    return this.name ?? `${this.table[PgTable.Symbol.Name]}_${this.columns.map((column) => column.name).join("_")}_pk`;
  }
}

// node_modules/drizzle-orm/sql/expressions/conditions.js
var bindIfParam = function(value, column2) {
  if (isDriverValueEncoder(column2) && !isSQLWrapper(value) && !is(value, Param) && !is(value, Placeholder) && !is(value, Column) && !is(value, Table) && !is(value, View)) {
    return new Param(value, column2);
  }
  return value;
};
var and = function(...unfilteredConditions) {
  const conditions = unfilteredConditions.filter((c2) => c2 !== undefined);
  if (conditions.length === 0) {
    return;
  }
  if (conditions.length === 1) {
    return new SQL(conditions);
  }
  return new SQL([
    new StringChunk("("),
    sql2.join(conditions, new StringChunk(" and ")),
    new StringChunk(")")
  ]);
};
var or = function(...unfilteredConditions) {
  const conditions = unfilteredConditions.filter((c2) => c2 !== undefined);
  if (conditions.length === 0) {
    return;
  }
  if (conditions.length === 1) {
    return new SQL(conditions);
  }
  return new SQL([
    new StringChunk("("),
    sql2.join(conditions, new StringChunk(" or ")),
    new StringChunk(")")
  ]);
};
var not = function(condition) {
  return sql2`not ${condition}`;
};
var inArray = function(column2, values) {
  if (Array.isArray(values)) {
    if (values.length === 0) {
      throw new Error("inArray requires at least one value");
    }
    return sql2`${column2} in ${values.map((v) => bindIfParam(v, column2))}`;
  }
  return sql2`${column2} in ${bindIfParam(values, column2)}`;
};
var notInArray = function(column2, values) {
  if (Array.isArray(values)) {
    if (values.length === 0) {
      throw new Error("notInArray requires at least one value");
    }
    return sql2`${column2} not in ${values.map((v) => bindIfParam(v, column2))}`;
  }
  return sql2`${column2} not in ${bindIfParam(values, column2)}`;
};
var isNull = function(value) {
  return sql2`${value} is null`;
};
var isNotNull = function(value) {
  return sql2`${value} is not null`;
};
var exists = function(subquery) {
  return sql2`exists (${subquery})`;
};
var notExists = function(subquery) {
  return sql2`not exists (${subquery})`;
};
var between = function(column2, min, max) {
  return sql2`${column2} between ${bindIfParam(min, column2)} and ${bindIfParam(max, column2)}`;
};
var notBetween = function(column2, min, max) {
  return sql2`${column2} not between ${bindIfParam(min, column2)} and ${bindIfParam(max, column2)}`;
};
var like = function(column2, value) {
  return sql2`${column2} like ${value}`;
};
var notLike = function(column2, value) {
  return sql2`${column2} not like ${value}`;
};
var ilike = function(column2, value) {
  return sql2`${column2} ilike ${value}`;
};
var notIlike = function(column2, value) {
  return sql2`${column2} not ilike ${value}`;
};
var eq = (left, right) => {
  return sql2`${left} = ${bindIfParam(right, left)}`;
};
var ne = (left, right) => {
  return sql2`${left} <> ${bindIfParam(right, left)}`;
};
var gt = (left, right) => {
  return sql2`${left} > ${bindIfParam(right, left)}`;
};
var gte = (left, right) => {
  return sql2`${left} >= ${bindIfParam(right, left)}`;
};
var lt = (left, right) => {
  return sql2`${left} < ${bindIfParam(right, left)}`;
};
var lte = (left, right) => {
  return sql2`${left} <= ${bindIfParam(right, left)}`;
};

// node_modules/drizzle-orm/sql/expressions/select.js
var asc = function(column2) {
  return sql2`${column2} asc`;
};
var desc = function(column2) {
  return sql2`${column2} desc`;
};

// node_modules/drizzle-orm/relations.js
var getOperators = function() {
  return {
    and,
    between,
    eq,
    exists,
    gt,
    gte,
    ilike,
    inArray,
    isNull,
    isNotNull,
    like,
    lt,
    lte,
    ne,
    not,
    notBetween,
    notExists,
    notLike,
    notIlike,
    notInArray,
    or,
    sql: sql2
  };
};
var getOrderByOperators = function() {
  return {
    sql: sql2,
    asc,
    desc
  };
};
var extractTablesRelationalConfig = function(schema, configHelpers) {
  if (Object.keys(schema).length === 1 && "default" in schema && !is(schema["default"], Table)) {
    schema = schema["default"];
  }
  const tableNamesMap = {};
  const relationsBuffer = {};
  const tablesConfig = {};
  for (const [key, value] of Object.entries(schema)) {
    if (isTable(value)) {
      const dbName = value[Table.Symbol.Name];
      const bufferedRelations = relationsBuffer[dbName];
      tableNamesMap[dbName] = key;
      tablesConfig[key] = {
        tsName: key,
        dbName: value[Table.Symbol.Name],
        schema: value[Table.Symbol.Schema],
        columns: value[Table.Symbol.Columns],
        relations: bufferedRelations?.relations ?? {},
        primaryKey: bufferedRelations?.primaryKey ?? []
      };
      for (const column3 of Object.values(value[Table.Symbol.Columns])) {
        if (column3.primary) {
          tablesConfig[key].primaryKey.push(column3);
        }
      }
      const extraConfig = value[Table.Symbol.ExtraConfigBuilder]?.(value);
      if (extraConfig) {
        for (const configEntry of Object.values(extraConfig)) {
          if (is(configEntry, PrimaryKeyBuilder)) {
            tablesConfig[key].primaryKey.push(...configEntry.columns);
          }
        }
      }
    } else if (is(value, Relations)) {
      const dbName = value.table[Table.Symbol.Name];
      const tableName = tableNamesMap[dbName];
      const relations2 = value.config(configHelpers(value.table));
      let primaryKey;
      for (const [relationName, relation] of Object.entries(relations2)) {
        if (tableName) {
          const tableConfig = tablesConfig[tableName];
          tableConfig.relations[relationName] = relation;
          if (primaryKey) {
            tableConfig.primaryKey.push(...primaryKey);
          }
        } else {
          if (!(dbName in relationsBuffer)) {
            relationsBuffer[dbName] = {
              relations: {},
              primaryKey
            };
          }
          relationsBuffer[dbName].relations[relationName] = relation;
        }
      }
    }
  }
  return { tables: tablesConfig, tableNamesMap };
};
var relations = function(table5, relations2) {
  return new Relations(table5, (helpers) => Object.fromEntries(Object.entries(relations2(helpers)).map(([key, value]) => [
    key,
    value.withFieldName(key)
  ])));
};
var createOne = function(sourceTable) {
  return function one(table5, config) {
    return new One(sourceTable, table5, config, config?.fields.reduce((res, f) => res && f.notNull, true) ?? false);
  };
};
var createMany = function(sourceTable) {
  return function many(referencedTable, config) {
    return new Many(sourceTable, referencedTable, config);
  };
};
var normalizeRelation = function(schema, tableNamesMap, relation) {
  if (is(relation, One) && relation.config) {
    return {
      fields: relation.config.fields,
      references: relation.config.references
    };
  }
  const referencedTableTsName = tableNamesMap[relation.referencedTable[Table.Symbol.Name]];
  if (!referencedTableTsName) {
    throw new Error(`Table "${relation.referencedTable[Table.Symbol.Name]}" not found in schema`);
  }
  const referencedTableConfig = schema[referencedTableTsName];
  if (!referencedTableConfig) {
    throw new Error(`Table "${referencedTableTsName}" not found in schema`);
  }
  const sourceTable = relation.sourceTable;
  const sourceTableTsName = tableNamesMap[sourceTable[Table.Symbol.Name]];
  if (!sourceTableTsName) {
    throw new Error(`Table "${sourceTable[Table.Symbol.Name]}" not found in schema`);
  }
  const reverseRelations = [];
  for (const referencedTableRelation of Object.values(referencedTableConfig.relations)) {
    if (relation.relationName && relation !== referencedTableRelation && referencedTableRelation.relationName === relation.relationName || !relation.relationName && referencedTableRelation.referencedTable === relation.sourceTable) {
      reverseRelations.push(referencedTableRelation);
    }
  }
  if (reverseRelations.length > 1) {
    throw relation.relationName ? new Error(`There are multiple relations with name "${relation.relationName}" in table "${referencedTableTsName}"`) : new Error(`There are multiple relations between "${referencedTableTsName}" and "${relation.sourceTable[Table.Symbol.Name]}". Please specify relation name`);
  }
  if (reverseRelations[0] && is(reverseRelations[0], One) && reverseRelations[0].config) {
    return {
      fields: reverseRelations[0].config.references,
      references: reverseRelations[0].config.fields
    };
  }
  throw new Error(`There is not enough information to infer relation "${sourceTableTsName}.${relation.fieldName}"`);
};
var createTableRelationsHelpers = function(sourceTable) {
  return {
    one: createOne(sourceTable),
    many: createMany(sourceTable)
  };
};
var mapRelationalRow = function(tablesConfig, tableConfig, row, buildQueryResultSelection, mapColumnValue = (value) => value) {
  const result = {};
  for (const [
    selectionItemIndex,
    selectionItem
  ] of buildQueryResultSelection.entries()) {
    if (selectionItem.isJson) {
      const relation = tableConfig.relations[selectionItem.tsKey];
      const rawSubRows = row[selectionItemIndex];
      const subRows = typeof rawSubRows === "string" ? JSON.parse(rawSubRows) : rawSubRows;
      result[selectionItem.tsKey] = is(relation, One) ? subRows && mapRelationalRow(tablesConfig, tablesConfig[selectionItem.relationTableTsKey], subRows, selectionItem.selection, mapColumnValue) : subRows.map((subRow) => mapRelationalRow(tablesConfig, tablesConfig[selectionItem.relationTableTsKey], subRow, selectionItem.selection, mapColumnValue));
    } else {
      const value = mapColumnValue(row[selectionItemIndex]);
      const field = selectionItem.field;
      let decoder;
      if (is(field, Column)) {
        decoder = field;
      } else if (is(field, SQL)) {
        decoder = field.decoder;
      } else {
        decoder = field.sql.decoder;
      }
      result[selectionItem.tsKey] = value === null ? null : decoder.mapFromDriverValue(value);
    }
  }
  return result;
};

class Relation {
  constructor(sourceTable, referencedTable, relationName) {
    this.sourceTable = sourceTable;
    this.referencedTable = referencedTable;
    this.relationName = relationName;
    this.referencedTableName = referencedTable[Table.Symbol.Name];
  }
  static [entityKind] = "Relation";
  referencedTableName;
  fieldName;
}

class Relations {
  constructor(table5, config) {
    this.table = table5;
    this.config = config;
  }
  static [entityKind] = "Relations";
}

class One extends Relation {
  constructor(sourceTable, referencedTable, config, isNullable) {
    super(sourceTable, referencedTable, config?.relationName);
    this.config = config;
    this.isNullable = isNullable;
  }
  static [entityKind] = "One";
  withFieldName(fieldName) {
    const relation = new One(this.sourceTable, this.referencedTable, this.config, this.isNullable);
    relation.fieldName = fieldName;
    return relation;
  }
}

class Many extends Relation {
  constructor(sourceTable, referencedTable, config) {
    super(sourceTable, referencedTable, config?.relationName);
    this.config = config;
  }
  static [entityKind] = "Many";
  withFieldName(fieldName) {
    const relation = new Many(this.sourceTable, this.referencedTable, this.config);
    relation.fieldName = fieldName;
    return relation;
  }
}

// node_modules/drizzle-orm/subquery.js
var SubqueryConfig = Symbol.for("drizzle:SubqueryConfig");

class Subquery {
  static [entityKind] = "Subquery";
  [SubqueryConfig];
  constructor(sql5, selection, alias, isWith = false) {
    this[SubqueryConfig] = {
      sql: sql5,
      selection,
      alias,
      isWith
    };
  }
}

class WithSubquery extends Subquery {
  static [entityKind] = "WithSubquery";
}

// node_modules/drizzle-orm/tracing-utils.js
var iife = function(fn, ...args) {
  return fn(...args);
};

// node_modules/drizzle-orm/version.js
var version = "0.29.1";

// node_modules/drizzle-orm/tracing.js
var otel;
var rawTracer;
var tracer = {
  startActiveSpan(name, fn) {
    if (!otel) {
      return fn();
    }
    if (!rawTracer) {
      rawTracer = otel.trace.getTracer("drizzle-orm", version);
    }
    return iife((otel2, rawTracer2) => rawTracer2.startActiveSpan(name, (span) => {
      try {
        return fn(span);
      } catch (e) {
        span.setStatus({
          code: otel2.SpanStatusCode.ERROR,
          message: e instanceof Error ? e.message : "Unknown error"
        });
        throw e;
      } finally {
        span.end();
      }
    }), otel, rawTracer);
  }
};

// node_modules/drizzle-orm/view-common.js
var ViewBaseConfig = Symbol.for("drizzle:ViewBaseConfig");

// node_modules/drizzle-orm/sql/sql.js
var isSQLWrapper = function(value) {
  return typeof value === "object" && value !== null && "getSQL" in value && typeof value.getSQL === "function";
};
var mergeQueries = function(queries) {
  const result = { sql: "", params: [] };
  for (const query of queries) {
    result.sql += query.sql;
    result.params.push(...query.params);
    if (query.typings?.length) {
      if (!result.typings) {
        result.typings = [];
      }
      result.typings.push(...query.typings);
    }
  }
  return result;
};
var isDriverValueEncoder = function(value) {
  return typeof value === "object" && value !== null && "mapToDriverValue" in value && typeof value.mapToDriverValue === "function";
};
var sql2 = function(strings, ...params) {
  const queryChunks = [];
  if (params.length > 0 || strings.length > 0 && strings[0] !== "") {
    queryChunks.push(new StringChunk(strings[0]));
  }
  for (const [paramIndex, param2] of params.entries()) {
    queryChunks.push(param2, new StringChunk(strings[paramIndex + 1]));
  }
  return new SQL(queryChunks);
};
var fillPlaceholders = function(params, values) {
  return params.map((p) => {
    if (is(p, Placeholder)) {
      if (!(p.name in values)) {
        throw new Error(`No value for placeholder "${p.name}" was provided`);
      }
      return values[p.name];
    }
    return p;
  });
};
class StringChunk {
  static [entityKind] = "StringChunk";
  value;
  constructor(value) {
    this.value = Array.isArray(value) ? value : [value];
  }
  getSQL() {
    return new SQL([this]);
  }
}

class SQL {
  constructor(queryChunks) {
    this.queryChunks = queryChunks;
  }
  static [entityKind] = "SQL";
  decoder = noopDecoder;
  shouldInlineParams = false;
  append(query) {
    this.queryChunks.push(...query.queryChunks);
    return this;
  }
  toQuery(config) {
    return tracer.startActiveSpan("drizzle.buildSQL", (span) => {
      const query = this.buildQueryFromSourceParams(this.queryChunks, config);
      span?.setAttributes({
        "drizzle.query.text": query.sql,
        "drizzle.query.params": JSON.stringify(query.params)
      });
      return query;
    });
  }
  buildQueryFromSourceParams(chunks, _config) {
    const config = Object.assign({}, _config, {
      inlineParams: _config.inlineParams || this.shouldInlineParams,
      paramStartIndex: _config.paramStartIndex || { value: 0 }
    });
    const {
      escapeName,
      escapeParam,
      prepareTyping,
      inlineParams,
      paramStartIndex
    } = config;
    return mergeQueries(chunks.map((chunk) => {
      if (is(chunk, StringChunk)) {
        return { sql: chunk.value.join(""), params: [] };
      }
      if (is(chunk, Name)) {
        return { sql: escapeName(chunk.value), params: [] };
      }
      if (chunk === undefined) {
        return { sql: "", params: [] };
      }
      if (Array.isArray(chunk)) {
        const result = [new StringChunk("(")];
        for (const [i, p] of chunk.entries()) {
          result.push(p);
          if (i < chunk.length - 1) {
            result.push(new StringChunk(", "));
          }
        }
        result.push(new StringChunk(")"));
        return this.buildQueryFromSourceParams(result, config);
      }
      if (is(chunk, SQL)) {
        return this.buildQueryFromSourceParams(chunk.queryChunks, {
          ...config,
          inlineParams: inlineParams || chunk.shouldInlineParams
        });
      }
      if (is(chunk, Table)) {
        const schemaName = chunk[Table.Symbol.Schema];
        const tableName = chunk[Table.Symbol.Name];
        return {
          sql: schemaName === undefined ? escapeName(tableName) : escapeName(schemaName) + "." + escapeName(tableName),
          params: []
        };
      }
      if (is(chunk, Column)) {
        return { sql: escapeName(chunk.table[Table.Symbol.Name]) + "." + escapeName(chunk.name), params: [] };
      }
      if (is(chunk, View)) {
        const schemaName = chunk[ViewBaseConfig].schema;
        const viewName = chunk[ViewBaseConfig].name;
        return {
          sql: schemaName === undefined ? escapeName(viewName) : escapeName(schemaName) + "." + escapeName(viewName),
          params: []
        };
      }
      if (is(chunk, Param)) {
        const mappedValue = chunk.value === null ? null : chunk.encoder.mapToDriverValue(chunk.value);
        if (is(mappedValue, SQL)) {
          return this.buildQueryFromSourceParams([mappedValue], config);
        }
        if (inlineParams) {
          return { sql: this.mapInlineParam(mappedValue, config), params: [] };
        }
        let typings;
        if (prepareTyping !== undefined) {
          typings = [prepareTyping(chunk.encoder)];
        }
        return { sql: escapeParam(paramStartIndex.value++, mappedValue), params: [mappedValue], typings };
      }
      if (is(chunk, Placeholder)) {
        return { sql: escapeParam(paramStartIndex.value++, chunk), params: [chunk] };
      }
      if (is(chunk, SQL.Aliased) && chunk.fieldAlias !== undefined) {
        return { sql: escapeName(chunk.fieldAlias), params: [] };
      }
      if (is(chunk, Subquery)) {
        if (chunk[SubqueryConfig].isWith) {
          return { sql: escapeName(chunk[SubqueryConfig].alias), params: [] };
        }
        return this.buildQueryFromSourceParams([
          new StringChunk("("),
          chunk[SubqueryConfig].sql,
          new StringChunk(") "),
          new Name(chunk[SubqueryConfig].alias)
        ], config);
      }
      if (isSQLWrapper(chunk)) {
        return this.buildQueryFromSourceParams([
          new StringChunk("("),
          chunk.getSQL(),
          new StringChunk(")")
        ], config);
      }
      if (is(chunk, Relation)) {
        return this.buildQueryFromSourceParams([
          chunk.sourceTable,
          new StringChunk("."),
          sql2.identifier(chunk.fieldName)
        ], config);
      }
      if (inlineParams) {
        return { sql: this.mapInlineParam(chunk, config), params: [] };
      }
      return { sql: escapeParam(paramStartIndex.value++, chunk), params: [chunk] };
    }));
  }
  mapInlineParam(chunk, { escapeString }) {
    if (chunk === null) {
      return "null";
    }
    if (typeof chunk === "number" || typeof chunk === "boolean") {
      return chunk.toString();
    }
    if (typeof chunk === "string") {
      return escapeString(chunk);
    }
    if (typeof chunk === "object") {
      const mappedValueAsString = chunk.toString();
      if (mappedValueAsString === "[object Object]") {
        return escapeString(JSON.stringify(chunk));
      }
      return escapeString(mappedValueAsString);
    }
    throw new Error("Unexpected param value: " + chunk);
  }
  getSQL() {
    return this;
  }
  as(alias) {
    if (alias === undefined) {
      return this;
    }
    return new SQL.Aliased(this, alias);
  }
  mapWith(decoder) {
    this.decoder = typeof decoder === "function" ? { mapFromDriverValue: decoder } : decoder;
    return this;
  }
  inlineParams() {
    this.shouldInlineParams = true;
    return this;
  }
}

class Name {
  constructor(value) {
    this.value = value;
  }
  static [entityKind] = "Name";
  brand;
  getSQL() {
    return new SQL([this]);
  }
}
var noopDecoder = {
  mapFromDriverValue: (value) => value
};
var noopEncoder = {
  mapToDriverValue: (value) => value
};
var noopMapper = {
  ...noopDecoder,
  ...noopEncoder
};

class Param {
  constructor(value, encoder = noopEncoder) {
    this.value = value;
    this.encoder = encoder;
  }
  static [entityKind] = "Param";
  brand;
  getSQL() {
    return new SQL([this]);
  }
}
((sql22) => {
  function empty() {
    return new SQL([]);
  }
  sql22.empty = empty;
  function fromList(list) {
    return new SQL(list);
  }
  sql22.fromList = fromList;
  function raw(str) {
    return new SQL([new StringChunk(str)]);
  }
  sql22.raw = raw;
  function join(chunks, separator) {
    const result = [];
    for (const [i, chunk] of chunks.entries()) {
      if (i > 0 && separator !== undefined) {
        result.push(separator);
      }
      result.push(chunk);
    }
    return new SQL(result);
  }
  sql22.join = join;
  function identifier(value) {
    return new Name(value);
  }
  sql22.identifier = identifier;
  function placeholder2(name2) {
    return new Placeholder(name2);
  }
  sql22.placeholder = placeholder2;
  function param2(value, encoder) {
    return new Param(value, encoder);
  }
  sql22.param = param2;
})(sql2 || (sql2 = {}));
((SQL2) => {

  class Aliased {
    constructor(sql22, fieldAlias) {
      this.sql = sql22;
      this.fieldAlias = fieldAlias;
    }
    static [entityKind] = "SQL.Aliased";
    isSelectionField = false;
    getSQL() {
      return this.sql;
    }
    clone() {
      return new Aliased(this.sql, this.fieldAlias);
    }
  }
  SQL2.Aliased = Aliased;
})(SQL || (SQL = {}));

class Placeholder {
  constructor(name2) {
    this.name = name2;
  }
  static [entityKind] = "Placeholder";
  getSQL() {
    return new SQL([this]);
  }
}

class View {
  static [entityKind] = "View";
  [ViewBaseConfig];
  constructor({ name: name2, schema, selectedFields, query }) {
    this[ViewBaseConfig] = {
      name: name2,
      originalName: name2,
      schema,
      selectedFields,
      query,
      isExisting: !query,
      isAlias: false
    };
  }
  getSQL() {
    return new SQL([this]);
  }
}
Column.prototype.getSQL = function() {
  return new SQL([this]);
};
Table.prototype.getSQL = function() {
  return new SQL([this]);
};
Subquery.prototype.getSQL = function() {
  return new SQL([this]);
};

// node_modules/drizzle-orm/alias.js
var aliasedTable = function(table7, tableAlias) {
  return new Proxy(table7, new TableAliasProxyHandler(tableAlias, false));
};
var aliasedTableColumn = function(column5, tableAlias) {
  return new Proxy(column5, new ColumnAliasProxyHandler(new Proxy(column5.table, new TableAliasProxyHandler(tableAlias, false))));
};
var mapColumnsInAliasedSQLToAlias = function(query, alias) {
  return new SQL.Aliased(mapColumnsInSQLToAlias(query.sql, alias), query.fieldAlias);
};
var mapColumnsInSQLToAlias = function(query, alias) {
  return sql2.join(query.queryChunks.map((c2) => {
    if (is(c2, Column)) {
      return aliasedTableColumn(c2, alias);
    }
    if (is(c2, SQL)) {
      return mapColumnsInSQLToAlias(c2, alias);
    }
    if (is(c2, SQL.Aliased)) {
      return mapColumnsInAliasedSQLToAlias(c2, alias);
    }
    return c2;
  }));
};

class ColumnAliasProxyHandler {
  constructor(table7) {
    this.table = table7;
  }
  static [entityKind] = "ColumnAliasProxyHandler";
  get(columnObj, prop) {
    if (prop === "table") {
      return this.table;
    }
    return columnObj[prop];
  }
}

class TableAliasProxyHandler {
  constructor(alias, replaceOriginalName) {
    this.alias = alias;
    this.replaceOriginalName = replaceOriginalName;
  }
  static [entityKind] = "TableAliasProxyHandler";
  get(target, prop) {
    if (prop === Table.Symbol.IsAlias) {
      return true;
    }
    if (prop === Table.Symbol.Name) {
      return this.alias;
    }
    if (this.replaceOriginalName && prop === Table.Symbol.OriginalName) {
      return this.alias;
    }
    if (prop === ViewBaseConfig) {
      return {
        ...target[ViewBaseConfig],
        name: this.alias,
        isAlias: true
      };
    }
    if (prop === Table.Symbol.Columns) {
      const columns = target[Table.Symbol.Columns];
      if (!columns) {
        return columns;
      }
      const proxiedColumns = {};
      Object.keys(columns).map((key) => {
        proxiedColumns[key] = new Proxy(columns[key], new ColumnAliasProxyHandler(new Proxy(target, this)));
      });
      return proxiedColumns;
    }
    const value = target[prop];
    if (is(value, Column)) {
      return new Proxy(value, new ColumnAliasProxyHandler(new Proxy(target, this)));
    }
    return value;
  }
}

// node_modules/drizzle-orm/column-builder.js
class ColumnBuilder {
  static [entityKind] = "ColumnBuilder";
  config;
  constructor(name, dataType, columnType) {
    this.config = {
      name,
      notNull: false,
      default: undefined,
      hasDefault: false,
      primaryKey: false,
      isUnique: false,
      uniqueName: undefined,
      uniqueType: undefined,
      dataType,
      columnType
    };
  }
  $type() {
    return this;
  }
  notNull() {
    this.config.notNull = true;
    return this;
  }
  default(value) {
    this.config.default = value;
    this.config.hasDefault = true;
    return this;
  }
  $defaultFn(fn) {
    this.config.defaultFn = fn;
    this.config.hasDefault = true;
    return this;
  }
  $default = this.$defaultFn;
  primaryKey() {
    this.config.primaryKey = true;
    this.config.notNull = true;
    return this;
  }
}

// node_modules/drizzle-orm/errors.js
class DrizzleError extends Error {
  static [entityKind] = "DrizzleError";
  constructor({ message, cause }) {
    super(message);
    this.name = "DrizzleError";
    this.cause = cause;
  }
}

class TransactionRollbackError extends DrizzleError {
  static [entityKind] = "TransactionRollbackError";
  constructor() {
    super({ message: "Rollback" });
  }
}

// node_modules/drizzle-orm/logger.js
class ConsoleLogWriter {
  static [entityKind] = "ConsoleLogWriter";
  write(message) {
    console.log(message);
  }
}

class DefaultLogger {
  static [entityKind] = "DefaultLogger";
  writer;
  constructor(config) {
    this.writer = config?.writer ?? new ConsoleLogWriter;
  }
  logQuery(query, params) {
    const stringifiedParams = params.map((p) => {
      try {
        return JSON.stringify(p);
      } catch {
        return String(p);
      }
    });
    const paramsStr = stringifiedParams.length ? ` -- params: [${stringifiedParams.join(", ")}]` : "";
    this.writer.write(`Query: ${query}${paramsStr}`);
  }
}

class NoopLogger {
  static [entityKind] = "NoopLogger";
  logQuery() {
  }
}

// node_modules/drizzle-orm/query-promise.js
class QueryPromise {
  static [entityKind] = "QueryPromise";
  [Symbol.toStringTag] = "QueryPromise";
  catch(onRejected) {
    return this.then(undefined, onRejected);
  }
  finally(onFinally) {
    return this.then((value) => {
      onFinally?.();
      return value;
    }, (reason) => {
      onFinally?.();
      throw reason;
    });
  }
  then(onFulfilled, onRejected) {
    return this.execute().then(onFulfilled, onRejected);
  }
}

// node_modules/drizzle-orm/sql/functions/aggregate.js
var count = function(expression) {
  return sql2`count(${expression || sql2.raw("*")})`.mapWith(Number);
};
var sum = function(expression) {
  return sql2`sum(${expression})`.mapWith(String);
};

// node_modules/drizzle-orm/utils.js
var mapResultRow = function(columns, row, joinsNotNullableMap) {
  const nullifyMap = {};
  const result = columns.reduce((result2, { path, field }, columnIndex) => {
    let decoder;
    if (is(field, Column)) {
      decoder = field;
    } else if (is(field, SQL)) {
      decoder = field.decoder;
    } else {
      decoder = field.sql.decoder;
    }
    let node = result2;
    for (const [pathChunkIndex, pathChunk] of path.entries()) {
      if (pathChunkIndex < path.length - 1) {
        if (!(pathChunk in node)) {
          node[pathChunk] = {};
        }
        node = node[pathChunk];
      } else {
        const rawValue = row[columnIndex];
        const value = node[pathChunk] = rawValue === null ? null : decoder.mapFromDriverValue(rawValue);
        if (joinsNotNullableMap && is(field, Column) && path.length === 2) {
          const objectName = path[0];
          if (!(objectName in nullifyMap)) {
            nullifyMap[objectName] = value === null ? getTableName(field.table) : false;
          } else if (typeof nullifyMap[objectName] === "string" && nullifyMap[objectName] !== getTableName(field.table)) {
            nullifyMap[objectName] = false;
          }
        }
      }
    }
    return result2;
  }, {});
  if (joinsNotNullableMap && Object.keys(nullifyMap).length > 0) {
    for (const [objectName, tableName] of Object.entries(nullifyMap)) {
      if (typeof tableName === "string" && !joinsNotNullableMap[tableName]) {
        result[objectName] = null;
      }
    }
  }
  return result;
};
var orderSelectedFields = function(fields, pathPrefix) {
  return Object.entries(fields).reduce((result, [name, field]) => {
    if (typeof name !== "string") {
      return result;
    }
    const newPath = pathPrefix ? [...pathPrefix, name] : [name];
    if (is(field, Column) || is(field, SQL) || is(field, SQL.Aliased)) {
      result.push({ path: newPath, field });
    } else if (is(field, Table)) {
      result.push(...orderSelectedFields(field[Table.Symbol.Columns], newPath));
    } else {
      result.push(...orderSelectedFields(field, newPath));
    }
    return result;
  }, []);
};
var haveSameKeys = function(left, right) {
  const leftKeys = Object.keys(left);
  const rightKeys = Object.keys(right);
  if (leftKeys.length !== rightKeys.length) {
    return false;
  }
  for (const [index, key] of leftKeys.entries()) {
    if (key !== rightKeys[index]) {
      return false;
    }
  }
  return true;
};
var mapUpdateSet = function(table8, values) {
  const entries = Object.entries(values).filter(([, value]) => value !== undefined).map(([key, value]) => {
    if (is(value, SQL)) {
      return [key, value];
    } else {
      return [key, new Param(value, table8[Table.Symbol.Columns][key])];
    }
  });
  if (entries.length === 0) {
    throw new Error("No values to set");
  }
  return Object.fromEntries(entries);
};
var applyMixins = function(baseClass, extendedClasses) {
  for (const extendedClass of extendedClasses) {
    for (const name of Object.getOwnPropertyNames(extendedClass.prototype)) {
      Object.defineProperty(baseClass.prototype, name, Object.getOwnPropertyDescriptor(extendedClass.prototype, name) || Object.create(null));
    }
  }
};
var getTableColumns = function(table8) {
  return table8[Table.Symbol.Columns];
};
var getTableLikeName = function(table8) {
  return is(table8, Subquery) ? table8[SubqueryConfig].alias : is(table8, View) ? table8[ViewBaseConfig].name : is(table8, SQL) ? undefined : table8[Table.Symbol.IsAlias] ? table8[Table.Symbol.Name] : table8[Table.Symbol.BaseName];
};

// node_modules/drizzle-orm/pg-core/foreign-keys.js
class ForeignKeyBuilder {
  static [entityKind] = "PgForeignKeyBuilder";
  reference;
  _onUpdate = "no action";
  _onDelete = "no action";
  constructor(config, actions) {
    this.reference = () => {
      const { name, columns, foreignColumns } = config();
      return { name, columns, foreignTable: foreignColumns[0].table, foreignColumns };
    };
    if (actions) {
      this._onUpdate = actions.onUpdate;
      this._onDelete = actions.onDelete;
    }
  }
  onUpdate(action) {
    this._onUpdate = action === undefined ? "no action" : action;
    return this;
  }
  onDelete(action) {
    this._onDelete = action === undefined ? "no action" : action;
    return this;
  }
  build(table9) {
    return new ForeignKey(table9, this);
  }
}

class ForeignKey {
  constructor(table9, builder) {
    this.table = table9;
    this.reference = builder.reference;
    this.onUpdate = builder._onUpdate;
    this.onDelete = builder._onDelete;
  }
  static [entityKind] = "PgForeignKey";
  reference;
  onUpdate;
  onDelete;
  getName() {
    const { name, columns, foreignColumns } = this.reference();
    const columnNames = columns.map((column6) => column6.name);
    const foreignColumnNames = foreignColumns.map((column6) => column6.name);
    const chunks = [
      this.table[PgTable.Symbol.Name],
      ...columnNames,
      foreignColumns[0].table[PgTable.Symbol.Name],
      ...foreignColumnNames
    ];
    return name ?? `${chunks.join("_")}_fk`;
  }
}

// node_modules/drizzle-orm/pg-core/unique-constraint.js
var uniqueKeyName = function(table10, columns) {
  return `${table10[PgTable.Symbol.Name]}_${columns.join("_")}_unique`;
};

// node_modules/drizzle-orm/pg-core/utils/array.js
var parsePgArrayValue = function(arrayString, startFrom, inQuotes) {
  for (let i = startFrom;i < arrayString.length; i++) {
    const char = arrayString[i];
    if (char === "\\") {
      i++;
      continue;
    }
    if (char === '"') {
      return [arrayString.slice(startFrom, i).replace(/\\/g, ""), i + 1];
    }
    if (inQuotes) {
      continue;
    }
    if (char === "," || char === "}") {
      return [arrayString.slice(startFrom, i).replace(/\\/g, ""), i];
    }
  }
  return [arrayString.slice(startFrom).replace(/\\/g, ""), arrayString.length];
};
var parsePgNestedArray = function(arrayString, startFrom = 0) {
  const result = [];
  let i = startFrom;
  let lastCharIsComma = false;
  while (i < arrayString.length) {
    const char = arrayString[i];
    if (char === ",") {
      if (lastCharIsComma || i === startFrom) {
        result.push("");
      }
      lastCharIsComma = true;
      i++;
      continue;
    }
    lastCharIsComma = false;
    if (char === "\\") {
      i += 2;
      continue;
    }
    if (char === '"') {
      const [value2, startFrom2] = parsePgArrayValue(arrayString, i + 1, true);
      result.push(value2);
      i = startFrom2;
      continue;
    }
    if (char === "}") {
      return [result, i + 1];
    }
    if (char === "{") {
      const [value2, startFrom2] = parsePgNestedArray(arrayString, i + 1);
      result.push(value2);
      i = startFrom2;
      continue;
    }
    const [value, newStartFrom] = parsePgArrayValue(arrayString, i, false);
    result.push(value);
    i = newStartFrom;
  }
  return [result, i];
};
var parsePgArray = function(arrayString) {
  const [result] = parsePgNestedArray(arrayString, 1);
  return result;
};
var makePgArray = function(array) {
  return `{${array.map((item) => {
    if (Array.isArray(item)) {
      return makePgArray(item);
    }
    if (typeof item === "string" && item.includes(",")) {
      return `"${item.replace(/"/g, '\\"')}"`;
    }
    return `${item}`;
  }).join(",")}}`;
};

// node_modules/drizzle-orm/pg-core/columns/common.js
class PgColumnBuilder extends ColumnBuilder {
  foreignKeyConfigs = [];
  static [entityKind] = "PgColumnBuilder";
  array(size) {
    return new PgArrayBuilder(this.config.name, this, size);
  }
  references(ref, actions = {}) {
    this.foreignKeyConfigs.push({ ref, actions });
    return this;
  }
  unique(name, config) {
    this.config.isUnique = true;
    this.config.uniqueName = name;
    this.config.uniqueType = config?.nulls;
    return this;
  }
  buildForeignKeys(column7, table10) {
    return this.foreignKeyConfigs.map(({ ref, actions }) => {
      return iife((ref2, actions2) => {
        const builder = new ForeignKeyBuilder(() => {
          const foreignColumn = ref2();
          return { columns: [column7], foreignColumns: [foreignColumn] };
        });
        if (actions2.onUpdate) {
          builder.onUpdate(actions2.onUpdate);
        }
        if (actions2.onDelete) {
          builder.onDelete(actions2.onDelete);
        }
        return builder.build(table10);
      }, ref, actions);
    });
  }
}

class PgColumn extends Column {
  constructor(table10, config) {
    if (!config.uniqueName) {
      config.uniqueName = uniqueKeyName(table10, [config.name]);
    }
    super(table10, config);
    this.table = table10;
  }
  static [entityKind] = "PgColumn";
}

class PgArrayBuilder extends PgColumnBuilder {
  static [entityKind] = "PgArrayBuilder";
  constructor(name, baseBuilder, size) {
    super(name, "array", "PgArray");
    this.config.baseBuilder = baseBuilder;
    this.config.size = size;
  }
  build(table10) {
    const baseColumn = this.config.baseBuilder.build(table10);
    return new PgArray(table10, this.config, baseColumn);
  }
}

class PgArray extends PgColumn {
  constructor(table10, config, baseColumn, range) {
    super(table10, config);
    this.baseColumn = baseColumn;
    this.range = range;
    this.size = config.size;
  }
  size;
  static [entityKind] = "PgArray";
  getSQLType() {
    return `${this.baseColumn.getSQLType()}[${typeof this.size === "number" ? this.size : ""}]`;
  }
  mapFromDriverValue(value) {
    if (typeof value === "string") {
      value = parsePgArray(value);
    }
    return value.map((v) => this.baseColumn.mapFromDriverValue(v));
  }
  mapToDriverValue(value, isNestedArray = false) {
    const a = value.map((v) => v === null ? null : is(this.baseColumn, PgArray) ? this.baseColumn.mapToDriverValue(v, true) : this.baseColumn.mapToDriverValue(v));
    if (isNestedArray)
      return a;
    return makePgArray(a);
  }
}

// node_modules/drizzle-orm/pg-core/columns/char.js
class PgChar extends PgColumn {
  static [entityKind] = "PgChar";
  length = this.config.length;
  enumValues = this.config.enumValues;
  getSQLType() {
    return this.length === undefined ? `char` : `char(${this.length})`;
  }
}

// node_modules/drizzle-orm/pg-core/columns/date.common.js
class PgDateColumnBaseBuilder extends PgColumnBuilder {
  static [entityKind] = "PgDateColumnBaseBuilder";
  defaultNow() {
    return this.default(sql2`now()`);
  }
}

// node_modules/drizzle-orm/pg-core/columns/date.js
class PgDate extends PgColumn {
  static [entityKind] = "PgDate";
  getSQLType() {
    return "date";
  }
  mapFromDriverValue(value) {
    return new Date(value);
  }
  mapToDriverValue(value) {
    return value.toISOString();
  }
}

// node_modules/drizzle-orm/pg-core/columns/enum.js
var pgEnum = function(enumName, values) {
  const enumInstance = Object.assign((name) => new PgEnumColumnBuilder(name, enumInstance), {
    enumName,
    enumValues: values,
    [isPgEnumSym]: true
  });
  return enumInstance;
};
var isPgEnumSym = Symbol.for("drizzle:isPgEnum");

class PgEnumColumnBuilder extends PgColumnBuilder {
  static [entityKind] = "PgEnumColumnBuilder";
  constructor(name, enumInstance) {
    super(name, "string", "PgEnumColumn");
    this.config.enum = enumInstance;
  }
  build(table10) {
    return new PgEnumColumn(table10, this.config);
  }
}

class PgEnumColumn extends PgColumn {
  static [entityKind] = "PgEnumColumn";
  enum = this.config.enum;
  enumValues = this.config.enum.enumValues;
  constructor(table10, config) {
    super(table10, config);
    this.enum = config.enum;
  }
  getSQLType() {
    return this.enum.enumName;
  }
}

// node_modules/drizzle-orm/pg-core/columns/integer.js
var integer = function(name) {
  return new PgIntegerBuilder(name);
};

class PgIntegerBuilder extends PgColumnBuilder {
  static [entityKind] = "PgIntegerBuilder";
  constructor(name) {
    super(name, "number", "PgInteger");
  }
  build(table10) {
    return new PgInteger(table10, this.config);
  }
}

class PgInteger extends PgColumn {
  static [entityKind] = "PgInteger";
  getSQLType() {
    return "integer";
  }
  mapFromDriverValue(value) {
    if (typeof value === "string") {
      return Number.parseInt(value);
    }
    return value;
  }
}

// node_modules/drizzle-orm/pg-core/columns/json.js
class PgJson extends PgColumn {
  static [entityKind] = "PgJson";
  constructor(table10, config) {
    super(table10, config);
  }
  getSQLType() {
    return "json";
  }
  mapToDriverValue(value) {
    return JSON.stringify(value);
  }
  mapFromDriverValue(value) {
    if (typeof value === "string") {
      try {
        return JSON.parse(value);
      } catch {
        return value;
      }
    }
    return value;
  }
}

// node_modules/drizzle-orm/pg-core/columns/jsonb.js
class PgJsonb extends PgColumn {
  static [entityKind] = "PgJsonb";
  constructor(table10, config) {
    super(table10, config);
  }
  getSQLType() {
    return "jsonb";
  }
  mapToDriverValue(value) {
    return JSON.stringify(value);
  }
  mapFromDriverValue(value) {
    if (typeof value === "string") {
      try {
        return JSON.parse(value);
      } catch {
        return value;
      }
    }
    return value;
  }
}

// node_modules/drizzle-orm/pg-core/columns/numeric.js
class PgNumeric extends PgColumn {
  static [entityKind] = "PgNumeric";
  precision;
  scale;
  constructor(table10, config) {
    super(table10, config);
    this.precision = config.precision;
    this.scale = config.scale;
  }
  getSQLType() {
    if (this.precision !== undefined && this.scale !== undefined) {
      return `numeric(${this.precision}, ${this.scale})`;
    } else if (this.precision === undefined) {
      return "numeric";
    } else {
      return `numeric(${this.precision})`;
    }
  }
}

// node_modules/drizzle-orm/pg-core/columns/text.js
var text = function(name, config = {}) {
  return new PgTextBuilder(name, config);
};

class PgTextBuilder extends PgColumnBuilder {
  static [entityKind] = "PgTextBuilder";
  constructor(name, config) {
    super(name, "string", "PgText");
    this.config.enumValues = config.enum;
  }
  build(table10) {
    return new PgText(table10, this.config);
  }
}

class PgText extends PgColumn {
  static [entityKind] = "PgText";
  enumValues = this.config.enumValues;
  getSQLType() {
    return "text";
  }
}

// node_modules/drizzle-orm/pg-core/columns/time.js
class PgTime extends PgColumn {
  static [entityKind] = "PgTime";
  withTimezone;
  precision;
  constructor(table10, config) {
    super(table10, config);
    this.withTimezone = config.withTimezone;
    this.precision = config.precision;
  }
  getSQLType() {
    const precision = this.precision === undefined ? "" : `(${this.precision})`;
    return `time${precision}${this.withTimezone ? " with time zone" : ""}`;
  }
}

// node_modules/drizzle-orm/pg-core/columns/timestamp.js
var timestamp = function(name, config = {}) {
  if (config.mode === "string") {
    return new PgTimestampStringBuilder(name, config.withTimezone ?? false, config.precision);
  }
  return new PgTimestampBuilder(name, config.withTimezone ?? false, config.precision);
};

class PgTimestampBuilder extends PgDateColumnBaseBuilder {
  static [entityKind] = "PgTimestampBuilder";
  constructor(name, withTimezone, precision) {
    super(name, "date", "PgTimestamp");
    this.config.withTimezone = withTimezone;
    this.config.precision = precision;
  }
  build(table10) {
    return new PgTimestamp(table10, this.config);
  }
}

class PgTimestamp extends PgColumn {
  static [entityKind] = "PgTimestamp";
  withTimezone;
  precision;
  constructor(table10, config) {
    super(table10, config);
    this.withTimezone = config.withTimezone;
    this.precision = config.precision;
  }
  getSQLType() {
    const precision = this.precision === undefined ? "" : ` (${this.precision})`;
    return `timestamp${precision}${this.withTimezone ? " with time zone" : ""}`;
  }
  mapFromDriverValue = (value) => {
    return new Date(this.withTimezone ? value : value + "+0000");
  };
  mapToDriverValue = (value) => {
    return this.withTimezone ? value.toUTCString() : value.toISOString();
  };
}

class PgTimestampStringBuilder extends PgDateColumnBaseBuilder {
  static [entityKind] = "PgTimestampStringBuilder";
  constructor(name, withTimezone, precision) {
    super(name, "string", "PgTimestampString");
    this.config.withTimezone = withTimezone;
    this.config.precision = precision;
  }
  build(table10) {
    return new PgTimestampString(table10, this.config);
  }
}

class PgTimestampString extends PgColumn {
  static [entityKind] = "PgTimestampString";
  withTimezone;
  precision;
  constructor(table10, config) {
    super(table10, config);
    this.withTimezone = config.withTimezone;
    this.precision = config.precision;
  }
  getSQLType() {
    const precision = this.precision === undefined ? "" : `(${this.precision})`;
    return `timestamp${precision}${this.withTimezone ? " with time zone" : ""}`;
  }
}

// node_modules/drizzle-orm/pg-core/columns/uuid.js
class PgUUID extends PgColumn {
  static [entityKind] = "PgUUID";
  getSQLType() {
    return "uuid";
  }
}

// node_modules/drizzle-orm/pg-core/columns/varchar.js
class PgVarchar extends PgColumn {
  static [entityKind] = "PgVarchar";
  length = this.config.length;
  enumValues = this.config.enumValues;
  getSQLType() {
    return this.length === undefined ? `varchar` : `varchar(${this.length})`;
  }
}

// node_modules/drizzle-orm/pg-core/query-builders/delete.js
class PgDeleteBase extends QueryPromise {
  constructor(table11, session, dialect) {
    super();
    this.session = session;
    this.dialect = dialect;
    this.config = { table: table11 };
  }
  static [entityKind] = "PgDelete";
  config;
  where(where) {
    this.config.where = where;
    return this;
  }
  returning(fields = this.config.table[Table.Symbol.Columns]) {
    this.config.returning = orderSelectedFields(fields);
    return this;
  }
  getSQL() {
    return this.dialect.buildDeleteQuery(this.config);
  }
  toSQL() {
    const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
    return rest;
  }
  _prepare(name) {
    return tracer.startActiveSpan("drizzle.prepareQuery", () => {
      return this.session.prepareQuery(this.dialect.sqlToQuery(this.getSQL()), this.config.returning, name);
    });
  }
  prepare(name) {
    return this._prepare(name);
  }
  execute = (placeholderValues) => {
    return tracer.startActiveSpan("drizzle.operation", () => {
      return this._prepare().execute(placeholderValues);
    });
  };
  $dynamic() {
    return this;
  }
}

// node_modules/drizzle-orm/pg-core/query-builders/insert.js
class PgInsertBuilder {
  constructor(table12, session, dialect) {
    this.table = table12;
    this.session = session;
    this.dialect = dialect;
  }
  static [entityKind] = "PgInsertBuilder";
  values(values) {
    values = Array.isArray(values) ? values : [values];
    if (values.length === 0) {
      throw new Error("values() must be called with at least one value");
    }
    const mappedValues = values.map((entry) => {
      const result = {};
      const cols = this.table[Table.Symbol.Columns];
      for (const colKey of Object.keys(entry)) {
        const colValue = entry[colKey];
        result[colKey] = is(colValue, SQL) ? colValue : new Param(colValue, cols[colKey]);
      }
      return result;
    });
    return new PgInsertBase(this.table, mappedValues, this.session, this.dialect);
  }
}

class PgInsertBase extends QueryPromise {
  constructor(table12, values, session, dialect) {
    super();
    this.session = session;
    this.dialect = dialect;
    this.config = { table: table12, values };
  }
  static [entityKind] = "PgInsert";
  config;
  returning(fields = this.config.table[Table.Symbol.Columns]) {
    this.config.returning = orderSelectedFields(fields);
    return this;
  }
  onConflictDoNothing(config = {}) {
    if (config.target === undefined) {
      this.config.onConflict = sql2`do nothing`;
    } else {
      let targetColumn = "";
      targetColumn = Array.isArray(config.target) ? config.target.map((it) => this.dialect.escapeName(it.name)).join(",") : this.dialect.escapeName(config.target.name);
      const whereSql = config.where ? sql2` where ${config.where}` : undefined;
      this.config.onConflict = sql2`(${sql2.raw(targetColumn)}) do nothing${whereSql}`;
    }
    return this;
  }
  onConflictDoUpdate(config) {
    const whereSql = config.where ? sql2` where ${config.where}` : undefined;
    const setSql = this.dialect.buildUpdateSet(this.config.table, mapUpdateSet(this.config.table, config.set));
    let targetColumn = "";
    targetColumn = Array.isArray(config.target) ? config.target.map((it) => this.dialect.escapeName(it.name)).join(",") : this.dialect.escapeName(config.target.name);
    this.config.onConflict = sql2`(${sql2.raw(targetColumn)}) do update set ${setSql}${whereSql}`;
    return this;
  }
  getSQL() {
    return this.dialect.buildInsertQuery(this.config);
  }
  toSQL() {
    const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
    return rest;
  }
  _prepare(name) {
    return tracer.startActiveSpan("drizzle.prepareQuery", () => {
      return this.session.prepareQuery(this.dialect.sqlToQuery(this.getSQL()), this.config.returning, name);
    });
  }
  prepare(name) {
    return this._prepare(name);
  }
  execute = (placeholderValues) => {
    return tracer.startActiveSpan("drizzle.operation", () => {
      return this._prepare().execute(placeholderValues);
    });
  };
  $dynamic() {
    return this;
  }
}

// node_modules/drizzle-orm/pg-core/view-base.js
class PgViewBase extends View {
  static [entityKind] = "PgViewBase";
}

// node_modules/drizzle-orm/pg-core/dialect.js
class PgDialect {
  static [entityKind] = "PgDialect";
  async migrate(migrations, session) {
    const migrationTableCreate = sql2`
			CREATE TABLE IF NOT EXISTS "drizzle"."__drizzle_migrations" (
				id SERIAL PRIMARY KEY,
				hash text NOT NULL,
				created_at bigint
			)
		`;
    await session.execute(sql2`CREATE SCHEMA IF NOT EXISTS "drizzle"`);
    await session.execute(migrationTableCreate);
    const dbMigrations = await session.all(sql2`select id, hash, created_at from "drizzle"."__drizzle_migrations" order by created_at desc limit 1`);
    const lastDbMigration = dbMigrations[0];
    await session.transaction(async (tx) => {
      for await (const migration of migrations) {
        if (!lastDbMigration || Number(lastDbMigration.created_at) < migration.folderMillis) {
          for (const stmt of migration.sql) {
            await tx.execute(sql2.raw(stmt));
          }
          await tx.execute(sql2`insert into "drizzle"."__drizzle_migrations" ("hash", "created_at") values(${migration.hash}, ${migration.folderMillis})`);
        }
      }
    });
  }
  escapeName(name) {
    return `"${name}"`;
  }
  escapeParam(num) {
    return `\$${num + 1}`;
  }
  escapeString(str) {
    return `'${str.replace(/'/g, "''")}'`;
  }
  buildDeleteQuery({ table: table14, where, returning }) {
    const returningSql = returning ? sql2` returning ${this.buildSelection(returning, { isSingleTable: true })}` : undefined;
    const whereSql = where ? sql2` where ${where}` : undefined;
    return sql2`delete from ${table14}${whereSql}${returningSql}`;
  }
  buildUpdateSet(table14, set) {
    const setEntries = Object.entries(set);
    const setSize = setEntries.length;
    return sql2.join(setEntries.flatMap(([colName, value], i) => {
      const col = table14[Table.Symbol.Columns][colName];
      const res = sql2`${sql2.identifier(col.name)} = ${value}`;
      if (i < setSize - 1) {
        return [res, sql2.raw(", ")];
      }
      return [res];
    }));
  }
  buildUpdateQuery({ table: table14, set, where, returning }) {
    const setSql = this.buildUpdateSet(table14, set);
    const returningSql = returning ? sql2` returning ${this.buildSelection(returning, { isSingleTable: true })}` : undefined;
    const whereSql = where ? sql2` where ${where}` : undefined;
    return sql2`update ${table14} set ${setSql}${whereSql}${returningSql}`;
  }
  buildSelection(fields, { isSingleTable = false } = {}) {
    const columnsLen = fields.length;
    const chunks = fields.flatMap(({ field }, i) => {
      const chunk = [];
      if (is(field, SQL.Aliased) && field.isSelectionField) {
        chunk.push(sql2.identifier(field.fieldAlias));
      } else if (is(field, SQL.Aliased) || is(field, SQL)) {
        const query = is(field, SQL.Aliased) ? field.sql : field;
        if (isSingleTable) {
          chunk.push(new SQL(query.queryChunks.map((c2) => {
            if (is(c2, PgColumn)) {
              return sql2.identifier(c2.name);
            }
            return c2;
          })));
        } else {
          chunk.push(query);
        }
        if (is(field, SQL.Aliased)) {
          chunk.push(sql2` as ${sql2.identifier(field.fieldAlias)}`);
        }
      } else if (is(field, Column)) {
        if (isSingleTable) {
          chunk.push(sql2.identifier(field.name));
        } else {
          chunk.push(field);
        }
      }
      if (i < columnsLen - 1) {
        chunk.push(sql2`, `);
      }
      return chunk;
    });
    return sql2.join(chunks);
  }
  buildSelectQuery({
    withList,
    fields,
    fieldsFlat,
    where,
    having,
    table: table14,
    joins,
    orderBy,
    groupBy,
    limit,
    offset,
    lockingClause,
    distinct,
    setOperators
  }) {
    const fieldsList = fieldsFlat ?? orderSelectedFields(fields);
    for (const f of fieldsList) {
      if (is(f.field, Column) && getTableName(f.field.table) !== (is(table14, Subquery) ? table14[SubqueryConfig].alias : is(table14, PgViewBase) ? table14[ViewBaseConfig].name : is(table14, SQL) ? undefined : getTableName(table14)) && !((table22) => joins?.some(({ alias: alias2 }) => alias2 === (table22[Table.Symbol.IsAlias] ? getTableName(table22) : table22[Table.Symbol.BaseName])))(f.field.table)) {
        const tableName = getTableName(f.field.table);
        throw new Error(`Your "${f.path.join("->")}" field references a column "${tableName}"."${f.field.name}", but the table "${tableName}" is not part of the query! Did you forget to join it?`);
      }
    }
    const isSingleTable = !joins || joins.length === 0;
    let withSql;
    if (withList?.length) {
      const withSqlChunks = [sql2`with `];
      for (const [i, w] of withList.entries()) {
        withSqlChunks.push(sql2`${sql2.identifier(w[SubqueryConfig].alias)} as (${w[SubqueryConfig].sql})`);
        if (i < withList.length - 1) {
          withSqlChunks.push(sql2`, `);
        }
      }
      withSqlChunks.push(sql2` `);
      withSql = sql2.join(withSqlChunks);
    }
    let distinctSql;
    if (distinct) {
      distinctSql = distinct === true ? sql2` distinct` : sql2` distinct on (${sql2.join(distinct.on, sql2`, `)})`;
    }
    const selection = this.buildSelection(fieldsList, { isSingleTable });
    const tableSql = (() => {
      if (is(table14, Table) && table14[Table.Symbol.OriginalName] !== table14[Table.Symbol.Name]) {
        let fullName = sql2`${sql2.identifier(table14[Table.Symbol.OriginalName])}`;
        if (table14[Table.Symbol.Schema]) {
          fullName = sql2`${sql2.identifier(table14[Table.Symbol.Schema])}.${fullName}`;
        }
        return sql2`${fullName} ${sql2.identifier(table14[Table.Symbol.Name])}`;
      }
      return table14;
    })();
    const joinsArray = [];
    if (joins) {
      for (const [index, joinMeta] of joins.entries()) {
        if (index === 0) {
          joinsArray.push(sql2` `);
        }
        const table22 = joinMeta.table;
        const lateralSql = joinMeta.lateral ? sql2` lateral` : undefined;
        if (is(table22, PgTable)) {
          const tableName = table22[PgTable.Symbol.Name];
          const tableSchema = table22[PgTable.Symbol.Schema];
          const origTableName = table22[PgTable.Symbol.OriginalName];
          const alias2 = tableName === origTableName ? undefined : joinMeta.alias;
          joinsArray.push(sql2`${sql2.raw(joinMeta.joinType)} join${lateralSql} ${tableSchema ? sql2`${sql2.identifier(tableSchema)}.` : undefined}${sql2.identifier(origTableName)}${alias2 && sql2` ${sql2.identifier(alias2)}`} on ${joinMeta.on}`);
        } else if (is(table22, View)) {
          const viewName = table22[ViewBaseConfig].name;
          const viewSchema = table22[ViewBaseConfig].schema;
          const origViewName = table22[ViewBaseConfig].originalName;
          const alias2 = viewName === origViewName ? undefined : joinMeta.alias;
          joinsArray.push(sql2`${sql2.raw(joinMeta.joinType)} join${lateralSql} ${viewSchema ? sql2`${sql2.identifier(viewSchema)}.` : undefined}${sql2.identifier(origViewName)}${alias2 && sql2` ${sql2.identifier(alias2)}`} on ${joinMeta.on}`);
        } else {
          joinsArray.push(sql2`${sql2.raw(joinMeta.joinType)} join${lateralSql} ${table22} on ${joinMeta.on}`);
        }
        if (index < joins.length - 1) {
          joinsArray.push(sql2` `);
        }
      }
    }
    const joinsSql = sql2.join(joinsArray);
    const whereSql = where ? sql2` where ${where}` : undefined;
    const havingSql = having ? sql2` having ${having}` : undefined;
    let orderBySql;
    if (orderBy && orderBy.length > 0) {
      orderBySql = sql2` order by ${sql2.join(orderBy, sql2`, `)}`;
    }
    let groupBySql;
    if (groupBy && groupBy.length > 0) {
      groupBySql = sql2` group by ${sql2.join(groupBy, sql2`, `)}`;
    }
    const limitSql = limit ? sql2` limit ${limit}` : undefined;
    const offsetSql = offset ? sql2` offset ${offset}` : undefined;
    const lockingClauseSql = sql2.empty();
    if (lockingClause) {
      const clauseSql = sql2` for ${sql2.raw(lockingClause.strength)}`;
      if (lockingClause.config.of) {
        clauseSql.append(sql2` of ${sql2.join(Array.isArray(lockingClause.config.of) ? lockingClause.config.of : [lockingClause.config.of], sql2`, `)}`);
      }
      if (lockingClause.config.noWait) {
        clauseSql.append(sql2` no wait`);
      } else if (lockingClause.config.skipLocked) {
        clauseSql.append(sql2` skip locked`);
      }
      lockingClauseSql.append(clauseSql);
    }
    const finalQuery = sql2`${withSql}select${distinctSql} ${selection} from ${tableSql}${joinsSql}${whereSql}${groupBySql}${havingSql}${orderBySql}${limitSql}${offsetSql}${lockingClauseSql}`;
    if (setOperators.length > 0) {
      return this.buildSetOperations(finalQuery, setOperators);
    }
    return finalQuery;
  }
  buildSetOperations(leftSelect, setOperators) {
    const [setOperator, ...rest] = setOperators;
    if (!setOperator) {
      throw new Error("Cannot pass undefined values to any set operator");
    }
    if (rest.length === 0) {
      return this.buildSetOperationQuery({ leftSelect, setOperator });
    }
    return this.buildSetOperations(this.buildSetOperationQuery({ leftSelect, setOperator }), rest);
  }
  buildSetOperationQuery({
    leftSelect,
    setOperator: { type, isAll, rightSelect, limit, orderBy, offset }
  }) {
    const leftChunk = sql2`(${leftSelect.getSQL()}) `;
    const rightChunk = sql2`(${rightSelect.getSQL()})`;
    let orderBySql;
    if (orderBy && orderBy.length > 0) {
      const orderByValues = [];
      for (const singleOrderBy of orderBy) {
        if (is(singleOrderBy, PgColumn)) {
          orderByValues.push(sql2.identifier(singleOrderBy.name));
        } else if (is(singleOrderBy, SQL)) {
          for (let i = 0;i < singleOrderBy.queryChunks.length; i++) {
            const chunk = singleOrderBy.queryChunks[i];
            if (is(chunk, PgColumn)) {
              singleOrderBy.queryChunks[i] = sql2.identifier(chunk.name);
            }
          }
          orderByValues.push(sql2`${singleOrderBy}`);
        } else {
          orderByValues.push(sql2`${singleOrderBy}`);
        }
      }
      orderBySql = sql2` order by ${sql2.join(orderByValues, sql2`, `)} `;
    }
    const limitSql = limit ? sql2` limit ${limit}` : undefined;
    const operatorChunk = sql2.raw(`${type} ${isAll ? "all " : ""}`);
    const offsetSql = offset ? sql2` offset ${offset}` : undefined;
    return sql2`${leftChunk}${operatorChunk}${rightChunk}${orderBySql}${limitSql}${offsetSql}`;
  }
  buildInsertQuery({ table: table14, values, onConflict, returning }) {
    const valuesSqlList = [];
    const columns2 = table14[Table.Symbol.Columns];
    const colEntries = Object.entries(columns2);
    const insertOrder = colEntries.map(([, column8]) => sql2.identifier(column8.name));
    for (const [valueIndex, value] of values.entries()) {
      const valueList = [];
      for (const [fieldName, col] of colEntries) {
        const colValue = value[fieldName];
        if (colValue === undefined || is(colValue, Param) && colValue.value === undefined) {
          if (col.defaultFn !== undefined) {
            const defaultFnResult = col.defaultFn();
            const defaultValue = is(defaultFnResult, SQL) ? defaultFnResult : sql2.param(defaultFnResult, col);
            valueList.push(defaultValue);
          } else {
            valueList.push(sql2`default`);
          }
        } else {
          valueList.push(colValue);
        }
      }
      valuesSqlList.push(valueList);
      if (valueIndex < values.length - 1) {
        valuesSqlList.push(sql2`, `);
      }
    }
    const valuesSql = sql2.join(valuesSqlList);
    const returningSql = returning ? sql2` returning ${this.buildSelection(returning, { isSingleTable: true })}` : undefined;
    const onConflictSql = onConflict ? sql2` on conflict ${onConflict}` : undefined;
    return sql2`insert into ${table14} ${insertOrder} values ${valuesSql}${onConflictSql}${returningSql}`;
  }
  buildRefreshMaterializedViewQuery({ view, concurrently, withNoData }) {
    const concurrentlySql = concurrently ? sql2` concurrently` : undefined;
    const withNoDataSql = withNoData ? sql2` with no data` : undefined;
    return sql2`refresh materialized view${concurrentlySql} ${view}${withNoDataSql}`;
  }
  prepareTyping(encoder) {
    if (is(encoder, PgJsonb) || is(encoder, PgJson)) {
      return "json";
    } else if (is(encoder, PgNumeric)) {
      return "decimal";
    } else if (is(encoder, PgTime)) {
      return "time";
    } else if (is(encoder, PgTimestamp)) {
      return "timestamp";
    } else if (is(encoder, PgDate)) {
      return "date";
    } else if (is(encoder, PgUUID)) {
      return "uuid";
    } else {
      return "none";
    }
  }
  sqlToQuery(sql22) {
    return sql22.toQuery({
      escapeName: this.escapeName,
      escapeParam: this.escapeParam,
      escapeString: this.escapeString,
      prepareTyping: this.prepareTyping
    });
  }
  buildRelationalQueryWithoutPK({
    fullSchema,
    schema,
    tableNamesMap,
    table: table14,
    tableConfig,
    queryConfig: config,
    tableAlias,
    nestedQueryRelation,
    joinOn
  }) {
    let selection = [];
    let limit, offset, orderBy = [], where;
    const joins = [];
    if (config === true) {
      const selectionEntries = Object.entries(tableConfig.columns);
      selection = selectionEntries.map(([key, value]) => ({
        dbKey: value.name,
        tsKey: key,
        field: aliasedTableColumn(value, tableAlias),
        relationTableTsKey: undefined,
        isJson: false,
        selection: []
      }));
    } else {
      const aliasedColumns = Object.fromEntries(Object.entries(tableConfig.columns).map(([key, value]) => [key, aliasedTableColumn(value, tableAlias)]));
      if (config.where) {
        const whereSql = typeof config.where === "function" ? config.where(aliasedColumns, getOperators()) : config.where;
        where = whereSql && mapColumnsInSQLToAlias(whereSql, tableAlias);
      }
      const fieldsSelection = [];
      let selectedColumns = [];
      if (config.columns) {
        let isIncludeMode = false;
        for (const [field, value] of Object.entries(config.columns)) {
          if (value === undefined) {
            continue;
          }
          if (field in tableConfig.columns) {
            if (!isIncludeMode && value === true) {
              isIncludeMode = true;
            }
            selectedColumns.push(field);
          }
        }
        if (selectedColumns.length > 0) {
          selectedColumns = isIncludeMode ? selectedColumns.filter((c2) => config.columns?.[c2] === true) : Object.keys(tableConfig.columns).filter((key) => !selectedColumns.includes(key));
        }
      } else {
        selectedColumns = Object.keys(tableConfig.columns);
      }
      for (const field of selectedColumns) {
        const column8 = tableConfig.columns[field];
        fieldsSelection.push({ tsKey: field, value: column8 });
      }
      let selectedRelations = [];
      if (config.with) {
        selectedRelations = Object.entries(config.with).filter((entry) => !!entry[1]).map(([tsKey, queryConfig]) => ({ tsKey, queryConfig, relation: tableConfig.relations[tsKey] }));
      }
      let extras;
      if (config.extras) {
        extras = typeof config.extras === "function" ? config.extras(aliasedColumns, { sql: sql2 }) : config.extras;
        for (const [tsKey, value] of Object.entries(extras)) {
          fieldsSelection.push({
            tsKey,
            value: mapColumnsInAliasedSQLToAlias(value, tableAlias)
          });
        }
      }
      for (const { tsKey, value } of fieldsSelection) {
        selection.push({
          dbKey: is(value, SQL.Aliased) ? value.fieldAlias : tableConfig.columns[tsKey].name,
          tsKey,
          field: is(value, Column) ? aliasedTableColumn(value, tableAlias) : value,
          relationTableTsKey: undefined,
          isJson: false,
          selection: []
        });
      }
      let orderByOrig = typeof config.orderBy === "function" ? config.orderBy(aliasedColumns, getOrderByOperators()) : config.orderBy ?? [];
      if (!Array.isArray(orderByOrig)) {
        orderByOrig = [orderByOrig];
      }
      orderBy = orderByOrig.map((orderByValue) => {
        if (is(orderByValue, Column)) {
          return aliasedTableColumn(orderByValue, tableAlias);
        }
        return mapColumnsInSQLToAlias(orderByValue, tableAlias);
      });
      limit = config.limit;
      offset = config.offset;
      for (const {
        tsKey: selectedRelationTsKey,
        queryConfig: selectedRelationConfigValue,
        relation
      } of selectedRelations) {
        const normalizedRelation = normalizeRelation(schema, tableNamesMap, relation);
        const relationTableName = relation.referencedTable[Table.Symbol.Name];
        const relationTableTsName = tableNamesMap[relationTableName];
        const relationTableAlias = `${tableAlias}_${selectedRelationTsKey}`;
        const joinOn2 = and(...normalizedRelation.fields.map((field2, i) => eq(aliasedTableColumn(normalizedRelation.references[i], relationTableAlias), aliasedTableColumn(field2, tableAlias))));
        const builtRelation = this.buildRelationalQueryWithoutPK({
          fullSchema,
          schema,
          tableNamesMap,
          table: fullSchema[relationTableTsName],
          tableConfig: schema[relationTableTsName],
          queryConfig: is(relation, One) ? selectedRelationConfigValue === true ? { limit: 1 } : { ...selectedRelationConfigValue, limit: 1 } : selectedRelationConfigValue,
          tableAlias: relationTableAlias,
          joinOn: joinOn2,
          nestedQueryRelation: relation
        });
        const field = sql2`${sql2.identifier(relationTableAlias)}.${sql2.identifier("data")}`.as(selectedRelationTsKey);
        joins.push({
          on: sql2`true`,
          table: new Subquery(builtRelation.sql, {}, relationTableAlias),
          alias: relationTableAlias,
          joinType: "left",
          lateral: true
        });
        selection.push({
          dbKey: selectedRelationTsKey,
          tsKey: selectedRelationTsKey,
          field,
          relationTableTsKey: relationTableTsName,
          isJson: true,
          selection: builtRelation.selection
        });
      }
    }
    if (selection.length === 0) {
      throw new DrizzleError({ message: `No fields selected for table "${tableConfig.tsName}" ("${tableAlias}")` });
    }
    let result;
    where = and(joinOn, where);
    if (nestedQueryRelation) {
      let field = sql2`json_build_array(${sql2.join(selection.map(({ field: field2, tsKey, isJson }) => isJson ? sql2`${sql2.identifier(`${tableAlias}_${tsKey}`)}.${sql2.identifier("data")}` : is(field2, SQL.Aliased) ? field2.sql : field2), sql2`, `)})`;
      if (is(nestedQueryRelation, Many)) {
        field = sql2`coalesce(json_agg(${field}${orderBy.length > 0 ? sql2` order by ${sql2.join(orderBy, sql2`, `)}` : undefined}), '[]'::json)`;
      }
      const nestedSelection = [{
        dbKey: "data",
        tsKey: "data",
        field: field.as("data"),
        isJson: true,
        relationTableTsKey: tableConfig.tsName,
        selection
      }];
      const needsSubquery = limit !== undefined || offset !== undefined || orderBy.length > 0;
      if (needsSubquery) {
        result = this.buildSelectQuery({
          table: aliasedTable(table14, tableAlias),
          fields: {},
          fieldsFlat: [{
            path: [],
            field: sql2.raw("*")
          }],
          where,
          limit,
          offset,
          orderBy,
          setOperators: []
        });
        where = undefined;
        limit = undefined;
        offset = undefined;
        orderBy = [];
      } else {
        result = aliasedTable(table14, tableAlias);
      }
      result = this.buildSelectQuery({
        table: is(result, PgTable) ? result : new Subquery(result, {}, tableAlias),
        fields: {},
        fieldsFlat: nestedSelection.map(({ field: field2 }) => ({
          path: [],
          field: is(field2, Column) ? aliasedTableColumn(field2, tableAlias) : field2
        })),
        joins,
        where,
        limit,
        offset,
        orderBy,
        setOperators: []
      });
    } else {
      result = this.buildSelectQuery({
        table: aliasedTable(table14, tableAlias),
        fields: {},
        fieldsFlat: selection.map(({ field }) => ({
          path: [],
          field: is(field, Column) ? aliasedTableColumn(field, tableAlias) : field
        })),
        joins,
        where,
        limit,
        offset,
        orderBy,
        setOperators: []
      });
    }
    return {
      tableTsKey: tableConfig.tsName,
      sql: result,
      selection
    };
  }
}

// node_modules/drizzle-orm/query-builders/query-builder.js
class TypedQueryBuilder {
  static [entityKind] = "TypedQueryBuilder";
  getSelectedFields() {
    return this._.selectedFields;
  }
}

// node_modules/drizzle-orm/selection-proxy.js
class SelectionProxyHandler {
  static [entityKind] = "SelectionProxyHandler";
  config;
  constructor(config) {
    this.config = { ...config };
  }
  get(subquery5, prop) {
    if (prop === SubqueryConfig) {
      return {
        ...subquery5[SubqueryConfig],
        selection: new Proxy(subquery5[SubqueryConfig].selection, this)
      };
    }
    if (prop === ViewBaseConfig) {
      return {
        ...subquery5[ViewBaseConfig],
        selectedFields: new Proxy(subquery5[ViewBaseConfig].selectedFields, this)
      };
    }
    if (typeof prop === "symbol") {
      return subquery5[prop];
    }
    const columns2 = is(subquery5, Subquery) ? subquery5[SubqueryConfig].selection : is(subquery5, View) ? subquery5[ViewBaseConfig].selectedFields : subquery5;
    const value = columns2[prop];
    if (is(value, SQL.Aliased)) {
      if (this.config.sqlAliasedBehavior === "sql" && !value.isSelectionField) {
        return value.sql;
      }
      const newValue = value.clone();
      newValue.isSelectionField = true;
      return newValue;
    }
    if (is(value, SQL)) {
      if (this.config.sqlBehavior === "sql") {
        return value;
      }
      throw new Error(`You tried to reference "${prop}" field from a subquery, which is a raw SQL field, but it doesn't have an alias declared. Please add an alias to the field using ".as('alias')" method.`);
    }
    if (is(value, Column)) {
      if (this.config.alias) {
        return new Proxy(value, new ColumnAliasProxyHandler(new Proxy(value.table, new TableAliasProxyHandler(this.config.alias, this.config.replaceOriginalName ?? false))));
      }
      return value;
    }
    if (typeof value !== "object" || value === null) {
      return value;
    }
    return new Proxy(value, new SelectionProxyHandler(this.config));
  }
}

// node_modules/drizzle-orm/pg-core/query-builders/select.js
var createSetOperator = function(type, isAll) {
  return (leftSelect, rightSelect, ...restSelects) => {
    const setOperators = [rightSelect, ...restSelects].map((select) => ({
      type,
      isAll,
      rightSelect: select
    }));
    for (const setOperator of setOperators) {
      if (!haveSameKeys(leftSelect.getSelectedFields(), setOperator.rightSelect.getSelectedFields())) {
        throw new Error("Set operator error (union / intersect / except): selected fields are not the same or are in a different order");
      }
    }
    return leftSelect.addSetOperators(setOperators);
  };
};

class PgSelectBuilder {
  static [entityKind] = "PgSelectBuilder";
  fields;
  session;
  dialect;
  withList = [];
  distinct;
  constructor(config) {
    this.fields = config.fields;
    this.session = config.session;
    this.dialect = config.dialect;
    if (config.withList) {
      this.withList = config.withList;
    }
    this.distinct = config.distinct;
  }
  from(source) {
    const isPartialSelect = !!this.fields;
    let fields;
    if (this.fields) {
      fields = this.fields;
    } else if (is(source, Subquery)) {
      fields = Object.fromEntries(Object.keys(source[SubqueryConfig].selection).map((key) => [key, source[key]]));
    } else if (is(source, PgViewBase)) {
      fields = source[ViewBaseConfig].selectedFields;
    } else if (is(source, SQL)) {
      fields = {};
    } else {
      fields = getTableColumns(source);
    }
    return new PgSelectBase({
      table: source,
      fields,
      isPartialSelect,
      session: this.session,
      dialect: this.dialect,
      withList: this.withList,
      distinct: this.distinct
    });
  }
}

class PgSelectQueryBuilderBase extends TypedQueryBuilder {
  static [entityKind] = "PgSelectQueryBuilder";
  _;
  config;
  joinsNotNullableMap;
  tableName;
  isPartialSelect;
  session;
  dialect;
  constructor({ table: table15, fields, isPartialSelect, session, dialect, withList, distinct }) {
    super();
    this.config = {
      withList,
      table: table15,
      fields: { ...fields },
      distinct,
      setOperators: []
    };
    this.isPartialSelect = isPartialSelect;
    this.session = session;
    this.dialect = dialect;
    this._ = {
      selectedFields: fields
    };
    this.tableName = getTableLikeName(table15);
    this.joinsNotNullableMap = typeof this.tableName === "string" ? { [this.tableName]: true } : {};
  }
  createJoin(joinType) {
    return (table15, on) => {
      const baseTableName = this.tableName;
      const tableName = getTableLikeName(table15);
      if (typeof tableName === "string" && this.config.joins?.some((join) => join.alias === tableName)) {
        throw new Error(`Alias "${tableName}" is already used in this query`);
      }
      if (!this.isPartialSelect) {
        if (Object.keys(this.joinsNotNullableMap).length === 1 && typeof baseTableName === "string") {
          this.config.fields = {
            [baseTableName]: this.config.fields
          };
        }
        if (typeof tableName === "string" && !is(table15, SQL)) {
          const selection = is(table15, Subquery) ? table15[SubqueryConfig].selection : is(table15, View) ? table15[ViewBaseConfig].selectedFields : table15[Table.Symbol.Columns];
          this.config.fields[tableName] = selection;
        }
      }
      if (typeof on === "function") {
        on = on(new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })));
      }
      if (!this.config.joins) {
        this.config.joins = [];
      }
      this.config.joins.push({ on, table: table15, joinType, alias: tableName });
      if (typeof tableName === "string") {
        switch (joinType) {
          case "left": {
            this.joinsNotNullableMap[tableName] = false;
            break;
          }
          case "right": {
            this.joinsNotNullableMap = Object.fromEntries(Object.entries(this.joinsNotNullableMap).map(([key]) => [key, false]));
            this.joinsNotNullableMap[tableName] = true;
            break;
          }
          case "inner": {
            this.joinsNotNullableMap[tableName] = true;
            break;
          }
          case "full": {
            this.joinsNotNullableMap = Object.fromEntries(Object.entries(this.joinsNotNullableMap).map(([key]) => [key, false]));
            this.joinsNotNullableMap[tableName] = false;
            break;
          }
        }
      }
      return this;
    };
  }
  leftJoin = this.createJoin("left");
  rightJoin = this.createJoin("right");
  innerJoin = this.createJoin("inner");
  fullJoin = this.createJoin("full");
  createSetOperator(type, isAll) {
    return (rightSelection) => {
      const rightSelect = typeof rightSelection === "function" ? rightSelection(getPgSetOperators()) : rightSelection;
      if (!haveSameKeys(this.getSelectedFields(), rightSelect.getSelectedFields())) {
        throw new Error("Set operator error (union / intersect / except): selected fields are not the same or are in a different order");
      }
      this.config.setOperators.push({ type, isAll, rightSelect });
      return this;
    };
  }
  union = this.createSetOperator("union", false);
  unionAll = this.createSetOperator("union", true);
  intersect = this.createSetOperator("intersect", false);
  intersectAll = this.createSetOperator("intersect", true);
  except = this.createSetOperator("except", false);
  exceptAll = this.createSetOperator("except", true);
  addSetOperators(setOperators) {
    this.config.setOperators.push(...setOperators);
    return this;
  }
  where(where) {
    if (typeof where === "function") {
      where = where(new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })));
    }
    this.config.where = where;
    return this;
  }
  having(having) {
    if (typeof having === "function") {
      having = having(new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })));
    }
    this.config.having = having;
    return this;
  }
  groupBy(...columns2) {
    if (typeof columns2[0] === "function") {
      const groupBy = columns2[0](new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: "alias", sqlBehavior: "sql" })));
      this.config.groupBy = Array.isArray(groupBy) ? groupBy : [groupBy];
    } else {
      this.config.groupBy = columns2;
    }
    return this;
  }
  orderBy(...columns2) {
    if (typeof columns2[0] === "function") {
      const orderBy = columns2[0](new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: "alias", sqlBehavior: "sql" })));
      const orderByArray = Array.isArray(orderBy) ? orderBy : [orderBy];
      if (this.config.setOperators.length > 0) {
        this.config.setOperators.at(-1).orderBy = orderByArray;
      } else {
        this.config.orderBy = orderByArray;
      }
    } else {
      const orderByArray = columns2;
      if (this.config.setOperators.length > 0) {
        this.config.setOperators.at(-1).orderBy = orderByArray;
      } else {
        this.config.orderBy = orderByArray;
      }
    }
    return this;
  }
  limit(limit) {
    if (this.config.setOperators.length > 0) {
      this.config.setOperators.at(-1).limit = limit;
    } else {
      this.config.limit = limit;
    }
    return this;
  }
  offset(offset) {
    if (this.config.setOperators.length > 0) {
      this.config.setOperators.at(-1).offset = offset;
    } else {
      this.config.offset = offset;
    }
    return this;
  }
  for(strength, config = {}) {
    this.config.lockingClause = { strength, config };
    return this;
  }
  getSQL() {
    return this.dialect.buildSelectQuery(this.config);
  }
  toSQL() {
    const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
    return rest;
  }
  as(alias3) {
    return new Proxy(new Subquery(this.getSQL(), this.config.fields, alias3), new SelectionProxyHandler({ alias: alias3, sqlAliasedBehavior: "alias", sqlBehavior: "error" }));
  }
  getSelectedFields() {
    return new Proxy(this.config.fields, new SelectionProxyHandler({ alias: this.tableName, sqlAliasedBehavior: "alias", sqlBehavior: "error" }));
  }
  $dynamic() {
    return this;
  }
}

class PgSelectBase extends PgSelectQueryBuilderBase {
  static [entityKind] = "PgSelect";
  _prepare(name) {
    const { session, config, dialect, joinsNotNullableMap } = this;
    if (!session) {
      throw new Error("Cannot execute a query on a query builder. Please use a database instance instead.");
    }
    return tracer.startActiveSpan("drizzle.prepareQuery", () => {
      const fieldsList = orderSelectedFields(config.fields);
      const query = session.prepareQuery(dialect.sqlToQuery(this.getSQL()), fieldsList, name);
      query.joinsNotNullableMap = joinsNotNullableMap;
      return query;
    });
  }
  prepare(name) {
    return this._prepare(name);
  }
  execute = (placeholderValues) => {
    return tracer.startActiveSpan("drizzle.operation", () => {
      return this._prepare().execute(placeholderValues);
    });
  };
}
applyMixins(PgSelectBase, [QueryPromise]);
var getPgSetOperators = () => ({
  union,
  unionAll,
  intersect,
  intersectAll,
  except,
  exceptAll
});
var union = createSetOperator("union", false);
var unionAll = createSetOperator("union", true);
var intersect = createSetOperator("intersect", false);
var intersectAll = createSetOperator("intersect", true);
var except = createSetOperator("except", false);
var exceptAll = createSetOperator("except", true);

// node_modules/drizzle-orm/pg-core/query-builders/query-builder.js
class QueryBuilder {
  static [entityKind] = "PgQueryBuilder";
  dialect;
  $with(alias3) {
    const queryBuilder = this;
    return {
      as(qb) {
        if (typeof qb === "function") {
          qb = qb(queryBuilder);
        }
        return new Proxy(new WithSubquery(qb.getSQL(), qb.getSelectedFields(), alias3, true), new SelectionProxyHandler({ alias: alias3, sqlAliasedBehavior: "alias", sqlBehavior: "error" }));
      }
    };
  }
  with(...queries) {
    const self2 = this;
    function select2(fields) {
      return new PgSelectBuilder({
        fields: fields ?? undefined,
        session: undefined,
        dialect: self2.getDialect(),
        withList: queries
      });
    }
    function selectDistinct(fields) {
      return new PgSelectBuilder({
        fields: fields ?? undefined,
        session: undefined,
        dialect: self2.getDialect(),
        distinct: true
      });
    }
    function selectDistinctOn(on, fields) {
      return new PgSelectBuilder({
        fields: fields ?? undefined,
        session: undefined,
        dialect: self2.getDialect(),
        distinct: { on }
      });
    }
    return { select: select2, selectDistinct, selectDistinctOn };
  }
  select(fields) {
    return new PgSelectBuilder({
      fields: fields ?? undefined,
      session: undefined,
      dialect: this.getDialect()
    });
  }
  selectDistinct(fields) {
    return new PgSelectBuilder({
      fields: fields ?? undefined,
      session: undefined,
      dialect: this.getDialect(),
      distinct: true
    });
  }
  selectDistinctOn(on, fields) {
    return new PgSelectBuilder({
      fields: fields ?? undefined,
      session: undefined,
      dialect: this.getDialect(),
      distinct: { on }
    });
  }
  getDialect() {
    if (!this.dialect) {
      this.dialect = new PgDialect;
    }
    return this.dialect;
  }
}

// node_modules/drizzle-orm/pg-core/query-builders/refresh-materialized-view.js
class PgRefreshMaterializedView extends QueryPromise {
  constructor(view, session, dialect2) {
    super();
    this.session = session;
    this.dialect = dialect2;
    this.config = { view };
  }
  static [entityKind] = "PgRefreshMaterializedView";
  config;
  concurrently() {
    if (this.config.withNoData !== undefined) {
      throw new Error("Cannot use concurrently and withNoData together");
    }
    this.config.concurrently = true;
    return this;
  }
  withNoData() {
    if (this.config.concurrently !== undefined) {
      throw new Error("Cannot use concurrently and withNoData together");
    }
    this.config.withNoData = true;
    return this;
  }
  getSQL() {
    return this.dialect.buildRefreshMaterializedViewQuery(this.config);
  }
  toSQL() {
    const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
    return rest;
  }
  _prepare(name) {
    return tracer.startActiveSpan("drizzle.prepareQuery", () => {
      return this.session.prepareQuery(this.dialect.sqlToQuery(this.getSQL()), undefined, name);
    });
  }
  prepare(name) {
    return this._prepare(name);
  }
  execute = (placeholderValues) => {
    return tracer.startActiveSpan("drizzle.operation", () => {
      return this._prepare().execute(placeholderValues);
    });
  };
}

// node_modules/drizzle-orm/pg-core/query-builders/update.js
class PgUpdateBuilder {
  constructor(table16, session, dialect2) {
    this.table = table16;
    this.session = session;
    this.dialect = dialect2;
  }
  static [entityKind] = "PgUpdateBuilder";
  set(values) {
    return new PgUpdateBase(this.table, mapUpdateSet(this.table, values), this.session, this.dialect);
  }
}

class PgUpdateBase extends QueryPromise {
  constructor(table16, set, session, dialect2) {
    super();
    this.session = session;
    this.dialect = dialect2;
    this.config = { set, table: table16 };
  }
  static [entityKind] = "PgUpdate";
  config;
  where(where) {
    this.config.where = where;
    return this;
  }
  returning(fields = this.config.table[Table.Symbol.Columns]) {
    this.config.returning = orderSelectedFields(fields);
    return this;
  }
  getSQL() {
    return this.dialect.buildUpdateQuery(this.config);
  }
  toSQL() {
    const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
    return rest;
  }
  _prepare(name) {
    return this.session.prepareQuery(this.dialect.sqlToQuery(this.getSQL()), this.config.returning, name);
  }
  prepare(name) {
    return this._prepare(name);
  }
  execute = (placeholderValues) => {
    return this._prepare().execute(placeholderValues);
  };
  $dynamic() {
    return this;
  }
}

// node_modules/drizzle-orm/pg-core/query-builders/query.js
class RelationalQueryBuilder {
  constructor(fullSchema, schema, tableNamesMap, table16, tableConfig, dialect2, session) {
    this.fullSchema = fullSchema;
    this.schema = schema;
    this.tableNamesMap = tableNamesMap;
    this.table = table16;
    this.tableConfig = tableConfig;
    this.dialect = dialect2;
    this.session = session;
  }
  static [entityKind] = "PgRelationalQueryBuilder";
  findMany(config) {
    return new PgRelationalQuery(this.fullSchema, this.schema, this.tableNamesMap, this.table, this.tableConfig, this.dialect, this.session, config ? config : {}, "many");
  }
  findFirst(config) {
    return new PgRelationalQuery(this.fullSchema, this.schema, this.tableNamesMap, this.table, this.tableConfig, this.dialect, this.session, config ? { ...config, limit: 1 } : { limit: 1 }, "first");
  }
}

class PgRelationalQuery extends QueryPromise {
  constructor(fullSchema, schema, tableNamesMap, table16, tableConfig, dialect2, session, config, mode) {
    super();
    this.fullSchema = fullSchema;
    this.schema = schema;
    this.tableNamesMap = tableNamesMap;
    this.table = table16;
    this.tableConfig = tableConfig;
    this.dialect = dialect2;
    this.session = session;
    this.config = config;
    this.mode = mode;
  }
  static [entityKind] = "PgRelationalQuery";
  _prepare(name) {
    return tracer.startActiveSpan("drizzle.prepareQuery", () => {
      const { query, builtQuery } = this._toSQL();
      return this.session.prepareQuery(builtQuery, undefined, name, (rawRows, mapColumnValue) => {
        const rows = rawRows.map((row) => mapRelationalRow(this.schema, this.tableConfig, row, query.selection, mapColumnValue));
        if (this.mode === "first") {
          return rows[0];
        }
        return rows;
      });
    });
  }
  prepare(name) {
    return this._prepare(name);
  }
  _getQuery() {
    return this.dialect.buildRelationalQueryWithoutPK({
      fullSchema: this.fullSchema,
      schema: this.schema,
      tableNamesMap: this.tableNamesMap,
      table: this.table,
      tableConfig: this.tableConfig,
      queryConfig: this.config,
      tableAlias: this.tableConfig.tsName
    });
  }
  getSQL() {
    return this._getQuery().sql;
  }
  _toSQL() {
    const query = this._getQuery();
    const builtQuery = this.dialect.sqlToQuery(query.sql);
    return { query, builtQuery };
  }
  toSQL() {
    return this._toSQL().builtQuery;
  }
  execute() {
    return tracer.startActiveSpan("drizzle.operation", () => {
      return this._prepare().execute();
    });
  }
}

// node_modules/drizzle-orm/pg-core/db.js
class PgDatabase {
  constructor(dialect2, session, schema) {
    this.dialect = dialect2;
    this.session = session;
    this._ = schema ? { schema: schema.schema, tableNamesMap: schema.tableNamesMap } : { schema: undefined, tableNamesMap: {} };
    this.query = {};
    if (this._.schema) {
      for (const [tableName, columns2] of Object.entries(this._.schema)) {
        this.query[tableName] = new RelationalQueryBuilder(schema.fullSchema, this._.schema, this._.tableNamesMap, schema.fullSchema[tableName], columns2, dialect2, session);
      }
    }
  }
  static [entityKind] = "PgDatabase";
  query;
  $with(alias3) {
    return {
      as(qb) {
        if (typeof qb === "function") {
          qb = qb(new QueryBuilder);
        }
        return new Proxy(new WithSubquery(qb.getSQL(), qb.getSelectedFields(), alias3, true), new SelectionProxyHandler({ alias: alias3, sqlAliasedBehavior: "alias", sqlBehavior: "error" }));
      }
    };
  }
  with(...queries) {
    const self2 = this;
    function select2(fields) {
      return new PgSelectBuilder({
        fields: fields ?? undefined,
        session: self2.session,
        dialect: self2.dialect,
        withList: queries
      });
    }
    return { select: select2 };
  }
  select(fields) {
    return new PgSelectBuilder({
      fields: fields ?? undefined,
      session: this.session,
      dialect: this.dialect
    });
  }
  selectDistinct(fields) {
    return new PgSelectBuilder({
      fields: fields ?? undefined,
      session: this.session,
      dialect: this.dialect,
      distinct: true
    });
  }
  selectDistinctOn(on, fields) {
    return new PgSelectBuilder({
      fields: fields ?? undefined,
      session: this.session,
      dialect: this.dialect,
      distinct: { on }
    });
  }
  update(table16) {
    return new PgUpdateBuilder(table16, this.session, this.dialect);
  }
  insert(table16) {
    return new PgInsertBuilder(table16, this.session, this.dialect);
  }
  delete(table16) {
    return new PgDeleteBase(table16, this.session, this.dialect);
  }
  refreshMaterializedView(view) {
    return new PgRefreshMaterializedView(view, this.session, this.dialect);
  }
  execute(query2) {
    return this.session.execute(query2.getSQL());
  }
  transaction(transaction, config) {
    return this.session.transaction(transaction, config);
  }
}

// node_modules/drizzle-orm/pg-core/session.js
class PreparedQuery {
  static [entityKind] = "PgPreparedQuery";
  joinsNotNullableMap;
}

class PgSession {
  constructor(dialect2) {
    this.dialect = dialect2;
  }
  static [entityKind] = "PgSession";
  execute(query2) {
    return tracer.startActiveSpan("drizzle.operation", () => {
      const prepared = tracer.startActiveSpan("drizzle.prepareQuery", () => {
        return this.prepareQuery(this.dialect.sqlToQuery(query2), undefined, undefined);
      });
      return prepared.execute();
    });
  }
  all(query2) {
    return this.prepareQuery(this.dialect.sqlToQuery(query2), undefined, undefined).all();
  }
}

class PgTransaction extends PgDatabase {
  constructor(dialect2, session, schema, nestedIndex = 0) {
    super(dialect2, session, schema);
    this.schema = schema;
    this.nestedIndex = nestedIndex;
  }
  static [entityKind] = "PgTransaction";
  rollback() {
    throw new TransactionRollbackError;
  }
  getTransactionConfigSQL(config) {
    const chunks = [];
    if (config.isolationLevel) {
      chunks.push(`isolation level ${config.isolationLevel}`);
    }
    if (config.accessMode) {
      chunks.push(config.accessMode);
    }
    if (typeof config.deferrable === "boolean") {
      chunks.push(config.deferrable ? "deferrable" : "not deferrable");
    }
    return sql2.raw(chunks.join(" "));
  }
  setTransaction(config) {
    return this.session.execute(sql2`set transaction ${this.getTransactionConfigSQL(config)}`);
  }
}

// src/db/schema/order-items.ts
var orderItems = pgTable("order_items", {
  id: text("id").$defaultFn(() => $createId()).primaryKey(),
  orderId: text("order_id").notNull().references(() => orders.id, {
    onDelete: "cascade"
  }),
  productId: text("product_id").references(() => products.id, {
    onDelete: "set null"
  }),
  quantity: integer("quantity").default(1),
  priceInCents: integer("price_in_cents").notNull()
});
var orderItemsRelations = relations(orderItems, ({ one }) => ({
  order: one(orders, {
    fields: [orderItems.orderId],
    references: [orders.id]
  }),
  product: one(products, {
    fields: [orderItems.productId],
    references: [products.id]
  })
}));

// src/db/schema/orders.ts
var orderStatusEnum = pgEnum("order_status", [
  "pending",
  "canceled",
  "processing",
  "delivering",
  "delivered"
]);
var orders = pgTable("orders", {
  id: text("id").$defaultFn(() => $createId()).primaryKey(),
  customerId: text("customer_id").references(() => users.id, {
    onDelete: "set null"
  }).notNull(),
  restaurantId: text("restaurant_id").references(() => restaurants.id, {
    onDelete: "set null"
  }).notNull(),
  status: orderStatusEnum("status").default("pending").notNull(),
  totalInCents: integer("total_in_cents").notNull(),
  createdAt: timestamp("created_at").defaultNow()
});
var ordersRelations = relations(orders, ({ one, many }) => ({
  customer: one(users, {
    fields: [orders.customerId],
    references: [users.id]
  }),
  restaurant: one(restaurants, {
    fields: [orders.restaurantId],
    references: [restaurants.id]
  }),
  orderItems: many(orderItems)
}));

// src/db/schema/users.ts
var userRoleEnum = pgEnum("user_role", ["manager", "customer"]);
var users = pgTable("users", {
  id: text("id").$defaultFn(() => $createId()).primaryKey(),
  name: text("name").notNull(),
  email: text("email").notNull().unique(),
  phone: text("phone"),
  role: userRoleEnum("role").default("customer").notNull(),
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow()
});
var usersRelations = relations(users, ({ many }) => ({
  orders: many(orders)
}));
// src/db/schema/restaurants.ts
var restaurants = pgTable("restaurants", {
  id: text("id").$defaultFn(() => $createId()).primaryKey(),
  name: text("name").notNull(),
  description: text("description"),
  managerId: text("manager_id").references(() => users.id, {
    onDelete: "set null"
  }),
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow()
});
var restaurantsRelations = relations(restaurants, ({ one, many }) => ({
  manager: one(users, {
    fields: [restaurants.managerId],
    references: [users.id],
    relationName: "restaurantManager"
  }),
  orders: many(orders),
  products: many(products)
}));
// src/db/schema/evaluations.ts
var evaluations = pgTable("evaluations", {
  id: text("id").$defaultFn(() => $createId()).primaryKey(),
  customerId: text("customer_id").references(() => users.id),
  restaurantId: text("restaurant_id").references(() => users.id),
  rate: integer("rate").notNull(),
  comment: text("comment"),
  createdAt: timestamp("created_at").defaultNow()
});
var evaluationsRelations = relations(evaluations, ({ one }) => ({
  customer: one(users, {
    fields: [evaluations.customerId],
    references: [users.id]
  }),
  restaurant: one(restaurants, {
    fields: [evaluations.restaurantId],
    references: [restaurants.id]
  })
}));
// src/db/schema/auth-links.ts
var authLinks = pgTable("auth_links", {
  id: text("id").$defaultFn(() => $createId()).primaryKey(),
  code: text("code").notNull().unique(),
  userId: text("user_id").references(() => users.id).notNull(),
  createdAt: timestamp("created_at").defaultNow()
});
// src/db/schema/products.ts
var products = pgTable("products", {
  id: text("id").$defaultFn(() => $createId()).primaryKey(),
  name: text("name").notNull(),
  description: text("description"),
  priceInCents: integer("price_in_cents").notNull(),
  restaurantId: text("restaurant_id").references(() => restaurants.id, {
    onDelete: "cascade"
  }).notNull(),
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow()
});
var productsRelations = relations(products, ({ one, many }) => ({
  restaurant: one(restaurants, {
    fields: [products.restaurantId],
    references: [restaurants.id],
    relationName: "productRestaurant"
  }),
  orderItems: many(orderItems)
}));
// node_modules/drizzle-orm/postgres-js/session.js
class PostgresJsPreparedQuery extends PreparedQuery {
  constructor(client, query2, params, logger2, fields, customResultMapper) {
    super();
    this.client = client;
    this.query = query2;
    this.params = params;
    this.logger = logger2;
    this.fields = fields;
    this.customResultMapper = customResultMapper;
  }
  static [entityKind] = "PostgresJsPreparedQuery";
  async execute(placeholderValues = {}) {
    return tracer.startActiveSpan("drizzle.execute", async (span) => {
      const params = fillPlaceholders(this.params, placeholderValues);
      span?.setAttributes({
        "drizzle.query.text": this.query,
        "drizzle.query.params": JSON.stringify(params)
      });
      this.logger.logQuery(this.query, params);
      const { fields, query: query2, client, joinsNotNullableMap, customResultMapper } = this;
      if (!fields && !customResultMapper) {
        return tracer.startActiveSpan("drizzle.driver.execute", () => {
          return client.unsafe(query2, params);
        });
      }
      const rows = await tracer.startActiveSpan("drizzle.driver.execute", () => {
        span?.setAttributes({
          "drizzle.query.text": query2,
          "drizzle.query.params": JSON.stringify(params)
        });
        return client.unsafe(query2, params).values();
      });
      return tracer.startActiveSpan("drizzle.mapResponse", () => {
        return customResultMapper ? customResultMapper(rows) : rows.map((row) => mapResultRow(fields, row, joinsNotNullableMap));
      });
    });
  }
  all(placeholderValues = {}) {
    return tracer.startActiveSpan("drizzle.execute", async (span) => {
      const params = fillPlaceholders(this.params, placeholderValues);
      span?.setAttributes({
        "drizzle.query.text": this.query,
        "drizzle.query.params": JSON.stringify(params)
      });
      this.logger.logQuery(this.query, params);
      return tracer.startActiveSpan("drizzle.driver.execute", () => {
        span?.setAttributes({
          "drizzle.query.text": this.query,
          "drizzle.query.params": JSON.stringify(params)
        });
        return this.client.unsafe(this.query, params);
      });
    });
  }
}

class PostgresJsSession extends PgSession {
  constructor(client, dialect2, schema, options = {}) {
    super(dialect2);
    this.client = client;
    this.schema = schema;
    this.options = options;
    this.logger = options.logger ?? new NoopLogger;
  }
  static [entityKind] = "PostgresJsSession";
  logger;
  prepareQuery(query2, fields, name, customResultMapper) {
    return new PostgresJsPreparedQuery(this.client, query2.sql, query2.params, this.logger, fields, customResultMapper);
  }
  query(query2, params) {
    this.logger.logQuery(query2, params);
    return this.client.unsafe(query2, params).values();
  }
  queryObjects(query2, params) {
    return this.client.unsafe(query2, params);
  }
  transaction(transaction, config) {
    return this.client.begin(async (client) => {
      const session2 = new PostgresJsSession(client, this.dialect, this.schema, this.options);
      const tx = new PostgresJsTransaction(this.dialect, session2, this.schema);
      if (config) {
        await tx.setTransaction(config);
      }
      return transaction(tx);
    });
  }
}

class PostgresJsTransaction extends PgTransaction {
  constructor(dialect2, session2, schema, nestedIndex = 0) {
    super(dialect2, session2, schema, nestedIndex);
    this.session = session2;
  }
  static [entityKind] = "PostgresJsTransaction";
  transaction(transaction) {
    return this.session.client.savepoint((client) => {
      const session2 = new PostgresJsSession(client, this.dialect, this.schema, this.session.options);
      const tx = new PostgresJsTransaction(this.dialect, session2, this.schema);
      return transaction(tx);
    });
  }
}

// node_modules/drizzle-orm/postgres-js/driver.js
var drizzle = function(client, config = {}) {
  const dialect3 = new PgDialect;
  let logger3;
  if (config.logger === true) {
    logger3 = new DefaultLogger;
  } else if (config.logger !== false) {
    logger3 = config.logger;
  }
  let schema;
  if (config.schema) {
    const tablesConfig = extractTablesRelationalConfig(config.schema, createTableRelationsHelpers);
    schema = {
      fullSchema: config.schema,
      schema: tablesConfig.tables,
      tableNamesMap: tablesConfig.tableNamesMap
    };
  }
  const session3 = new PostgresJsSession(client, dialect3, schema, { logger: logger3 });
  return new PgDatabase(dialect3, session3, schema);
};

// node_modules/postgres/src/index.js
import os from "os";
import fs from "fs";

// node_modules/postgres/src/query.js
var cachedError = function(xs) {
  if (originCache.has(xs))
    return originCache.get(xs);
  const x = Error.stackTraceLimit;
  Error.stackTraceLimit = 4;
  originCache.set(xs, new Error);
  Error.stackTraceLimit = x;
  return originCache.get(xs);
};
var originCache = new Map;
var originStackCache = new Map;
var originError = Symbol("OriginError");
var CLOSE = {};

class Query extends Promise {
  constructor(strings, args, handler, canceller, options = {}) {
    let resolve, reject;
    super((a, b) => {
      resolve = a;
      reject = b;
    });
    this.tagged = Array.isArray(strings.raw);
    this.strings = strings;
    this.args = args;
    this.handler = handler;
    this.canceller = canceller;
    this.options = options;
    this.state = null;
    this.statement = null;
    this.resolve = (x) => (this.active = false, resolve(x));
    this.reject = (x) => (this.active = false, reject(x));
    this.active = false;
    this.cancelled = null;
    this.executed = false;
    this.signature = "";
    this[originError] = this.handler.debug ? new Error : this.tagged && cachedError(this.strings);
  }
  get origin() {
    return (this.handler.debug ? this[originError].stack : this.tagged && originStackCache.has(this.strings) ? originStackCache.get(this.strings) : originStackCache.set(this.strings, this[originError].stack).get(this.strings)) || "";
  }
  static get [Symbol.species]() {
    return Promise;
  }
  cancel() {
    return this.canceller && (this.canceller(this), this.canceller = null);
  }
  simple() {
    this.options.simple = true;
    this.options.prepare = false;
    return this;
  }
  async readable() {
    this.simple();
    this.streaming = true;
    return this;
  }
  async writable() {
    this.simple();
    this.streaming = true;
    return this;
  }
  cursor(rows = 1, fn) {
    this.options.simple = false;
    if (typeof rows === "function") {
      fn = rows;
      rows = 1;
    }
    this.cursorRows = rows;
    if (typeof fn === "function")
      return this.cursorFn = fn, this;
    let prev;
    return {
      [Symbol.asyncIterator]: () => ({
        next: () => {
          if (this.executed && !this.active)
            return { done: true };
          prev && prev();
          const promise = new Promise((resolve, reject) => {
            this.cursorFn = (value) => {
              resolve({ value, done: false });
              return new Promise((r) => prev = r);
            };
            this.resolve = () => (this.active = false, resolve({ done: true }));
            this.reject = (x) => (this.active = false, reject(x));
          });
          this.execute();
          return promise;
        },
        return() {
          prev && prev(CLOSE);
          return { done: true };
        }
      })
    };
  }
  describe() {
    this.options.simple = false;
    this.onlyDescribe = this.options.prepare = true;
    return this;
  }
  stream() {
    throw new Error(".stream has been renamed to .forEach");
  }
  forEach(fn) {
    this.forEachFn = fn;
    this.handle();
    return this;
  }
  raw() {
    this.isRaw = true;
    return this;
  }
  values() {
    this.isRaw = "values";
    return this;
  }
  async handle() {
    !this.executed && (this.executed = true) && await 1 && this.handler(this);
  }
  execute() {
    this.handle();
    return this;
  }
  then() {
    this.handle();
    return super.then.apply(this, arguments);
  }
  catch() {
    this.handle();
    return super.catch.apply(this, arguments);
  }
  finally() {
    this.handle();
    return super.finally.apply(this, arguments);
  }
}

// node_modules/postgres/src/errors.js
var connection = function(x, options, socket) {
  const { host, port } = socket || options;
  const error = Object.assign(new Error("write " + x + " " + (options.path || host + ":" + port)), {
    code: x,
    errno: x,
    address: options.path || host
  }, options.path ? {} : { port });
  Error.captureStackTrace(error, connection);
  return error;
};
var postgres = function(x) {
  const error = new PostgresError(x);
  Error.captureStackTrace(error, postgres);
  return error;
};
var generic = function(code, message) {
  const error = Object.assign(new Error(code + ": " + message), { code });
  Error.captureStackTrace(error, generic);
  return error;
};
var notSupported = function(x) {
  const error = Object.assign(new Error(x + " (B) is not supported"), {
    code: "MESSAGE_NOT_SUPPORTED",
    name: x
  });
  Error.captureStackTrace(error, notSupported);
  return error;
};

class PostgresError extends Error {
  constructor(x) {
    super(x.message);
    this.name = this.constructor.name;
    Object.assign(this, x);
  }
}
var Errors = {
  connection,
  postgres,
  generic,
  notSupported
};

// node_modules/postgres/src/types.js
function handleValue(x, parameters, types, options) {
  let value = x instanceof Parameter ? x.value : x;
  if (value === undefined) {
    x instanceof Parameter ? x.value = options.transform.undefined : value = x = options.transform.undefined;
    if (value === undefined)
      throw Errors.generic("UNDEFINED_VALUE", "Undefined values are not allowed");
  }
  return "$" + types.push(x instanceof Parameter ? (parameters.push(x.value), x.array ? x.array[x.type || inferType(x.value)] || x.type || firstIsString(x.value) : x.type) : (parameters.push(x), inferType(x)));
}
function stringify(q, string, value, parameters, types, options) {
  for (let i = 1;i < q.strings.length; i++) {
    string += stringifyValue(string, value, parameters, types, options) + q.strings[i];
    value = q.args[i];
  }
  return string;
}
var stringifyValue = function(string, value, parameters, types, o2) {
  return value instanceof Builder ? value.build(string, parameters, types, o2) : value instanceof Query ? fragment(value, parameters, types, o2) : value instanceof Identifier ? value.value : value && value[0] instanceof Query ? value.reduce((acc, x) => acc + " " + fragment(x, parameters, types, o2), "") : handleValue(value, parameters, types, o2);
};
var fragment = function(q, parameters, types, options) {
  q.fragment = true;
  return stringify(q, q.strings[0], q.args[0], parameters, types, options);
};
var valuesBuilder = function(first, parameters, types, columns2, options) {
  return first.map((row) => "(" + columns2.map((column9) => stringifyValue("values", row[column9], parameters, types, options)).join(",") + ")").join(",");
};
var values = function(first, rest, parameters, types, options) {
  const multi = Array.isArray(first[0]);
  const columns2 = rest.length ? rest.flat() : Object.keys(multi ? first[0] : first);
  return valuesBuilder(multi ? first : [first], parameters, types, columns2, options);
};
var select2 = function(first, rest, parameters, types, options) {
  typeof first === "string" && (first = [first].concat(rest));
  if (Array.isArray(first))
    return escapeIdentifiers(first, options);
  let value;
  const columns2 = rest.length ? rest.flat() : Object.keys(first);
  return columns2.map((x) => {
    value = first[x];
    return (value instanceof Query ? fragment(value, parameters, types, options) : value instanceof Identifier ? value.value : handleValue(value, parameters, types, options)) + " as " + escapeIdentifier(options.transform.column.to ? options.transform.column.to(x) : x);
  }).join(",");
};
var notTagged = function() {
  throw Errors.generic("NOT_TAGGED_CALL", "Query not called as a tagged template literal");
};
var firstIsString = function(x) {
  if (Array.isArray(x))
    return firstIsString(x[0]);
  return typeof x === "string" ? 1009 : 0;
};
var typeHandlers = function(types) {
  return Object.keys(types).reduce((acc, k) => {
    types[k].from && [].concat(types[k].from).forEach((x) => acc.parsers[x] = types[k].parse);
    if (types[k].serialize) {
      acc.serializers[types[k].to] = types[k].serialize;
      types[k].from && [].concat(types[k].from).forEach((x) => acc.serializers[x] = types[k].serialize);
    }
    return acc;
  }, { parsers: {}, serializers: {} });
};
var escapeIdentifiers = function(xs, { transform: { column: column9 } }) {
  return xs.map((x) => escapeIdentifier(column9.to ? column9.to(x) : x)).join(",");
};
var arrayEscape = function(x) {
  return x.replace(escapeBackslash, "\\\\").replace(escapeQuote, '\\"');
};
var arrayParserLoop = function(s, x, parser, typarray) {
  const xs = [];
  const delimiter = typarray === 1020 ? ";" : ",";
  for (;s.i < x.length; s.i++) {
    s.char = x[s.i];
    if (s.quoted) {
      if (s.char === "\\") {
        s.str += x[++s.i];
      } else if (s.char === '"') {
        xs.push(parser ? parser(s.str) : s.str);
        s.str = "";
        s.quoted = x[s.i + 1] === '"';
        s.last = s.i + 2;
      } else {
        s.str += s.char;
      }
    } else if (s.char === '"') {
      s.quoted = true;
    } else if (s.char === "{") {
      s.last = ++s.i;
      xs.push(arrayParserLoop(s, x, parser, typarray));
    } else if (s.char === "}") {
      s.quoted = false;
      s.last < s.i && xs.push(parser ? parser(x.slice(s.last, s.i)) : x.slice(s.last, s.i));
      s.last = s.i + 1;
      break;
    } else if (s.char === delimiter && s.p !== "}" && s.p !== '"') {
      xs.push(parser ? parser(x.slice(s.last, s.i)) : x.slice(s.last, s.i));
      s.last = s.i + 1;
    }
    s.p = s.char;
  }
  s.last < s.i && xs.push(parser ? parser(x.slice(s.last, s.i + 1)) : x.slice(s.last, s.i + 1));
  return xs;
};
var createJsonTransform = function(fn) {
  return function jsonTransform(x, column9) {
    return typeof x === "object" && x !== null && (column9.type === 114 || column9.type === 3802) ? Array.isArray(x) ? x.map((x2) => jsonTransform(x2, column9)) : Object.entries(x).reduce((acc, [k, v]) => Object.assign(acc, { [fn(k)]: jsonTransform(v, column9) }), {}) : x;
  };
};
var types = {
  string: {
    to: 25,
    from: null,
    serialize: (x) => "" + x
  },
  number: {
    to: 0,
    from: [21, 23, 26, 700, 701],
    serialize: (x) => "" + x,
    parse: (x) => +x
  },
  json: {
    to: 114,
    from: [114, 3802],
    serialize: (x) => JSON.stringify(x),
    parse: (x) => JSON.parse(x)
  },
  boolean: {
    to: 16,
    from: 16,
    serialize: (x) => x === true ? "t" : "f",
    parse: (x) => x === "t"
  },
  date: {
    to: 1184,
    from: [1082, 1114, 1184],
    serialize: (x) => (x instanceof Date ? x : new Date(x)).toISOString(),
    parse: (x) => new Date(x)
  },
  bytea: {
    to: 17,
    from: 17,
    serialize: (x) => "\\x" + Buffer.from(x).toString("hex"),
    parse: (x) => Buffer.from(x.slice(2), "hex")
  }
};

class NotTagged {
  then() {
    notTagged();
  }
  catch() {
    notTagged();
  }
  finally() {
    notTagged();
  }
}

class Identifier extends NotTagged {
  constructor(value) {
    super();
    this.value = escapeIdentifier(value);
  }
}

class Parameter extends NotTagged {
  constructor(value, type, array2) {
    super();
    this.value = value;
    this.type = type;
    this.array = array2;
  }
}

class Builder extends NotTagged {
  constructor(first, rest) {
    super();
    this.first = first;
    this.rest = rest;
  }
  build(before, parameters, types2, options) {
    const keyword = builders.map(([x, fn]) => ({ fn, i: before.search(x) })).sort((a, b) => a.i - b.i).pop();
    return keyword.i === -1 ? escapeIdentifiers(this.first, options) : keyword.fn(this.first, this.rest, parameters, types2, options);
  }
}
var defaultHandlers = typeHandlers(types);
var builders = Object.entries({
  values,
  in: (...xs) => {
    const x = values(...xs);
    return x === "()" ? "(null)" : x;
  },
  select: select2,
  as: select2,
  returning: select2,
  "\\(": select2,
  update(first, rest, parameters, types2, options) {
    return (rest.length ? rest.flat() : Object.keys(first)).map((x) => escapeIdentifier(options.transform.column.to ? options.transform.column.to(x) : x) + "=" + stringifyValue("values", first[x], parameters, types2, options));
  },
  insert(first, rest, parameters, types2, options) {
    const columns2 = rest.length ? rest.flat() : Object.keys(Array.isArray(first) ? first[0] : first);
    return "(" + escapeIdentifiers(columns2, options) + ")values" + valuesBuilder(Array.isArray(first) ? first : [first], parameters, types2, columns2, options);
  }
}).map(([x, fn]) => [new RegExp("((?:^|[\\s(])" + x + "(?:$|[\\s(]))(?![\\s\\S]*\\1)", "i"), fn]);
var serializers = defaultHandlers.serializers;
var parsers = defaultHandlers.parsers;
var mergeUserTypes = function(types2) {
  const user = typeHandlers(types2 || {});
  return {
    serializers: Object.assign({}, serializers, user.serializers),
    parsers: Object.assign({}, parsers, user.parsers)
  };
};
var escapeIdentifier = function escape(str) {
  return '"' + str.replace(/"/g, '""').replace(/\./g, '"."') + '"';
};
var inferType = function inferType2(x) {
  return x instanceof Parameter ? x.type : x instanceof Date ? 1184 : x instanceof Uint8Array ? 17 : x === true || x === false ? 16 : typeof x === "bigint" ? 20 : Array.isArray(x) ? inferType2(x[0]) : 0;
};
var escapeBackslash = /\\/g;
var escapeQuote = /"/g;
var arraySerializer = function arraySerializer2(xs, serializer, options, typarray) {
  if (Array.isArray(xs) === false)
    return xs;
  if (!xs.length)
    return "{}";
  const first = xs[0];
  const delimiter = typarray === 1020 ? ";" : ",";
  if (Array.isArray(first) && !first.type)
    return "{" + xs.map((x) => arraySerializer2(x, serializer, options, typarray)).join(delimiter) + "}";
  return "{" + xs.map((x) => {
    if (x === undefined) {
      x = options.transform.undefined;
      if (x === undefined)
        throw Errors.generic("UNDEFINED_VALUE", "Undefined values are not allowed");
    }
    return x === null ? "null" : '"' + arrayEscape(serializer ? serializer(x.type ? x.value : x) : "" + x) + '"';
  }).join(delimiter) + "}";
};
var arrayParserState = {
  i: 0,
  char: null,
  str: "",
  quoted: false,
  last: 0
};
var arrayParser = function arrayParser2(x, parser, typarray) {
  arrayParserState.i = arrayParserState.last = 0;
  return arrayParserLoop(arrayParserState, x, parser, typarray);
};
var toCamel = (x) => {
  let str = x[0];
  for (let i = 1;i < x.length; i++)
    str += x[i] === "_" ? x[++i].toUpperCase() : x[i];
  return str;
};
var toPascal = (x) => {
  let str = x[0].toUpperCase();
  for (let i = 1;i < x.length; i++)
    str += x[i] === "_" ? x[++i].toUpperCase() : x[i];
  return str;
};
var toKebab = (x) => x.replace(/_/g, "-");
var fromCamel = (x) => x.replace(/([A-Z])/g, "_$1").toLowerCase();
var fromPascal = (x) => (x.slice(0, 1) + x.slice(1).replace(/([A-Z])/g, "_$1")).toLowerCase();
var fromKebab = (x) => x.replace(/-/g, "_");
toCamel.column = { from: toCamel };
toCamel.value = { from: createJsonTransform(toCamel) };
fromCamel.column = { to: fromCamel };
var camel = { ...toCamel };
camel.column.to = fromCamel;
toPascal.column = { from: toPascal };
toPascal.value = { from: createJsonTransform(toPascal) };
fromPascal.column = { to: fromPascal };
var pascal = { ...toPascal };
pascal.column.to = fromPascal;
toKebab.column = { from: toKebab };
toKebab.value = { from: createJsonTransform(toKebab) };
fromKebab.column = { to: fromKebab };
var kebab = { ...toKebab };
kebab.column.to = fromKebab;

// node_modules/postgres/src/connection.js
import net from "net";
import tls from "tls";
import crypto2 from "crypto";
import Stream from "stream";
import {performance} from "perf_hooks";

// node_modules/postgres/src/result.js
class Result extends Array {
  constructor() {
    super();
    Object.defineProperties(this, {
      count: { value: null, writable: true },
      state: { value: null, writable: true },
      command: { value: null, writable: true },
      columns: { value: null, writable: true },
      statement: { value: null, writable: true }
    });
  }
  static get [Symbol.species]() {
    return Array;
  }
}

// node_modules/postgres/src/queue.js
var Queue = function(initial = []) {
  let xs = initial.slice();
  let index = 0;
  return {
    get length() {
      return xs.length - index;
    },
    remove: (x) => {
      const index2 = xs.indexOf(x);
      return index2 === -1 ? null : (xs.splice(index2, 1), x);
    },
    push: (x) => (xs.push(x), x),
    shift: () => {
      const out = xs[index++];
      if (index === xs.length) {
        index = 0;
        xs = [];
      } else {
        xs[index - 1] = undefined;
      }
      return out;
    }
  };
};
var queue_default = Queue;

// node_modules/postgres/src/bytes.js
var fit = function(x) {
  if (buffer.length - b.i < x) {
    const prev = buffer, length = prev.length;
    buffer = Buffer.allocUnsafe(length + (length >> 1) + x);
    prev.copy(buffer);
  }
};
var reset = function() {
  b.i = 0;
  return b;
};
var size = 256;
var buffer = Buffer.allocUnsafe(size);
var messages = "BCcDdEFfHPpQSX".split("").reduce((acc, x) => {
  const v = x.charCodeAt(0);
  acc[x] = () => {
    buffer[0] = v;
    b.i = 5;
    return b;
  };
  return acc;
}, {});
var b = Object.assign(reset, messages, {
  N: String.fromCharCode(0),
  i: 0,
  inc(x) {
    b.i += x;
    return b;
  },
  str(x) {
    const length = Buffer.byteLength(x);
    fit(length);
    b.i += buffer.write(x, b.i, length, "utf8");
    return b;
  },
  i16(x) {
    fit(2);
    buffer.writeUInt16BE(x, b.i);
    b.i += 2;
    return b;
  },
  i32(x, i) {
    if (i || i === 0) {
      buffer.writeUInt32BE(x, i);
      return b;
    }
    fit(4);
    buffer.writeUInt32BE(x, b.i);
    b.i += 4;
    return b;
  },
  z(x) {
    fit(x);
    buffer.fill(0, b.i, b.i + x);
    b.i += x;
    return b;
  },
  raw(x) {
    buffer = Buffer.concat([buffer.subarray(0, b.i), x]);
    b.i = buffer.length;
    return b;
  },
  end(at = 1) {
    buffer.writeUInt32BE(b.i - at, at);
    const out = buffer.subarray(0, b.i);
    b.i = 0;
    buffer = Buffer.allocUnsafe(size);
    return out;
  }
});
var bytes_default = b;

// node_modules/postgres/src/connection.js
var Connection = function(options, queues = {}, { onopen = noop, onend = noop, onclose = noop } = {}) {
  const {
    ssl,
    max,
    user,
    host,
    port,
    database,
    parsers: parsers2,
    transform,
    onnotice,
    onnotify,
    onparameter,
    max_pipeline,
    keep_alive,
    backoff,
    target_session_attrs
  } = options;
  const sent = queue_default(), id = uid++, backend = { pid: null, secret: null }, idleTimer = timer(end, options.idle_timeout), lifeTimer = timer(end, options.max_lifetime), connectTimer = timer(connectTimedOut, options.connect_timeout);
  let socket = null, cancelMessage, result2 = new Result, incoming = Buffer.alloc(0), needsTypes = options.fetch_types, backendParameters = {}, statements = {}, statementId = Math.random().toString(36).slice(2), statementCount = 1, closedDate = 0, remaining = 0, hostIndex = 0, retries = 0, length = 0, delay = 0, rows = 0, serverSignature = null, nextWriteTimer = null, terminated = false, incomings = null, results = null, initial = null, ending = null, stream = null, chunk = null, ended = null, nonce = null, query4 = null, final = null;
  const connection2 = {
    queue: queues.closed,
    idleTimer,
    connect(query5) {
      initial = query5 || true;
      reconnect();
    },
    terminate,
    execute,
    cancel,
    end,
    count: 0,
    id
  };
  queues.closed && queues.closed.push(connection2);
  return connection2;
  async function createSocket() {
    let x;
    try {
      x = options.socket ? await Promise.resolve(options.socket(options)) : new net.Socket;
    } catch (e) {
      error(e);
      return;
    }
    x.on("error", error);
    x.on("close", closed);
    x.on("drain", drain);
    return x;
  }
  async function cancel({ pid, secret }, resolve, reject) {
    try {
      cancelMessage = bytes_default().i32(16).i32(80877102).i32(pid).i32(secret).end(16);
      await connect();
      socket.once("error", reject);
      socket.once("close", resolve);
    } catch (error2) {
      reject(error2);
    }
  }
  function execute(q) {
    if (terminated)
      return queryError(q, Errors.connection("CONNECTION_DESTROYED", options));
    if (q.cancelled)
      return;
    try {
      q.state = backend;
      query4 ? sent.push(q) : (query4 = q, query4.active = true);
      build(q);
      return write(toBuffer(q)) && !q.describeFirst && !q.cursorFn && sent.length < max_pipeline && (!q.options.onexecute || q.options.onexecute(connection2));
    } catch (error2) {
      sent.length === 0 && write(Sync);
      errored(error2);
      return true;
    }
  }
  function toBuffer(q) {
    if (q.parameters.length >= 65534)
      throw Errors.generic("MAX_PARAMETERS_EXCEEDED", "Max number of parameters (65534) exceeded");
    return q.options.simple ? bytes_default().Q().str(q.statement.string + bytes_default.N).end() : q.describeFirst ? Buffer.concat([describe(q), Flush]) : q.prepare ? q.prepared ? prepared(q) : Buffer.concat([describe(q), prepared(q)]) : unnamed(q);
  }
  function describe(q) {
    return Buffer.concat([
      Parse(q.statement.string, q.parameters, q.statement.types, q.statement.name),
      Describe("S", q.statement.name)
    ]);
  }
  function prepared(q) {
    return Buffer.concat([
      Bind(q.parameters, q.statement.types, q.statement.name, q.cursorName),
      q.cursorFn ? Execute("", q.cursorRows) : ExecuteUnnamed
    ]);
  }
  function unnamed(q) {
    return Buffer.concat([
      Parse(q.statement.string, q.parameters, q.statement.types),
      DescribeUnnamed,
      prepared(q)
    ]);
  }
  function build(q) {
    const parameters = [], types3 = [];
    const string = stringify(q, q.strings[0], q.args[0], parameters, types3, options);
    !q.tagged && q.args.forEach((x) => handleValue(x, parameters, types3, options));
    q.prepare = options.prepare && ("prepare" in q.options ? q.options.prepare : true);
    q.string = string;
    q.signature = q.prepare && types3 + string;
    q.onlyDescribe && delete statements[q.signature];
    q.parameters = q.parameters || parameters;
    q.prepared = q.prepare && q.signature in statements;
    q.describeFirst = q.onlyDescribe || parameters.length && !q.prepared;
    q.statement = q.prepared ? statements[q.signature] : { string, types: types3, name: q.prepare ? statementId + statementCount++ : "" };
    typeof options.debug === "function" && options.debug(id, string, parameters, types3);
  }
  function write(x, fn) {
    chunk = chunk ? Buffer.concat([chunk, x]) : Buffer.from(x);
    if (fn || chunk.length >= 1024)
      return nextWrite(fn);
    nextWriteTimer === null && (nextWriteTimer = setImmediate(nextWrite));
    return true;
  }
  function nextWrite(fn) {
    const x = socket.write(chunk, fn);
    nextWriteTimer !== null && clearImmediate(nextWriteTimer);
    chunk = nextWriteTimer = null;
    return x;
  }
  function connectTimedOut() {
    errored(Errors.connection("CONNECT_TIMEOUT", options, socket));
    socket.destroy();
  }
  async function secure() {
    write(SSLRequest);
    const canSSL = await new Promise((r) => socket.once("data", (x) => r(x[0] === 83)));
    if (!canSSL && ssl === "prefer")
      return connected();
    socket.removeAllListeners();
    socket = tls.connect({
      socket,
      servername: net.isIP(socket.host) ? undefined : socket.host,
      ...ssl === "require" || ssl === "allow" || ssl === "prefer" ? { rejectUnauthorized: false } : ssl === "verify-full" ? {} : typeof ssl === "object" ? ssl : {}
    });
    socket.on("secureConnect", connected);
    socket.on("error", error);
    socket.on("close", closed);
    socket.on("drain", drain);
  }
  function drain() {
    !query4 && onopen(connection2);
  }
  function data(x) {
    if (incomings) {
      incomings.push(x);
      remaining -= x.length;
      if (remaining >= 0)
        return;
    }
    incoming = incomings ? Buffer.concat(incomings, length - remaining) : incoming.length === 0 ? x : Buffer.concat([incoming, x], incoming.length + x.length);
    while (incoming.length > 4) {
      length = incoming.readUInt32BE(1);
      if (length >= incoming.length) {
        remaining = length - incoming.length;
        incomings = [incoming];
        break;
      }
      try {
        handle(incoming.subarray(0, length + 1));
      } catch (e) {
        query4 && (query4.cursorFn || query4.describeFirst) && write(Sync);
        errored(e);
      }
      incoming = incoming.subarray(length + 1);
      remaining = 0;
      incomings = null;
    }
  }
  async function connect() {
    terminated = false;
    backendParameters = {};
    socket || (socket = await createSocket());
    if (!socket)
      return;
    connectTimer.start();
    if (options.socket)
      return ssl ? secure() : connected();
    socket.on("connect", ssl ? secure : connected);
    if (options.path)
      return socket.connect(options.path);
    socket.ssl = ssl;
    socket.connect(port[hostIndex], host[hostIndex]);
    socket.host = host[hostIndex];
    socket.port = port[hostIndex];
    hostIndex = (hostIndex + 1) % port.length;
  }
  function reconnect() {
    setTimeout(connect, closedDate ? closedDate + delay - performance.now() : 0);
  }
  function connected() {
    try {
      statements = {};
      needsTypes = options.fetch_types;
      statementId = Math.random().toString(36).slice(2);
      statementCount = 1;
      lifeTimer.start();
      socket.on("data", data);
      keep_alive && socket.setKeepAlive && socket.setKeepAlive(true, 1000 * keep_alive);
      const s = StartupMessage();
      write(s);
    } catch (err) {
      error(err);
    }
  }
  function error(err) {
    if (connection2.queue === queues.connecting && options.host[retries + 1])
      return;
    errored(err);
    while (sent.length)
      queryError(sent.shift(), err);
  }
  function errored(err) {
    stream && (stream.destroy(err), stream = null);
    query4 && queryError(query4, err);
    initial && (queryError(initial, err), initial = null);
  }
  function queryError(query5, err) {
    Object.defineProperties(err, {
      stack: { value: err.stack + query5.origin.replace(/.*\n/, "\n"), enumerable: options.debug },
      query: { value: query5.string, enumerable: options.debug },
      parameters: { value: query5.parameters, enumerable: options.debug },
      args: { value: query5.args, enumerable: options.debug },
      types: { value: query5.statement && query5.statement.types, enumerable: options.debug }
    });
    query5.reject(err);
  }
  function end() {
    return ending || (!connection2.reserved && onend(connection2), !connection2.reserved && !initial && !query4 && sent.length === 0 ? (terminate(), new Promise((r) => socket && socket.readyState !== "closed" ? socket.once("close", r) : r())) : ending = new Promise((r) => ended = r));
  }
  function terminate() {
    terminated = true;
    if (stream || query4 || initial || sent.length)
      error(Errors.connection("CONNECTION_DESTROYED", options));
    clearImmediate(nextWriteTimer);
    if (socket) {
      socket.removeListener("data", data);
      socket.removeListener("connect", connected);
      socket.readyState === "open" && socket.end(bytes_default().X().end());
    }
    ended && (ended(), ending = ended = null);
  }
  async function closed(hadError) {
    incoming = Buffer.alloc(0);
    remaining = 0;
    incomings = null;
    clearImmediate(nextWriteTimer);
    socket.removeListener("data", data);
    socket.removeListener("connect", connected);
    idleTimer.cancel();
    lifeTimer.cancel();
    connectTimer.cancel();
    if (socket.encrypted) {
      socket.removeAllListeners();
      socket = null;
    }
    if (initial)
      return reconnect();
    !hadError && (query4 || sent.length) && error(Errors.connection("CONNECTION_CLOSED", options, socket));
    closedDate = performance.now();
    hadError && options.shared.retries++;
    delay = (typeof backoff === "function" ? backoff(options.shared.retries) : backoff) * 1000;
    onclose(connection2, Errors.connection("CONNECTION_CLOSED", options, socket));
  }
  function handle(xs, x = xs[0]) {
    (x === 68 ? DataRow : x === 100 ? CopyData : x === 65 ? NotificationResponse : x === 83 ? ParameterStatus : x === 90 ? ReadyForQuery : x === 67 ? CommandComplete : x === 50 ? BindComplete : x === 49 ? ParseComplete : x === 116 ? ParameterDescription : x === 84 ? RowDescription : x === 82 ? Authentication : x === 110 ? NoData : x === 75 ? BackendKeyData : x === 69 ? ErrorResponse : x === 115 ? PortalSuspended : x === 51 ? CloseComplete : x === 71 ? CopyInResponse : x === 78 ? NoticeResponse : x === 72 ? CopyOutResponse : x === 99 ? CopyDone : x === 73 ? EmptyQueryResponse : x === 86 ? FunctionCallResponse : x === 118 ? NegotiateProtocolVersion : x === 87 ? CopyBothResponse : UnknownMessage)(xs);
  }
  function DataRow(x) {
    let index = 7;
    let length2;
    let column9;
    let value;
    const row = query4.isRaw ? new Array(query4.statement.columns.length) : {};
    for (let i = 0;i < query4.statement.columns.length; i++) {
      column9 = query4.statement.columns[i];
      length2 = x.readInt32BE(index);
      index += 4;
      value = length2 === -1 ? null : query4.isRaw === true ? x.subarray(index, index += length2) : column9.parser === undefined ? x.toString("utf8", index, index += length2) : column9.parser.array === true ? column9.parser(x.toString("utf8", index + 1, index += length2)) : column9.parser(x.toString("utf8", index, index += length2));
      query4.isRaw ? row[i] = query4.isRaw === true ? value : transform.value.from ? transform.value.from(value, column9) : value : row[column9.name] = transform.value.from ? transform.value.from(value, column9) : value;
    }
    query4.forEachFn ? query4.forEachFn(transform.row.from ? transform.row.from(row) : row, result2) : result2[rows++] = transform.row.from ? transform.row.from(row) : row;
  }
  function ParameterStatus(x) {
    const [k, v] = x.toString("utf8", 5, x.length - 1).split(bytes_default.N);
    backendParameters[k] = v;
    if (options.parameters[k] !== v) {
      options.parameters[k] = v;
      onparameter && onparameter(k, v);
    }
  }
  function ReadyForQuery(x) {
    query4 && query4.options.simple && query4.resolve(results || result2);
    query4 = results = null;
    result2 = new Result;
    connectTimer.cancel();
    if (initial) {
      if (target_session_attrs) {
        if (!backendParameters.in_hot_standby || !backendParameters.default_transaction_read_only)
          return fetchState();
        else if (tryNext(target_session_attrs, backendParameters))
          return terminate();
      }
      if (needsTypes) {
        initial === true && (initial = null);
        return fetchArrayTypes();
      }
      initial !== true && execute(initial);
      options.shared.retries = retries = 0;
      initial = null;
      return;
    }
    while (sent.length && (query4 = sent.shift()) && (query4.active = true, query4.cancelled))
      Connection(options).cancel(query4.state, query4.cancelled.resolve, query4.cancelled.reject);
    if (query4)
      return;
    connection2.reserved ? !connection2.reserved.release && x[5] === 73 ? ending ? terminate() : (connection2.reserved = null, onopen(connection2)) : connection2.reserved() : ending ? terminate() : onopen(connection2);
  }
  function CommandComplete(x) {
    rows = 0;
    for (let i = x.length - 1;i > 0; i--) {
      if (x[i] === 32 && x[i + 1] < 58 && result2.count === null)
        result2.count = +x.toString("utf8", i + 1, x.length - 1);
      if (x[i - 1] >= 65) {
        result2.command = x.toString("utf8", 5, i);
        result2.state = backend;
        break;
      }
    }
    final && (final(), final = null);
    if (result2.command === "BEGIN" && max !== 1 && !connection2.reserved)
      return errored(Errors.generic("UNSAFE_TRANSACTION", "Only use sql.begin, sql.reserved or max: 1"));
    if (query4.options.simple)
      return BindComplete();
    if (query4.cursorFn) {
      result2.count && query4.cursorFn(result2);
      write(Sync);
    }
    query4.resolve(result2);
  }
  function ParseComplete() {
    query4.parsing = false;
  }
  function BindComplete() {
    !result2.statement && (result2.statement = query4.statement);
    result2.columns = query4.statement.columns;
  }
  function ParameterDescription(x) {
    const length2 = x.readUInt16BE(5);
    for (let i = 0;i < length2; ++i)
      !query4.statement.types[i] && (query4.statement.types[i] = x.readUInt32BE(7 + i * 4));
    query4.prepare && (statements[query4.signature] = query4.statement);
    query4.describeFirst && !query4.onlyDescribe && (write(prepared(query4)), query4.describeFirst = false);
  }
  function RowDescription(x) {
    if (result2.command) {
      results = results || [result2];
      results.push(result2 = new Result);
      result2.count = null;
      query4.statement.columns = null;
    }
    const length2 = x.readUInt16BE(5);
    let index = 7;
    let start;
    query4.statement.columns = Array(length2);
    for (let i = 0;i < length2; ++i) {
      start = index;
      while (x[index++] !== 0)
        ;
      const table16 = x.readUInt32BE(index);
      const number = x.readUInt16BE(index + 4);
      const type = x.readUInt32BE(index + 6);
      query4.statement.columns[i] = {
        name: transform.column.from ? transform.column.from(x.toString("utf8", start, index - 1)) : x.toString("utf8", start, index - 1),
        parser: parsers2[type],
        table: table16,
        number,
        type
      };
      index += 18;
    }
    result2.statement = query4.statement;
    if (query4.onlyDescribe)
      return query4.resolve(query4.statement), write(Sync);
  }
  async function Authentication(x, type = x.readUInt32BE(5)) {
    (type === 3 ? AuthenticationCleartextPassword : type === 5 ? AuthenticationMD5Password : type === 10 ? SASL : type === 11 ? SASLContinue : type === 12 ? SASLFinal : type !== 0 ? UnknownAuth : noop)(x, type);
  }
  async function AuthenticationCleartextPassword() {
    const payload = await Pass();
    write(bytes_default().p().str(payload).z(1).end());
  }
  async function AuthenticationMD5Password(x) {
    const payload = "md5" + await md5(Buffer.concat([
      Buffer.from(await md5(await Pass() + user)),
      x.subarray(9)
    ]));
    write(bytes_default().p().str(payload).z(1).end());
  }
  async function SASL() {
    nonce = (await crypto2.randomBytes(18)).toString("base64");
    bytes_default().p().str("SCRAM-SHA-256" + bytes_default.N);
    const i = bytes_default.i;
    write(bytes_default.inc(4).str("n,,n=*,r=" + nonce).i32(bytes_default.i - i - 4, i).end());
  }
  async function SASLContinue(x) {
    const res = x.toString("utf8", 9).split(",").reduce((acc, x2) => (acc[x2[0]] = x2.slice(2), acc), {});
    const saltedPassword = await crypto2.pbkdf2Sync(await Pass(), Buffer.from(res.s, "base64"), parseInt(res.i), 32, "sha256");
    const clientKey = await hmac(saltedPassword, "Client Key");
    const auth = "n=*,r=" + nonce + ",r=" + res.r + ",s=" + res.s + ",i=" + res.i + ",c=biws,r=" + res.r;
    serverSignature = (await hmac(await hmac(saltedPassword, "Server Key"), auth)).toString("base64");
    const payload = "c=biws,r=" + res.r + ",p=" + xor(clientKey, Buffer.from(await hmac(await sha256(clientKey), auth))).toString("base64");
    write(bytes_default().p().str(payload).end());
  }
  function SASLFinal(x) {
    if (x.toString("utf8", 9).split(bytes_default.N, 1)[0].slice(2) === serverSignature)
      return;
    errored(Errors.generic("SASL_SIGNATURE_MISMATCH", "The server did not return the correct signature"));
    socket.destroy();
  }
  function Pass() {
    return Promise.resolve(typeof options.pass === "function" ? options.pass() : options.pass);
  }
  function NoData() {
    result2.statement = query4.statement;
    result2.statement.columns = [];
    if (query4.onlyDescribe)
      return query4.resolve(query4.statement), write(Sync);
  }
  function BackendKeyData(x) {
    backend.pid = x.readUInt32BE(5);
    backend.secret = x.readUInt32BE(9);
  }
  async function fetchArrayTypes() {
    needsTypes = false;
    const types3 = await new Query([`
      select b.oid, b.typarray
      from pg_catalog.pg_type a
      left join pg_catalog.pg_type b on b.oid = a.typelem
      where a.typcategory = 'A'
      group by b.oid, b.typarray
      order by b.oid
    `], [], execute);
    types3.forEach(({ oid, typarray }) => addArrayType(oid, typarray));
  }
  function addArrayType(oid, typarray) {
    if (!!options.parsers[typarray] && !!options.serializers[typarray])
      return;
    const parser = options.parsers[oid];
    options.shared.typeArrayMap[oid] = typarray;
    options.parsers[typarray] = (xs) => arrayParser(xs, parser, typarray);
    options.parsers[typarray].array = true;
    options.serializers[typarray] = (xs) => arraySerializer(xs, options.serializers[oid], options, typarray);
  }
  function tryNext(x, xs) {
    return x === "read-write" && xs.default_transaction_read_only === "on" || x === "read-only" && xs.default_transaction_read_only === "off" || x === "primary" && xs.in_hot_standby === "on" || x === "standby" && xs.in_hot_standby === "off" || x === "prefer-standby" && xs.in_hot_standby === "off" && options.host[retries];
  }
  function fetchState() {
    const query5 = new Query([`
      show transaction_read_only;
      select pg_catalog.pg_is_in_recovery()
    `], [], execute, null, { simple: true });
    query5.resolve = ([[a], [b2]]) => {
      backendParameters.default_transaction_read_only = a.transaction_read_only;
      backendParameters.in_hot_standby = b2.pg_is_in_recovery ? "on" : "off";
    };
    query5.execute();
  }
  function ErrorResponse(x) {
    query4 && (query4.cursorFn || query4.describeFirst) && write(Sync);
    const error2 = Errors.postgres(parseError(x));
    query4 && query4.retried ? errored(query4.retried) : query4 && retryRoutines.has(error2.routine) ? retry(query4, error2) : errored(error2);
  }
  function retry(q, error2) {
    delete statements[q.signature];
    q.retried = error2;
    execute(q);
  }
  function NotificationResponse(x) {
    if (!onnotify)
      return;
    let index = 9;
    while (x[index++] !== 0)
      ;
    onnotify(x.toString("utf8", 9, index - 1), x.toString("utf8", index, x.length - 1));
  }
  async function PortalSuspended() {
    try {
      const x = await Promise.resolve(query4.cursorFn(result2));
      rows = 0;
      x === CLOSE ? write(Close(query4.portal)) : (result2 = new Result, write(Execute("", query4.cursorRows)));
    } catch (err) {
      write(Sync);
      query4.reject(err);
    }
  }
  function CloseComplete() {
    result2.count && query4.cursorFn(result2);
    query4.resolve(result2);
  }
  function CopyInResponse() {
    stream = new Stream.Writable({
      autoDestroy: true,
      write(chunk2, encoding, callback) {
        socket.write(bytes_default().d().raw(chunk2).end(), callback);
      },
      destroy(error2, callback) {
        callback(error2);
        socket.write(bytes_default().f().str(error2 + bytes_default.N).end());
        stream = null;
      },
      final(callback) {
        socket.write(bytes_default().c().end());
        final = callback;
      }
    });
    query4.resolve(stream);
  }
  function CopyOutResponse() {
    stream = new Stream.Readable({
      read() {
        socket.resume();
      }
    });
    query4.resolve(stream);
  }
  function CopyBothResponse() {
    stream = new Stream.Duplex({
      autoDestroy: true,
      read() {
        socket.resume();
      },
      write(chunk2, encoding, callback) {
        socket.write(bytes_default().d().raw(chunk2).end(), callback);
      },
      destroy(error2, callback) {
        callback(error2);
        socket.write(bytes_default().f().str(error2 + bytes_default.N).end());
        stream = null;
      },
      final(callback) {
        socket.write(bytes_default().c().end());
        final = callback;
      }
    });
    query4.resolve(stream);
  }
  function CopyData(x) {
    stream && (stream.push(x.subarray(5)) || socket.pause());
  }
  function CopyDone() {
    stream && stream.push(null);
    stream = null;
  }
  function NoticeResponse(x) {
    onnotice ? onnotice(parseError(x)) : console.log(parseError(x));
  }
  function EmptyQueryResponse() {
  }
  function FunctionCallResponse() {
    errored(Errors.notSupported("FunctionCallResponse"));
  }
  function NegotiateProtocolVersion() {
    errored(Errors.notSupported("NegotiateProtocolVersion"));
  }
  function UnknownMessage(x) {
    console.error("Postgres.js : Unknown Message:", x[0]);
  }
  function UnknownAuth(x, type) {
    console.error("Postgres.js : Unknown Auth:", type);
  }
  function Bind(parameters, types3, statement = "", portal = "") {
    let prev, type;
    bytes_default().B().str(portal + bytes_default.N).str(statement + bytes_default.N).i16(0).i16(parameters.length);
    parameters.forEach((x, i) => {
      if (x === null)
        return bytes_default.i32(4294967295);
      type = types3[i];
      parameters[i] = x = type in options.serializers ? options.serializers[type](x) : "" + x;
      prev = bytes_default.i;
      bytes_default.inc(4).str(x).i32(bytes_default.i - prev - 4, prev);
    });
    bytes_default.i16(0);
    return bytes_default.end();
  }
  function Parse(str, parameters, types3, name = "") {
    bytes_default().P().str(name + bytes_default.N).str(str + bytes_default.N).i16(parameters.length);
    parameters.forEach((x, i) => bytes_default.i32(types3[i] || 0));
    return bytes_default.end();
  }
  function Describe(x, name = "") {
    return bytes_default().D().str(x).str(name + bytes_default.N).end();
  }
  function Execute(portal = "", rows2 = 0) {
    return Buffer.concat([
      bytes_default().E().str(portal + bytes_default.N).i32(rows2).end(),
      Flush
    ]);
  }
  function Close(portal = "") {
    return Buffer.concat([
      bytes_default().C().str("P").str(portal + bytes_default.N).end(),
      bytes_default().S().end()
    ]);
  }
  function StartupMessage() {
    return cancelMessage || bytes_default().inc(4).i16(3).z(2).str(Object.entries(Object.assign({
      user,
      database,
      client_encoding: "UTF8"
    }, options.connection)).filter(([, v]) => v).map(([k, v]) => k + bytes_default.N + v).join(bytes_default.N)).z(2).end(0);
  }
};
var parseError = function(x) {
  const error = {};
  let start = 5;
  for (let i = 5;i < x.length - 1; i++) {
    if (x[i] === 0) {
      error[errorFields[x[start]]] = x.toString("utf8", start + 1, i);
      start = i + 1;
    }
  }
  return error;
};
var md5 = function(x) {
  return crypto2.createHash("md5").update(x).digest("hex");
};
var hmac = function(key, x) {
  return crypto2.createHmac("sha256", key).update(x).digest();
};
var sha256 = function(x) {
  return crypto2.createHash("sha256").update(x).digest();
};
var xor = function(a, b2) {
  const length = Math.max(a.length, b2.length);
  const buffer2 = Buffer.allocUnsafe(length);
  for (let i = 0;i < length; i++)
    buffer2[i] = a[i] ^ b2[i];
  return buffer2;
};
var timer = function(fn, seconds) {
  seconds = typeof seconds === "function" ? seconds() : seconds;
  if (!seconds)
    return { cancel: noop, start: noop };
  let timer2;
  return {
    cancel() {
      timer2 && (clearTimeout(timer2), timer2 = null);
    },
    start() {
      timer2 && clearTimeout(timer2);
      timer2 = setTimeout(done, seconds * 1000, arguments);
    }
  };
  function done(args) {
    fn.apply(null, args);
    timer2 = null;
  }
};
var connection_default = Connection;
var uid = 1;
var Sync = bytes_default().S().end();
var Flush = bytes_default().H().end();
var SSLRequest = bytes_default().i32(8).i32(80877103).end(8);
var ExecuteUnnamed = Buffer.concat([bytes_default().E().str(bytes_default.N).i32(0).end(), Sync]);
var DescribeUnnamed = bytes_default().D().str("S").str(bytes_default.N).end();
var noop = () => {
};
var retryRoutines = new Set([
  "FetchPreparedStatement",
  "RevalidateCachedQuery",
  "transformAssignedExpr"
]);
var errorFields = {
  83: "severity_local",
  86: "severity",
  67: "code",
  77: "message",
  68: "detail",
  72: "hint",
  80: "position",
  112: "internal_position",
  113: "internal_query",
  87: "where",
  115: "schema_name",
  116: "table_name",
  99: "column_name",
  100: "data type_name",
  110: "constraint_name",
  70: "file",
  76: "line",
  82: "routine"
};

// node_modules/postgres/src/subscribe.js
var Time = function(x) {
  return new Date(Date.UTC(2000, 0, 1) + Number(x / BigInt(1000)));
};
var parse = function(x, state, parsers2, handle, transform) {
  const char = (acc, [k, v]) => (acc[k.charCodeAt(0)] = v, acc);
  Object.entries({
    R: (x2) => {
      let i = 1;
      const r = state[x2.readUInt32BE(i)] = {
        schema: x2.toString("utf8", i += 4, i = x2.indexOf(0, i)) || "pg_catalog",
        table: x2.toString("utf8", i + 1, i = x2.indexOf(0, i + 1)),
        columns: Array(x2.readUInt16BE(i += 2)),
        keys: []
      };
      i += 2;
      let columnIndex = 0, column9;
      while (i < x2.length) {
        column9 = r.columns[columnIndex++] = {
          key: x2[i++],
          name: transform.column.from ? transform.column.from(x2.toString("utf8", i, i = x2.indexOf(0, i))) : x2.toString("utf8", i, i = x2.indexOf(0, i)),
          type: x2.readUInt32BE(i += 1),
          parser: parsers2[x2.readUInt32BE(i)],
          atttypmod: x2.readUInt32BE(i += 4)
        };
        column9.key && r.keys.push(column9);
        i += 4;
      }
    },
    Y: () => {
    },
    O: () => {
    },
    B: (x2) => {
      state.date = Time(x2.readBigInt64BE(9));
      state.lsn = x2.subarray(1, 9);
    },
    I: (x2) => {
      let i = 1;
      const relation = state[x2.readUInt32BE(i)];
      const { row } = tuples(x2, relation.columns, i += 7, transform);
      handle(row, {
        command: "insert",
        relation
      });
    },
    D: (x2) => {
      let i = 1;
      const relation = state[x2.readUInt32BE(i)];
      i += 4;
      const key = x2[i] === 75;
      handle(key || x2[i] === 79 ? tuples(x2, relation.columns, i += 3, transform).row : null, {
        command: "delete",
        relation,
        key
      });
    },
    U: (x2) => {
      let i = 1;
      const relation = state[x2.readUInt32BE(i)];
      i += 4;
      const key = x2[i] === 75;
      const xs = key || x2[i] === 79 ? tuples(x2, relation.columns, i += 3, transform) : null;
      xs && (i = xs.i);
      const { row } = tuples(x2, relation.columns, i + 3, transform);
      handle(row, {
        command: "update",
        relation,
        key,
        old: xs && xs.row
      });
    },
    T: () => {
    },
    C: () => {
    }
  }).reduce(char, {})[x[0]](x);
};
var tuples = function(x, columns2, xi, transform) {
  let type, column9, value;
  const row = transform.raw ? new Array(columns2.length) : {};
  for (let i = 0;i < columns2.length; i++) {
    type = x[xi++];
    column9 = columns2[i];
    value = type === 110 ? null : type === 117 ? undefined : column9.parser === undefined ? x.toString("utf8", xi + 4, xi += 4 + x.readUInt32BE(xi)) : column9.parser.array === true ? column9.parser(x.toString("utf8", xi + 5, xi += 4 + x.readUInt32BE(xi))) : column9.parser(x.toString("utf8", xi + 4, xi += 4 + x.readUInt32BE(xi)));
    transform.raw ? row[i] = transform.raw === true ? value : transform.value.from ? transform.value.from(value, column9) : value : row[column9.name] = transform.value.from ? transform.value.from(value, column9) : value;
  }
  return { i: xi, row: transform.row.from ? transform.row.from(row) : row };
};
var parseEvent = function(x) {
  const xs = x.match(/^(\*|insert|update|delete)?:?([^.]+?\.?[^=]+)?=?(.+)?/i) || [];
  if (!xs)
    throw new Error("Malformed subscribe pattern: " + x);
  const [, command, path, key] = xs;
  return (command || "*") + (path ? ":" + (path.indexOf(".") === -1 ? "public." + path : path) : "") + (key ? "=" + key : "");
};
var noop2 = () => {
};
function Subscribe(postgres2, options) {
  const subscribers = new Map, slot = "postgresjs_" + Math.random().toString(36).slice(2), state = {};
  let connection2, stream, ended = false;
  const sql17 = subscribe.sql = postgres2({
    ...options,
    transform: { column: {}, value: {}, row: {} },
    max: 1,
    fetch_types: false,
    idle_timeout: null,
    max_lifetime: null,
    connection: {
      ...options.connection,
      replication: "database"
    },
    onclose: async function() {
      if (ended)
        return;
      stream = null;
      state.pid = state.secret = undefined;
      connected(await init2(sql17, slot, options.publications));
      subscribers.forEach((event) => event.forEach(({ onsubscribe }) => onsubscribe()));
    },
    no_subscribe: true
  });
  const { end, close } = sql17;
  sql17.end = async () => {
    ended = true;
    stream && await new Promise((r) => (stream.once("close", r), stream.end()));
    return end();
  };
  sql17.close = async () => {
    stream && await new Promise((r) => (stream.once("close", r), stream.end()));
    return close();
  };
  return subscribe;
  async function subscribe(event, fn, onsubscribe = noop2) {
    event = parseEvent(event);
    if (!connection2)
      connection2 = init2(sql17, slot, options.publications);
    const subscriber = { fn, onsubscribe };
    const fns = subscribers.has(event) ? subscribers.get(event).add(subscriber) : subscribers.set(event, new Set([subscriber])).get(event);
    const unsubscribe = () => {
      fns.delete(subscriber);
      fns.size === 0 && subscribers.delete(event);
    };
    return connection2.then((x) => {
      connected(x);
      onsubscribe();
      return { unsubscribe, state, sql: sql17 };
    });
  }
  function connected(x) {
    stream = x.stream;
    state.pid = x.state.pid;
    state.secret = x.state.secret;
  }
  async function init2(sql18, slot2, publications) {
    if (!publications)
      throw new Error("Missing publication names");
    const xs = await sql18.unsafe(`CREATE_REPLICATION_SLOT ${slot2} TEMPORARY LOGICAL pgoutput NOEXPORT_SNAPSHOT`);
    const [x] = xs;
    const stream2 = await sql18.unsafe(`START_REPLICATION SLOT ${slot2} LOGICAL ${x.consistent_point} (proto_version '1', publication_names '${publications}')`).writable();
    const state2 = {
      lsn: Buffer.concat(x.consistent_point.split("/").map((x2) => Buffer.from(("00000000" + x2).slice(-8), "hex")))
    };
    stream2.on("data", data);
    stream2.on("error", error);
    stream2.on("close", sql18.close);
    return { stream: stream2, state: xs.state };
    function error(e) {
      console.error("Unexpected error during logical streaming - reconnecting", e);
    }
    function data(x2) {
      if (x2[0] === 119)
        parse(x2.subarray(25), state2, sql18.options.parsers, handle, options.transform);
      else if (x2[0] === 107 && x2[17])
        pong();
    }
    function handle(a, b2) {
      const path = b2.relation.schema + "." + b2.relation.table;
      call("*", a, b2);
      call("*:" + path, a, b2);
      b2.relation.keys.length && call("*:" + path + "=" + b2.relation.keys.map((x2) => a[x2.name]), a, b2);
      call(b2.command, a, b2);
      call(b2.command + ":" + path, a, b2);
      b2.relation.keys.length && call(b2.command + ":" + path + "=" + b2.relation.keys.map((x2) => a[x2.name]), a, b2);
    }
    function pong() {
      const x2 = Buffer.alloc(34);
      x2[0] = "r".charCodeAt(0);
      x2.fill(state2.lsn, 1);
      x2.writeBigInt64BE(BigInt(Date.now() - Date.UTC(2000, 0, 1)) * BigInt(1000), 25);
      stream2.write(x2);
    }
  }
  function call(x, a, b2) {
    subscribers.has(x) && subscribers.get(x).forEach(({ fn }) => fn(a, b2, x));
  }
}

// node_modules/postgres/src/large.js
import Stream2 from "stream";
function largeObject(sql17, oid, mode = 131072 | 262144) {
  return new Promise(async (resolve, reject) => {
    await sql17.begin(async (sql18) => {
      let finish;
      !oid && ([{ oid }] = await sql18`select lo_creat(-1) as oid`);
      const [{ fd }] = await sql18`select lo_open(${oid}, ${mode}) as fd`;
      const lo = {
        writable,
        readable,
        close: () => sql18`select lo_close(${fd})`.then(finish),
        tell: () => sql18`select lo_tell64(${fd})`,
        read: (x) => sql18`select loread(${fd}, ${x}) as data`,
        write: (x) => sql18`select lowrite(${fd}, ${x})`,
        truncate: (x) => sql18`select lo_truncate64(${fd}, ${x})`,
        seek: (x, whence = 0) => sql18`select lo_lseek64(${fd}, ${x}, ${whence})`,
        size: () => sql18`
          select
            lo_lseek64(${fd}, location, 0) as position,
            seek.size
          from (
            select
              lo_lseek64($1, 0, 2) as size,
              tell.location
            from (select lo_tell64($1) as location) tell
          ) seek
        `
      };
      resolve(lo);
      return new Promise(async (r) => finish = r);
      async function readable({
        highWaterMark = 2048 * 8,
        start = 0,
        end = Infinity
      } = {}) {
        let max = end - start;
        start && await lo.seek(start);
        return new Stream2.Readable({
          highWaterMark,
          async read(size2) {
            const l = size2 > max ? size2 - max : size2;
            max -= size2;
            const [{ data }] = await lo.read(l);
            this.push(data);
            if (data.length < size2)
              this.push(null);
          }
        });
      }
      async function writable({
        highWaterMark = 2048 * 8,
        start = 0
      } = {}) {
        start && await lo.seek(start);
        return new Stream2.Writable({
          highWaterMark,
          write(chunk, encoding, callback) {
            lo.write(chunk).then(() => callback(), callback);
          }
        });
      }
    }).catch(reject);
  });
}

// node_modules/postgres/src/index.js
var Postgres = function(a, b2) {
  const options = parseOptions(a, b2), subscribe2 = options.no_subscribe || Subscribe(Postgres, { ...options });
  let ending = false;
  const queries = queue_default(), connecting = queue_default(), reserved = queue_default(), closed = queue_default(), ended = queue_default(), open = queue_default(), busy = queue_default(), full = queue_default(), queues = { connecting, reserved, closed, ended, open, busy, full };
  const connections = [...Array(options.max)].map(() => connection_default(options, queues, { onopen, onend, onclose }));
  const sql17 = Sql(handler);
  Object.assign(sql17, {
    get parameters() {
      return options.parameters;
    },
    largeObject: largeObject.bind(null, sql17),
    subscribe: subscribe2,
    CLOSE,
    END: CLOSE,
    PostgresError,
    options,
    reserve,
    listen,
    begin,
    close,
    end
  });
  return sql17;
  function Sql(handler2) {
    handler2.debug = options.debug;
    Object.entries(options.types).reduce((acc, [name, type]) => {
      acc[name] = (x) => new Parameter(x, type.to);
      return acc;
    }, typed);
    Object.assign(sql18, {
      types: typed,
      typed,
      unsafe,
      notify,
      array: array2,
      json,
      file
    });
    return sql18;
    function typed(value, type) {
      return new Parameter(value, type);
    }
    function sql18(strings, ...args) {
      const query5 = strings && Array.isArray(strings.raw) ? new Query(strings, args, handler2, cancel) : typeof strings === "string" && !args.length ? new Identifier(options.transform.column.to ? options.transform.column.to(strings) : strings) : new Builder(strings, args);
      return query5;
    }
    function unsafe(string, args = [], options2 = {}) {
      arguments.length === 2 && !Array.isArray(args) && (options2 = args, args = []);
      const query5 = new Query([string], args, handler2, cancel, {
        prepare: false,
        ...options2,
        simple: "simple" in options2 ? options2.simple : args.length === 0
      });
      return query5;
    }
    function file(path, args = [], options2 = {}) {
      arguments.length === 2 && !Array.isArray(args) && (options2 = args, args = []);
      const query5 = new Query([], args, (query6) => {
        fs.readFile(path, "utf8", (err, string) => {
          if (err)
            return query6.reject(err);
          query6.strings = [string];
          handler2(query6);
        });
      }, cancel, {
        ...options2,
        simple: "simple" in options2 ? options2.simple : args.length === 0
      });
      return query5;
    }
  }
  async function listen(name, fn, onlisten) {
    const listener = { fn, onlisten };
    const sql18 = listen.sql || (listen.sql = Postgres({
      ...options,
      max: 1,
      idle_timeout: null,
      max_lifetime: null,
      fetch_types: false,
      onclose() {
        Object.entries(listen.channels).forEach(([name2, { listeners }]) => {
          delete listen.channels[name2];
          Promise.all(listeners.map((l) => listen(name2, l.fn, l.onlisten).catch(() => {
          })));
        });
      },
      onnotify(c2, x) {
        c2 in listen.channels && listen.channels[c2].listeners.forEach((l) => l.fn(x));
      }
    }));
    const channels = listen.channels || (listen.channels = {}), exists2 = name in channels;
    if (exists2) {
      channels[name].listeners.push(listener);
      const result3 = await channels[name].result;
      listener.onlisten && listener.onlisten();
      return { state: result3.state, unlisten };
    }
    channels[name] = { result: sql18`listen ${sql18.unsafe('"' + name.replace(/"/g, '""') + '"')}`, listeners: [listener] };
    const result2 = await channels[name].result;
    listener.onlisten && listener.onlisten();
    return { state: result2.state, unlisten };
    async function unlisten() {
      if (name in channels === false)
        return;
      channels[name].listeners = channels[name].listeners.filter((x) => x !== listener);
      if (channels[name].listeners.length)
        return;
      delete channels[name];
      return sql18`unlisten ${sql18.unsafe('"' + name.replace(/"/g, '""') + '"')}`;
    }
  }
  async function notify(channel, payload) {
    return await sql17`select pg_notify(${channel}, ${"" + payload})`;
  }
  async function reserve() {
    const queue3 = queue_default();
    const c2 = open.length ? open.shift() : await new Promise((r) => {
      queries.push({ reserve: r });
      closed.length && connect(closed.shift());
    });
    move(c2, reserved);
    c2.reserved = () => queue3.length ? c2.execute(queue3.shift()) : move(c2, reserved);
    c2.reserved.release = true;
    const sql18 = Sql(handler2);
    sql18.release = () => {
      c2.reserved = null;
      onopen(c2);
    };
    return sql18;
    function handler2(q) {
      c2.queue === full ? queue3.push(q) : c2.execute(q) || move(c2, full);
    }
  }
  async function begin(options2, fn) {
    !fn && (fn = options2, options2 = "");
    const queries2 = queue_default();
    let savepoints = 0, connection3, prepare = null;
    try {
      await sql17.unsafe("begin " + options2.replace(/[^a-z ]/ig, ""), [], { onexecute }).execute();
      return await Promise.race([
        scope(connection3, fn),
        new Promise((_, reject) => connection3.onclose = reject)
      ]);
    } catch (error) {
      throw error;
    }
    async function scope(c2, fn2, name) {
      const sql18 = Sql(handler2);
      sql18.savepoint = savepoint;
      sql18.prepare = (x) => prepare = x.replace(/[^a-z0-9$-_. ]/gi);
      let uncaughtError, result2;
      name && await sql18`savepoint ${sql18(name)}`;
      try {
        result2 = await new Promise((resolve, reject) => {
          const x = fn2(sql18);
          Promise.resolve(Array.isArray(x) ? Promise.all(x) : x).then(resolve, reject);
        });
        if (uncaughtError)
          throw uncaughtError;
      } catch (e) {
        await (name ? sql18`rollback to ${sql18(name)}` : sql18`rollback`);
        throw e instanceof PostgresError && e.code === "25P02" && uncaughtError || e;
      }
      if (!name) {
        prepare ? await sql18`prepare transaction '${sql18.unsafe(prepare)}'` : await sql18`commit`;
      }
      return result2;
      function savepoint(name2, fn3) {
        if (name2 && Array.isArray(name2.raw))
          return savepoint((sql19) => sql19.apply(sql19, arguments));
        arguments.length === 1 && (fn3 = name2, name2 = null);
        return scope(c2, fn3, "s" + savepoints++ + (name2 ? "_" + name2 : ""));
      }
      function handler2(q) {
        q.catch((e) => uncaughtError || (uncaughtError = e));
        c2.queue === full ? queries2.push(q) : c2.execute(q) || move(c2, full);
      }
    }
    function onexecute(c2) {
      connection3 = c2;
      move(c2, reserved);
      c2.reserved = () => queries2.length ? c2.execute(queries2.shift()) : move(c2, reserved);
    }
  }
  function move(c2, queue3) {
    c2.queue.remove(c2);
    queue3.push(c2);
    c2.queue = queue3;
    queue3 === open ? c2.idleTimer.start() : c2.idleTimer.cancel();
    return c2;
  }
  function json(x) {
    return new Parameter(x, 3802);
  }
  function array2(x, type) {
    if (!Array.isArray(x))
      return array2(Array.from(arguments));
    return new Parameter(x, type || (x.length ? inferType(x) || 25 : 0), options.shared.typeArrayMap);
  }
  function handler(query5) {
    if (ending)
      return query5.reject(Errors.connection("CONNECTION_ENDED", options, options));
    if (open.length)
      return go(open.shift(), query5);
    if (closed.length)
      return connect(closed.shift(), query5);
    busy.length ? go(busy.shift(), query5) : queries.push(query5);
  }
  function go(c2, query5) {
    return c2.execute(query5) ? move(c2, busy) : move(c2, full);
  }
  function cancel(query5) {
    return new Promise((resolve, reject) => {
      query5.state ? query5.active ? connection_default(options).cancel(query5.state, resolve, reject) : query5.cancelled = { resolve, reject } : (queries.remove(query5), query5.cancelled = true, query5.reject(Errors.generic("57014", "canceling statement due to user request")), resolve());
    });
  }
  async function end({ timeout = null } = {}) {
    if (ending)
      return ending;
    await 1;
    let timer2;
    return ending = Promise.race([
      new Promise((r) => timeout !== null && (timer2 = setTimeout(destroy, timeout * 1000, r))),
      Promise.all(connections.map((c2) => c2.end()).concat(listen.sql ? listen.sql.end({ timeout: 0 }) : [], subscribe2.sql ? subscribe2.sql.end({ timeout: 0 }) : []))
    ]).then(() => clearTimeout(timer2));
  }
  async function close() {
    await Promise.all(connections.map((c2) => c2.end()));
  }
  async function destroy(resolve) {
    await Promise.all(connections.map((c2) => c2.terminate()));
    while (queries.length)
      queries.shift().reject(Errors.connection("CONNECTION_DESTROYED", options));
    resolve();
  }
  function connect(c2, query5) {
    move(c2, connecting);
    c2.connect(query5);
    return c2;
  }
  function onend(c2) {
    move(c2, ended);
  }
  function onopen(c2) {
    if (queries.length === 0)
      return move(c2, open);
    let max = Math.ceil(queries.length / (connecting.length + 1)), ready = true;
    while (ready && queries.length && max-- > 0) {
      const query5 = queries.shift();
      if (query5.reserve)
        return query5.reserve(c2);
      ready = c2.execute(query5);
    }
    ready ? move(c2, busy) : move(c2, full);
  }
  function onclose(c2, e) {
    move(c2, closed);
    c2.reserved = null;
    c2.onclose && (c2.onclose(e), c2.onclose = null);
    options.onclose && options.onclose(c2.id);
    queries.length && connect(c2, queries.shift());
  }
};
var parseOptions = function(a, b2) {
  if (a && a.shared)
    return a;
  const env = process.env, o2 = (!a || typeof a === "string" ? b2 : a) || {}, { url, multihost } = parseUrl(a), query5 = [...url.searchParams].reduce((a2, [b3, c2]) => (a2[b3] = c2, a2), {}), host = o2.hostname || o2.host || multihost || url.hostname || env.PGHOST || "localhost", port = o2.port || url.port || env.PGPORT || 5432, user = o2.user || o2.username || url.username || env.PGUSERNAME || env.PGUSER || osUsername();
  o2.no_prepare && (o2.prepare = false);
  query5.sslmode && (query5.ssl = query5.sslmode, delete query5.sslmode);
  "timeout" in o2 && (console.log("The timeout option is deprecated, use idle_timeout instead"), o2.idle_timeout = o2.timeout);
  query5.sslrootcert === "system" && (query5.ssl = "verify-full");
  const ints = ["idle_timeout", "connect_timeout", "max_lifetime", "max_pipeline", "backoff", "keep_alive"];
  const defaults = {
    max: 10,
    ssl: false,
    idle_timeout: null,
    connect_timeout: 30,
    max_lifetime,
    max_pipeline: 100,
    backoff,
    keep_alive: 60,
    prepare: true,
    debug: false,
    fetch_types: true,
    publications: "alltables",
    target_session_attrs: null
  };
  return {
    host: Array.isArray(host) ? host : host.split(",").map((x) => x.split(":")[0]),
    port: Array.isArray(port) ? port : host.split(",").map((x) => parseInt(x.split(":")[1] || port)),
    path: o2.path || host.indexOf("/") > -1 && host + "/.s.PGSQL." + port,
    database: o2.database || o2.db || (url.pathname || "").slice(1) || env.PGDATABASE || user,
    user,
    pass: o2.pass || o2.password || url.password || env.PGPASSWORD || "",
    ...Object.entries(defaults).reduce((acc, [k, d]) => {
      const value = k in o2 ? o2[k] : (k in query5) ? query5[k] === "disable" || query5[k] === "false" ? false : query5[k] : env["PG" + k.toUpperCase()] || d;
      acc[k] = typeof value === "string" && ints.includes(k) ? +value : value;
      return acc;
    }, {}),
    connection: {
      application_name: "postgres.js",
      ...o2.connection,
      ...Object.entries(query5).reduce((acc, [k, v]) => ((k in defaults) || (acc[k] = v), acc), {})
    },
    types: o2.types || {},
    target_session_attrs: tsa(o2, url, env),
    onnotice: o2.onnotice,
    onnotify: o2.onnotify,
    onclose: o2.onclose,
    onparameter: o2.onparameter,
    socket: o2.socket,
    transform: parseTransform(o2.transform || { undefined: undefined }),
    parameters: {},
    shared: { retries: 0, typeArrayMap: {} },
    ...mergeUserTypes(o2.types)
  };
};
var tsa = function(o2, url, env) {
  const x = o2.target_session_attrs || url.searchParams.get("target_session_attrs") || env.PGTARGETSESSIONATTRS;
  if (!x || ["read-write", "read-only", "primary", "standby", "prefer-standby"].includes(x))
    return x;
  throw new Error("target_session_attrs " + x + " is not supported");
};
var backoff = function(retries) {
  return (0.5 + Math.random() / 2) * Math.min(3 ** retries / 100, 20);
};
var max_lifetime = function() {
  return 60 * (30 + Math.random() * 30);
};
var parseTransform = function(x) {
  return {
    undefined: x.undefined,
    column: {
      from: typeof x.column === "function" ? x.column : x.column && x.column.from,
      to: x.column && x.column.to
    },
    value: {
      from: typeof x.value === "function" ? x.value : x.value && x.value.from,
      to: x.value && x.value.to
    },
    row: {
      from: typeof x.row === "function" ? x.row : x.row && x.row.from,
      to: x.row && x.row.to
    }
  };
};
var parseUrl = function(url) {
  if (!url || typeof url !== "string")
    return { url: { searchParams: new Map } };
  let host = url;
  host = host.slice(host.indexOf("://") + 3).split(/[?/]/)[0];
  host = decodeURIComponent(host.slice(host.indexOf("@") + 1));
  const urlObj = new URL(url.replace(host, host.split(",")[0]));
  return {
    url: {
      username: decodeURIComponent(urlObj.username),
      password: decodeURIComponent(urlObj.password),
      host: urlObj.host,
      hostname: urlObj.hostname,
      port: urlObj.port,
      pathname: urlObj.pathname,
      searchParams: urlObj.searchParams
    },
    multihost: host.indexOf(",") > -1 && host
  };
};
var osUsername = function() {
  try {
    return os.userInfo().username;
  } catch (_) {
    return "enzo.dourado";
  }
};
Object.assign(Postgres, {
  PostgresError,
  toPascal,
  pascal,
  toCamel,
  camel,
  toKebab,
  kebab,
  fromPascal,
  fromCamel,
  fromKebab,
  BigInt: {
    to: 20,
    from: [20],
    parse: (x) => BigInt(x),
    serialize: (x) => x.toString()
  }
});
var src_default = Postgres;

// node_modules/zod/lib/index.mjs
var setErrorMap = function(map) {
  overrideErrorMap = map;
};
var getErrorMap = function() {
  return overrideErrorMap;
};
var addIssueToContext = function(ctx, issueData) {
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      ctx.schemaErrorMap,
      getErrorMap(),
      errorMap
    ].filter((x) => !!x)
  });
  ctx.common.issues.push(issue);
};
var processCreateParams = function(params) {
  if (!params)
    return {};
  const { errorMap, invalid_type_error, required_error, description } = params;
  if (errorMap && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap)
    return { errorMap, description };
  const customMap = (iss, ctx) => {
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    if (typeof ctx.data === "undefined") {
      return { message: required_error !== null && required_error !== undefined ? required_error : ctx.defaultError };
    }
    return { message: invalid_type_error !== null && invalid_type_error !== undefined ? invalid_type_error : ctx.defaultError };
  };
  return { errorMap: customMap, description };
};
var isValidIP = function(ip, version3) {
  if ((version3 === "v4" || !version3) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version3 === "v6" || !version3) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
};
var floatSafeRemainder = function(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / Math.pow(10, decCount);
};
var deepPartialify = function(schema) {
  if (schema instanceof ZodObject) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray) {
    return new ZodArray({
      ...schema._def,
      type: deepPartialify(schema.element)
    });
  } else if (schema instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple) {
    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
  } else {
    return schema;
  }
};
var mergeValues = function(a, b2) {
  const aType = getParsedType(a);
  const bType = getParsedType(b2);
  if (a === b2) {
    return { valid: true, data: a };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b2);
    const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b2 };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a[key], b2[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a.length !== b2.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index = 0;index < a.length; index++) {
      const itemA = a[index];
      const itemB = b2[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b2) {
    return { valid: true, data: a };
  } else {
    return { valid: false };
  }
};
var createZodEnum = function(values2, params) {
  return new ZodEnum({
    values: values2,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
};
var util;
(function(util2) {
  util2.assertEqual = (val) => val;
  function assertIs(_arg) {
  }
  util2.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error;
  }
  util2.assertNever = assertNever;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
    const filtered = {};
    for (const k of validKeys) {
      filtered[k] = obj[k];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e) {
      return obj[e];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
    const keys = [];
    for (const key in object) {
      if (Object.prototype.hasOwnProperty.call(object, key)) {
        keys.push(key);
      }
    }
    return keys;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
  function joinValues(array2, separator = " | ") {
    return array2.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util || (util = {}));
var objectUtil;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => {
    return {
      ...first,
      ...second
    };
  };
})(objectUtil || (objectUtil = {}));
var ZodParsedType = util.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
var getParsedType = (data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType.array;
      }
      if (data === null) {
        return ZodParsedType.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
};
var ZodIssueCode = util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
var quotelessJson = (obj) => {
  const json = JSON.stringify(obj, null, 2);
  return json.replace(/"([^"]+)":/g, "$1:");
};

class ZodError extends Error {
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  get errors() {
    return this.issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue) {
      return issue.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error) => {
      for (const issue of error.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          fieldErrors._errors.push(mapper(issue));
        } else {
          let curr = fieldErrors;
          let i = 0;
          while (i < issue.path.length) {
            const el = issue.path[i];
            const terminal = i === issue.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue));
            }
            curr = curr[el];
            i++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
        fieldErrors[sub.path[0]].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
}
ZodError.create = (issues) => {
  const error = new ZodError(issues);
  return error;
};
var errorMap = (issue, _ctx) => {
  let message;
  switch (issue.code) {
    case ZodIssueCode.invalid_type:
      if (issue.received === ZodParsedType.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode.invalid_string:
      if (typeof issue.validation === "object") {
        if ("includes" in issue.validation) {
          message = `Invalid input: must include "${issue.validation.includes}"`;
          if (typeof issue.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
          }
        } else if ("startsWith" in issue.validation) {
          message = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message = `Invalid ${issue.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode.too_small:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "bigint")
        message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode.not_multiple_of:
      message = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util.assertNever(issue);
  }
  return { message };
};
var overrideErrorMap = errorMap;
var makeIssue = (params) => {
  const { data, path, errorMaps, issueData } = params;
  const fullPath = [...path, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  let errorMessage = "";
  const maps = errorMaps.filter((m) => !!m).slice().reverse();
  for (const map of maps) {
    errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: issueData.message || errorMessage
  };
};
var EMPTY_PATH = [];

class ParseStatus {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s of results) {
      if (s.status === "aborted")
        return INVALID;
      if (s.status === "dirty")
        status.dirty();
      arrayValue.push(s.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      syncPairs.push({
        key: await pair.key,
        value: await pair.value
      });
    }
    return ParseStatus.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value } = pair;
      if (key.status === "aborted")
        return INVALID;
      if (value.status === "aborted")
        return INVALID;
      if (key.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
}
var INVALID = Object.freeze({
  status: "aborted"
});
var DIRTY = (value) => ({ status: "dirty", value });
var OK = (value) => ({ status: "valid", value });
var isAborted = (x) => x.status === "aborted";
var isDirty = (x) => x.status === "dirty";
var isValid = (x) => x.status === "valid";
var isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;
var errorUtil;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message === null || message === undefined ? undefined : message.message;
})(errorUtil || (errorUtil = {}));

class ParseInputLazyPath {
  constructor(parent, value, path, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (this._key instanceof Array) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
}
var handleResult = (ctx, result2) => {
  if (isValid(result2)) {
    return { success: true, data: result2.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error = new ZodError(ctx.common.issues);
        this._error = error;
        return this._error;
      }
    };
  }
};

class ZodType {
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus,
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result2 = this._parse(input);
    if (isAsync(result2)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result2;
  }
  _parseAsync(input) {
    const result2 = this._parse(input);
    return Promise.resolve(result2);
  }
  parse(data, params) {
    const result2 = this.safeParse(data, params);
    if (result2.success)
      return result2.data;
    throw result2.error;
  }
  safeParse(data, params) {
    var _a;
    const ctx = {
      common: {
        issues: [],
        async: (_a = params === null || params === undefined ? undefined : params.async) !== null && _a !== undefined ? _a : false,
        contextualErrorMap: params === null || params === undefined ? undefined : params.errorMap
      },
      path: (params === null || params === undefined ? undefined : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const result2 = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult(ctx, result2);
  }
  async parseAsync(data, params) {
    const result2 = await this.safeParseAsync(data, params);
    if (result2.success)
      return result2.data;
    throw result2.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params === null || params === undefined ? undefined : params.errorMap,
        async: true
      },
      path: (params === null || params === undefined ? undefined : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result2 = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx, result2);
  }
  refine(check, message) {
    const getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result2 = check(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result2 instanceof Promise) {
        return result2.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result2) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this, this._def);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(option) {
    return ZodUnion.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming, this._def);
  }
  transform(transform) {
    return new ZodEffects({
      ...processCreateParams(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    });
  }
  brand() {
    return new ZodBranded({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this,
      ...processCreateParams(this._def)
    });
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline.create(this, target);
  }
  readonly() {
    return ZodReadonly.create(this);
  }
  isOptional() {
    return this.safeParse(undefined).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
var cuidRegex = /^c[^\s-]{8,}$/i;
var cuid2Regex = /^[a-z][a-z0-9]*$/;
var ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/;
var uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
var emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_+-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
var _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+\$`;
var emojiRegex;
var ipv4Regex = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/;
var ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
var datetimeRegex = (args) => {
  if (args.precision) {
    if (args.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)\$`);
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}Z\$`);
    }
  } else if (args.precision === 0) {
    if (args.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)\$`);
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z\$`);
    }
  } else {
    if (args.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)\$`);
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z\$`);
    }
  }
};

class ZodString extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.string,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const status = new ParseStatus;
    let ctx = undefined;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.length < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.length > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "length") {
        const tooBig = input.data.length > check.value;
        const tooSmall = input.data.length < check.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          } else if (tooSmall) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          }
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "email",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "emoji") {
        if (!emojiRegex) {
          emojiRegex = new RegExp(_emojiRegex, "u");
        }
        if (!emojiRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "emoji",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "uuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid2") {
        if (!cuid2Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid2",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ulid") {
        if (!ulidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ulid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input.data);
        } catch (_a) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "regex",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "trim") {
        input.data = input.data.trim();
      } else if (check.kind === "includes") {
        if (!input.data.includes(check.value, check.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { includes: check.value, position: check.position },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check.kind === "startsWith") {
        if (!input.data.startsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { startsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "endsWith") {
        if (!input.data.endsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { endsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "datetime") {
        const regex = datetimeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "datetime",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ip") {
        if (!isValidIP(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ip",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _regex(regex, validation, message) {
    return this.refinement((data) => regex.test(data), {
      validation,
      code: ZodIssueCode.invalid_string,
      ...errorUtil.errToObj(message)
    });
  }
  _addCheck(check) {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
  }
  datetime(options) {
    var _a;
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        message: options
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof (options === null || options === undefined ? undefined : options.precision) === "undefined" ? null : options === null || options === undefined ? undefined : options.precision,
      offset: (_a = options === null || options === undefined ? undefined : options.offset) !== null && _a !== undefined ? _a : false,
      ...errorUtil.errToObj(options === null || options === undefined ? undefined : options.message)
    });
  }
  regex(regex, message) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil.errToObj(message)
    });
  }
  includes(value, options) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options === null || options === undefined ? undefined : options.position,
      ...errorUtil.errToObj(options === null || options === undefined ? undefined : options.message)
    });
  }
  startsWith(value, message) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  endsWith(value, message) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil.errToObj(message)
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil.errToObj(message)
    });
  }
  nonempty(message) {
    return this.min(1, errorUtil.errToObj(message));
  }
  trim() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get minLength() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxLength() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
}
ZodString.create = (params) => {
  var _a;
  return new ZodString({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodString,
    coerce: (_a = params === null || params === undefined ? undefined : params.coerce) !== null && _a !== undefined ? _a : false,
    ...processCreateParams(params)
  });
};

class ZodNumber extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = undefined;
    const status = new ParseStatus;
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder(input.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_finite,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodNumber({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodNumber({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
  }
  get isFinite() {
    let max = null, min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      } else if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return Number.isFinite(min) && Number.isFinite(max);
  }
}
ZodNumber.create = (params) => {
  return new ZodNumber({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodNumber,
    coerce: (params === null || params === undefined ? undefined : params.coerce) || false,
    ...processCreateParams(params)
  });
};

class ZodBigInt extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = BigInt(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.bigint) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.bigint,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = undefined;
    const status = new ParseStatus;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            type: "bigint",
            minimum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            type: "bigint",
            maximum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (input.data % check.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodBigInt({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodBigInt({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
}
ZodBigInt.create = (params) => {
  var _a;
  return new ZodBigInt({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodBigInt,
    coerce: (_a = params === null || params === undefined ? undefined : params.coerce) !== null && _a !== undefined ? _a : false,
    ...processCreateParams(params)
  });
};

class ZodBoolean extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodBoolean.create = (params) => {
  return new ZodBoolean({
    typeName: ZodFirstPartyTypeKind.ZodBoolean,
    coerce: (params === null || params === undefined ? undefined : params.coerce) || false,
    ...processCreateParams(params)
  });
};

class ZodDate extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    if (isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_date
      });
      return INVALID;
    }
    const status = new ParseStatus;
    let ctx = undefined;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.getTime() < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            message: check.message,
            inclusive: true,
            exact: false,
            minimum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.getTime() > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            message: check.message,
            inclusive: true,
            exact: false,
            maximum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check) {
    return new ZodDate({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  get minDate() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min != null ? new Date(min) : null;
  }
  get maxDate() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max != null ? new Date(max) : null;
  }
}
ZodDate.create = (params) => {
  return new ZodDate({
    checks: [],
    coerce: (params === null || params === undefined ? undefined : params.coerce) || false,
    typeName: ZodFirstPartyTypeKind.ZodDate,
    ...processCreateParams(params)
  });
};

class ZodSymbol extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.symbol,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodSymbol.create = (params) => {
  return new ZodSymbol({
    typeName: ZodFirstPartyTypeKind.ZodSymbol,
    ...processCreateParams(params)
  });
};

class ZodUndefined extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodUndefined.create = (params) => {
  return new ZodUndefined({
    typeName: ZodFirstPartyTypeKind.ZodUndefined,
    ...processCreateParams(params)
  });
};

class ZodNull extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodNull.create = (params) => {
  return new ZodNull({
    typeName: ZodFirstPartyTypeKind.ZodNull,
    ...processCreateParams(params)
  });
};

class ZodAny extends ZodType {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK(input.data);
  }
}
ZodAny.create = (params) => {
  return new ZodAny({
    typeName: ZodFirstPartyTypeKind.ZodAny,
    ...processCreateParams(params)
  });
};

class ZodUnknown extends ZodType {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK(input.data);
  }
}
ZodUnknown.create = (params) => {
  return new ZodUnknown({
    typeName: ZodFirstPartyTypeKind.ZodUnknown,
    ...processCreateParams(params)
  });
};

class ZodNever extends ZodType {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType
    });
    return INVALID;
  }
}
ZodNever.create = (params) => {
  return new ZodNever({
    typeName: ZodFirstPartyTypeKind.ZodNever,
    ...processCreateParams(params)
  });
};

class ZodVoid extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodVoid.create = (params) => {
  return new ZodVoid({
    typeName: ZodFirstPartyTypeKind.ZodVoid,
    ...processCreateParams(params)
  });
};

class ZodArray extends ZodType {
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (def.exactLength !== null) {
      const tooBig = ctx.data.length > def.exactLength.value;
      const tooSmall = ctx.data.length < def.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext(ctx, {
          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
          minimum: tooSmall ? def.exactLength.value : undefined,
          maximum: tooBig ? def.exactLength.value : undefined,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message
        });
        status.dirty();
      }
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message
        });
        status.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i) => {
        return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
      })).then((result3) => {
        return ParseStatus.mergeArray(status, result3);
      });
    }
    const result2 = [...ctx.data].map((item, i) => {
      return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
    });
    return ParseStatus.mergeArray(status, result2);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new ZodArray({
      ...this._def,
      minLength: { value: minLength, message: errorUtil.toString(message) }
    });
  }
  max(maxLength, message) {
    return new ZodArray({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil.toString(message) }
    });
  }
  length(len, message) {
    return new ZodArray({
      ...this._def,
      exactLength: { value: len, message: errorUtil.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
}
ZodArray.create = (schema, params) => {
  return new ZodArray({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind.ZodArray,
    ...processCreateParams(params)
  });
};

class ZodObject extends ZodType {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys = util.objectKeys(shape);
    return this._cached = { shape, keys };
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip")
        ;
      else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          syncPairs.push({
            key,
            value: await pair.value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil.errToObj;
    return new ZodObject({
      ...this._def,
      unknownKeys: "strict",
      ...message !== undefined ? {
        errorMap: (issue, ctx) => {
          var _a, _b, _c, _d;
          const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === undefined ? undefined : _b.call(_a, issue, ctx).message) !== null && _c !== undefined ? _c : ctx.defaultError;
          if (issue.code === "unrecognized_keys")
            return {
              message: (_d = errorUtil.errToObj(message).message) !== null && _d !== undefined ? _d : defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  extend(augmentation) {
    return new ZodObject({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  merge(merging) {
    const merged = new ZodObject({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind.ZodObject
    });
    return merged;
  }
  setKey(key, schema) {
    return this.augment({ [key]: schema });
  }
  catchall(index) {
    return new ZodObject({
      ...this._def,
      catchall: index
    });
  }
  pick(mask) {
    const shape = {};
    util.objectKeys(mask).forEach((key) => {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask) {
    const shape = {};
    util.objectKeys(this.shape).forEach((key) => {
      if (!mask[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  deepPartial() {
    return deepPartialify(this);
  }
  partial(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key) => {
      const fieldSchema = this.shape[key];
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key) => {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum(util.objectKeys(this.shape));
  }
}
ZodObject.create = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.strictCreate = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.lazycreate = (shape, params) => {
  return new ZodObject({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};

class ZodUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options = this._def.options;
    function handleResults(results) {
      for (const result2 of results) {
        if (result2.result.status === "valid") {
          return result2.result;
        }
      }
      for (const result2 of results) {
        if (result2.result.status === "dirty") {
          ctx.common.issues.push(...result2.ctx.common.issues);
          return result2.result;
        }
      }
      const unionErrors = results.map((result2) => new ZodError(result2.ctx.common.issues));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return Promise.all(options.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = undefined;
      const issues = [];
      for (const option of options) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result2 = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result2.status === "valid") {
          return result2;
        } else if (result2.status === "dirty" && !dirty) {
          dirty = { result: result2, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError(issues2));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
}
ZodUnion.create = (types4, params) => {
  return new ZodUnion({
    options: types4,
    typeName: ZodFirstPartyTypeKind.ZodUnion,
    ...processCreateParams(params)
  });
};
var getDiscriminator = (type) => {
  if (type instanceof ZodLazy) {
    return getDiscriminator(type.schema);
  } else if (type instanceof ZodEffects) {
    return getDiscriminator(type.innerType());
  } else if (type instanceof ZodLiteral) {
    return [type.value];
  } else if (type instanceof ZodEnum) {
    return type.options;
  } else if (type instanceof ZodNativeEnum) {
    return Object.keys(type.enum);
  } else if (type instanceof ZodDefault) {
    return getDiscriminator(type._def.innerType);
  } else if (type instanceof ZodUndefined) {
    return [undefined];
  } else if (type instanceof ZodNull) {
    return [null];
  } else {
    return null;
  }
};

class ZodDiscriminatedUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const discriminator = this.discriminator;
    const discriminatorValue = ctx.data[discriminator];
    const option = this.optionsMap.get(discriminatorValue);
    if (!option) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator]
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return option._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    } else {
      return option._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  static create(discriminator, options, params) {
    const optionsMap = new Map;
    for (const type of options) {
      const discriminatorValues = getDiscriminator(type.shape[discriminator]);
      if (!discriminatorValues) {
        throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
      }
      for (const value of discriminatorValues) {
        if (optionsMap.has(value)) {
          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
        }
        optionsMap.set(value, type);
      }
    }
    return new ZodDiscriminatedUnion({
      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
      discriminator,
      options,
      optionsMap,
      ...processCreateParams(params)
    });
  }
}

class ZodIntersection extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
        return INVALID;
      }
      const merged = mergeValues(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_intersection_types
        });
        return INVALID;
      }
      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
}
ZodIntersection.create = (left, right, params) => {
  return new ZodIntersection({
    left,
    right,
    typeName: ZodFirstPartyTypeKind.ZodIntersection,
    ...processCreateParams(params)
  });
};

class ZodTuple extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
    }).filter((x) => !!x);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus.mergeArray(status, results);
      });
    } else {
      return ParseStatus.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new ZodTuple({
      ...this._def,
      rest
    });
  }
}
ZodTuple.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple({
    items: schemas,
    typeName: ZodFirstPartyTypeKind.ZodTuple,
    rest: null,
    ...processCreateParams(params)
  });
};

class ZodRecord extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const pairs = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key in ctx.data) {
      pairs.push({
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key))
      });
    }
    if (ctx.common.async) {
      return ParseStatus.mergeObjectAsync(status, pairs);
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first, second, third) {
    if (second instanceof ZodType) {
      return new ZodRecord({
        keyType: first,
        valueType: second,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(third)
      });
    }
    return new ZodRecord({
      keyType: ZodString.create(),
      valueType: first,
      typeName: ZodFirstPartyTypeKind.ZodRecord,
      ...processCreateParams(second)
    });
  }
}

class ZodMap extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.map) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key, value], index) => {
      return {
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
        value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = new Map;
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = new Map;
      for (const pair of pairs) {
        const key = pair.key;
        const value = pair.value;
        if (key.status === "aborted" || value.status === "aborted") {
          return INVALID;
        }
        if (key.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
}
ZodMap.create = (keyType, valueType, params) => {
  return new ZodMap({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind.ZodMap,
    ...processCreateParams(params)
  });
};

class ZodSet extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.set) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message
        });
        status.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = new Set;
      for (const element of elements2) {
        if (element.status === "aborted")
          return INVALID;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message) {
    return new ZodSet({
      ...this._def,
      minSize: { value: minSize, message: errorUtil.toString(message) }
    });
  }
  max(maxSize, message) {
    return new ZodSet({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil.toString(message) }
    });
  }
  size(size2, message) {
    return this.min(size2, message).max(size2, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
}
ZodSet.create = (valueType, params) => {
  return new ZodSet({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind.ZodSet,
    ...processCreateParams(params)
  });
};

class ZodFunction extends ZodType {
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.function) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.function,
        received: ctx.parsedType
      });
      return INVALID;
    }
    function makeArgsIssue(args, error) {
      return makeIssue({
        data: args,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_arguments,
          argumentsError: error
        }
      });
    }
    function makeReturnsIssue(returns, error) {
      return makeIssue({
        data: returns,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_return_type,
          returnTypeError: error
        }
      });
    }
    const params = { errorMap: ctx.common.contextualErrorMap };
    const fn = ctx.data;
    if (this._def.returns instanceof ZodPromise) {
      const me = this;
      return OK(async function(...args) {
        const error = new ZodError([]);
        const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
          error.addIssue(makeArgsIssue(args, e));
          throw error;
        });
        const result2 = await Reflect.apply(fn, this, parsedArgs);
        const parsedReturns = await me._def.returns._def.type.parseAsync(result2, params).catch((e) => {
          error.addIssue(makeReturnsIssue(result2, e));
          throw error;
        });
        return parsedReturns;
      });
    } else {
      const me = this;
      return OK(function(...args) {
        const parsedArgs = me._def.args.safeParse(args, params);
        if (!parsedArgs.success) {
          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
        }
        const result2 = Reflect.apply(fn, this, parsedArgs.data);
        const parsedReturns = me._def.returns.safeParse(result2, params);
        if (!parsedReturns.success) {
          throw new ZodError([makeReturnsIssue(result2, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new ZodFunction({
      ...this._def,
      args: ZodTuple.create(items).rest(ZodUnknown.create())
    });
  }
  returns(returnType) {
    return new ZodFunction({
      ...this._def,
      returns: returnType
    });
  }
  implement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  strictImplement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  static create(args, returns, params) {
    return new ZodFunction({
      args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
      returns: returns || ZodUnknown.create(),
      typeName: ZodFirstPartyTypeKind.ZodFunction,
      ...processCreateParams(params)
    });
  }
}

class ZodLazy extends ZodType {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
}
ZodLazy.create = (getter, params) => {
  return new ZodLazy({
    getter,
    typeName: ZodFirstPartyTypeKind.ZodLazy,
    ...processCreateParams(params)
  });
};

class ZodLiteral extends ZodType {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
}
ZodLiteral.create = (value, params) => {
  return new ZodLiteral({
    value,
    typeName: ZodFirstPartyTypeKind.ZodLiteral,
    ...processCreateParams(params)
  });
};

class ZodEnum extends ZodType {
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (this._def.values.indexOf(input.data) === -1) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values2) {
    return ZodEnum.create(values2);
  }
  exclude(values2) {
    return ZodEnum.create(this.options.filter((opt) => !values2.includes(opt)));
  }
}
ZodEnum.create = createZodEnum;

class ZodNativeEnum extends ZodType {
  _parse(input) {
    const nativeEnumValues = util.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (nativeEnumValues.indexOf(input.data) === -1) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get enum() {
    return this._def.values;
  }
}
ZodNativeEnum.create = (values2, params) => {
  return new ZodNativeEnum({
    values: values2,
    typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
    ...processCreateParams(params)
  });
};

class ZodPromise extends ZodType {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
}
ZodPromise.create = (schema, params) => {
  return new ZodPromise({
    type: schema,
    typeName: ZodFirstPartyTypeKind.ZodPromise,
    ...processCreateParams(params)
  });
};

class ZodEffects extends ZodType {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.issues.length) {
        return {
          status: "dirty",
          value: ctx.data
        };
      }
      if (ctx.common.async) {
        return Promise.resolve(processed).then((processed2) => {
          return this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
        });
      } else {
        return this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = (acc) => {
        const result2 = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result2);
        }
        if (result2 instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid(base))
          return base;
        const result2 = effect.transform(base.value, checkCtx);
        if (result2 instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result2 };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
          if (!isValid(base))
            return base;
          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result2) => ({ status: status.value, value: result2 }));
        });
      }
    }
    util.assertNever(effect);
  }
}
ZodEffects.create = (schema, effect, params) => {
  return new ZodEffects({
    schema,
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    effect,
    ...processCreateParams(params)
  });
};
ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
  return new ZodEffects({
    schema,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    ...processCreateParams(params)
  });
};

class ZodOptional extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.undefined) {
      return OK(undefined);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodOptional.create = (type, params) => {
  return new ZodOptional({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodOptional,
    ...processCreateParams(params)
  });
};

class ZodNullable extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.null) {
      return OK(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodNullable.create = (type, params) => {
  return new ZodNullable({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodNullable,
    ...processCreateParams(params)
  });
};

class ZodDefault extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
}
ZodDefault.create = (type, params) => {
  return new ZodDefault({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams(params)
  });
};

class ZodCatch extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result2 = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync(result2)) {
      return result2.then((result3) => {
        return {
          status: "valid",
          value: result3.status === "valid" ? result3.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result2.status === "valid" ? result2.value : this._def.catchValue({
          get error() {
            return new ZodError(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
}
ZodCatch.create = (type, params) => {
  return new ZodCatch({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams(params)
  });
};

class ZodNaN extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
}
ZodNaN.create = (params) => {
  return new ZodNaN({
    typeName: ZodFirstPartyTypeKind.ZodNaN,
    ...processCreateParams(params)
  });
};
var BRAND = Symbol("zod_brand");

class ZodBranded extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
}

class ZodPipeline extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      };
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a, b2) {
    return new ZodPipeline({
      in: a,
      out: b2,
      typeName: ZodFirstPartyTypeKind.ZodPipeline
    });
  }
}

class ZodReadonly extends ZodType {
  _parse(input) {
    const result2 = this._def.innerType._parse(input);
    if (isValid(result2)) {
      result2.value = Object.freeze(result2.value);
    }
    return result2;
  }
}
ZodReadonly.create = (type, params) => {
  return new ZodReadonly({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodReadonly,
    ...processCreateParams(params)
  });
};
var custom = (check, params = {}, fatal) => {
  if (check)
    return ZodAny.create().superRefine((data, ctx) => {
      var _a, _b;
      if (!check(data)) {
        const p = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
        const _fatal = (_b = (_a = p.fatal) !== null && _a !== undefined ? _a : fatal) !== null && _b !== undefined ? _b : true;
        const p2 = typeof p === "string" ? { message: p } : p;
        ctx.addIssue({ code: "custom", ...p2, fatal: _fatal });
      }
    });
  return ZodAny.create();
};
var late = {
  object: ZodObject.lazycreate
};
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
var instanceOfType = (cls, params = {
  message: `Input not instance of ${cls.name}`
}) => custom((data) => data instanceof cls, params);
var stringType = ZodString.create;
var numberType = ZodNumber.create;
var nanType = ZodNaN.create;
var bigIntType = ZodBigInt.create;
var booleanType = ZodBoolean.create;
var dateType = ZodDate.create;
var symbolType = ZodSymbol.create;
var undefinedType = ZodUndefined.create;
var nullType = ZodNull.create;
var anyType = ZodAny.create;
var unknownType = ZodUnknown.create;
var neverType = ZodNever.create;
var voidType = ZodVoid.create;
var arrayType = ZodArray.create;
var objectType = ZodObject.create;
var strictObjectType = ZodObject.strictCreate;
var unionType = ZodUnion.create;
var discriminatedUnionType = ZodDiscriminatedUnion.create;
var intersectionType = ZodIntersection.create;
var tupleType = ZodTuple.create;
var recordType = ZodRecord.create;
var mapType = ZodMap.create;
var setType = ZodSet.create;
var functionType = ZodFunction.create;
var lazyType = ZodLazy.create;
var literalType = ZodLiteral.create;
var enumType = ZodEnum.create;
var nativeEnumType = ZodNativeEnum.create;
var promiseType = ZodPromise.create;
var effectsType = ZodEffects.create;
var optionalType = ZodOptional.create;
var nullableType = ZodNullable.create;
var preprocessType = ZodEffects.createWithPreprocess;
var pipelineType = ZodPipeline.create;
var ostring = () => stringType().optional();
var onumber = () => numberType().optional();
var oboolean = () => booleanType().optional();
var coerce = {
  string: (arg) => ZodString.create({ ...arg, coerce: true }),
  number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
  boolean: (arg) => ZodBoolean.create({
    ...arg,
    coerce: true
  }),
  bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
  date: (arg) => ZodDate.create({ ...arg, coerce: true })
};
var NEVER = INVALID;
var z = Object.freeze({
  __proto__: null,
  defaultErrorMap: errorMap,
  setErrorMap,
  getErrorMap,
  makeIssue,
  EMPTY_PATH,
  addIssueToContext,
  ParseStatus,
  INVALID,
  DIRTY,
  OK,
  isAborted,
  isDirty,
  isValid,
  isAsync,
  get util() {
    return util;
  },
  get objectUtil() {
    return objectUtil;
  },
  ZodParsedType,
  getParsedType,
  ZodType,
  ZodString,
  ZodNumber,
  ZodBigInt,
  ZodBoolean,
  ZodDate,
  ZodSymbol,
  ZodUndefined,
  ZodNull,
  ZodAny,
  ZodUnknown,
  ZodNever,
  ZodVoid,
  ZodArray,
  ZodObject,
  ZodUnion,
  ZodDiscriminatedUnion,
  ZodIntersection,
  ZodTuple,
  ZodRecord,
  ZodMap,
  ZodSet,
  ZodFunction,
  ZodLazy,
  ZodLiteral,
  ZodEnum,
  ZodNativeEnum,
  ZodPromise,
  ZodEffects,
  ZodTransformer: ZodEffects,
  ZodOptional,
  ZodNullable,
  ZodDefault,
  ZodCatch,
  ZodNaN,
  BRAND,
  ZodBranded,
  ZodPipeline,
  ZodReadonly,
  custom,
  Schema: ZodType,
  ZodSchema: ZodType,
  late,
  get ZodFirstPartyTypeKind() {
    return ZodFirstPartyTypeKind;
  },
  coerce,
  any: anyType,
  array: arrayType,
  bigint: bigIntType,
  boolean: booleanType,
  date: dateType,
  discriminatedUnion: discriminatedUnionType,
  effect: effectsType,
  enum: enumType,
  function: functionType,
  instanceof: instanceOfType,
  intersection: intersectionType,
  lazy: lazyType,
  literal: literalType,
  map: mapType,
  nan: nanType,
  nativeEnum: nativeEnumType,
  never: neverType,
  null: nullType,
  nullable: nullableType,
  number: numberType,
  object: objectType,
  oboolean,
  onumber,
  optional: optionalType,
  ostring,
  pipeline: pipelineType,
  preprocess: preprocessType,
  promise: promiseType,
  record: recordType,
  set: setType,
  strictObject: strictObjectType,
  string: stringType,
  symbol: symbolType,
  transformer: effectsType,
  tuple: tupleType,
  undefined: undefinedType,
  union: unionType,
  unknown: unknownType,
  void: voidType,
  NEVER,
  ZodIssueCode,
  quotelessJson,
  ZodError
});

// src/env.ts
var envSchema = z.object({
  API_BASE_URL: z.string().url(),
  AUTH_REDIRECT_URL: z.string().url(),
  DB_URL: z.string().url().min(1),
  JWT_SECRET_KEY: z.string().min(1),
  RESEND_API_KEY: z.string().min(1)
});
var env = envSchema.parse(process.env);

// src/db/connection.ts
var client = src_default(env.DB_URL);
var db3 = drizzle(client, { schema: exports_schema });

// src/http/routes/register-restaurant.ts
var registerRestaurant = new I$().post("/restaurants", async ({ body, set }) => {
  const { restaurantName, managerName, email, phone } = body;
  const [manager] = await db3.insert(users).values({
    name: managerName,
    email,
    phone,
    role: "manager"
  }).returning();
  await db3.insert(restaurants).values({
    name: restaurantName,
    managerId: manager.id
  });
  set.status = 204;
}, {
  body: export_t.Object({
    restaurantName: export_t.String(),
    managerName: export_t.String(),
    phone: export_t.String(),
    email: export_t.String({ format: "email" })
  })
});

// src/http/routes/register-customer.ts
var registerCustomerBodySchema = z.object({
  name: z.string().min(1),
  phone: z.string(),
  email: z.string().email()
});
var registerCustomer = new I$().post("/customers", async ({ body, set }) => {
  const { name, phone, email } = registerCustomerBodySchema.parse(body);
  await db3.insert(users).values({
    name,
    email,
    phone
  });
  set.status = 401;
});

// src/mail/client.ts
var import_resend = __toESM(require_src3(), 1);
var resend = new import_resend.Resend(env.RESEND_API_KEY);

// node_modules/@react-email/body/dist/index.mjs
var jsx_runtime = __toESM(require_jsx_runtime(), 1);
var __defProp2 = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp2 = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => (key in obj) ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp2.call(b2, prop))
      __defNormalProp(a, prop, b2[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b2)) {
      if (__propIsEnum.call(b2, prop))
        __defNormalProp(a, prop, b2[prop]);
    }
  return a;
};
var __spreadProps = (a, b2) => __defProps(a, __getOwnPropDescs(b2));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp2.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var Body = (_a) => {
  var _b = _a, {
    children,
    style
  } = _b, props = __objRest(_b, [
    "children",
    "style"
  ]);
  return jsx_runtime.jsx("body", __spreadProps(__spreadValues({}, props), { style, children }));
};
Body.displayName = "Body";

// node_modules/@react-email/button/dist/index.mjs
var jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
var convertToPx = function(value) {
  let px = 0;
  if (!value) {
    return px;
  }
  if (typeof value === "number") {
    return value;
  }
  const matches = value.match(/^([\d.]+)(px|em|rem|%)$/);
  if (matches && matches.length === 3) {
    const numValue = parseFloat(matches[1]);
    const unit = matches[2];
    switch (unit) {
      case "px":
        return numValue;
      case "em":
      case "rem":
        px = numValue * 16;
        return px;
      case "%":
        px = numValue / 100 * 600;
        return px;
      default:
        return numValue;
    }
  } else {
    return 0;
  }
};
var parsePadding = function({
  padding = "",
  paddingTop,
  paddingRight,
  paddingBottom,
  paddingLeft
}) {
  let pt = 0;
  let pr = 0;
  let pb = 0;
  let pl = 0;
  if (typeof padding === "number") {
    pt = padding;
    pr = padding;
    pb = padding;
    pl = padding;
  } else {
    const values2 = padding.split(/\s+/);
    switch (values2.length) {
      case 1:
        pt = convertToPx(values2[0]);
        pr = convertToPx(values2[0]);
        pb = convertToPx(values2[0]);
        pl = convertToPx(values2[0]);
        break;
      case 2:
        pt = convertToPx(values2[0]);
        pb = convertToPx(values2[0]);
        pr = convertToPx(values2[1]);
        pl = convertToPx(values2[1]);
        break;
      case 3:
        pt = convertToPx(values2[0]);
        pr = convertToPx(values2[1]);
        pl = convertToPx(values2[1]);
        pb = convertToPx(values2[2]);
        break;
      case 4:
        pt = convertToPx(values2[0]);
        pr = convertToPx(values2[1]);
        pb = convertToPx(values2[2]);
        pl = convertToPx(values2[3]);
        break;
      default:
        break;
    }
  }
  return {
    pt: paddingTop ? convertToPx(paddingTop) : pt,
    pr: paddingRight ? convertToPx(paddingRight) : pr,
    pb: paddingBottom ? convertToPx(paddingBottom) : pb,
    pl: paddingLeft ? convertToPx(paddingLeft) : pl
  };
};
var __defProp3 = Object.defineProperty;
var __defProps2 = Object.defineProperties;
var __getOwnPropDescs2 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols2 = Object.getOwnPropertySymbols;
var __hasOwnProp3 = Object.prototype.hasOwnProperty;
var __propIsEnum2 = Object.prototype.propertyIsEnumerable;
var __defNormalProp2 = (obj, key, value) => (key in obj) ? __defProp3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues2 = (a, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp3.call(b2, prop))
      __defNormalProp2(a, prop, b2[prop]);
  if (__getOwnPropSymbols2)
    for (var prop of __getOwnPropSymbols2(b2)) {
      if (__propIsEnum2.call(b2, prop))
        __defNormalProp2(a, prop, b2[prop]);
    }
  return a;
};
var __spreadProps2 = (a, b2) => __defProps2(a, __getOwnPropDescs2(b2));
var __objRest2 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp3.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols2)
    for (var prop of __getOwnPropSymbols2(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum2.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var pxToPt = (px) => typeof px === "number" && !isNaN(Number(px)) ? px * 3 / 4 : null;
var Button = (_a) => {
  var _b = _a, {
    children,
    style,
    target = "_blank"
  } = _b, props = __objRest2(_b, [
    "children",
    "style",
    "target"
  ]);
  const { pt, pr, pb, pl } = parsePadding({
    padding: style == null ? undefined : style.padding,
    paddingLeft: style == null ? undefined : style.paddingLeft,
    paddingRight: style == null ? undefined : style.paddingRight,
    paddingTop: style == null ? undefined : style.paddingTop,
    paddingBottom: style == null ? undefined : style.paddingBottom
  });
  const y = pt + pb;
  const textRaise = pxToPt(y);
  return jsx_runtime2.jsxs("a", __spreadProps2(__spreadValues2({}, props), {
    style: buttonStyle(__spreadProps2(__spreadValues2({}, style), { pt, pr, pb, pl })),
    target,
    children: [
      jsx_runtime2.jsx("span", {
        dangerouslySetInnerHTML: {
          __html: `<!--[if mso]><i style="letter-spacing: ${pl}px;mso-font-width:-100%;mso-text-raise:${textRaise}" hidden>&nbsp;</i><![endif]-->`
        }
      }),
      jsx_runtime2.jsx("span", { style: buttonTextStyle(pb), children }),
      jsx_runtime2.jsx("span", {
        dangerouslySetInnerHTML: {
          __html: `<!--[if mso]><i style="letter-spacing: ${pr}px;mso-font-width:-100%" hidden>&nbsp;</i><![endif]-->`
        }
      })
    ]
  }));
};
var buttonStyle = (style) => {
  const _a = style || {}, { pt, pr, pb, pl } = _a, rest = __objRest2(_a, ["pt", "pr", "pb", "pl"]);
  return __spreadProps2(__spreadValues2({}, rest), {
    lineHeight: "100%",
    textDecoration: "none",
    display: "inline-block",
    maxWidth: "100%",
    padding: `${pt}px ${pr}px ${pb}px ${pl}px`
  });
};
var buttonTextStyle = (pb) => {
  return {
    maxWidth: "100%",
    display: "inline-block",
    lineHeight: "120%",
    msoPaddingAlt: "0px",
    msoTextRaise: pxToPt(pb || 0)
  };
};

// node_modules/@react-email/container/dist/index.mjs
var jsx_runtime3 = __toESM(require_jsx_runtime(), 1);
var __defProp4 = Object.defineProperty;
var __defProps3 = Object.defineProperties;
var __getOwnPropDescs3 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols3 = Object.getOwnPropertySymbols;
var __hasOwnProp4 = Object.prototype.hasOwnProperty;
var __propIsEnum3 = Object.prototype.propertyIsEnumerable;
var __defNormalProp3 = (obj, key, value) => (key in obj) ? __defProp4(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues3 = (a, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp4.call(b2, prop))
      __defNormalProp3(a, prop, b2[prop]);
  if (__getOwnPropSymbols3)
    for (var prop of __getOwnPropSymbols3(b2)) {
      if (__propIsEnum3.call(b2, prop))
        __defNormalProp3(a, prop, b2[prop]);
    }
  return a;
};
var __spreadProps3 = (a, b2) => __defProps3(a, __getOwnPropDescs3(b2));
var __objRest3 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp4.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols3)
    for (var prop of __getOwnPropSymbols3(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum3.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var Container = (_a) => {
  var _b = _a, {
    children,
    style
  } = _b, props = __objRest3(_b, [
    "children",
    "style"
  ]);
  return jsx_runtime3.jsx("table", __spreadProps3(__spreadValues3({
    align: "center",
    width: "100%"
  }, props), {
    border: 0,
    cellPadding: "0",
    cellSpacing: "0",
    role: "presentation",
    style: __spreadValues3({ maxWidth: "37.5em" }, style),
    children: jsx_runtime3.jsx("tbody", { children: jsx_runtime3.jsx("tr", { style: { width: "100%" }, children: jsx_runtime3.jsx("td", { children }) }) })
  }));
};

// node_modules/@react-email/head/dist/index.mjs
var jsx_runtime4 = __toESM(require_jsx_runtime(), 1);
var __defProp5 = Object.defineProperty;
var __defProps4 = Object.defineProperties;
var __getOwnPropDescs4 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols4 = Object.getOwnPropertySymbols;
var __hasOwnProp5 = Object.prototype.hasOwnProperty;
var __propIsEnum4 = Object.prototype.propertyIsEnumerable;
var __defNormalProp4 = (obj, key, value) => (key in obj) ? __defProp5(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues4 = (a, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp5.call(b2, prop))
      __defNormalProp4(a, prop, b2[prop]);
  if (__getOwnPropSymbols4)
    for (var prop of __getOwnPropSymbols4(b2)) {
      if (__propIsEnum4.call(b2, prop))
        __defNormalProp4(a, prop, b2[prop]);
    }
  return a;
};
var __spreadProps4 = (a, b2) => __defProps4(a, __getOwnPropDescs4(b2));
var __objRest4 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp5.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols4)
    for (var prop of __getOwnPropSymbols4(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum4.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var Head = (_a) => {
  var _b = _a, { children } = _b, props = __objRest4(_b, ["children"]);
  return jsx_runtime4.jsxs("head", __spreadProps4(__spreadValues4({}, props), { children: [
    jsx_runtime4.jsx("meta", { content: "text/html; charset=UTF-8", httpEquiv: "Content-Type" }),
    children
  ] }));
};

// node_modules/@radix-ui/react-slot/node_modules/@babel/runtime/helpers/esm/extends.js
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1;i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}

// node_modules/@radix-ui/react-slot/dist/index.mjs
var import_react2 = __toESM(require_react(), 1);

// node_modules/@radix-ui/react-compose-refs/dist/index.mjs
var import_react = __toESM(require_react(), 1);
var $6ed0406888f73fc4$var$setRef = function(ref, value) {
  if (typeof ref === "function")
    ref(value);
  else if (ref !== null && ref !== undefined)
    ref.current = value;
};
var $6ed0406888f73fc4$export$43e446d32b3d21af = function(...refs) {
  return (node) => refs.forEach((ref) => $6ed0406888f73fc4$var$setRef(ref, node));
};

// node_modules/@radix-ui/react-slot/dist/index.mjs
var $5e63c961fc1ce211$var$isSlottable = function(child) {
  return import_react2.isValidElement(child) && child.type === $5e63c961fc1ce211$export$d9f1ccf0bdb05d45;
};
var $5e63c961fc1ce211$var$mergeProps = function(slotProps, childProps) {
  const overrideProps = {
    ...childProps
  };
  for (const propName in childProps) {
    const slotPropValue = slotProps[propName];
    const childPropValue = childProps[propName];
    const isHandler = /^on[A-Z]/.test(propName);
    if (isHandler) {
      if (slotPropValue && childPropValue)
        overrideProps[propName] = (...args) => {
          childPropValue(...args);
          slotPropValue(...args);
        };
      else if (slotPropValue)
        overrideProps[propName] = slotPropValue;
    } else if (propName === "style")
      overrideProps[propName] = {
        ...slotPropValue,
        ...childPropValue
      };
    else if (propName === "className")
      overrideProps[propName] = [
        slotPropValue,
        childPropValue
      ].filter(Boolean).join(" ");
  }
  return {
    ...slotProps,
    ...overrideProps
  };
};
var $5e63c961fc1ce211$export$8c6ed5c666ac1360 = import_react2.forwardRef((props, forwardedRef) => {
  const { children, ...slotProps } = props;
  const childrenArray = import_react2.Children.toArray(children);
  const slottable = childrenArray.find($5e63c961fc1ce211$var$isSlottable);
  if (slottable) {
    const newElement = slottable.props.children;
    const newChildren = childrenArray.map((child) => {
      if (child === slottable) {
        if (import_react2.Children.count(newElement) > 1)
          return import_react2.Children.only(null);
        return import_react2.isValidElement(newElement) ? newElement.props.children : null;
      } else
        return child;
    });
    return import_react2.createElement($5e63c961fc1ce211$var$SlotClone, _extends({}, slotProps, {
      ref: forwardedRef
    }), import_react2.isValidElement(newElement) ? import_react2.cloneElement(newElement, undefined, newChildren) : null);
  }
  return import_react2.createElement($5e63c961fc1ce211$var$SlotClone, _extends({}, slotProps, {
    ref: forwardedRef
  }), children);
});
$5e63c961fc1ce211$export$8c6ed5c666ac1360.displayName = "Slot";
var $5e63c961fc1ce211$var$SlotClone = import_react2.forwardRef((props, forwardedRef) => {
  const { children, ...slotProps } = props;
  if (import_react2.isValidElement(children))
    return import_react2.cloneElement(children, {
      ...$5e63c961fc1ce211$var$mergeProps(slotProps, children.props),
      ref: forwardedRef ? $6ed0406888f73fc4$export$43e446d32b3d21af(forwardedRef, children.ref) : children.ref
    });
  return import_react2.Children.count(children) > 1 ? import_react2.Children.only(null) : null;
});
$5e63c961fc1ce211$var$SlotClone.displayName = "SlotClone";
var $5e63c961fc1ce211$export$d9f1ccf0bdb05d45 = ({ children }) => {
  return import_react2.createElement(import_react2.Fragment, null, children);
};

// node_modules/@react-email/heading/dist/index.mjs
var React = __toESM(require_react(), 1);
var jsx_runtime5 = __toESM(require_jsx_runtime(), 1);
var __defProp6 = Object.defineProperty;
var __defProps5 = Object.defineProperties;
var __getOwnPropDescs5 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols5 = Object.getOwnPropertySymbols;
var __hasOwnProp6 = Object.prototype.hasOwnProperty;
var __propIsEnum5 = Object.prototype.propertyIsEnumerable;
var __defNormalProp5 = (obj, key, value) => (key in obj) ? __defProp6(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues5 = (a, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp6.call(b2, prop))
      __defNormalProp5(a, prop, b2[prop]);
  if (__getOwnPropSymbols5)
    for (var prop of __getOwnPropSymbols5(b2)) {
      if (__propIsEnum5.call(b2, prop))
        __defNormalProp5(a, prop, b2[prop]);
    }
  return a;
};
var __spreadProps5 = (a, b2) => __defProps5(a, __getOwnPropDescs5(b2));
var __objRest5 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp6.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols5)
    for (var prop of __getOwnPropSymbols5(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum5.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var withMargin = (props) => {
  const nonEmptyStyles = [
    withSpace(props.m, ["margin"]),
    withSpace(props.mx, ["marginLeft", "marginRight"]),
    withSpace(props.my, ["marginTop", "marginBottom"]),
    withSpace(props.mt, ["marginTop"]),
    withSpace(props.mr, ["marginRight"]),
    withSpace(props.mb, ["marginBottom"]),
    withSpace(props.ml, ["marginLeft"])
  ].filter((s) => Object.keys(s).length);
  const mergedStyles = nonEmptyStyles.reduce((acc, style) => {
    return __spreadValues5(__spreadValues5({}, acc), style);
  }, {});
  return mergedStyles;
};
var withSpace = (value, properties) => {
  return properties.reduce((styles, property) => {
    if (!isNaN(parseFloat(value))) {
      return __spreadProps5(__spreadValues5({}, styles), { [property]: `${value}px` });
    }
    return styles;
  }, {});
};
var Heading = React.forwardRef((_a, forwardedRef) => {
  var _b = _a, { as: Tag = "h1", children, style, m, mx, my, mt, mr, mb, ml } = _b, props = __objRest5(_b, ["as", "children", "style", "m", "mx", "my", "mt", "mr", "mb", "ml"]);
  return jsx_runtime5.jsx($5e63c961fc1ce211$export$8c6ed5c666ac1360, __spreadProps5(__spreadValues5({}, props), {
    ref: forwardedRef,
    style: __spreadValues5(__spreadValues5({}, withMargin({ m, mx, my, mt, mr, mb, ml })), style),
    children: jsx_runtime5.jsx(Tag, { children })
  }));
});
Heading.displayName = "Heading";

// node_modules/@react-email/hr/dist/index.mjs
var jsx_runtime6 = __toESM(require_jsx_runtime(), 1);
var __defProp7 = Object.defineProperty;
var __defProps6 = Object.defineProperties;
var __getOwnPropDescs6 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols6 = Object.getOwnPropertySymbols;
var __hasOwnProp7 = Object.prototype.hasOwnProperty;
var __propIsEnum6 = Object.prototype.propertyIsEnumerable;
var __defNormalProp6 = (obj, key, value) => (key in obj) ? __defProp7(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues6 = (a, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp7.call(b2, prop))
      __defNormalProp6(a, prop, b2[prop]);
  if (__getOwnPropSymbols6)
    for (var prop of __getOwnPropSymbols6(b2)) {
      if (__propIsEnum6.call(b2, prop))
        __defNormalProp6(a, prop, b2[prop]);
    }
  return a;
};
var __spreadProps6 = (a, b2) => __defProps6(a, __getOwnPropDescs6(b2));
var __objRest6 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp7.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols6)
    for (var prop of __getOwnPropSymbols6(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum6.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var Hr = (_a) => {
  var _b = _a, { style } = _b, props = __objRest6(_b, ["style"]);
  return jsx_runtime6.jsx("hr", __spreadProps6(__spreadValues6({}, props), {
    style: __spreadValues6({
      width: "100%",
      border: "none",
      borderTop: "1px solid #eaeaea"
    }, style)
  }));
};

// node_modules/@react-email/html/dist/index.mjs
var jsx_runtime7 = __toESM(require_jsx_runtime(), 1);
var __defProp8 = Object.defineProperty;
var __defProps7 = Object.defineProperties;
var __getOwnPropDescs7 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols7 = Object.getOwnPropertySymbols;
var __hasOwnProp8 = Object.prototype.hasOwnProperty;
var __propIsEnum7 = Object.prototype.propertyIsEnumerable;
var __defNormalProp7 = (obj, key, value) => (key in obj) ? __defProp8(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues7 = (a, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp8.call(b2, prop))
      __defNormalProp7(a, prop, b2[prop]);
  if (__getOwnPropSymbols7)
    for (var prop of __getOwnPropSymbols7(b2)) {
      if (__propIsEnum7.call(b2, prop))
        __defNormalProp7(a, prop, b2[prop]);
    }
  return a;
};
var __spreadProps7 = (a, b2) => __defProps7(a, __getOwnPropDescs7(b2));
var __objRest7 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp8.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols7)
    for (var prop of __getOwnPropSymbols7(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum7.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var Html = (_a) => {
  var _b = _a, {
    children,
    lang = "en",
    dir = "ltr"
  } = _b, props = __objRest7(_b, [
    "children",
    "lang",
    "dir"
  ]);
  return jsx_runtime7.jsx("html", __spreadProps7(__spreadValues7({}, props), { dir, lang, children }));
};

// node_modules/@react-email/link/dist/index.mjs
var jsx_runtime8 = __toESM(require_jsx_runtime(), 1);
var __defProp9 = Object.defineProperty;
var __defProps8 = Object.defineProperties;
var __getOwnPropDescs8 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols8 = Object.getOwnPropertySymbols;
var __hasOwnProp9 = Object.prototype.hasOwnProperty;
var __propIsEnum8 = Object.prototype.propertyIsEnumerable;
var __defNormalProp8 = (obj, key, value) => (key in obj) ? __defProp9(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues8 = (a, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp9.call(b2, prop))
      __defNormalProp8(a, prop, b2[prop]);
  if (__getOwnPropSymbols8)
    for (var prop of __getOwnPropSymbols8(b2)) {
      if (__propIsEnum8.call(b2, prop))
        __defNormalProp8(a, prop, b2[prop]);
    }
  return a;
};
var __spreadProps8 = (a, b2) => __defProps8(a, __getOwnPropDescs8(b2));
var __objRest8 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp9.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols8)
    for (var prop of __getOwnPropSymbols8(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum8.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var Link = (_a) => {
  var _b = _a, {
    target = "_blank",
    style
  } = _b, props = __objRest8(_b, [
    "target",
    "style"
  ]);
  return jsx_runtime8.jsx("a", __spreadProps8(__spreadValues8({}, props), {
    style: __spreadValues8({
      color: "#067df7",
      textDecoration: "none"
    }, style),
    target,
    children: props.children
  }));
};

// node_modules/@react-email/preview/dist/index.mjs
var jsx_runtime9 = __toESM(require_jsx_runtime(), 1);
var __defProp10 = Object.defineProperty;
var __defProps9 = Object.defineProperties;
var __getOwnPropDescs9 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols9 = Object.getOwnPropertySymbols;
var __hasOwnProp10 = Object.prototype.hasOwnProperty;
var __propIsEnum9 = Object.prototype.propertyIsEnumerable;
var __defNormalProp9 = (obj, key, value) => (key in obj) ? __defProp10(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues9 = (a, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp10.call(b2, prop))
      __defNormalProp9(a, prop, b2[prop]);
  if (__getOwnPropSymbols9)
    for (var prop of __getOwnPropSymbols9(b2)) {
      if (__propIsEnum9.call(b2, prop))
        __defNormalProp9(a, prop, b2[prop]);
    }
  return a;
};
var __spreadProps9 = (a, b2) => __defProps9(a, __getOwnPropDescs9(b2));
var __objRest9 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp10.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols9)
    for (var prop of __getOwnPropSymbols9(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum9.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var PREVIEW_MAX_LENGTH = 150;
var Preview = (_a) => {
  var _b = _a, {
    children = ""
  } = _b, props = __objRest9(_b, [
    "children"
  ]);
  let text2 = Array.isArray(children) ? children.join("") : children;
  text2 = text2.substr(0, PREVIEW_MAX_LENGTH);
  return jsx_runtime9.jsxs("div", __spreadProps9(__spreadValues9({
    style: {
      display: "none",
      overflow: "hidden",
      lineHeight: "1px",
      opacity: 0,
      maxHeight: 0,
      maxWidth: 0
    }
  }, props), {
    children: [
      text2,
      renderWhiteSpace(text2)
    ]
  }));
};
var renderWhiteSpace = (text2) => {
  if (text2.length >= PREVIEW_MAX_LENGTH) {
    return null;
  }
  const whiteSpaceCodes = "\xA0\u200C\u200B\u200D\u200E\u200F\uFEFF";
  return jsx_runtime9.jsx("div", { children: whiteSpaceCodes.repeat(PREVIEW_MAX_LENGTH - text2.length) });
};

// node_modules/@react-email/section/dist/index.mjs
var jsx_runtime10 = __toESM(require_jsx_runtime(), 1);
var __defProp11 = Object.defineProperty;
var __defProps10 = Object.defineProperties;
var __getOwnPropDescs10 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols10 = Object.getOwnPropertySymbols;
var __hasOwnProp11 = Object.prototype.hasOwnProperty;
var __propIsEnum10 = Object.prototype.propertyIsEnumerable;
var __defNormalProp10 = (obj, key, value) => (key in obj) ? __defProp11(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues10 = (a, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp11.call(b2, prop))
      __defNormalProp10(a, prop, b2[prop]);
  if (__getOwnPropSymbols10)
    for (var prop of __getOwnPropSymbols10(b2)) {
      if (__propIsEnum10.call(b2, prop))
        __defNormalProp10(a, prop, b2[prop]);
    }
  return a;
};
var __spreadProps10 = (a, b2) => __defProps10(a, __getOwnPropDescs10(b2));
var __objRest10 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp11.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols10)
    for (var prop of __getOwnPropSymbols10(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum10.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var Section = (_a) => {
  var _b = _a, {
    children,
    style
  } = _b, props = __objRest10(_b, [
    "children",
    "style"
  ]);
  return jsx_runtime10.jsx("table", __spreadProps10(__spreadValues10({
    align: "center",
    width: "100%"
  }, props), {
    border: 0,
    cellPadding: "0",
    cellSpacing: "0",
    role: "presentation",
    style,
    children: jsx_runtime10.jsx("tbody", { children: jsx_runtime10.jsx("tr", { children: jsx_runtime10.jsx("td", { children }) }) })
  }));
};

// node_modules/@react-email/tailwind/dist/index.mjs
var React2 = __toESM(require_react(), 1);
var server = __toESM(require_server_node(), 1);

// node_modules/tw-to-css/dist/index.mjs
var $n = function() {
};
var Un = function(t) {
  let e = new Set, r = new Set, n = new Set;
  if (t.walkAtRules((i) => {
    i.name === "apply" && n.add(i), i.name === "import" && (i.params === '"tailwindcss/base"' || i.params === "'tailwindcss/base'" ? (i.name = "tailwind", i.params = "base") : i.params === '"tailwindcss/components"' || i.params === "'tailwindcss/components'" ? (i.name = "tailwind", i.params = "components") : i.params === '"tailwindcss/utilities"' || i.params === "'tailwindcss/utilities'" ? (i.name = "tailwind", i.params = "utilities") : (i.params === '"tailwindcss/screens"' || i.params === "'tailwindcss/screens'" || i.params === '"tailwindcss/variants"' || i.params === "'tailwindcss/variants'") && (i.name = "tailwind", i.params = "variants")), i.name === "tailwind" && (i.params === "screens" && (i.params = "variants"), e.add(i.params)), ["layer", "responsive", "variants"].includes(i.name) && (["responsive", "variants"].includes(i.name) && L.warn(`${i.name}-at-rule-deprecated`, [`The \`@${i.name}\` directive has been deprecated in Tailwind CSS v3.0.`, "Use `@layer utilities` or `@layer components` instead.", "https://tailwindcss.com/docs/upgrade-guide#replace-variants-with-layer"]), r.add(i));
  }), !e.has("base") || !e.has("components") || !e.has("utilities")) {
    for (let i of r)
      if (i.name === "layer" && ["base", "components", "utilities"].includes(i.params)) {
        if (!e.has(i.params))
          throw i.error(`\`@layer ${i.params}\` is used but no matching \`@tailwind ${i.params}\` directive is present.`);
      } else if (i.name === "responsive") {
        if (!e.has("utilities"))
          throw i.error("`@responsive` is used but `@tailwind utilities` is missing.");
      } else if (i.name === "variants" && !e.has("utilities"))
        throw i.error("`@variants` is used but `@tailwind utilities` is missing.");
  }
  return { tailwindDirectives: e, applyDirectives: n };
};
var Dp = function(t) {
  if (t === undefined)
    return false;
  if (t === "true" || t === "1")
    return true;
  if (t === "false" || t === "0")
    return false;
  if (t === "*")
    return true;
  let e = t.split(",").map((r) => r.split(":")[0]);
  return e.includes("-tailwindcss") ? false : !!e.includes("tailwindcss");
};
var nt = function(t) {
  return Array.isArray(t) ? t.flatMap((e) => R([(0, $u.default)({ bubble: ["screen"] })]).process(e, { parser: tn }).root.nodes) : nt([t]);
};
var X = function(t) {
  if (Object.prototype.toString.call(t) !== "[object Object]")
    return false;
  let e = Object.getPrototypeOf(t);
  return e === null || e === Object.prototype;
};
var it = function(t, e, r = false) {
  if (t === "")
    return e;
  let n = typeof e == "string" ? (0, Uu.default)().astSync(e) : e;
  return n.walkClasses((i) => {
    let a = i.value, s = r && a.startsWith("-");
    i.value = s ? `-${t}${a.slice(1)}` : `${t}${a}`;
  }), typeof e == "string" ? n.toString() : n;
};
var Be = function(t) {
  return t.replace(/\\,/g, "\\2c ");
};
var ir = function(t, { loose: e = false } = {}) {
  var a, s, o2;
  if (typeof t != "string")
    return null;
  if (t = t.trim(), t === "transparent")
    return { mode: "rgb", color: ["0", "0", "0"], alpha: "0" };
  if (t in ks)
    return { mode: "rgb", color: ks[t].map((l) => l.toString()) };
  let r = t.replace(A0, (l, u, f, p, c2) => ["#", u, u, f, f, p, p, c2 ? c2 + c2 : ""].join("")).match(C0);
  if (r !== null)
    return { mode: "rgb", color: [parseInt(r[1], 16), parseInt(r[2], 16), parseInt(r[3], 16)].map((l) => l.toString()), alpha: r[4] ? (parseInt(r[4], 16) / 255).toString() : undefined };
  let n = (a = t.match(_0)) != null ? a : t.match(T0);
  if (n === null)
    return null;
  let i = [n[2], n[3], n[4]].filter(Boolean).map((l) => l.toString());
  return i.length === 2 && i[0].startsWith("var(") ? { mode: n[1], color: [i[0]], alpha: i[1] } : !e && i.length !== 3 || i.length < 3 && !i.some((l) => /^var\(.*?\)$/.test(l)) ? null : { mode: n[1], color: i, alpha: (o2 = (s = n[5]) == null ? undefined : s.toString) == null ? undefined : o2.call(s) };
};
var Os = function({ mode: t, color: e, alpha: r }) {
  let n = r !== undefined;
  return t === "rgba" || t === "hsla" ? `${t}(${e.join(", ")}${n ? `, ${r}` : ""})` : `${t}(${e.join(" ")}${n ? ` / ${r}` : ""})`;
};
var we = function(t, e, r) {
  if (typeof t == "function")
    return t({ opacityValue: e });
  let n = ir(t, { loose: true });
  return n === null ? r : Os({ ...n, alpha: e });
};
var Z = function({ color: t, property: e, variable: r }) {
  let n = [].concat(e);
  if (typeof t == "function")
    return { [r]: "1", ...Object.fromEntries(n.map((a) => [a, t({ opacityVariable: r, opacityValue: `var(${r})` })])) };
  let i = ir(t);
  return i === null ? Object.fromEntries(n.map((a) => [a, t])) : i.alpha !== undefined ? Object.fromEntries(n.map((a) => [a, t])) : { [r]: "1", ...Object.fromEntries(n.map((a) => [a, Os({ ...i, alpha: `var(${r})` })])) };
};
var ee = function(t, e) {
  let r = [], n = [], i = 0, a = false;
  for (let s = 0;s < t.length; s++) {
    let o2 = t[s];
    r.length === 0 && o2 === e[0] && !a && (e.length === 1 || t.slice(s, s + e.length) === e) && (n.push(t.slice(i, s)), i = s + e.length), a ? a = false : o2 === "\\" && (a = true), o2 === "(" || o2 === "[" || o2 === "{" ? r.push(o2) : (o2 === ")" && r[r.length - 1] === "(" || o2 === "]" && r[r.length - 1] === "[" || o2 === "}" && r[r.length - 1] === "{") && r.pop();
  }
  return n.push(t.slice(i)), n;
};
var nn = function(t) {
  return ee(t, ",").map((r) => {
    let n = r.trim(), i = { raw: n }, a = n.split(I0), s = new Set;
    for (let o2 of a)
      zu.lastIndex = 0, !s.has("KEYWORD") && P0.has(o2) ? (i.keyword = o2, s.add("KEYWORD")) : zu.test(o2) ? s.has("X") ? s.has("Y") ? s.has("BLUR") ? s.has("SPREAD") || (i.spread = o2, s.add("SPREAD")) : (i.blur = o2, s.add("BLUR")) : (i.y = o2, s.add("Y")) : (i.x = o2, s.add("X")) : i.color ? (i.unknown || (i.unknown = []), i.unknown.push(o2)) : i.color = o2;
    return i.valid = i.x !== undefined && i.y !== undefined, i;
  });
};
var Vu = function(t) {
  return t.map((e) => e.valid ? [e.keyword, e.x, e.y, e.blur, e.spread, e.color].filter(Boolean).join(" ") : e.raw).join(", ");
};
var Es = function(t) {
  return R02.some((e) => new RegExp(`^${e}\\(.*\\)`).test(t));
};
var z2 = function(t, e = true) {
  return t.startsWith("--") ? `var(${t})` : t.includes("url(") ? t.split(/(url\(.*?\))/g).filter(Boolean).map((r) => /^url\(.*?\)$/.test(r) ? r : z2(r, false)).join("") : (t = t.replace(/([^\\])_+/g, (r, n) => n + " ".repeat(r.length - 1)).replace(/^_/g, " ").replace(/\\_/g, "_"), e && (t = t.trim()), t = t.replace(/(calc|min|max|clamp)\(.+\)/g, (r) => {
    let n = [];
    return r.replace(/var\((--.+?)[,)]/g, (i, a) => (n.push(a), i.replace(a, Wu))).replace(/(-?\d*\.?\d(?!\b-\d.+[,)](?![^+\-/*])\D)(?:%|[a-z]+)?|\))([+\-/*])/g, "$1 $2 ").replace(D0, () => n.shift());
  }), t);
};
var Cs = function(t) {
  return t.startsWith("url(");
};
var As = function(t) {
  return !isNaN(Number(t)) || Es(t);
};
var sr = function(t) {
  return t.endsWith("%") && As(t.slice(0, -1)) || Es(t);
};
var ar = function(t) {
  return t === "0" || new RegExp(`^[+-]?[0-9]*.?[0-9]+(?:[eE][+-]?[0-9]+)?${F0}\$`).test(t) || Es(t);
};
var Bu = function(t) {
  return L0.has(t);
};
var Gu = function(t) {
  let e = nn(z2(t));
  for (let r of e)
    if (!r.valid)
      return false;
  return true;
};
var Yu = function(t) {
  let e = 0;
  return ee(t, "_").every((n) => (n = z2(n), n.startsWith("var(") ? true : ir(n, { loose: true }) !== null ? (e++, true) : false)) ? e > 0 : false;
};
var Hu = function(t) {
  let e = 0;
  return ee(t, ",").every((n) => (n = z2(n), n.startsWith("var(") ? true : Cs(n) || q0(n) || ["element(", "image(", "cross-fade(", "image-set("].some((i) => n.startsWith(i)) ? (e++, true) : false)) ? e > 0 : false;
};
var q0 = function(t) {
  t = z2(t);
  for (let e of N0)
    if (t.startsWith(`${e}(`))
      return true;
  return false;
};
var Qu = function(t) {
  let e = 0;
  return ee(t, "_").every((n) => (n = z2(n), n.startsWith("var(") ? true : $02.has(n) || ar(n) || sr(n) ? (e++, true) : false)) ? e > 0 : false;
};
var Ju = function(t) {
  let e = 0;
  return ee(t, ",").every((n) => (n = z2(n), n.startsWith("var(") ? true : n.includes(" ") && !/(['"])([^"']+)\1/g.test(n) || /^\d/g.test(n) ? false : (e++, true))) ? e > 0 : false;
};
var Xu = function(t) {
  return U02.has(t);
};
var Ku = function(t) {
  return j0.has(t);
};
var Zu = function(t) {
  return z02.has(t);
};
var Re = function(t) {
  if (t = `${t}`, t === "0")
    return "0";
  if (/^[+-]?(\d+|\d*\.\d+)(e[+-]?\d+)?(%|\w+)?$/.test(t))
    return t.replace(/^[+-]?/, (r) => r === "-" ? "" : "-");
  let e = ["var", "calc", "min", "max", "clamp"];
  for (let r of e)
    if (t.includes(`${r}(`))
      return `calc(${t} * -1)`;
};
var ef = function(t) {
  let e = ["cover", "contain"];
  return ee(t, ",").every((r) => {
    let n = ee(r, "_").filter(Boolean);
    return n.length === 1 && e.includes(n[0]) ? true : n.length !== 1 && n.length !== 2 ? false : n.every((i) => ar(i) || sr(i) || i === "auto");
  });
};
var G = function(t, e) {
  var r, n, i, a, s, o2;
  return sn.future.includes(e) ? t.future === "all" || ((i = (n = (r = t == null ? undefined : t.future) == null ? undefined : r[e]) != null ? n : tf[e]) != null ? i : false) : sn.experimental.includes(e) ? t.experimental === "all" || ((o2 = (s = (a = t == null ? undefined : t.experimental) == null ? undefined : a[e]) != null ? s : tf[e]) != null ? o2 : false) : false;
};
var nf = function(t) {
  if (false) {
  }
};
var af = function(t, e) {
  t.walkClasses((r) => {
    r.value = e(r.value), r.raws && r.raws.value && (r.raws.value = Be(r.raws.value));
  });
};
var of = function(t, e) {
  if (!De(t))
    return;
  let r = t.slice(1, -1);
  if (!!e(r))
    return z2(r);
};
var V0 = function(t, e = {}, r) {
  let n = e[t];
  if (n !== undefined)
    return Re(n);
  if (De(t)) {
    let i = of(t, r);
    return i === undefined ? undefined : Re(i);
  }
};
var an = function(t, e = {}, { validate: r = () => true } = {}) {
  var i;
  let n = (i = e.values) == null ? undefined : i[t];
  return n !== undefined ? n : e.supportsNegativeValues && t.startsWith("-") ? V0(t.slice(1), e.values, r) : of(t, r);
};
var De = function(t) {
  return t.startsWith("[") && t.endsWith("]");
};
var lf = function(t) {
  let e = t.lastIndexOf("/");
  return e === -1 || e === t.length - 1 ? [t, undefined] : De(t) && !t.includes("]/[") ? [t, undefined] : [t.slice(0, e), t.slice(e + 1)];
};
var st = function(t) {
  if (typeof t == "string" && t.includes("<alpha-value>")) {
    let e = t;
    return ({ opacityValue: r = 1 }) => e.replace("<alpha-value>", r);
  }
  return t;
};
var uf = function(t) {
  return z2(t.slice(1, -1));
};
var W0 = function(t, e = {}, { tailwindConfig: r = {} } = {}) {
  var a, s, o2, l, u, f;
  if (((a = e.values) == null ? undefined : a[t]) !== undefined)
    return st((s = e.values) == null ? undefined : s[t]);
  let [n, i] = lf(t);
  if (i !== undefined) {
    let p = (l = (o2 = e.values) == null ? undefined : o2[n]) != null ? l : De(n) ? n.slice(1, -1) : undefined;
    return p === undefined ? undefined : (p = st(p), De(i) ? we(p, uf(i)) : ((f = (u = r.theme) == null ? undefined : u.opacity) == null ? undefined : f[i]) === undefined ? undefined : we(p, r.theme.opacity[i]));
  }
  return an(t, e, { validate: Yu });
};
var B02 = function(t, e = {}) {
  var r;
  return (r = e.values) == null ? undefined : r[t];
};
var oe = function(t) {
  return (e, r) => an(e, r, { validate: t });
};
var G0 = function(t, e) {
  let r = t.indexOf(e);
  return r === -1 ? [undefined, t] : [t.slice(0, r), t.slice(r + 1)];
};
var Ts = function(t, e, r, n) {
  if (r.values && e in r.values)
    for (let { type: a } of t != null ? t : []) {
      let s = _s[a](e, r, { tailwindConfig: n });
      if (s !== undefined)
        return [s, a, null];
    }
  if (De(e)) {
    let a = e.slice(1, -1), [s, o2] = G0(a, ":");
    if (!/^[\w-_]+$/g.test(s))
      o2 = a;
    else if (s !== undefined && !sf.includes(s))
      return [];
    if (o2.length > 0 && sf.includes(s))
      return [an(`[${o2}]`, r), s, null];
  }
  let i = Ps(t, e, r, n);
  for (let a of i)
    return a;
  return [];
};
function* Ps(t, e, r, n) {
  var l, u;
  let i = G(n, "generalizedModifiers"), [a, s] = lf(e);
  if (i && r.modifiers != null && (r.modifiers === "any" || typeof r.modifiers == "object" && (s && De(s) || (s in r.modifiers))) || (a = e, s = undefined), s !== undefined && a === "" && (a = "DEFAULT"), s !== undefined && typeof r.modifiers == "object") {
    let f = (u = (l = r.modifiers) == null ? undefined : l[s]) != null ? u : null;
    f !== null ? s = f : De(s) && (s = uf(s));
  }
  for (let { type: f } of t != null ? t : []) {
    let p = _s[f](a, r, { tailwindConfig: n });
    p !== undefined && (yield [p, f, s != null ? s : null]);
  }
}
var re = function(t) {
  var r, n;
  let e = ff.default.className();
  return e.value = t, Be((n = (r = e == null ? undefined : e.raws) == null ? undefined : r.value) != null ? n : e.value);
};
var at = function(t) {
  let [e] = cf(t);
  return e.forEach(([r, n]) => r.removeChild(n)), t.nodes.push(...e.map(([, r]) => r)), t;
};
var cf = function(t) {
  var n;
  let e = [], r = null;
  for (let i of t.nodes)
    if (i.type === "combinator")
      e = e.filter(([, a]) => Rs(a).includes("jumpable")), r = null;
    else if (i.type === "pseudo") {
      Y0(i) ? (r = i, e.push([t, i, null])) : r && H0(i, r) ? e.push([t, i, r]) : r = null;
      for (let a of (n = i.nodes) != null ? n : []) {
        let [s, o2] = cf(a);
        r = o2 || r, e.push(...s);
      }
    }
  return [e, r];
};
var pf = function(t) {
  return t.value.startsWith("::") || Is[t.value] !== undefined;
};
var Y0 = function(t) {
  return pf(t) && Rs(t).includes("terminal");
};
var H0 = function(t, e) {
  return t.type !== "pseudo" || pf(t) ? false : Rs(e).includes("actionable");
};
var Rs = function(t) {
  var e;
  return (e = Is[t.value]) != null ? e : Is.__default__;
};
var ot = function(t, { context: e, candidate: r }) {
  var s;
  let n = (s = e == null ? undefined : e.tailwindConfig.prefix) != null ? s : "", i = t.map((o2) => {
    let l = (0, be.default)().astSync(o2.format);
    return { ...o2, ast: o2.isArbitraryVariant ? l : it(n, l) };
  }), a = be.default.root({ nodes: [be.default.selector({ nodes: [be.default.className({ value: re(r) })] })] });
  for (let { ast: o2 } of i)
    [a, o2] = J0(a, o2), o2.walkNesting((l) => l.replaceWith(...a.nodes[0].nodes)), a = o2;
  return a;
};
var df = function(t) {
  let e = [];
  for (;t.prev() && t.prev().type !== "combinator"; )
    t = t.prev();
  for (;t && t.type !== "combinator"; )
    e.push(t), t = t.next();
  return e;
};
var Q0 = function(t) {
  return t.sort((e, r) => e.type === "tag" && r.type === "class" ? -1 : e.type === "class" && r.type === "tag" ? 1 : e.type === "class" && r.type === "pseudo" && r.value.startsWith("::") ? -1 : e.type === "pseudo" && e.value.startsWith("::") && r.type === "class" ? 1 : t.index(e) - t.index(r)), t;
};
var Ms = function(t, e) {
  let r = false;
  t.walk((n) => {
    if (n.type === "class" && n.value === e)
      return r = true, false;
  }), r || t.remove();
};
var on = function(t, e, { context: r, candidate: n, base: i }) {
  var f, p;
  let a = (p = (f = r == null ? undefined : r.tailwindConfig) == null ? undefined : f.separator) != null ? p : ":";
  i = i != null ? i : n.split(new RegExp(`\\${a}(?![^[]*\\])`)).pop();
  let s = (0, be.default)().astSync(t);
  s.walkClasses((c2) => {
    c2.raws && c2.value.includes(i) && (c2.raws.value = re((0, hf.default)(c2.raws.value)));
  }), s.each((c2) => Ms(c2, i));
  let o2 = Array.isArray(e) ? ot(e, { context: r, candidate: n }) : e;
  if (o2 === null)
    return s.toString();
  let l = be.default.comment({ value: "/*__simple__*/" }), u = be.default.comment({ value: "/*__simple__*/" });
  return s.walkClasses((c2) => {
    if (c2.value !== i)
      return;
    let d = c2.parent, h = o2.nodes[0].nodes;
    if (d.nodes.length === 1) {
      c2.replaceWith(...h);
      return;
    }
    let y = df(c2);
    d.insertBefore(y[0], l), d.insertAfter(y[y.length - 1], u);
    for (let g of h)
      d.insertBefore(y[0], g.clone());
    c2.remove(), y = df(l);
    let m = d.index(l);
    d.nodes.splice(m, y.length, ...Q0(be.default.selector({ nodes: y })).nodes), l.remove(), u.remove();
  }), s.walkPseudos((c2) => {
    c2.value === Ds && c2.replaceWith(c2.nodes);
  }), s.each((c2) => at(c2)), s.toString();
};
var J0 = function(t, e) {
  let r = [];
  return t.walkPseudos((n) => {
    n.value === Ds && r.push({ pseudo: n, value: n.nodes[0].toString() });
  }), e.walkPseudos((n) => {
    if (n.value !== Ds)
      return;
    let i = n.nodes[0].toString(), a = r.find((u) => u.value === i);
    if (!a)
      return;
    let s = [], o2 = n.next();
    for (;o2 && o2.type !== "combinator"; )
      s.push(o2), o2 = o2.next();
    let l = o2;
    a.pseudo.parent.insertAfter(a.pseudo, be.default.selector({ nodes: s.map((u) => u.clone()) })), n.remove(), s.forEach((u) => u.remove()), l && l.type === "combinator" && l.remove();
  }), [t, e];
};
var Fs = function(t) {
  return Be(`.${re(t)}`);
};
var ln = function(t, e) {
  return Fs(or2(t, e));
};
var or2 = function(t, e) {
  return e === "DEFAULT" ? t : e === "-" || e === "-DEFAULT" ? `-${t}` : e.startsWith("-") ? `-${t}${e}` : e.startsWith("/") ? `${t}${e}` : `${t}-${e}`;
};
var Ce = function(t) {
  return ["fontSize", "outline"].includes(t) ? (e) => (typeof e == "function" && (e = e({})), Array.isArray(e) && (e = e[0]), e) : t === "fontFamily" ? (e) => {
    typeof e == "function" && (e = e({}));
    let r = Array.isArray(e) && X(e[1]) ? e[0] : e;
    return Array.isArray(r) ? r.join(", ") : r;
  } : ["boxShadow", "transitionProperty", "transitionDuration", "transitionDelay", "transitionTimingFunction", "backgroundImage", "backgroundSize", "backgroundColor", "cursor", "animation"].includes(t) ? (e) => (typeof e == "function" && (e = e({})), Array.isArray(e) && (e = e.join(", ")), e) : ["gridTemplateColumns", "gridTemplateRows", "objectPosition"].includes(t) ? (e) => (typeof e == "function" && (e = e({})), typeof e == "string" && (e = R.list.comma(e).join(" ")), e) : (e, r = {}) => (typeof e == "function" && (e = e(r)), e);
};
var T = function(t, e = [[t, [t]]], { filterDefault: r = false, ...n } = {}) {
  let i = Ce(t);
  return function({ matchUtilities: a, theme: s }) {
    var o2;
    for (let l of e) {
      let u = Array.isArray(l[0]) ? l : [l];
      a(u.reduce((f, [p, c2]) => Object.assign(f, { [p]: (d) => c2.reduce((h, y) => Array.isArray(y) ? Object.assign(h, { [y[0]]: y[1] }) : Object.assign(h, { [y]: i(d) }), {}) }), {}), { ...n, values: r ? Object.fromEntries(Object.entries((o2 = s(t)) != null ? o2 : {}).filter(([f]) => f !== "DEFAULT")) : s(t) });
    }
  };
};
var Me = function(t) {
  return t = Array.isArray(t) ? t : [t], t.map((e) => {
    let r = e.values.map((n) => n.raw !== undefined ? n.raw : [n.min && `(min-width: ${n.min})`, n.max && `(max-width: ${n.max})`].filter(Boolean).join(" and "));
    return e.not ? `not all and ${r}` : r;
  }).join(", ");
};
var $s = function(t) {
  return t.split(nv).map((r) => {
    let n = r.trim(), i = { value: n }, a = n.split(iv), s = new Set;
    for (let o2 of a)
      !s.has("DIRECTIONS") && X0.has(o2) ? (i.direction = o2, s.add("DIRECTIONS")) : !s.has("PLAY_STATES") && K0.has(o2) ? (i.playState = o2, s.add("PLAY_STATES")) : !s.has("FILL_MODES") && Z0.has(o2) ? (i.fillMode = o2, s.add("FILL_MODES")) : !s.has("ITERATION_COUNTS") && (ev.has(o2) || sv.test(o2)) ? (i.iterationCount = o2, s.add("ITERATION_COUNTS")) : !s.has("TIMING_FUNCTION") && tv.has(o2) || !s.has("TIMING_FUNCTION") && rv.some((l) => o2.startsWith(`${l}(`)) ? (i.timingFunction = o2, s.add("TIMING_FUNCTION")) : !s.has("DURATION") && mf.test(o2) ? (i.duration = o2, s.add("DURATION")) : !s.has("DELAY") && mf.test(o2) ? (i.delay = o2, s.add("DELAY")) : s.has("NAME") ? (i.unknown || (i.unknown = []), i.unknown.push(o2)) : (i.name = o2, s.add("NAME"));
    return i;
  });
};
var M = function(t) {
  return typeof t == "function" ? t({}) : t;
};
var Fe = function(t, e = true) {
  return Array.isArray(t) ? t.map((r) => {
    if (e && Array.isArray(r))
      throw new Error("The tuple syntax is not supported for `screens`.");
    if (typeof r == "string")
      return { name: r.toString(), not: false, values: [{ min: r, max: undefined }] };
    let [n, i] = r;
    return n = n.toString(), typeof i == "string" ? { name: n, not: false, values: [{ min: i, max: undefined }] } : Array.isArray(i) ? { name: n, not: false, values: i.map((a) => yf(a)) } : { name: n, not: false, values: [yf(i)] };
  }) : Fe(Object.entries(t != null ? t : {}), false);
};
var un = function(t) {
  return t.values.length !== 1 ? { result: false, reason: "multiple-values" } : t.values[0].raw !== undefined ? { result: false, reason: "raw-values" } : t.values[0].min !== undefined && t.values[0].max !== undefined ? { result: false, reason: "min-and-max" } : { result: true, reason: null };
};
var vf = function(t, e, r) {
  let n = fn(e, t), i = fn(r, t), a = un(n), s = un(i);
  if (a.reason === "multiple-values" || s.reason === "multiple-values")
    throw new Error("Attempted to sort a screen with multiple values. This should never happen. Please open a bug report.");
  if (a.reason === "raw-values" || s.reason === "raw-values")
    throw new Error("Attempted to sort a screen with raw values. This should never happen. Please open a bug report.");
  if (a.reason === "min-and-max" || s.reason === "min-and-max")
    throw new Error("Attempted to sort a screen with both min and max values. This should never happen. Please open a bug report.");
  let { min: o2, max: l } = n.values[0], { min: u, max: f } = i.values[0];
  e.not && ([o2, l] = [l, o2]), r.not && ([u, f] = [f, u]), o2 = o2 === undefined ? o2 : parseFloat(o2), l = l === undefined ? l : parseFloat(l), u = u === undefined ? u : parseFloat(u), f = f === undefined ? f : parseFloat(f);
  let [p, c2] = t === "min" ? [o2, u] : [f, l];
  return p - c2;
};
var fn = function(t, e) {
  return typeof t == "object" ? t : { name: "arbitrary-screen", values: [{ [e]: t }] };
};
var yf = function({ "min-width": t, min: e = t, max: r, raw: n } = {}) {
  return { min: e, max: r, raw: n };
};
var cn = function(t, e) {
  t.walkDecls((r) => {
    if (e.includes(r.prop)) {
      r.remove();
      return;
    }
    for (let n of e)
      r.value.includes(`/ var(${n})`) && (r.value = r.value.replace(`/ var(${n})`, ""));
  });
};
var Le = function(t) {
  if (Array.isArray(t))
    return t;
  let e = t.split("[").length - 1, r = t.split("]").length - 1;
  if (e !== r)
    throw new Error(`Path is invalid. Has unbalanced brackets: ${t}`);
  return t.split(/\.(?![^\[]*\])|[\[\]]/g).filter(Boolean);
};
var lt2 = function(t) {
  let e = [], r = false;
  for (let n = 0;n < t.length; n++) {
    let i = t[n];
    if (i === ":" && !r && e.length === 0)
      return false;
    if (av.has(i) && t[n - 1] !== "\\" && (r = !r), !r && t[n - 1] !== "\\") {
      if (xf.has(i))
        e.push(i);
      else if (bf.has(i)) {
        let a = bf.get(i);
        if (e.length <= 0 || e.pop() !== a)
          return false;
      }
    }
  }
  return !(e.length > 0);
};
var pn = function(t) {
  return (t > 0n) - (t < 0n);
};
var Sf = function(t, e) {
  let r = 0n, n = 0n;
  for (let [i, a] of e)
    t & i && (r = r | i, n = n | a);
  return t & ~r | n;
};
var kf = function(t) {
  let e = null;
  for (let r of t)
    e = e != null ? e : r, e = e > r ? e : r;
  return e;
};
var ov = function(t, e) {
  let r = t.length, n = e.length, i = r < n ? r : n;
  for (let a = 0;a < i; a++) {
    let s = t.charCodeAt(a) - e.charCodeAt(a);
    if (s !== 0)
      return s;
  }
  return r - n;
};
var js = function(t, e) {
  let r = t.tailwindConfig.prefix;
  return typeof r == "function" ? r(e) : r + e;
};
var Of = function({ type: t = "any", ...e }) {
  let r = [].concat(t);
  return { ...e, types: r.map((n) => Array.isArray(n) ? { type: n[0], ...n[1] } : { type: n, preferOnConflict: false }) };
};
var lv = function(t) {
  let e = [], r = "", n = 0;
  for (let i = 0;i < t.length; i++) {
    let a = t[i];
    if (a === "\\")
      r += "\\" + t[++i];
    else if (a === "{")
      ++n, e.push(r.trim()), r = "";
    else if (a === "}") {
      if (--n < 0)
        throw new Error("Your { and } are unbalanced.");
      e.push(r.trim()), r = "";
    } else
      r += a;
  }
  return r.length > 0 && e.push(r.trim()), e = e.filter((i) => i !== ""), e;
};
var uv = function(t, e, { before: r = [] } = {}) {
  if (r = [].concat(r), r.length <= 0) {
    t.push(e);
    return;
  }
  let n = t.length - 1;
  for (let i of r) {
    let a = t.indexOf(i);
    a !== -1 && (n = Math.min(n, a));
  }
  t.splice(n, 0, e);
};
var Af = function(t) {
  return Array.isArray(t) ? t.flatMap((e) => !Array.isArray(e) && !X(e) ? e : nt(e)) : Af([t]);
};
var Ef = function(t, e) {
  return (0, Vs.default)((n) => {
    let i = [];
    return e && e(n), n.walkClasses((a) => {
      i.push(a.value);
    }), i;
  }).transformSync(t);
};
var fv = function(t, e = { containsNonOnDemandable: false }, r = 0) {
  let n = [];
  if (t.type === "rule") {
    let i = function(a) {
      a.walkPseudos((s) => {
        s.value === ":not" && s.remove();
      });
    };
    for (let a of t.selectors) {
      let s = Ef(a, i);
      s.length === 0 && (e.containsNonOnDemandable = true);
      for (let o2 of s)
        n.push(o2);
    }
  } else
    t.type === "atrule" && t.walkRules((i) => {
      for (let a of i.selectors.flatMap((s) => Ef(s)))
        n.push(a);
    });
  return r === 0 ? [e.containsNonOnDemandable || n.length === 0, n] : n;
};
var hn = function(t) {
  return Af(t).flatMap((e) => {
    let r = new Map, [n, i] = fv(e);
    return n && i.unshift(ke), i.map((a) => (r.has(e) || r.set(e, e), [a, r.get(e)]));
  });
};
var mn = function(t) {
  return t.startsWith("@") || t.includes("&");
};
var lr = function(t) {
  t = t.replace(/\n+/g, "").replace(/\s{1,}/g, " ").trim();
  let e = lv(t).map((r) => {
    if (!r.startsWith("@"))
      return ({ format: a }) => a(r);
    let [, n, i] = /@(.*?)( .+|[({].*)/g.exec(r);
    return ({ wrap: a }) => a(R.atRule({ name: n, params: i.trim() }));
  }).reverse();
  return (r) => {
    for (let n of e)
      n(r);
  };
};
var cv = function(t, e, { variantList: r, variantMap: n, offsets: i, classList: a }) {
  function s(c2, d) {
    return c2 ? (0, Cf.default)(t, c2, d) : t;
  }
  function o2(c2) {
    return it(t.prefix, c2);
  }
  function l(c2, d) {
    return c2 === ke ? ke : d.respectPrefix ? e.tailwindConfig.prefix + c2 : c2;
  }
  function u(c2, d, h = {}) {
    let y = Le(c2), m = s(["theme", ...y], d);
    return Ce(y[0])(m, h);
  }
  let f = 0, p = { postcss: R, prefix: o2, e: re, config: s, theme: u, corePlugins: (c2) => Array.isArray(t.corePlugins) ? t.corePlugins.includes(c2) : s(["corePlugins", c2], true), variants: () => [], addBase(c2) {
    for (let [d, h] of hn(c2)) {
      let y = l(d, {}), m = i.create("base");
      e.candidateRuleMap.has(y) || e.candidateRuleMap.set(y, []), e.candidateRuleMap.get(y).push([{ sort: m, layer: "base" }, h]);
    }
  }, addDefaults(c2, d) {
    let h = { [`@defaults ${c2}`]: d };
    for (let [y, m] of hn(h)) {
      let g = l(y, {});
      e.candidateRuleMap.has(g) || e.candidateRuleMap.set(g, []), e.candidateRuleMap.get(g).push([{ sort: i.create("defaults"), layer: "defaults" }, m]);
    }
  }, addComponents(c2, d) {
    d = Object.assign({}, { preserveSource: false, respectPrefix: true, respectImportant: false }, Array.isArray(d) ? {} : d);
    for (let [y, m] of hn(c2)) {
      let g = l(y, d);
      a.add(g), e.candidateRuleMap.has(g) || e.candidateRuleMap.set(g, []), e.candidateRuleMap.get(g).push([{ sort: i.create("components"), layer: "components", options: d }, m]);
    }
  }, addUtilities(c2, d) {
    d = Object.assign({}, { preserveSource: false, respectPrefix: true, respectImportant: true }, Array.isArray(d) ? {} : d);
    for (let [y, m] of hn(c2)) {
      let g = l(y, d);
      a.add(g), e.candidateRuleMap.has(g) || e.candidateRuleMap.set(g, []), e.candidateRuleMap.get(g).push([{ sort: i.create("utilities"), layer: "utilities", options: d }, m]);
    }
  }, matchUtilities: function(c2, d) {
    d = Of({ ...{ respectPrefix: true, respectImportant: true, modifiers: false }, ...d });
    let y = i.create("utilities");
    for (let m in c2) {
      let b2 = function(O, { isOnlyPlugin: x }) {
        let [A, E, I] = Ts(d.types, O, d, t);
        if (A === undefined)
          return [];
        if (!d.types.some(({ type: B }) => B === E))
          if (x)
            L.warn([`Unnecessary typehint \`${E}\` in \`${m}-${O}\`.`, `You can safely update it to \`${m}-${O.replace(E + ":", "")}\`.`]);
          else
            return [];
        if (!lt2(A))
          return [];
        let F = { get modifier() {
          return d.modifiers || L.warn(`modifier-used-without-options-for-${m}`, ["Your plugin must set `modifiers: true` in its options to support modifiers."]), I;
        } }, Y = G(t, "generalizedModifiers");
        return [].concat(Y ? w(A, F) : w(A)).filter(Boolean).map((B) => ({ [ln(m, O)]: B }));
      }, g = l(m, d), w = c2[m];
      a.add([g, d]);
      let v = [{ sort: y, layer: "utilities", options: d }, b2];
      e.candidateRuleMap.has(g) || e.candidateRuleMap.set(g, []), e.candidateRuleMap.get(g).push(v);
    }
  }, matchComponents: function(c2, d) {
    d = Of({ ...{ respectPrefix: true, respectImportant: false, modifiers: false }, ...d });
    let y = i.create("components");
    for (let m in c2) {
      let b2 = function(O, { isOnlyPlugin: x }) {
        let [A, E, I] = Ts(d.types, O, d, t);
        if (A === undefined)
          return [];
        if (!d.types.some(({ type: B }) => B === E))
          if (x)
            L.warn([`Unnecessary typehint \`${E}\` in \`${m}-${O}\`.`, `You can safely update it to \`${m}-${O.replace(E + ":", "")}\`.`]);
          else
            return [];
        if (!lt2(A))
          return [];
        let F = { get modifier() {
          return d.modifiers || L.warn(`modifier-used-without-options-for-${m}`, ["Your plugin must set `modifiers: true` in its options to support modifiers."]), I;
        } }, Y = G(t, "generalizedModifiers");
        return [].concat(Y ? w(A, F) : w(A)).filter(Boolean).map((B) => ({ [ln(m, O)]: B }));
      }, g = l(m, d), w = c2[m];
      a.add([g, d]);
      let v = [{ sort: y, layer: "components", options: d }, b2];
      e.candidateRuleMap.has(g) || e.candidateRuleMap.set(g, []), e.candidateRuleMap.get(g).push(v);
    }
  }, addVariant(c2, d, h = {}) {
    d = [].concat(d).map((y) => {
      if (typeof y != "string")
        return (m = {}) => {
          let { args: g, modifySelectors: w, container: b2, separator: v, wrap: O, format: x } = m, A = y(Object.assign({ modifySelectors: w, container: b2, separator: v }, h.type === Us.MatchVariant && { args: g, wrap: O, format: x }));
          if (typeof A == "string" && !mn(A))
            throw new Error(`Your custom variant \`${c2}\` has an invalid format string. Make sure it's an at-rule or contains a \`&\` placeholder.`);
          return Array.isArray(A) ? A.filter((E) => typeof E == "string").map((E) => lr(E)) : A && typeof A == "string" && lr(A)(m);
        };
      if (!mn(y))
        throw new Error(`Your custom variant \`${c2}\` has an invalid format string. Make sure it's an at-rule or contains a \`&\` placeholder.`);
      return lr(y);
    }), uv(r, c2, h), n.set(c2, d), e.variantOptions.set(c2, h);
  }, matchVariant(c2, d, h) {
    var b2, v, O;
    let y = (b2 = h == null ? undefined : h.id) != null ? b2 : ++f, m = c2 === "@", g = G(t, "generalizedModifiers");
    for (let [x, A] of Object.entries((v = h == null ? undefined : h.values) != null ? v : {}))
      x !== "DEFAULT" && p.addVariant(m ? `${c2}${x}` : `${c2}-${x}`, ({ args: E, container: I }) => d(A, g ? { modifier: E == null ? undefined : E.modifier, container: I } : { container: I }), { ...h, value: A, id: y, type: Us.MatchVariant, variantInfo: zs.Base });
    let w = "DEFAULT" in ((O = h == null ? undefined : h.values) != null ? O : {});
    p.addVariant(c2, ({ args: x, container: A }) => {
      var E;
      return (x == null ? undefined : x.value) === mt && !w ? null : d((x == null ? undefined : x.value) === mt ? h.values.DEFAULT : (E = x == null ? undefined : x.value) != null ? E : typeof x == "string" ? x : "", g ? { modifier: x == null ? undefined : x.modifier, container: A } : { container: A });
    }, { ...h, id: y, type: Us.MatchVariant, variantInfo: zs.Dynamic });
  } };
  return p;
};
var _f = function(t) {
  t.walkAtRules((e) => {
    ["responsive", "variants"].includes(e.name) && (_f(e), e.before(e.nodes), e.remove());
  });
};
var pv = function(t) {
  let e = [];
  return t.each((r) => {
    r.type === "atrule" && ["responsive", "variants"].includes(r.name) && (r.name = "layer", r.params = "utilities");
  }), t.walkAtRules("layer", (r) => {
    if (_f(r), r.params === "base") {
      for (let n of r.nodes)
        e.push(function({ addBase: i }) {
          i(n, { respectPrefix: false });
        });
      r.remove();
    } else if (r.params === "components") {
      for (let n of r.nodes)
        e.push(function({ addComponents: i }) {
          i(n, { respectPrefix: false, preserveSource: true });
        });
      r.remove();
    } else if (r.params === "utilities") {
      for (let n of r.nodes)
        e.push(function({ addUtilities: i }) {
          i(n, { respectPrefix: false, preserveSource: true });
        });
      r.remove();
    }
  }), e;
};
var dv = function(t, e) {
  let r = Object.entries({ ...ne2, ...wf }).map(([o2, l]) => t.tailwindConfig.corePlugins.includes(o2) ? l : null).filter(Boolean), n = t.tailwindConfig.plugins.map((o2) => (o2.__isOptionsFunction && (o2 = o2()), typeof o2 == "function" ? o2 : o2.handler)), i = pv(e), a = [ne2.pseudoElementVariants, ne2.pseudoClassVariants, ne2.ariaVariants, ne2.dataVariants], s = [ne2.supportsVariants, ne2.directionVariants, ne2.reducedMotionVariants, ne2.prefersContrastVariants, ne2.darkVariants, ne2.printVariant, ne2.screenVariants, ne2.orientationVariants];
  return [...r, ...a, ...n, ...s, ...i];
};
var hv = function(t, e) {
  var f, p, c2;
  let r = [], n = new Map;
  e.variantMap = n;
  let i = new dn;
  e.offsets = i;
  let a = new Set, s = cv(e.tailwindConfig, e, { variantList: r, variantMap: n, offsets: i, classList: a });
  for (let d of t)
    if (Array.isArray(d))
      for (let h of d)
        h(s);
    else
      d == null || d(s);
  i.recordVariants(r, (d) => n.get(d).length);
  for (let [d, h] of n.entries())
    e.variantMap.set(d, h.map((y, m) => [i.forVariant(d, m), y]));
  let o2 = ((f = e.tailwindConfig.safelist) != null ? f : []).filter(Boolean);
  if (o2.length > 0) {
    let d = [];
    for (let h of o2) {
      if (typeof h == "string") {
        e.changedContent.push({ content: h, extension: "html" });
        continue;
      }
      if (h instanceof RegExp) {
        L.warn("root-regex", ["Regular expressions in `safelist` work differently in Tailwind CSS v3.0.", "Update your `safelist` configuration to eliminate this warning.", "https://tailwindcss.com/docs/content-configuration#safelisting-classes"]);
        continue;
      }
      d.push(h);
    }
    if (d.length > 0) {
      let h = new Map, y = e.tailwindConfig.prefix.length, m = d.some((g) => g.pattern.source.includes("!"));
      for (let g of a) {
        let w = Array.isArray(g) ? (() => {
          var A;
          let [b2, v] = g, x = Object.keys((A = v == null ? undefined : v.values) != null ? A : {}).map((E) => or2(b2, E));
          return v != null && v.supportsNegativeValues && (x = [...x, ...x.map((E) => "-" + E)], x = [...x, ...x.map((E) => E.slice(0, y) + "-" + E.slice(y))]), v.types.some(({ type: E }) => E === "color") && (x = [...x, ...x.flatMap((E) => Object.keys(e.tailwindConfig.theme.opacity).map((I) => `${E}/${I}`))]), m && (v == null ? undefined : v.respectImportant) && (x = [...x, ...x.map((E) => "!" + E)]), x;
        })() : [g];
        for (let b2 of w)
          for (let { pattern: v, variants: O = [] } of d)
            if (v.lastIndex = 0, h.has(v) || h.set(v, 0), !!v.test(b2)) {
              h.set(v, h.get(v) + 1), e.changedContent.push({ content: b2, extension: "html" });
              for (let x of O)
                e.changedContent.push({ content: x + e.tailwindConfig.separator + b2, extension: "html" });
            }
      }
      for (let [g, w] of h.entries())
        w === 0 && L.warn([`The safelist pattern \`${g}\` doesn't match any Tailwind CSS classes.`, "Fix this pattern or remove it from your `safelist` configuration.", "https://tailwindcss.com/docs/content-configuration#safelisting-classes"]);
    }
  }
  let l = (c2 = [].concat((p = e.tailwindConfig.darkMode) != null ? p : "media")[1]) != null ? c2 : "dark", u = [js(e, l), js(e, "group"), js(e, "peer")];
  e.getClassOrder = function(h) {
    let y = [...h].sort((b2, v) => b2 === v ? 0 : b2 < v ? -1 : 1), m = new Map(y.map((b2) => [b2, null])), g = gn(new Set(y), e);
    g = e.offsets.sort(g);
    let w = BigInt(u.length);
    for (let [, b2] of g)
      m.set(b2.raws.tailwind.candidate, w++);
    return h.map((b2) => {
      var x;
      let v = (x = m.get(b2)) != null ? x : null, O = u.indexOf(b2);
      return v === null && O !== -1 && (v = BigInt(O)), [b2, v];
    });
  }, e.getClassList = function(h = {}) {
    var m, g, w, b2;
    let y = [];
    for (let v of a)
      if (Array.isArray(v)) {
        let [O, x] = v, A = [], E = Object.keys((m = x == null ? undefined : x.modifiers) != null ? m : {});
        (g = x == null ? undefined : x.types) != null && g.some(({ type: Y }) => Y === "color") && E.push(...Object.keys((w = e.tailwindConfig.theme.opacity) != null ? w : {}));
        let I = { modifiers: E }, F = h.includeMetadata && E.length > 0;
        for (let [Y, K] of Object.entries((b2 = x == null ? undefined : x.values) != null ? b2 : {})) {
          if (K == null)
            continue;
          let B = or2(O, Y);
          if (y.push(F ? [B, I] : B), (x == null ? undefined : x.supportsNegativeValues) && Re(K)) {
            let qe = or2(O, `-${Y}`);
            A.push(F ? [qe, I] : qe);
          }
        }
        y.push(...A);
      } else
        y.push(v);
    return y;
  }, e.getVariants = function() {
    var y;
    let h = [];
    for (let [m, g] of e.variantOptions.entries())
      g.variantInfo !== zs.Base && h.push({ name: m, isArbitrary: g.type === Symbol.for("MATCH_VARIANT"), values: Object.keys((y = g.values) != null ? y : {}), hasDash: m !== "@", selectors({ modifier: w, value: b2 } = {}) {
        var Ca, Aa, _a, Ta;
        let v = "__TAILWIND_PLACEHOLDER__", O = R.rule({ selector: `.${v}` }), x = R.root({ nodes: [O.clone()] }), A = x.toString(), E = ((Ca = e.variantMap.get(m)) != null ? Ca : []).flatMap(([ie, se]) => se), I = [];
        for (let ie of E) {
          let se = [], hr = { args: { modifier: w, value: (_a = (Aa = g.values) == null ? undefined : Aa[b2]) != null ? _a : b2 }, separator: e.tailwindConfig.separator, modifySelectors(pe) {
            return x.each((qn) => {
              qn.type === "rule" && (qn.selectors = qn.selectors.map((Pa) => pe({ get className() {
                return Ws(Pa);
              }, selector: Pa })));
            }), x;
          }, format(pe) {
            se.push(pe);
          }, wrap(pe) {
            se.push(`@${pe.name} ${pe.params} { & }`);
          }, container: x }, mr = ie(hr);
          if (se.length > 0 && I.push(se), Array.isArray(mr))
            for (let pe of mr)
              se = [], pe(hr), I.push(se);
        }
        let F = [], Y = x.toString();
        A !== Y && (x.walkRules((ie) => {
          let se = ie.selector, hr = (0, Vs.default)((mr) => {
            mr.walkClasses((pe) => {
              pe.value = `${m}${e.tailwindConfig.separator}${pe.value}`;
            });
          }).processSync(se);
          F.push(se.replace(hr, "&").replace(v, "&"));
        }), x.walkAtRules((ie) => {
          F.push(`@${ie.name} (${ie.params}) { & }`);
        }));
        let K = !(b2 in ((Ta = g.values) != null ? Ta : {}));
        I = I.map((ie) => ie.map((se) => ({ format: se, isArbitraryVariant: K }))), F = F.map((ie) => ({ format: ie, isArbitraryVariant: K }));
        let B = { candidate: v, context: e }, qe = I.map((ie) => on(`.${v}`, ot(ie, B), B).replace(`.${v}`, "&").replace("{ & }", "").trim());
        return F.length > 0 && qe.push(ot(F, B).toString().replace(`.${v}`, "&")), qe;
      } });
    return h;
  };
};
var Tf = function(t, e) {
  !t.classCache.has(e) || (t.notClassCache.add(e), t.classCache.delete(e), t.applyClassCache.delete(e), t.candidateRuleMap.delete(e), t.candidateRuleCache.delete(e), t.stylesheetCache = null);
};
var mv = function(t, e) {
  let r = e.raws.tailwind.candidate;
  if (!!r) {
    for (let n of t.ruleCache)
      n[1].raws.tailwind.candidate === r && t.ruleCache.delete(n);
    Tf(t, r);
  }
};
var Pf = function(t, e = [], r = R.root()) {
  var a;
  let n = { disposables: [], ruleCache: new Set, candidateRuleCache: new Map, classCache: new Map, applyClassCache: new Map, notClassCache: new Set((a = t.blocklist) != null ? a : []), postCssNodeCache: new Map, candidateRuleMap: new Map, tailwindConfig: t, changedContent: e, variantMap: new Map, stylesheetCache: null, variantOptions: new Map, markInvalidUtilityCandidate: (s) => Tf(n, s), markInvalidUtilityNode: (s) => mv(n, s) }, i = dv(n, r);
  return hv(i, n), n;
};
var yn = function(t, e) {
  let r = (0, Bs.default)().astSync(t);
  return r.each((n) => {
    n.nodes[0].type === "pseudo" && n.nodes[0].value === ":is" && n.nodes.every((a) => a.type !== "combinator") || (n.nodes = [Bs.default.pseudo({ value: ":is", nodes: [n.clone()] })]), at(n);
  }), `${e} ${r.toString()}`;
};
var Ws = function(t) {
  return gv.transformSync(t);
};
function* yv(t) {
  let e = 1 / 0;
  for (;e >= 0; ) {
    let r, n = false;
    if (e === 1 / 0 && t.endsWith("]")) {
      let s = t.indexOf("[");
      t[s - 1] === "-" ? r = s - 1 : t[s - 1] === "/" ? (r = s - 1, n = true) : r = -1;
    } else
      e === 1 / 0 && t.includes("/") ? (r = t.lastIndexOf("/"), n = true) : r = t.lastIndexOf("-", e);
    if (r < 0)
      break;
    let i = t.slice(0, r), a = t.slice(n ? r : r + 1);
    e = r - 1, !(i === "" || a === "/") && (yield [i, a]);
  }
}
var vv = function(t, e) {
  if (t.length === 0 || e.tailwindConfig.prefix === "")
    return t;
  for (let r of t) {
    let [n] = r;
    if (n.options.respectPrefix) {
      let i = R.root({ nodes: [r[1].clone()] }), a = r[1].raws.tailwind.classCandidate;
      i.walkRules((s) => {
        let o2 = a.startsWith("-");
        s.selector = it(e.tailwindConfig.prefix, s.selector, o2);
      }), r[1] = i.nodes[0];
    }
  }
  return t;
};
var wv = function(t, e) {
  if (t.length === 0)
    return t;
  let r = [];
  for (let [n, i] of t) {
    let a = R.root({ nodes: [i.clone()] });
    a.walkRules((s) => {
      let o2 = (0, wn.default)().astSync(s.selector);
      o2.each((l) => Ms(l, e)), af(o2, (l) => l === e ? `!${l}` : l), s.selector = o2.toString(), s.walkDecls((l) => l.important = true);
    }), r.push([{ ...n, important: true }, a.nodes[0]]);
  }
  return r;
};
var bv = function(t, e, r) {
  var i;
  if (e.length === 0)
    return e;
  let n = { modifier: null, value: mt };
  {
    let [a, ...s] = ee(t, "/");
    if (s.length > 1 && (a = a + "/" + s.slice(0, -1).join("/"), s = s.slice(-1)), s.length && !r.variantMap.has(t) && (t = a, n.modifier = s[0], !G(r.tailwindConfig, "generalizedModifiers")))
      return [];
  }
  if (t.endsWith("]") && !t.startsWith("[")) {
    let a = /(.)(-?)\[(.*)\]/g.exec(t);
    if (a) {
      let [, s, o2, l] = a;
      if (s === "@" && o2 === "-")
        return [];
      if (s !== "@" && o2 === "")
        return [];
      t = t.replace(`${o2}[${l}]`, ""), n.value = l;
    }
  }
  if (Ys(t) && !r.variantMap.has(t)) {
    let a = r.offsets.recordVariant(t), s = z2(t.slice(1, -1)), o2 = ee(s, ",");
    if (o2.length > 1)
      return [];
    if (!o2.every(mn))
      return [];
    let l = o2.map((u, f) => [r.offsets.applyParallelOffset(a, f), lr(u.trim())]);
    r.variantMap.set(t, l);
  }
  if (r.variantMap.has(t)) {
    let a = Ys(t), s = r.variantMap.get(t).slice(), o2 = [];
    for (let [l, u] of e) {
      if (l.layer === "user")
        continue;
      let f = R.root({ nodes: [u.clone()] });
      for (let [p, c2, d] of s) {
        let m = function() {
          h.raws.neededBackup || (h.raws.neededBackup = true, h.walkRules((v) => v.raws.originalSelector = v.selector));
        }, g = function(v) {
          return m(), h.each((O) => {
            O.type === "rule" && (O.selectors = O.selectors.map((x) => v({ get className() {
              return Ws(x);
            }, selector: x })));
          }), h;
        }, h = (d != null ? d : f).clone(), y = [], w = c2({ get container() {
          return m(), h;
        }, separator: r.tailwindConfig.separator, modifySelectors: g, wrap(v) {
          let O = h.nodes;
          h.removeAll(), v.append(O), h.append(v);
        }, format(v) {
          y.push({ format: v, isArbitraryVariant: a });
        }, args: n });
        if (Array.isArray(w)) {
          for (let [v, O] of w.entries())
            s.push([r.offsets.applyParallelOffset(p, v), O, h.clone()]);
          continue;
        }
        if (typeof w == "string" && y.push({ format: w, isArbitraryVariant: a }), w === null)
          continue;
        h.raws.neededBackup && (delete h.raws.neededBackup, h.walkRules((v) => {
          let O = v.raws.originalSelector;
          if (!O || (delete v.raws.originalSelector, O === v.selector))
            return;
          let x = v.selector, A = (0, wn.default)((E) => {
            E.walkClasses((I) => {
              I.value = `${t}${r.tailwindConfig.separator}${I.value}`;
            });
          }).processSync(O);
          y.push({ format: x.replace(A, "&"), isArbitraryVariant: a }), v.selector = O;
        })), h.nodes[0].raws.tailwind = { ...h.nodes[0].raws.tailwind, parentLayer: l.layer };
        let b2 = [{ ...l, sort: r.offsets.applyVariantOffset(l.sort, p, Object.assign(n, r.variantOptions.get(t))), collectedFormats: ((i = l.collectedFormats) != null ? i : []).concat(y) }, h.nodes[0]];
        o2.push(b2);
      }
    }
    return o2;
  }
  return [];
};
var Gs = function(t, e, r = {}) {
  return !X(t) && !Array.isArray(t) ? [[t], r] : Array.isArray(t) ? Gs(t[0], e, t[1]) : (e.has(t) || e.set(t, nt(t)), [e.get(t), r]);
};
var Sv = function(t) {
  return xv.test(t);
};
var kv = function(t) {
  if (!t.includes("://"))
    return false;
  try {
    let e = new URL(t);
    return e.scheme !== "" && e.host !== "";
  } catch {
    return false;
  }
};
var If = function(t) {
  let e = true;
  return t.walkDecls((r) => {
    if (!Rf(r.prop, r.value))
      return e = false, false;
  }), e;
};
var Rf = function(t, e) {
  if (kv(`${t}:${e}`))
    return false;
  try {
    return R.parse(`a{${t}:${e}}`).toResult(), true;
  } catch {
    return false;
  }
};
var Ov = function(t, e) {
  var s;
  let [, r, n] = (s = t.match(/^\[([a-zA-Z0-9-_]+):(\S+)\]$/)) != null ? s : [];
  if (n === undefined || !Sv(r) || !lt2(n))
    return null;
  let i = z2(n);
  return Rf(r, i) ? [[{ sort: e.offsets.arbitraryProperty(), layer: "utilities" }, () => ({ [Fs(t)]: { [r]: i } })]] : null;
};
function* Ev(t, e) {
  e.candidateRuleMap.has(t) && (yield [e.candidateRuleMap.get(t), "DEFAULT"]), yield* function* (o2) {
    o2 !== null && (yield [o2, "DEFAULT"]);
  }(Ov(t, e));
  let r = t, n = false, i = e.tailwindConfig.prefix, a = i.length, s = r.startsWith(i) || r.startsWith(`-${i}`);
  r[a] === "-" && s && (n = true, r = i + r.slice(a + 1)), n && e.candidateRuleMap.has(r) && (yield [e.candidateRuleMap.get(r), "-DEFAULT"]);
  for (let [o2, l] of yv(r))
    e.candidateRuleMap.has(o2) && (yield [e.candidateRuleMap.get(o2), n ? `-${l}` : l]);
}
var Cv = function(t, e) {
  return t === ke ? [ke] : ee(t, e);
};
function* Av(t, e) {
  var r, n;
  for (let i of t)
    i[1].raws.tailwind = { ...i[1].raws.tailwind, classCandidate: e, preserveSource: (n = (r = i[0].options) == null ? undefined : r.preserveSource) != null ? n : false }, yield i;
}
function* bn(t, e, r = t) {
  var o2, l, u, f;
  let n = e.tailwindConfig.separator, [i, ...a] = Cv(t, n).reverse(), s = false;
  if (i.startsWith("!") && (s = true, i = i.slice(1)), G(e.tailwindConfig, "variantGrouping") && i.startsWith("(") && i.endsWith(")")) {
    let p = a.slice().reverse().join(n);
    for (let c2 of ee(i.slice(1, -1), ","))
      yield* bn(p + n + c2, e, r);
  }
  for (let p of Ev(i, e)) {
    let c2 = [], d = new Map, [h, y] = p, m = h.length === 1;
    for (let [g, w] of h) {
      let b2 = [];
      if (typeof w == "function")
        for (let v of [].concat(w(y, { isOnlyPlugin: m }))) {
          let [O, x] = Gs(v, e.postCssNodeCache);
          for (let A of O)
            b2.push([{ ...g, options: { ...g.options, ...x } }, A]);
        }
      else if (y === "DEFAULT" || y === "-DEFAULT") {
        let v = w, [O, x] = Gs(v, e.postCssNodeCache);
        for (let A of O)
          b2.push([{ ...g, options: { ...g.options, ...x } }, A]);
      }
      if (b2.length > 0) {
        let v = Array.from(Ps((l = (o2 = g.options) == null ? undefined : o2.types) != null ? l : [], y, (u = g.options) != null ? u : {}, e.tailwindConfig)).map(([O, x]) => x);
        v.length > 0 && d.set(b2, v), c2.push(b2);
      }
    }
    if (Ys(y)) {
      if (c2.length > 1) {
        let b2 = function(O) {
          return O.length === 1 ? O[0] : O.find((x) => {
            let A = d.get(x);
            return x.some(([{ options: E }, I]) => If(I) ? E.types.some(({ type: F, preferOnConflict: Y }) => A.includes(F) && Y) : false);
          });
        }, [g, w] = c2.reduce((O, x) => (x.some(([{ options: E }]) => E.types.some(({ type: I }) => I === "any")) ? O[0].push(x) : O[1].push(x), O), [[], []]), v = (f = b2(w)) != null ? f : b2(g);
        if (v)
          c2 = [v];
        else {
          let O = c2.map((A) => {
            var E;
            return new Set([...(E = d.get(A)) != null ? E : []]);
          });
          for (let A of O)
            for (let E of A) {
              let I = false;
              for (let F of O)
                A !== F && F.has(E) && (F.delete(E), I = true);
              I && A.delete(E);
            }
          let x = [];
          for (let [A, E] of O.entries())
            for (let I of E) {
              let F = c2[A].map(([, Y]) => Y).flat().map((Y) => Y.toString().split(`
`).slice(1, -1).map((K) => K.trim()).map((K) => `      ${K}`).join(`
`)).join(`

`);
              x.push(`  Use \`${t.replace("[", `[${I}:`)}\` for \`${F.trim()}\``);
              break;
            }
          L.warn([`The class \`${t}\` is ambiguous and matches multiple utilities.`, ...x, `If this is content and not a class, replace it with \`${t.replace("[", "&lsqb;").replace("]", "&rsqb;")}\` to silence this warning.`]);
          continue;
        }
      }
      c2 = c2.map((g) => g.filter((w) => If(w[1])));
    }
    c2 = c2.flat(), c2 = Array.from(Av(c2, i)), c2 = vv(c2, e), s && (c2 = wv(c2, i));
    for (let g of a)
      c2 = bv(g, c2, e);
    for (let g of c2)
      g[1].raws.tailwind = { ...g[1].raws.tailwind, candidate: t }, g = _v(g, { context: e, candidate: t, original: r }), g !== null && (yield g);
  }
}
var _v = function(t, { context: e, candidate: r, original: n }) {
  if (!t[0].collectedFormats)
    return t;
  let i = true, a;
  try {
    a = ot(t[0].collectedFormats, { context: e, candidate: r });
  } catch {
    return null;
  }
  let s = R.root({ nodes: [t[1].clone()] });
  return s.walkRules((o2) => {
    if (!vn(o2))
      try {
        o2.selector = on(o2.selector, a, { candidate: n, context: e });
      } catch {
        return i = false, false;
      }
  }), i ? (t[1] = s.nodes[0], t) : null;
};
var vn = function(t) {
  return t.parent && t.parent.type === "atrule" && t.parent.name === "keyframes";
};
var Tv = function(t) {
  if (t === true)
    return (e) => {
      vn(e) || e.walkDecls((r) => {
        r.parent.type === "rule" && !vn(r.parent) && (r.important = true);
      });
    };
  if (typeof t == "string")
    return (e) => {
      vn(e) || (e.selectors = e.selectors.map((r) => yn(r, t)));
    };
};
var gn = function(t, e) {
  var i;
  let r = [], n = Tv(e.tailwindConfig.important);
  for (let a of t) {
    if (e.notClassCache.has(a))
      continue;
    if (e.candidateRuleCache.has(a)) {
      r = r.concat(Array.from(e.candidateRuleCache.get(a)));
      continue;
    }
    let s = Array.from(bn(a, e));
    if (s.length === 0) {
      e.notClassCache.add(a);
      continue;
    }
    e.classCache.set(a, s);
    let o2 = (i = e.candidateRuleCache.get(a)) != null ? i : new Set;
    e.candidateRuleCache.set(a, o2);
    for (let l of s) {
      let [{ sort: u, options: f }, p] = l;
      if (f.respectImportant && n) {
        let d = R.root({ nodes: [p.clone()] });
        d.walkRules(n), p = d.nodes[0];
      }
      let c2 = [u, p];
      o2.add(c2), e.ruleCache.add(c2), r.push(c2);
    }
  }
  return r;
};
var Ys = function(t) {
  return t.startsWith("[") && t.endsWith("]");
};
var Ge = function(t, e = undefined, r = undefined) {
  return t.map((n) => {
    var s;
    let i = n.clone(), a = ((s = n.raws.tailwind) == null ? undefined : s.preserveSource) !== true || !i.source;
    return e !== undefined && a && (i.source = e, ("walk" in i) && i.walk((o2) => {
      o2.source = e;
    })), r !== undefined && (i.raws.tailwind = { ...i.raws.tailwind, ...r }), i;
  });
};
var xn = function(t) {
  return t = Array.isArray(t) ? t : [t], t = t.map((e) => e instanceof RegExp ? e.source : e), t.join("");
};
var ce = function(t) {
  return new RegExp(xn(t), "g");
};
var ut = function(t) {
  return `(?:${t.map(xn).join("|")})`;
};
var Hs = function(t) {
  return `(?:${xn(t)})?`;
};
var Mf = function(t) {
  return `(?:${xn(t)})*`;
};
var Ff = function(t) {
  return t && Pv.test(t) ? t.replace(Df, "\\$&") : t || "";
};
var Lf = function(t) {
  let e = Array.from(Rv(t));
  return (r) => {
    var i;
    let n = [];
    for (let a of e)
      n = [...n, ...(i = r.match(a)) != null ? i : []];
    return n.filter((a) => a !== undefined).map(Fv);
  };
};
function* Rv(t) {
  let e = t.tailwindConfig.separator, r = G(t.tailwindConfig, "variantGrouping"), n = t.tailwindConfig.prefix !== "" ? Hs(ce([/-?/, Ff(t.tailwindConfig.prefix)])) : "", i = ut([/\[[^\s:'"`]+:[^\s\[\]]+\]/, /\[[^\s:'"`]+:[^\s]+?\[[^\s]+\][^\s]+?\]/, ce([/-?(?:\w+)/, Hs(ut([ce([/-(?:\w+-)*\[[^\s:]+\]/, /(?![{([]])/, /(?:\/[^\s'"`\\><$]*)?/]), ce([/-(?:\w+-)*\[[^\s]+\]/, /(?![{([]])/, /(?:\/[^\s'"`\\$]*)?/]), /[-\/][^\s'"`\\$={><]*/]))])]), a = [ut([ce([/@\[[^\s"'`]+\](\/[^\s"'`]+)?/, e]), ce([/([^\s"'`\[\\]+-)?\[[^\s"'`]+\]/, e]), ce([/[^\s"'`\[\\]+/, e])]), ut([ce([/([^\s"'`\[\\]+-)?\[[^\s`]+\]/, e]), ce([/[^\s`\[\\]+/, e])])];
  for (let s of a)
    yield ce(["((?=((", s, ")+))\\2)?", /!?/, n, r ? ut([ce([/\(/, i, Mf([/,/, i]), /\)/]), i]) : i]);
  yield /[^<>"'`\s.(){}[\]#=%$]*[^<>"'`\s.(){}[\]#=%:$]/g;
}
var Fv = function(t) {
  if (!t.includes("-["))
    return t;
  let e = 0, r = [], n = t.matchAll(Dv);
  n = Array.from(n).flatMap((i) => {
    let [, ...a] = i;
    return a.map((s, o2) => Object.assign([], i, { index: i.index + o2, 0: s }));
  });
  for (let i of n) {
    let a = i[0], s = r[r.length - 1];
    if (a === s ? r.pop() : (a === "'" || a === '"' || a === "`") && r.push(a), !s) {
      if (a === "[") {
        e++;
        continue;
      } else if (a === "]") {
        e--;
        continue;
      }
      if (e < 0)
        return t.substring(0, i.index - 1);
      if (e === 0 && !Mv.test(a))
        return t.substring(0, i.index);
    }
  }
  return t;
};
var Lv = function(t, e) {
  let r = t.tailwindConfig.content.extract;
  return r[e] || r.DEFAULT || Nf[e] || Nf.DEFAULT(t);
};
var Nv = function(t, e) {
  let r = t.content.transform;
  return r[e] || r.DEFAULT || qf[e] || qf.DEFAULT;
};
var qv = function(t, e, r, n) {
  ur.has(e) || ur.set(e, new $f.default({ maxSize: 25000 }));
  for (let i of t.split(`
`))
    if (i = i.trim(), !n.has(i))
      if (n.add(i), ur.get(e).has(i))
        for (let a of ur.get(e).get(i))
          r.add(a);
      else {
        let a = e(i).filter((o2) => o2 !== "!*"), s = new Set(a);
        for (let o2 of s)
          r.add(o2);
        ur.get(e).set(i, s);
      }
};
var $v = function(t, e) {
  let r = e.offsets.sort(t), n = { base: new Set, defaults: new Set, components: new Set, utilities: new Set, variants: new Set };
  for (let [i, a] of r)
    n[i.layer].add(a);
  return n;
};
var Qs = function(t) {
  return (e) => {
    var h;
    let r = { base: null, components: null, utilities: null, variants: null };
    if (e.walkAtRules((y) => {
      y.name === "tailwind" && Object.keys(r).includes(y.params) && (r[y.params] = y);
    }), Object.values(r).every((y) => y === null))
      return e;
    let n = new Set([...(h = t.candidates) != null ? h : [], ke]), i = new Set;
    Ae.DEBUG && console.time("Reading changed files");
    for (let { file: y, content: m, extension: g } of t.changedContent) {
      let w = Nv(t.tailwindConfig, g), b2 = Lv(t, g);
      m = y ? ht.readFileSync(y, "utf8") : m, qv(w(m), b2, n, i);
    }
    Ae.DEBUG && console.timeEnd("Reading changed files");
    let a = t.classCache.size;
    Ae.DEBUG && console.time("Generate rules"), Ae.DEBUG && console.time("Sorting candidates");
    let s = new Set([...n].sort((y, m) => y === m ? 0 : y < m ? -1 : 1));
    Ae.DEBUG && console.timeEnd("Sorting candidates"), gn(s, t), Ae.DEBUG && console.timeEnd("Generate rules"), Ae.DEBUG && console.time("Build stylesheet"), (t.stylesheetCache === null || t.classCache.size !== a) && (t.stylesheetCache = $v([...t.ruleCache], t)), Ae.DEBUG && console.timeEnd("Build stylesheet");
    let { defaults: o2, base: l, components: u, utilities: f, variants: p } = t.stylesheetCache;
    r.base && (r.base.before(Ge([...l, ...o2], r.base.source, { layer: "base" })), r.base.remove()), r.components && (r.components.before(Ge([...u], r.components.source, { layer: "components" })), r.components.remove()), r.utilities && (r.utilities.before(Ge([...f], r.utilities.source, { layer: "utilities" })), r.utilities.remove());
    let c2 = Array.from(p).filter((y) => {
      var g;
      let m = (g = y.raws.tailwind) == null ? undefined : g.parentLayer;
      return m === "components" ? r.components !== null : m === "utilities" ? r.utilities !== null : true;
    });
    r.variants ? (r.variants.before(Ge(c2, r.variants.source, { layer: "variants" })), r.variants.remove()) : c2.length > 0 && e.append(Ge(c2, e.source, { layer: "variants" }));
    let d = c2.some((y) => {
      var m;
      return ((m = y.raws.tailwind) == null ? undefined : m.parentLayer) === "utilities";
    });
    r.utilities && f.size === 0 && !d && L.warn("content-problems", ["No utility classes were detected in your source files. If this is unexpected, double-check the `content` option in your Tailwind CSS configuration.", "https://tailwindcss.com/docs/content-configuration"]), Ae.DEBUG && (console.log("Potential classes: ", n.size), console.log("Active contexts: ", Wn.size)), t.changedContent = [], e.walkAtRules("layer", (y) => {
      Object.keys(r).includes(y.params) && y.remove();
    });
  };
};
var Sn = function(t) {
  let e = new Map;
  R.root({ nodes: [t.clone()] }).walkRules((a) => {
    (0, kn.default)((s) => {
      s.walkClasses((o2) => {
        let l = o2.parent.toString(), u = e.get(l);
        u || e.set(l, u = new Set), u.add(o2.value);
      });
    }).processSync(a.selector);
  });
  let n = Array.from(e.values(), (a) => Array.from(a)), i = n.flat();
  return Object.assign(i, { groups: n });
};
var Js = function(t) {
  return Uv.astSync(t);
};
var Uf = function(t, e) {
  let r = new Set;
  for (let n of t)
    r.add(n.split(e).pop());
  return Array.from(r);
};
var jf = function(t, e) {
  let r = t.tailwindConfig.prefix;
  return typeof r == "function" ? r(e) : r + e;
};
function* Vf(t) {
  for (yield t;t.parent; )
    yield t.parent, t = t.parent;
}
var jv = function(t, e = {}) {
  let r = t.nodes;
  t.nodes = [];
  let n = t.clone(e);
  return t.nodes = r, n;
};
var zv = function(t) {
  for (let e of Vf(t))
    if (t !== e) {
      if (e.type === "root")
        break;
      t = jv(e, { nodes: [t] });
    }
  return t;
};
var Vv = function(t, e) {
  let r = new Map;
  return t.walkRules((n) => {
    var s;
    for (let o2 of Vf(n))
      if (((s = o2.raws.tailwind) == null ? undefined : s.layer) !== undefined)
        return;
    let i = zv(n), a = e.offsets.create("user");
    for (let o2 of Sn(n)) {
      let l = r.get(o2) || [];
      r.set(o2, l), l.push([{ layer: "user", sort: a, important: false }, i]);
    }
  }), r;
};
var Wv = function(t, e) {
  for (let r of t) {
    if (e.notClassCache.has(r) || e.applyClassCache.has(r))
      continue;
    if (e.classCache.has(r)) {
      e.applyClassCache.set(r, e.classCache.get(r).map(([i, a]) => [i, a.clone()]));
      continue;
    }
    let n = Array.from(bn(r, e));
    if (n.length === 0) {
      e.notClassCache.add(r);
      continue;
    }
    e.applyClassCache.set(r, n);
  }
  return e.applyClassCache;
};
var Bv = function(t) {
  let e = null;
  return { get: (r) => (e = e || t(), e.get(r)), has: (r) => (e = e || t(), e.has(r)) };
};
var Gv = function(t) {
  return { get: (e) => t.flatMap((r) => r.get(e) || []), has: (e) => t.some((r) => r.has(e)) };
};
var zf = function(t) {
  let e = t.split(/[\s\t\n]+/g);
  return e[e.length - 1] === "!important" ? [e.slice(0, -1), true] : [e, false];
};
var Wf = function(t, e, r) {
  let n = new Set, i = [];
  if (t.walkAtRules("apply", (l) => {
    let [u] = zf(l.params);
    for (let f of u)
      n.add(f);
    i.push(l);
  }), i.length === 0)
    return;
  let a = Gv([r, Wv(n, e)]);
  function s(l, u, f) {
    let p = Js(l), c2 = Js(u), h = Js(`.${re(f)}`).nodes[0].nodes[0];
    return p.each((y) => {
      let m = new Set;
      c2.each((g) => {
        let w = false;
        g = g.clone(), g.walkClasses((b2) => {
          b2.value === h.value && (w || (b2.replaceWith(...y.nodes.map((v) => v.clone())), m.add(g), w = true));
        });
      });
      for (let g of m) {
        let w = [[]];
        for (let b2 of g.nodes)
          b2.type === "combinator" ? (w.push(b2), w.push([])) : w[w.length - 1].push(b2);
        g.nodes = [];
        for (let b2 of w)
          Array.isArray(b2) && b2.sort((v, O) => v.type === "tag" && O.type === "class" ? -1 : v.type === "class" && O.type === "tag" ? 1 : v.type === "class" && O.type === "pseudo" && O.value.startsWith("::") ? -1 : v.type === "pseudo" && v.value.startsWith("::") && O.type === "class" ? 1 : 0), g.nodes = g.nodes.concat(b2);
      }
      y.replaceWith(...m);
    }), p.toString();
  }
  let o2 = new Map;
  for (let l of i) {
    let [u] = o2.get(l.parent) || [[], l.source];
    o2.set(l.parent, [u, l.source]);
    let [f, p] = zf(l.params);
    if (l.parent.type === "atrule") {
      if (l.parent.name === "screen") {
        let c2 = l.parent.params;
        throw l.error(`@apply is not supported within nested at-rules like @screen. We suggest you write this as @apply ${f.map((d) => `${c2}:${d}`).join(" ")} instead.`);
      }
      throw l.error(`@apply is not supported within nested at-rules like @${l.parent.name}. You can fix this by un-nesting @${l.parent.name}.`);
    }
    for (let c2 of f) {
      if ([jf(e, "group"), jf(e, "peer")].includes(c2))
        throw l.error(`@apply should not be used with the '${c2}' utility`);
      if (!a.has(c2))
        throw l.error(`The \`${c2}\` class does not exist. If \`${c2}\` is a custom class, make sure it is defined within a \`@layer\` directive.`);
      let d = a.get(c2);
      u.push([c2, p, d]);
    }
  }
  for (let [l, [u, f]] of o2) {
    let p = [];
    for (let [d, h, y] of u) {
      let m = [d, ...Uf([d], e.tailwindConfig.separator)];
      for (let [g, w] of y) {
        let b2 = Sn(l), v = Sn(w);
        if (v = v.groups.filter((E) => E.some((I) => m.includes(I))).flat(), v = v.concat(Uf(v, e.tailwindConfig.separator)), b2.some((E) => v.includes(E)))
          throw w.error(`You cannot \`@apply\` the \`${d}\` utility here because it creates a circular dependency.`);
        let x = R.root({ nodes: [w.clone()] });
        x.walk((E) => {
          E.source = f;
        }), (w.type !== "atrule" || w.type === "atrule" && w.name !== "keyframes") && x.walkRules((E) => {
          if (!Sn(E).some((B) => B === d)) {
            E.remove();
            return;
          }
          let I = typeof e.tailwindConfig.important == "string" ? e.tailwindConfig.important : null, Y = l.raws.tailwind !== undefined && I && l.selector.indexOf(I) === 0 ? l.selector.slice(I.length) : l.selector;
          E.selector = s(Y, E.selector, d), I && Y !== l.selector && (E.selector = yn(E.selector, I)), E.walkDecls((B) => {
            B.important = g.important || h;
          });
          let K = (0, kn.default)().astSync(E.selector);
          K.each((B) => at(B)), E.selector = K.toString();
        }), x.nodes[0] && p.push([g.sort, x.nodes[0]]);
      }
    }
    let c2 = e.offsets.sort(p).map((d) => d[1]);
    l.after(c2);
  }
  for (let l of i)
    l.parent.nodes.length > 1 ? l.remove() : l.parent.remove();
  Wf(t, e, r);
};
var Xs = function(t) {
  return (e) => {
    let r = Bv(() => Vv(e, t));
    Wf(e, t, r);
  };
};
var sa = function(t) {
  return typeof t == "object" && t !== null;
};
var tw = function(t, e) {
  let r = Le(e);
  do
    if (r.pop(), (0, fr.default)(t, r) !== undefined)
      break;
  while (r.length);
  return r.length ? r : undefined;
};
var ct = function(t) {
  return typeof t == "string" ? t : t.reduce((e, r, n) => r.includes(".") ? `${e}[${r}]` : n === 0 ? r : `${e}.${r}`, "");
};
var lc = function(t) {
  return t.map((e) => `'${e}'`).join(", ");
};
var ac = function(t) {
  return lc(Object.keys(t));
};
var aa = function(t, e, r, n = {}) {
  let i = Array.isArray(e) ? ct(e) : e.replace(/^['"]+|['"]+$/g, ""), a = Array.isArray(e) ? e : Le(i), s = (0, fr.default)(t.theme, a, r);
  if (s === undefined) {
    let l = `'${i}' does not exist in your theme config.`, u = a.slice(0, -1), f = (0, fr.default)(t.theme, u);
    if (sa(f)) {
      let p = Object.keys(f).filter((d) => aa(t, [...u, d]).isValid), c2 = (0, oc.default)(a[a.length - 1], p);
      c2 ? l += ` Did you mean '${ct([...u, c2])}'?` : p.length > 0 && (l += ` '${ct(u)}' has the following valid keys: ${lc(p)}`);
    } else {
      let p = tw(t.theme, i);
      if (p) {
        let c2 = (0, fr.default)(t.theme, p);
        sa(c2) ? l += ` '${ct(p)}' has the following keys: ${ac(c2)}` : l += ` '${ct(p)}' is not an object.`;
      } else
        l += ` Your theme has the following top-level keys: ${ac(t.theme)}`;
    }
    return { isValid: false, error: l };
  }
  if (!(typeof s == "string" || typeof s == "number" || typeof s == "function" || s instanceof String || s instanceof Number || Array.isArray(s))) {
    let l = `'${i}' was found but does not resolve to a string.`;
    if (sa(s)) {
      let u = Object.keys(s).filter((f) => aa(t, [...a, f]).isValid);
      u.length && (l += ` Did you mean something like '${ct([...a, u[0]])}'?`);
    }
    return { isValid: false, error: l };
  }
  let [o2] = a;
  return { isValid: true, value: Ce(o2)(s, n) };
};
var rw = function(t, e, r) {
  e = e.map((i) => uc(t, i, r));
  let n = [""];
  for (let i of e)
    i.type === "div" && i.value === "," ? n.push("") : n[n.length - 1] += oa.default.stringify(i);
  return n;
};
var uc = function(t, e, r) {
  if (e.type === "function" && r[e.value] !== undefined) {
    let n = rw(t, e.nodes, r);
    e.type = "word", e.value = r[e.value](t, ...n);
  }
  return e;
};
var nw = function(t, e, r) {
  return (0, oa.default)(e).walk((n) => {
    uc(t, n, r);
  }).toString();
};
function* sw(t) {
  t = t.replace(/^['"]+|['"]+$/g, "");
  let e = t.match(/^([^\s]+)(?![^\[]*\])(?:\s*\/\s*([^\/\s]+))$/), r;
  yield [t, undefined], e && (t = e[1], r = e[2], yield [t, r]);
}
var aw = function(t, e, r) {
  var i;
  let n = Array.from(sw(e)).map(([a, s]) => Object.assign(aa(t, a, r, { opacityValue: s }), { resolvedPath: a, alpha: s }));
  return (i = n.find((a) => a.isValid)) != null ? i : n[0];
};
var fc = function(t) {
  let e = t.tailwindConfig, r = { theme: (n, i, ...a) => {
    var c2;
    let { isValid: s, value: o2, error: l, alpha: u } = aw(e, i, a.length ? a : undefined);
    if (!s) {
      let d = n.parent, h = (c2 = d == null ? undefined : d.raws.tailwind) == null ? undefined : c2.candidate;
      if (d && h !== undefined) {
        t.markInvalidUtilityNode(d), d.remove(), L.warn("invalid-theme-key-in-class", [`The utility \`${h}\` contains an invalid theme value and was not generated.`]);
        return;
      }
      throw n.error(l);
    }
    let f = st(o2);
    return (u !== undefined || f !== undefined && typeof f == "function") && (u === undefined && (u = 1), o2 = we(f, u, f)), o2;
  }, screen: (n, i) => {
    i = i.replace(/^['"]+/g, "").replace(/['"]+$/g, "");
    let s = Fe(e.theme.screens).find(({ name: o2 }) => o2 === i);
    if (!s)
      throw n.error(`The '${i}' screen does not exist in your theme.`);
    return Me(s);
  } };
  return (n) => {
    n.walk((i) => {
      let a = iw[i.type];
      a !== undefined && (i[a] = nw(i, i[a], r));
    });
  };
};
var cc = function({ tailwindConfig: { theme: t } }) {
  return function(e) {
    e.walkAtRules("screen", (r) => {
      let n = r.params, a = Fe(t.screens).find(({ name: s }) => s === n);
      if (!a)
        throw r.error(`No \`${n}\` screen found.`);
      r.name = "media", r.params = Me(a);
    });
  };
};
var ow = function(t) {
  let e = t.filter((o2) => o2.type !== "pseudo" || o2.nodes.length > 0 ? true : o2.value.startsWith("::") || [":before", ":after", ":first-line", ":first-letter"].includes(o2.value)).reverse(), r = new Set(["tag", "class", "id", "attribute"]), n = e.findIndex((o2) => r.has(o2.type));
  if (n === -1)
    return e.reverse().join("").trim();
  let i = e[n], a = pc[i.type] ? pc[i.type](i) : i;
  e = e.slice(0, n);
  let s = e.findIndex((o2) => o2.type === "combinator" && o2.value === ">");
  return s !== -1 && (e.splice(0, s), e.unshift(Tn.default.universal())), [a, ...e.reverse()].join("").trim();
};
var uw = function(t) {
  return la.has(t) || la.set(t, lw.transformSync(t)), la.get(t);
};
var ua = function({ tailwindConfig: t }) {
  return (e) => {
    var i, a;
    let r = new Map, n = new Set;
    if (e.walkAtRules("defaults", (s) => {
      if (s.nodes && s.nodes.length > 0) {
        n.add(s);
        return;
      }
      let o2 = s.params;
      r.has(o2) || r.set(o2, new Set), r.get(o2).add(s.parent), s.remove();
    }), G(t, "optimizeUniversalDefaults"))
      for (let s of n) {
        let o2 = new Map, l = (i = r.get(s.params)) != null ? i : [];
        for (let u of l)
          for (let f of uw(u.selector)) {
            let p = f.includes(":-") || f.includes("::-") ? f : "__DEFAULT__", c2 = (a = o2.get(p)) != null ? a : new Set;
            o2.set(p, c2), c2.add(f);
          }
        if (G(t, "optimizeUniversalDefaults")) {
          if (o2.size === 0) {
            s.remove();
            continue;
          }
          for (let [, u] of o2) {
            let f = R.rule({ source: s.source });
            f.selectors = [...u], f.append(s.nodes.map((p) => p.clone())), s.before(f);
          }
        }
        s.remove();
      }
    else if (n.size) {
      let s = R.rule({ selectors: ["*", "::before", "::after"] });
      for (let l of n)
        s.append(l.nodes), s.parent || l.before(s), s.source || (s.source = l.source), l.remove();
      let o2 = s.clone({ selectors: ["::backdrop"] });
      s.after(o2);
    }
  };
};
var fa = function() {
  function t(e) {
    let r = null;
    e.each((n) => {
      if (!fw.has(n.type)) {
        r = null;
        return;
      }
      if (r === null) {
        r = n;
        return;
      }
      let i = dc[n.type];
      n.type === "atrule" && n.name === "font-face" ? r = n : i.every((a) => {
        var s, o2;
        return ((s = n[a]) != null ? s : "").replace(/\s+/g, " ") === ((o2 = r[a]) != null ? o2 : "").replace(/\s+/g, " ");
      }) ? (n.nodes && r.append(n.nodes), n.remove()) : r = n;
    }), e.each((n) => {
      n.type === "atrule" && t(n);
    });
  }
  return (e) => {
    t(e);
  };
};
var ca = function() {
  return (t) => {
    t.walkRules((e) => {
      let r = new Map, n = new Set([]), i = new Map;
      e.walkDecls((a) => {
        if (a.parent === e) {
          if (r.has(a.prop)) {
            if (r.get(a.prop).value === a.value) {
              n.add(r.get(a.prop)), r.set(a.prop, a);
              return;
            }
            i.has(a.prop) || i.set(a.prop, new Set), i.get(a.prop).add(r.get(a.prop)), i.get(a.prop).add(a);
          }
          r.set(a.prop, a);
        }
      });
      for (let a of n)
        a.remove();
      for (let a of i.values()) {
        let s = new Map;
        for (let o2 of a) {
          let l = pw(o2.value);
          l !== null && (s.has(l) || s.set(l, new Set), s.get(l).add(o2));
        }
        for (let o2 of s.values()) {
          let l = Array.from(o2).slice(0, -1);
          for (let u of l)
            u.remove();
        }
      }
    });
  };
};
var pw = function(t) {
  var r;
  let e = /^-?\d*.?\d+([\w%]+)?$/g.exec(t);
  return e ? (r = e[1]) != null ? r : cw : null;
};
var dw = function(t) {
  if (!t.walkAtRules)
    return;
  let e = new Set;
  if (t.walkAtRules("apply", (r) => {
    e.add(r.parent);
  }), e.size !== 0)
    for (let r of e) {
      let n = [], i = [];
      for (let a of r.nodes)
        a.type === "atrule" && a.name === "apply" ? (i.length > 0 && (n.push(i), i = []), n.push([a])) : i.push(a);
      if (i.length > 0 && n.push(i), n.length !== 1) {
        for (let a of [...n].reverse()) {
          let s = r.clone({ nodes: [] });
          s.append(a), r.after(s);
        }
        r.remove();
      }
    }
};
var Pn = function() {
  return (t) => {
    dw(t);
  };
};
var hw = function(t) {
  return t.type === "root";
};
var mw = function(t) {
  return t.type === "atrule" && t.name === "layer";
};
var hc = function(t) {
  return (e, r) => {
    let n = false;
    e.walkAtRules("tailwind", (i) => {
      if (n)
        return false;
      if (i.parent && !(hw(i.parent) || mw(i.parent)))
        return n = true, i.warn(r, ["Nested @tailwind rules were detected, but are not supported.", "Consider using a prefix to scope Tailwind's classes: https://tailwindcss.com/docs/configuration#prefix", "Alternatively, use the important selector strategy: https://tailwindcss.com/docs/configuration#selector-strategy"].join(`
`)), false;
    }), e.walkRules((i) => {
      if (n)
        return false;
      i.walkRules((a) => (n = true, a.warn(r, ["Nested CSS was detected, but CSS nesting has not been configured correctly.", "Please enable a CSS nesting plugin *before* Tailwind in your configuration.", "See how here: https://tailwindcss.com/docs/using-with-preprocessors#nesting"].join(`
`)), false));
    });
  };
};
var pa = function(t) {
  return function(e, r) {
    let { tailwindDirectives: n, applyDirectives: i } = Un(e);
    hc()(e, r), Pn()(e, r);
    let a = t({ tailwindDirectives: n, applyDirectives: i, registerDependency(s) {
      r.messages.push({ plugin: "tailwindcss", parent: r.opts.from, ...s });
    }, createContext(s, o2) {
      return Pf(s, o2, e);
    } })(e, r);
    if (a.tailwindConfig.separator === "-")
      throw new Error("The '-' character cannot be used as a custom separator in JIT mode due to parsing ambiguity. Please use another character like '_' instead.");
    nf(a.tailwindConfig), Qs(a)(e, r), Pn()(e, r), Xs(a)(e, r), fc(a)(e, r), cc(a)(e, r), ua(a)(e, r), fa(a)(e, r), ca(a)(e, r);
  };
};
var gc = function(t, e) {
  return t === undefined ? e : Array.isArray(t) ? t : [...new Set(e.filter((n) => t !== false && t[n] !== false).concat(Object.keys(t).filter((n) => t[n] !== false)))];
};
var cr = function({ version: t, from: e, to: r }) {
  L.warn(`${e}-color-renamed`, [`As of Tailwind CSS ${t}, \`${e}\` has been renamed to \`${r}\`.`, "Update your configuration file to silence this warning."]);
};
var da = function(t, ...e) {
  var r, n;
  for (let i of e) {
    for (let a in i)
      (r = t == null ? undefined : t.hasOwnProperty) != null && r.call(t, a) || (t[a] = i[a]);
    for (let a of Object.getOwnPropertySymbols(i))
      (n = t == null ? undefined : t.hasOwnProperty) != null && n.call(t, a) || (t[a] = i[a]);
  }
  return t;
};
var vc = function(t) {
  var r;
  (() => {
    if (t.purge || !t.content || !Array.isArray(t.content) && !(typeof t.content == "object" && t.content !== null))
      return false;
    if (Array.isArray(t.content))
      return t.content.every((n) => typeof n == "string" ? true : !(typeof (n == null ? undefined : n.raw) != "string" || (n == null ? undefined : n.extension) && typeof (n == null ? undefined : n.extension) != "string"));
    if (typeof t.content == "object" && t.content !== null) {
      if (Object.keys(t.content).some((n) => !["files", "relative", "extract", "transform"].includes(n)))
        return false;
      if (Array.isArray(t.content.files)) {
        if (!t.content.files.every((n) => typeof n == "string" ? true : !(typeof (n == null ? undefined : n.raw) != "string" || (n == null ? undefined : n.extension) && typeof (n == null ? undefined : n.extension) != "string")))
          return false;
        if (typeof t.content.extract == "object") {
          for (let n of Object.values(t.content.extract))
            if (typeof n != "function")
              return false;
        } else if (!(t.content.extract === undefined || typeof t.content.extract == "function"))
          return false;
        if (typeof t.content.transform == "object") {
          for (let n of Object.values(t.content.transform))
            if (typeof n != "function")
              return false;
        } else if (!(t.content.transform === undefined || typeof t.content.transform == "function"))
          return false;
        if (typeof t.content.relative != "boolean" && typeof t.content.relative < "u")
          return false;
      }
      return true;
    }
    return false;
  })() || L.warn("purge-deprecation", ["The `purge`/`content` options have changed in Tailwind CSS v3.0.", "Update your configuration file to eliminate this warning.", "https://tailwindcss.com/docs/upgrade-guide#configure-content-sources"]), t.safelist = (() => {
    var s;
    let { content: n, purge: i, safelist: a } = t;
    return Array.isArray(a) ? a : Array.isArray(n == null ? undefined : n.safelist) ? n.safelist : Array.isArray(i == null ? undefined : i.safelist) ? i.safelist : Array.isArray((s = i == null ? undefined : i.options) == null ? undefined : s.safelist) ? i.options.safelist : [];
  })(), t.blocklist = (() => {
    let { blocklist: n } = t;
    if (Array.isArray(n)) {
      if (n.every((i) => typeof i == "string"))
        return n;
      L.warn("blocklist-invalid", ["The `blocklist` option must be an array of strings.", "https://tailwindcss.com/docs/content-configuration#discarding-classes"]);
    }
    return [];
  })(), typeof t.prefix == "function" ? (L.warn("prefix-function", ["As of Tailwind CSS v3.0, `prefix` cannot be a function.", "Update `prefix` in your configuration to be a string to eliminate this warning.", "https://tailwindcss.com/docs/upgrade-guide#prefix-cannot-be-a-function"]), t.prefix = "") : t.prefix = (r = t.prefix) != null ? r : "", t.content = { relative: (() => {
    let { content: n } = t;
    return n != null && n.relative ? n.relative : G(t, "relativeContentPathsByDefault");
  })(), files: (() => {
    let { content: n, purge: i } = t;
    return Array.isArray(i) ? i : Array.isArray(i == null ? undefined : i.content) ? i.content : Array.isArray(n) ? n : Array.isArray(n == null ? undefined : n.content) ? n.content : Array.isArray(n == null ? undefined : n.files) ? n.files : [];
  })(), extract: (() => {
    let n = (() => {
      var s, o2, l, u, f, p, c2, d, h, y;
      return (s = t.purge) != null && s.extract ? t.purge.extract : (o2 = t.content) != null && o2.extract ? t.content.extract : (u = (l = t.purge) == null ? undefined : l.extract) != null && u.DEFAULT ? t.purge.extract.DEFAULT : (p = (f = t.content) == null ? undefined : f.extract) != null && p.DEFAULT ? t.content.extract.DEFAULT : (d = (c2 = t.purge) == null ? undefined : c2.options) != null && d.extractors ? t.purge.options.extractors : (y = (h = t.content) == null ? undefined : h.options) != null && y.extractors ? t.content.options.extractors : {};
    })(), i = {}, a = (() => {
      var s, o2, l, u;
      if ((o2 = (s = t.purge) == null ? undefined : s.options) != null && o2.defaultExtractor)
        return t.purge.options.defaultExtractor;
      if ((u = (l = t.content) == null ? undefined : l.options) != null && u.defaultExtractor)
        return t.content.options.defaultExtractor;
    })();
    if (a !== undefined && (i.DEFAULT = a), typeof n == "function")
      i.DEFAULT = n;
    else if (Array.isArray(n))
      for (let { extensions: s, extractor: o2 } of n != null ? n : [])
        for (let l of s)
          i[l] = o2;
    else
      typeof n == "object" && n !== null && Object.assign(i, n);
    return i;
  })(), transform: (() => {
    let n = (() => {
      var a, s, o2, l, u, f;
      return (a = t.purge) != null && a.transform ? t.purge.transform : (s = t.content) != null && s.transform ? t.content.transform : (l = (o2 = t.purge) == null ? undefined : o2.transform) != null && l.DEFAULT ? t.purge.transform.DEFAULT : (f = (u = t.content) == null ? undefined : u.transform) != null && f.DEFAULT ? t.content.transform.DEFAULT : {};
    })(), i = {};
    return typeof n == "function" && (i.DEFAULT = n), typeof n == "object" && n !== null && Object.assign(i, n), i;
  })() };
  for (let n of t.content.files)
    if (typeof n == "string" && /{([^,]*?)}/g.test(n)) {
      L.warn("invalid-glob-braces", [`The glob pattern ${n} in your Tailwind CSS configuration is invalid.`, `Update it to ${n.replace(/{([^,]*?)}/g, "$1")} to silence this warning.`]);
      break;
    }
  return t;
};
var In = function(t) {
  return Array.isArray(t) ? t.map((e) => In(e)) : typeof t == "object" && t !== null ? Object.fromEntries(Object.entries(t).map(([e, r]) => [e, In(r)])) : t;
};
var pt = function(t) {
  return typeof t == "function";
};
var pr = function(t, ...e) {
  let r = e.pop();
  for (let n of e)
    for (let i in n) {
      let a = r(t[i], n[i]);
      a === undefined ? X(t[i]) && X(n[i]) ? t[i] = pr({}, t[i], n[i], r) : t[i] = n[i] : t[i] = a;
    }
  return t;
};
var gw = function(t, ...e) {
  return pt(t) ? t(...e) : t;
};
var yw = function(t) {
  return t.reduce((e, { extend: r }) => pr(e, r, (n, i) => n === undefined ? [i] : Array.isArray(n) ? [i, ...n] : [i, n]), {});
};
var vw = function(t) {
  return { ...t.reduce((e, r) => da(e, r), {}), extend: yw(t) };
};
var wc = function(t, e) {
  if (Array.isArray(t) && X(t[0]))
    return t.concat(e);
  if (Array.isArray(e) && X(e[0]) && X(t))
    return [t, ...e];
  if (Array.isArray(e))
    return e;
};
var ww = function({ extend: t, ...e }) {
  return pr(e, t, (r, n) => !pt(r) && !n.some(pt) ? pr({}, r, ...n, wc) : (i, a) => pr({}, ...[r, ...n].map((s) => gw(s, i, a)), wc));
};
function* bw(t) {
  let e = Le(t);
  if (e.length === 0 || (yield e, Array.isArray(t)))
    return;
  let r = /^(.*?)\s*\/\s*([^/]+)$/, n = t.match(r);
  if (n !== null) {
    let [, i, a] = n, s = Le(i);
    s.alpha = a, yield s;
  }
}
var xw = function(t) {
  let e = (r, n) => {
    for (let i of bw(r)) {
      let a = 0, s = t;
      for (;s != null && a < i.length; )
        s = s[i[a++]], s = pt(s) && (i.alpha === undefined || a <= i.length - 1) ? s(e, ha) : s;
      if (s !== undefined) {
        if (i.alpha !== undefined) {
          let o2 = st(s);
          return we(o2, i.alpha, M(o2));
        }
        return X(s) ? In(s) : s;
      }
    }
    return n;
  };
  return Object.assign(e, { theme: e, ...ha }), Object.keys(t).reduce((r, n) => (r[n] = pt(t[n]) ? t[n](e, ha) : t[n], r), {});
};
var bc = function(t) {
  let e = [];
  return t.forEach((r) => {
    var i;
    e = [...e, r];
    let n = (i = r == null ? undefined : r.plugins) != null ? i : [];
    n.length !== 0 && n.forEach((a) => {
      var s;
      a.__isOptionsFunction && (a = a()), e = [...e, ...bc([(s = a == null ? undefined : a.config) != null ? s : {}])];
    });
  }), e;
};
var Sw = function(t) {
  return [...t].reduceRight((r, n) => pt(n) ? n({ corePlugins: r }) : gc(n, r), mc);
};
var kw = function(t) {
  return [...t].reduceRight((r, n) => [...r, ...n], []);
};
var ma = function(t) {
  let e = [...bc(t), { prefix: "", important: false, separator: ":" }];
  return vc(da({ theme: xw(ww(vw(e.map((r) => {
    var n;
    return (n = r == null ? undefined : r.theme) != null ? n : {};
  })))), corePlugins: Sw(e.map((r) => r.corePlugins)), plugins: kw(t.map((r) => {
    var n;
    return (n = r == null ? undefined : r.plugins) != null ? n : [];
  })) }, ...e));
};
var Rn = function(t) {
  var i;
  let e = ((i = t == null ? undefined : t.presets) != null ? i : [kc.default]).slice().reverse().flatMap((a) => Rn(a instanceof Function ? a() : a)), r = { respectDefaultRingColorOpacity: { theme: { ringColor: ({ theme: a }) => ({ DEFAULT: "#3b82f67f", ...a("colors") }) } }, disableColorOpacityUtilitiesByDefault: { corePlugins: { backgroundOpacity: false, borderOpacity: false, divideOpacity: false, placeholderOpacity: false, ringOpacity: false, textOpacity: false } } }, n = Object.keys(r).filter((a) => G(t, a)).map((a) => r[a]);
  return [t, ...n, ...e];
};
var ga = function(...t) {
  let [, ...e] = Rn(t[0]);
  return ma([...t, ...e]);
};
var kp = function(t) {
  let e = R.parse(t);
  return tn.objectify(e);
};
var Ap = Object.create;
var gr = Object.defineProperty;
var _p = Object.getOwnPropertyDescriptor;
var Tp = Object.getOwnPropertyNames;
var Pp = Object.getPrototypeOf;
var Ip = Object.prototype.hasOwnProperty;
var dt = (t, e) => () => (t && (e = t(t = 0)), e);
var S = (t, e) => () => (e || t((e = { exports: {} }).exports, e), e.exports);
var yr = (t, e) => {
  for (var r in e)
    gr(t, r, { get: e[r], enumerable: true });
};
var Ia = (t, e, r, n) => {
  if (e && typeof e == "object" || typeof e == "function")
    for (let i of Tp(e))
      !Ip.call(t, i) && i !== r && gr(t, i, { get: () => e[i], enumerable: !(n = _p(e, i)) || n.enumerable });
  return t;
};
var H = (t, e, r) => (r = t != null ? Ap(Pp(t)) : {}, Ia(e || !t || !t.__esModule ? gr(r, "default", { value: t, enumerable: true }) : r, t));
var $e = (t) => Ia(gr({}, "__esModule", { value: true }), t);
var Ma;
var Da = dt(() => {
  Ma = `*,:before,:after{box-sizing:border-box;border-width:0;border-style:solid;border-color:theme("borderColor.DEFAULT",currentColor)}:before,:after{--tw-content: ""}html{line-height:1.5;-webkit-text-size-adjust:100%;-moz-tab-size:4;tab-size:4;font-family:theme("fontFamily.sans",ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji");font-feature-settings:theme("fontFamily.sans[1].fontFeatureSettings",normal);font-variation-settings:theme("fontFamily.sans[1].fontVariationSettings",normal)}body{margin:0;line-height:inherit}hr{height:0;color:inherit;border-top-width:1px}abbr:where([title]){text-decoration:underline dotted}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;text-decoration:inherit}b,strong{font-weight:bolder}code,kbd,samp,pre{font-family:theme("fontFamily.mono",ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace);font-size:1em}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}table{text-indent:0;border-color:inherit;border-collapse:collapse}button,input,optgroup,select,textarea{font-family:inherit;font-size:100%;font-weight:inherit;line-height:inherit;color:inherit;margin:0;padding:0}button,select{text-transform:none}button,[type=button],[type=reset],[type=submit]{-webkit-appearance:button;background-color:transparent;background-image:none}:-moz-focusring{outline:auto}:-moz-ui-invalid{box-shadow:none}progress{vertical-align:baseline}::-webkit-inner-spin-button,::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}summary{display:list-item}blockquote,dl,dd,h1,h2,h3,h4,h5,h6,hr,figure,p,pre{margin:0}fieldset{margin:0;padding:0}legend{padding:0}ol,ul,menu{list-style:none;margin:0;padding:0}textarea{resize:vertical}input::placeholder,textarea::placeholder{opacity:1;color:theme("colors.gray.400",#9ca3af)}button,[role=button]{cursor:pointer}:disabled{cursor:default}img,svg,video,canvas,audio,iframe,embed,object{display:block;vertical-align:middle}img,video{max-width:100%;height:auto}[hidden]{display:none}
`;
});
var Fa = {};
yr(Fa, { default: () => ht });
var ht;
var vr = dt(() => {
  Da();
  ht = { readFileSync: () => Ma };
});
var Na = S((mb, La) => {
  var jn = class {
    constructor(e = {}) {
      if (!(e.maxSize && e.maxSize > 0))
        throw new TypeError("`maxSize` must be a number greater than 0");
      if (typeof e.maxAge == "number" && e.maxAge === 0)
        throw new TypeError("`maxAge` must be a number greater than 0");
      this.maxSize = e.maxSize, this.maxAge = e.maxAge || 1 / 0, this.onEviction = e.onEviction, this.cache = new Map, this.oldCache = new Map, this._size = 0;
    }
    _emitEvictions(e) {
      if (typeof this.onEviction == "function")
        for (let [r, n] of e)
          this.onEviction(r, n.value);
    }
    _deleteIfExpired(e, r) {
      return typeof r.expiry == "number" && r.expiry <= Date.now() ? (typeof this.onEviction == "function" && this.onEviction(e, r.value), this.delete(e)) : false;
    }
    _getOrDeleteIfExpired(e, r) {
      if (this._deleteIfExpired(e, r) === false)
        return r.value;
    }
    _getItemValue(e, r) {
      return r.expiry ? this._getOrDeleteIfExpired(e, r) : r.value;
    }
    _peek(e, r) {
      let n = r.get(e);
      return this._getItemValue(e, n);
    }
    _set(e, r) {
      this.cache.set(e, r), this._size++, this._size >= this.maxSize && (this._size = 0, this._emitEvictions(this.oldCache), this.oldCache = this.cache, this.cache = new Map);
    }
    _moveToRecent(e, r) {
      this.oldCache.delete(e), this._set(e, r);
    }
    *_entriesAscending() {
      for (let e of this.oldCache) {
        let [r, n] = e;
        this.cache.has(r) || this._deleteIfExpired(r, n) === false && (yield e);
      }
      for (let e of this.cache) {
        let [r, n] = e;
        this._deleteIfExpired(r, n) === false && (yield e);
      }
    }
    get(e) {
      if (this.cache.has(e)) {
        let r = this.cache.get(e);
        return this._getItemValue(e, r);
      }
      if (this.oldCache.has(e)) {
        let r = this.oldCache.get(e);
        if (this._deleteIfExpired(e, r) === false)
          return this._moveToRecent(e, r), r.value;
      }
    }
    set(e, r, { maxAge: n = this.maxAge === 1 / 0 ? undefined : Date.now() + this.maxAge } = {}) {
      this.cache.has(e) ? this.cache.set(e, { value: r, maxAge: n }) : this._set(e, { value: r, expiry: n });
    }
    has(e) {
      return this.cache.has(e) ? !this._deleteIfExpired(e, this.cache.get(e)) : this.oldCache.has(e) ? !this._deleteIfExpired(e, this.oldCache.get(e)) : false;
    }
    peek(e) {
      if (this.cache.has(e))
        return this._peek(e, this.cache);
      if (this.oldCache.has(e))
        return this._peek(e, this.oldCache);
    }
    delete(e) {
      let r = this.cache.delete(e);
      return r && this._size--, this.oldCache.delete(e) || r;
    }
    clear() {
      this.cache.clear(), this.oldCache.clear(), this._size = 0;
    }
    resize(e) {
      if (!(e && e > 0))
        throw new TypeError("`maxSize` must be a number greater than 0");
      let r = [...this._entriesAscending()], n = r.length - e;
      n < 0 ? (this.cache = new Map(r), this.oldCache = new Map, this._size = r.length) : (n > 0 && this._emitEvictions(r.slice(0, n)), this.oldCache = new Map(r.slice(n)), this.cache = new Map, this._size = 0), this.maxSize = e;
    }
    *keys() {
      for (let [e] of this)
        yield e;
    }
    *values() {
      for (let [, e] of this)
        yield e;
    }
    *[Symbol.iterator]() {
      for (let e of this.cache) {
        let [r, n] = e;
        this._deleteIfExpired(r, n) === false && (yield [r, n.value]);
      }
      for (let e of this.oldCache) {
        let [r, n] = e;
        this.cache.has(r) || this._deleteIfExpired(r, n) === false && (yield [r, n.value]);
      }
    }
    *entriesDescending() {
      let e = [...this.cache];
      for (let r = e.length - 1;r >= 0; --r) {
        let n = e[r], [i, a] = n;
        this._deleteIfExpired(i, a) === false && (yield [i, a.value]);
      }
      e = [...this.oldCache];
      for (let r = e.length - 1;r >= 0; --r) {
        let n = e[r], [i, a] = n;
        this.cache.has(i) || this._deleteIfExpired(i, a) === false && (yield [i, a.value]);
      }
    }
    *entriesAscending() {
      for (let [e, r] of this._entriesAscending())
        yield [e, r.value];
    }
    get size() {
      if (!this._size)
        return this.oldCache.size;
      let e = 0;
      for (let r of this.oldCache.keys())
        this.cache.has(r) || e++;
      return Math.min(this._size + e, this.maxSize);
    }
  };
  La.exports = jn;
});
var Ua = {};
yr(Ua, { default: () => Bn });
var Bn;
var Gn = dt(() => {
  Bn = { yellow: (t) => t };
});
var Yn = S(() => {
});
var br = S((bb, Va) => {
  var ja = (Gn(), $e(Ua)), za = Yn(), Ue = class extends Error {
    constructor(e, r, n, i, a, s) {
      super(e), this.name = "CssSyntaxError", this.reason = e, a && (this.file = a), i && (this.source = i), s && (this.plugin = s), typeof r < "u" && typeof n < "u" && (typeof r == "number" ? (this.line = r, this.column = n) : (this.line = r.line, this.column = r.column, this.endLine = n.line, this.endColumn = n.column)), this.setMessage(), Error.captureStackTrace && Error.captureStackTrace(this, Ue);
    }
    setMessage() {
      this.message = this.plugin ? this.plugin + ": " : "", this.message += this.file ? this.file : "<css input>", typeof this.line < "u" && (this.message += ":" + this.line + ":" + this.column), this.message += ": " + this.reason;
    }
    showSourceCode(e) {
      if (!this.source)
        return "";
      let r = this.source;
      e == null && (e = ja.isColorSupported), za && e && (r = za(r));
      let n = r.split(/\r?\n/), i = Math.max(this.line - 3, 0), a = Math.min(this.line + 2, n.length), s = String(a).length, o2, l;
      if (e) {
        let { bold: u, gray: f, red: p } = ja.createColors(true);
        o2 = (c2) => u(p(c2)), l = (c2) => f(c2);
      } else
        o2 = l = (u) => u;
      return n.slice(i, a).map((u, f) => {
        let p = i + 1 + f, c2 = " " + (" " + p).slice(-s) + " | ";
        if (p === this.line) {
          let d = l(c2.replace(/\d/g, " ")) + u.slice(0, this.column - 1).replace(/[^\t]/g, " ");
          return o2(">") + l(c2) + u + `
 ` + d + o2("^");
        }
        return " " + l(c2) + u;
      }).join(`
`);
    }
    toString() {
      let e = this.showSourceCode();
      return e && (e = `

` + e + `
`), this.name + ": " + this.message + e;
    }
  };
  Va.exports = Ue;
  Ue.default = Ue;
});
var xr = S((xb, Hn) => {
  Hn.exports.isClean = Symbol("isClean");
  Hn.exports.my = Symbol("my");
});
var Qn = S((Sb, Ba) => {
  var Wa = { after: `
`, beforeClose: `
`, beforeComment: `
`, beforeDecl: `
`, beforeOpen: " ", beforeRule: `
`, colon: ": ", commentLeft: " ", commentRight: " ", emptyBody: "", indent: "    ", semicolon: false };
  function Mp(t) {
    return t[0].toUpperCase() + t.slice(1);
  }
  var gt2 = class {
    constructor(e) {
      this.builder = e;
    }
    atrule(e, r) {
      let n = "@" + e.name, i = e.params ? this.rawValue(e, "params") : "";
      if (typeof e.raws.afterName < "u" ? n += e.raws.afterName : i && (n += " "), e.nodes)
        this.block(e, n + i);
      else {
        let a = (e.raws.between || "") + (r ? ";" : "");
        this.builder(n + i + a, e);
      }
    }
    beforeAfter(e, r) {
      let n;
      e.type === "decl" ? n = this.raw(e, null, "beforeDecl") : e.type === "comment" ? n = this.raw(e, null, "beforeComment") : r === "before" ? n = this.raw(e, null, "beforeRule") : n = this.raw(e, null, "beforeClose");
      let i = e.parent, a = 0;
      for (;i && i.type !== "root"; )
        a += 1, i = i.parent;
      if (n.includes(`
`)) {
        let s = this.raw(e, null, "indent");
        if (s.length)
          for (let o2 = 0;o2 < a; o2++)
            n += s;
      }
      return n;
    }
    block(e, r) {
      let n = this.raw(e, "between", "beforeOpen");
      this.builder(r + n + "{", e, "start");
      let i;
      e.nodes && e.nodes.length ? (this.body(e), i = this.raw(e, "after")) : i = this.raw(e, "after", "emptyBody"), i && this.builder(i), this.builder("}", e, "end");
    }
    body(e) {
      let r = e.nodes.length - 1;
      for (;r > 0 && e.nodes[r].type === "comment"; )
        r -= 1;
      let n = this.raw(e, "semicolon");
      for (let i = 0;i < e.nodes.length; i++) {
        let a = e.nodes[i], s = this.raw(a, "before");
        s && this.builder(s), this.stringify(a, r !== i || n);
      }
    }
    comment(e) {
      let r = this.raw(e, "left", "commentLeft"), n = this.raw(e, "right", "commentRight");
      this.builder("/*" + r + e.text + n + "*/", e);
    }
    decl(e, r) {
      let n = this.raw(e, "between", "colon"), i = e.prop + n + this.rawValue(e, "value");
      e.important && (i += e.raws.important || " !important"), r && (i += ";"), this.builder(i, e);
    }
    document(e) {
      this.body(e);
    }
    raw(e, r, n) {
      let i;
      if (n || (n = r), r && (i = e.raws[r], typeof i < "u"))
        return i;
      let a = e.parent;
      if (n === "before" && (!a || a.type === "root" && a.first === e || a && a.type === "document"))
        return "";
      if (!a)
        return Wa[n];
      let s = e.root();
      if (s.rawCache || (s.rawCache = {}), typeof s.rawCache[n] < "u")
        return s.rawCache[n];
      if (n === "before" || n === "after")
        return this.beforeAfter(e, n);
      {
        let o2 = "raw" + Mp(n);
        this[o2] ? i = this[o2](s, e) : s.walk((l) => {
          if (i = l.raws[r], typeof i < "u")
            return false;
        });
      }
      return typeof i > "u" && (i = Wa[n]), s.rawCache[n] = i, i;
    }
    rawBeforeClose(e) {
      let r;
      return e.walk((n) => {
        if (n.nodes && n.nodes.length > 0 && typeof n.raws.after < "u")
          return r = n.raws.after, r.includes(`
`) && (r = r.replace(/[^\n]+$/, "")), false;
      }), r && (r = r.replace(/\S/g, "")), r;
    }
    rawBeforeComment(e, r) {
      let n;
      return e.walkComments((i) => {
        if (typeof i.raws.before < "u")
          return n = i.raws.before, n.includes(`
`) && (n = n.replace(/[^\n]+$/, "")), false;
      }), typeof n > "u" ? n = this.raw(r, null, "beforeDecl") : n && (n = n.replace(/\S/g, "")), n;
    }
    rawBeforeDecl(e, r) {
      let n;
      return e.walkDecls((i) => {
        if (typeof i.raws.before < "u")
          return n = i.raws.before, n.includes(`
`) && (n = n.replace(/[^\n]+$/, "")), false;
      }), typeof n > "u" ? n = this.raw(r, null, "beforeRule") : n && (n = n.replace(/\S/g, "")), n;
    }
    rawBeforeOpen(e) {
      let r;
      return e.walk((n) => {
        if (n.type !== "decl" && (r = n.raws.between, typeof r < "u"))
          return false;
      }), r;
    }
    rawBeforeRule(e) {
      let r;
      return e.walk((n) => {
        if (n.nodes && (n.parent !== e || e.first !== n) && typeof n.raws.before < "u")
          return r = n.raws.before, r.includes(`
`) && (r = r.replace(/[^\n]+$/, "")), false;
      }), r && (r = r.replace(/\S/g, "")), r;
    }
    rawColon(e) {
      let r;
      return e.walkDecls((n) => {
        if (typeof n.raws.between < "u")
          return r = n.raws.between.replace(/[^\s:]/g, ""), false;
      }), r;
    }
    rawEmptyBody(e) {
      let r;
      return e.walk((n) => {
        if (n.nodes && n.nodes.length === 0 && (r = n.raws.after, typeof r < "u"))
          return false;
      }), r;
    }
    rawIndent(e) {
      if (e.raws.indent)
        return e.raws.indent;
      let r;
      return e.walk((n) => {
        let i = n.parent;
        if (i && i !== e && i.parent && i.parent === e && typeof n.raws.before < "u") {
          let a = n.raws.before.split(`
`);
          return r = a[a.length - 1], r = r.replace(/\S/g, ""), false;
        }
      }), r;
    }
    rawSemicolon(e) {
      let r;
      return e.walk((n) => {
        if (n.nodes && n.nodes.length && n.last.type === "decl" && (r = n.raws.semicolon, typeof r < "u"))
          return false;
      }), r;
    }
    rawValue(e, r) {
      let n = e[r], i = e.raws[r];
      return i && i.value === n ? i.raw : n;
    }
    root(e) {
      this.body(e), e.raws.after && this.builder(e.raws.after);
    }
    rule(e) {
      this.block(e, this.rawValue(e, "selector")), e.raws.ownSemicolon && this.builder(e.raws.ownSemicolon, e, "end");
    }
    stringify(e, r) {
      if (!this[e.type])
        throw new Error("Unknown AST node type " + e.type + ". Maybe you need to change PostCSS stringifier.");
      this[e.type](e, r);
    }
  };
  Ba.exports = gt2;
  gt2.default = gt2;
});
var yt = S((kb, Ga) => {
  var Fp = Qn();
  function Jn(t, e) {
    new Fp(e).stringify(t);
  }
  Ga.exports = Jn;
  Jn.default = Jn;
});
var wt = S((Ob, Ya) => {
  var { isClean: Sr, my: Lp } = xr(), Np = br(), qp = Qn(), $p = yt();
  function Xn(t, e) {
    let r = new t.constructor;
    for (let n in t) {
      if (!Object.prototype.hasOwnProperty.call(t, n) || n === "proxyCache")
        continue;
      let i = t[n], a = typeof i;
      n === "parent" && a === "object" ? e && (r[n] = e) : n === "source" ? r[n] = i : Array.isArray(i) ? r[n] = i.map((s) => Xn(s, r)) : (a === "object" && i !== null && (i = Xn(i)), r[n] = i);
    }
    return r;
  }
  var vt = class {
    constructor(e = {}) {
      this.raws = {}, this[Sr] = false, this[Lp] = true;
      for (let r in e)
        if (r === "nodes") {
          this.nodes = [];
          for (let n of e[r])
            typeof n.clone == "function" ? this.append(n.clone()) : this.append(n);
        } else
          this[r] = e[r];
    }
    addToError(e) {
      if (e.postcssNode = this, e.stack && this.source && /\n\s{4}at /.test(e.stack)) {
        let r = this.source;
        e.stack = e.stack.replace(/\n\s{4}at /, `\$&${r.input.from}:${r.start.line}:${r.start.column}\$&`);
      }
      return e;
    }
    after(e) {
      return this.parent.insertAfter(this, e), this;
    }
    assign(e = {}) {
      for (let r in e)
        this[r] = e[r];
      return this;
    }
    before(e) {
      return this.parent.insertBefore(this, e), this;
    }
    cleanRaws(e) {
      delete this.raws.before, delete this.raws.after, e || delete this.raws.between;
    }
    clone(e = {}) {
      let r = Xn(this);
      for (let n in e)
        r[n] = e[n];
      return r;
    }
    cloneAfter(e = {}) {
      let r = this.clone(e);
      return this.parent.insertAfter(this, r), r;
    }
    cloneBefore(e = {}) {
      let r = this.clone(e);
      return this.parent.insertBefore(this, r), r;
    }
    error(e, r = {}) {
      if (this.source) {
        let { end: n, start: i } = this.rangeBy(r);
        return this.source.input.error(e, { column: i.column, line: i.line }, { column: n.column, line: n.line }, r);
      }
      return new Np(e);
    }
    getProxyProcessor() {
      return { get(e, r) {
        return r === "proxyOf" ? e : r === "root" ? () => e.root().toProxy() : e[r];
      }, set(e, r, n) {
        return e[r] === n || (e[r] = n, (r === "prop" || r === "value" || r === "name" || r === "params" || r === "important" || r === "text") && e.markDirty()), true;
      } };
    }
    markDirty() {
      if (this[Sr]) {
        this[Sr] = false;
        let e = this;
        for (;e = e.parent; )
          e[Sr] = false;
      }
    }
    next() {
      if (!this.parent)
        return;
      let e = this.parent.index(this);
      return this.parent.nodes[e + 1];
    }
    positionBy(e, r) {
      let n = this.source.start;
      if (e.index)
        n = this.positionInside(e.index, r);
      else if (e.word) {
        r = this.toString();
        let i = r.indexOf(e.word);
        i !== -1 && (n = this.positionInside(i, r));
      }
      return n;
    }
    positionInside(e, r) {
      let n = r || this.toString(), i = this.source.start.column, a = this.source.start.line;
      for (let s = 0;s < e; s++)
        n[s] === `
` ? (i = 1, a += 1) : i += 1;
      return { column: i, line: a };
    }
    prev() {
      if (!this.parent)
        return;
      let e = this.parent.index(this);
      return this.parent.nodes[e - 1];
    }
    rangeBy(e) {
      let r = { column: this.source.start.column, line: this.source.start.line }, n = this.source.end ? { column: this.source.end.column + 1, line: this.source.end.line } : { column: r.column + 1, line: r.line };
      if (e.word) {
        let i = this.toString(), a = i.indexOf(e.word);
        a !== -1 && (r = this.positionInside(a, i), n = this.positionInside(a + e.word.length, i));
      } else
        e.start ? r = { column: e.start.column, line: e.start.line } : e.index && (r = this.positionInside(e.index)), e.end ? n = { column: e.end.column, line: e.end.line } : e.endIndex ? n = this.positionInside(e.endIndex) : e.index && (n = this.positionInside(e.index + 1));
      return (n.line < r.line || n.line === r.line && n.column <= r.column) && (n = { column: r.column + 1, line: r.line }), { end: n, start: r };
    }
    raw(e, r) {
      return new qp().raw(this, e, r);
    }
    remove() {
      return this.parent && this.parent.removeChild(this), this.parent = undefined, this;
    }
    replaceWith(...e) {
      if (this.parent) {
        let r = this, n = false;
        for (let i of e)
          i === this ? n = true : n ? (this.parent.insertAfter(r, i), r = i) : this.parent.insertBefore(r, i);
        n || this.remove();
      }
      return this;
    }
    root() {
      let e = this;
      for (;e.parent && e.parent.type !== "document"; )
        e = e.parent;
      return e;
    }
    toJSON(e, r) {
      let n = {}, i = r == null;
      r = r || new Map;
      let a = 0;
      for (let s in this) {
        if (!Object.prototype.hasOwnProperty.call(this, s) || s === "parent" || s === "proxyCache")
          continue;
        let o2 = this[s];
        if (Array.isArray(o2))
          n[s] = o2.map((l) => typeof l == "object" && l.toJSON ? l.toJSON(null, r) : l);
        else if (typeof o2 == "object" && o2.toJSON)
          n[s] = o2.toJSON(null, r);
        else if (s === "source") {
          let l = r.get(o2.input);
          l == null && (l = a, r.set(o2.input, a), a++), n[s] = { end: o2.end, inputId: l, start: o2.start };
        } else
          n[s] = o2;
      }
      return i && (n.inputs = [...r.keys()].map((s) => s.toJSON())), n;
    }
    toProxy() {
      return this.proxyCache || (this.proxyCache = new Proxy(this, this.getProxyProcessor())), this.proxyCache;
    }
    toString(e = $p) {
      e.stringify && (e = e.stringify);
      let r = "";
      return e(this, (n) => {
        r += n;
      }), r;
    }
    warn(e, r, n) {
      let i = { node: this };
      for (let a in n)
        i[a] = n[a];
      return e.warn(r, i);
    }
    get proxyOf() {
      return this;
    }
  };
  Ya.exports = vt;
  vt.default = vt;
});
var xt = S((Eb, Ha) => {
  var Up = wt(), bt = class extends Up {
    constructor(e) {
      e && typeof e.value < "u" && typeof e.value != "string" && (e = { ...e, value: String(e.value) }), super(e), this.type = "decl";
    }
    get variable() {
      return this.prop.startsWith("--") || this.prop[0] === "$";
    }
  };
  Ha.exports = bt;
  bt.default = bt;
});
var kr = S(() => {
});
var St = {};
yr(St, { join: () => Kn });
var Kn;
var kt = dt(() => {
  Kn = () => "";
});
var Zn = {};
yr(Zn, { default: () => jp });
var jp;
var ei = dt(() => {
  jp = null;
});
var Ja = S((_b, Qa) => {
  var zp = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict", Vp = (t, e = 21) => (r = e) => {
    let n = "", i = r;
    for (;i--; )
      n += t[Math.random() * t.length | 0];
    return n;
  }, Wp = (t = 21) => {
    let e = "", r = t;
    for (;r--; )
      e += zp[Math.random() * 64 | 0];
    return e;
  };
  Qa.exports = { nanoid: Wp, customAlphabet: Vp };
});
var ri = S((Tb, Za) => {
  var { SourceMapConsumer: Xa, SourceMapGenerator: Ka } = kr(), { existsSync: Bp, readFileSync: Gp } = (vr(), $e(Fa)), { dirname: ti, join: Yp } = (kt(), $e(St));
  function Hp(t) {
    return Buffer ? Buffer.from(t, "base64").toString() : window.atob(t);
  }
  var Ot = class {
    constructor(e, r) {
      if (r.map === false)
        return;
      this.loadAnnotation(e), this.inline = this.startWith(this.annotation, "data:");
      let n = r.map ? r.map.prev : undefined, i = this.loadMap(r.from, n);
      !this.mapFile && r.from && (this.mapFile = r.from), this.mapFile && (this.root = ti(this.mapFile)), i && (this.text = i);
    }
    consumer() {
      return this.consumerCache || (this.consumerCache = new Xa(this.text)), this.consumerCache;
    }
    decodeInline(e) {
      let r = /^data:application\/json;charset=utf-?8;base64,/, n = /^data:application\/json;base64,/, i = /^data:application\/json;charset=utf-?8,/, a = /^data:application\/json,/;
      if (i.test(e) || a.test(e))
        return decodeURIComponent(e.substr(RegExp.lastMatch.length));
      if (r.test(e) || n.test(e))
        return Hp(e.substr(RegExp.lastMatch.length));
      let s = e.match(/data:application\/json;([^,]+),/)[1];
      throw new Error("Unsupported source map encoding " + s);
    }
    getAnnotationURL(e) {
      return e.replace(/^\/\*\s*# sourceMappingURL=/, "").trim();
    }
    isMap(e) {
      return typeof e != "object" ? false : typeof e.mappings == "string" || typeof e._mappings == "string" || Array.isArray(e.sections);
    }
    loadAnnotation(e) {
      let r = e.match(/\/\*\s*# sourceMappingURL=/gm);
      if (!r)
        return;
      let n = e.lastIndexOf(r.pop()), i = e.indexOf("*/", n);
      n > -1 && i > -1 && (this.annotation = this.getAnnotationURL(e.substring(n, i)));
    }
    loadFile(e) {
      if (this.root = ti(e), Bp(e))
        return this.mapFile = e, Gp(e, "utf-8").toString().trim();
    }
    loadMap(e, r) {
      if (r === false)
        return false;
      if (r) {
        if (typeof r == "string")
          return r;
        if (typeof r == "function") {
          let n = r(e);
          if (n) {
            let i = this.loadFile(n);
            if (!i)
              throw new Error("Unable to load previous source map: " + n.toString());
            return i;
          }
        } else {
          if (r instanceof Xa)
            return Ka.fromSourceMap(r).toString();
          if (r instanceof Ka)
            return r.toString();
          if (this.isMap(r))
            return JSON.stringify(r);
          throw new Error("Unsupported previous source map format: " + r.toString());
        }
      } else {
        if (this.inline)
          return this.decodeInline(this.annotation);
        if (this.annotation) {
          let n = this.annotation;
          return e && (n = Yp(ti(e), n)), this.loadFile(n);
        }
      }
    }
    startWith(e, r) {
      return e ? e.substr(0, r.length) === r : false;
    }
    withContent() {
      return !!(this.consumer().sourcesContent && this.consumer().sourcesContent.length > 0);
    }
  };
  Za.exports = Ot;
  Ot.default = Ot;
});
var Et = S((Pb, no) => {
  var { SourceMapConsumer: Qp, SourceMapGenerator: Jp } = kr(), { fileURLToPath: eo, pathToFileURL: Or } = (ei(), $e(Zn)), { isAbsolute: si, resolve: ai } = (kt(), $e(St)), { nanoid: Xp } = Ja(), ni = Yn(), to = br(), Kp = ri(), ii = Symbol("fromOffsetCache"), Zp = Boolean(Qp && Jp), ro = Boolean(ai && si), Ye = class {
    constructor(e, r = {}) {
      if (e === null || typeof e > "u" || typeof e == "object" && !e.toString)
        throw new Error(`PostCSS received ${e} instead of CSS string`);
      if (this.css = e.toString(), this.css[0] === "\uFEFF" || this.css[0] === "\uFFFE" ? (this.hasBOM = true, this.css = this.css.slice(1)) : this.hasBOM = false, r.from && (!ro || /^\w+:\/\//.test(r.from) || si(r.from) ? this.file = r.from : this.file = ai(r.from)), ro && Zp) {
        let n = new Kp(this.css, r);
        if (n.text) {
          this.map = n;
          let i = n.consumer().file;
          !this.file && i && (this.file = this.mapResolve(i));
        }
      }
      this.file || (this.id = "<input css " + Xp(6) + ">"), this.map && (this.map.file = this.from);
    }
    error(e, r, n, i = {}) {
      let a, s, o2;
      if (r && typeof r == "object") {
        let u = r, f = n;
        if (typeof u.offset == "number") {
          let p = this.fromOffset(u.offset);
          r = p.line, n = p.col;
        } else
          r = u.line, n = u.column;
        if (typeof f.offset == "number") {
          let p = this.fromOffset(f.offset);
          s = p.line, o2 = p.col;
        } else
          s = f.line, o2 = f.column;
      } else if (!n) {
        let u = this.fromOffset(r);
        r = u.line, n = u.col;
      }
      let l = this.origin(r, n, s, o2);
      return l ? a = new to(e, l.endLine === undefined ? l.line : { column: l.column, line: l.line }, l.endLine === undefined ? l.column : { column: l.endColumn, line: l.endLine }, l.source, l.file, i.plugin) : a = new to(e, s === undefined ? r : { column: n, line: r }, s === undefined ? n : { column: o2, line: s }, this.css, this.file, i.plugin), a.input = { column: n, endColumn: o2, endLine: s, line: r, source: this.css }, this.file && (Or && (a.input.url = Or(this.file).toString()), a.input.file = this.file), a;
    }
    fromOffset(e) {
      let r, n;
      if (this[ii])
        n = this[ii];
      else {
        let a = this.css.split(`
`);
        n = new Array(a.length);
        let s = 0;
        for (let o2 = 0, l = a.length;o2 < l; o2++)
          n[o2] = s, s += a[o2].length + 1;
        this[ii] = n;
      }
      r = n[n.length - 1];
      let i = 0;
      if (e >= r)
        i = n.length - 1;
      else {
        let a = n.length - 2, s;
        for (;i < a; )
          if (s = i + (a - i >> 1), e < n[s])
            a = s - 1;
          else if (e >= n[s + 1])
            i = s + 1;
          else {
            i = s;
            break;
          }
      }
      return { col: e - n[i] + 1, line: i + 1 };
    }
    mapResolve(e) {
      return /^\w+:\/\//.test(e) ? e : ai(this.map.consumer().sourceRoot || this.map.root || ".", e);
    }
    origin(e, r, n, i) {
      if (!this.map)
        return false;
      let a = this.map.consumer(), s = a.originalPositionFor({ column: r, line: e });
      if (!s.source)
        return false;
      let o2;
      typeof n == "number" && (o2 = a.originalPositionFor({ column: i, line: n }));
      let l;
      si(s.source) ? l = Or(s.source) : l = new URL(s.source, this.map.consumer().sourceRoot || Or(this.map.mapFile));
      let u = { column: s.column, endColumn: o2 && o2.column, endLine: o2 && o2.line, line: s.line, url: l.toString() };
      if (l.protocol === "file:")
        if (eo)
          u.file = eo(l);
        else
          throw new Error("file: protocol is not available in this PostCSS build");
      let f = a.sourceContentFor(s.source);
      return f && (u.source = f), u;
    }
    toJSON() {
      let e = {};
      for (let r of ["hasBOM", "css", "file", "id"])
        this[r] != null && (e[r] = this[r]);
      return this.map && (e.map = { ...this.map }, e.map.consumerCache && (e.map.consumerCache = undefined)), e;
    }
    get from() {
      return this.file || this.id;
    }
  };
  no.exports = Ye;
  Ye.default = Ye;
  ni && ni.registerInput && ni.registerInput(Ye);
});
var li = S((Ib, uo) => {
  var { SourceMapConsumer: so, SourceMapGenerator: Er } = kr(), { dirname: Cr, relative: ao, resolve: oo, sep: lo } = (kt(), $e(St)), { pathToFileURL: io } = (ei(), $e(Zn)), ed = Et(), td = Boolean(so && Er), rd = Boolean(Cr && oo && ao && lo), oi = class {
    constructor(e, r, n, i) {
      this.stringify = e, this.mapOpts = n.map || {}, this.root = r, this.opts = n, this.css = i, this.usesFileUrls = !this.mapOpts.from && this.mapOpts.absolute, this.memoizedFileURLs = new Map, this.memoizedPaths = new Map, this.memoizedURLs = new Map;
    }
    addAnnotation() {
      let e;
      this.isInline() ? e = "data:application/json;base64," + this.toBase64(this.map.toString()) : typeof this.mapOpts.annotation == "string" ? e = this.mapOpts.annotation : typeof this.mapOpts.annotation == "function" ? e = this.mapOpts.annotation(this.opts.to, this.root) : e = this.outputFile() + ".map";
      let r = `
`;
      this.css.includes(`\r
`) && (r = `\r
`), this.css += r + "/*# sourceMappingURL=" + e + " */";
    }
    applyPrevMaps() {
      for (let e of this.previous()) {
        let r = this.toUrl(this.path(e.file)), n = e.root || Cr(e.file), i;
        this.mapOpts.sourcesContent === false ? (i = new so(e.text), i.sourcesContent && (i.sourcesContent = i.sourcesContent.map(() => null))) : i = e.consumer(), this.map.applySourceMap(i, r, this.toUrl(this.path(n)));
      }
    }
    clearAnnotation() {
      if (this.mapOpts.annotation !== false)
        if (this.root) {
          let e;
          for (let r = this.root.nodes.length - 1;r >= 0; r--)
            e = this.root.nodes[r], e.type === "comment" && e.text.indexOf("# sourceMappingURL=") === 0 && this.root.removeChild(r);
        } else
          this.css && (this.css = this.css.replace(/(\n)?\/\*#[\S\s]*?\*\/$/gm, ""));
    }
    generate() {
      if (this.clearAnnotation(), rd && td && this.isMap())
        return this.generateMap();
      {
        let e = "";
        return this.stringify(this.root, (r) => {
          e += r;
        }), [e];
      }
    }
    generateMap() {
      if (this.root)
        this.generateString();
      else if (this.previous().length === 1) {
        let e = this.previous()[0].consumer();
        e.file = this.outputFile(), this.map = Er.fromSourceMap(e);
      } else
        this.map = new Er({ file: this.outputFile() }), this.map.addMapping({ generated: { column: 0, line: 1 }, original: { column: 0, line: 1 }, source: this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>" });
      return this.isSourcesContent() && this.setSourcesContent(), this.root && this.previous().length > 0 && this.applyPrevMaps(), this.isAnnotation() && this.addAnnotation(), this.isInline() ? [this.css] : [this.css, this.map];
    }
    generateString() {
      this.css = "", this.map = new Er({ file: this.outputFile() });
      let e = 1, r = 1, n = "<no source>", i = { generated: { column: 0, line: 0 }, original: { column: 0, line: 0 }, source: "" }, a, s;
      this.stringify(this.root, (o2, l, u) => {
        if (this.css += o2, l && u !== "end" && (i.generated.line = e, i.generated.column = r - 1, l.source && l.source.start ? (i.source = this.sourcePath(l), i.original.line = l.source.start.line, i.original.column = l.source.start.column - 1, this.map.addMapping(i)) : (i.source = n, i.original.line = 1, i.original.column = 0, this.map.addMapping(i))), a = o2.match(/\n/g), a ? (e += a.length, s = o2.lastIndexOf(`
`), r = o2.length - s) : r += o2.length, l && u !== "start") {
          let f = l.parent || { raws: {} };
          (!(l.type === "decl" || l.type === "atrule" && !l.nodes) || l !== f.last || f.raws.semicolon) && (l.source && l.source.end ? (i.source = this.sourcePath(l), i.original.line = l.source.end.line, i.original.column = l.source.end.column - 1, i.generated.line = e, i.generated.column = r - 2, this.map.addMapping(i)) : (i.source = n, i.original.line = 1, i.original.column = 0, i.generated.line = e, i.generated.column = r - 1, this.map.addMapping(i)));
        }
      });
    }
    isAnnotation() {
      return this.isInline() ? true : typeof this.mapOpts.annotation < "u" ? this.mapOpts.annotation : this.previous().length ? this.previous().some((e) => e.annotation) : true;
    }
    isInline() {
      if (typeof this.mapOpts.inline < "u")
        return this.mapOpts.inline;
      let e = this.mapOpts.annotation;
      return typeof e < "u" && e !== true ? false : this.previous().length ? this.previous().some((r) => r.inline) : true;
    }
    isMap() {
      return typeof this.opts.map < "u" ? !!this.opts.map : this.previous().length > 0;
    }
    isSourcesContent() {
      return typeof this.mapOpts.sourcesContent < "u" ? this.mapOpts.sourcesContent : this.previous().length ? this.previous().some((e) => e.withContent()) : true;
    }
    outputFile() {
      return this.opts.to ? this.path(this.opts.to) : this.opts.from ? this.path(this.opts.from) : "to.css";
    }
    path(e) {
      if (this.mapOpts.absolute || e.charCodeAt(0) === 60 || /^\w+:\/\//.test(e))
        return e;
      let r = this.memoizedPaths.get(e);
      if (r)
        return r;
      let n = this.opts.to ? Cr(this.opts.to) : ".";
      typeof this.mapOpts.annotation == "string" && (n = Cr(oo(n, this.mapOpts.annotation)));
      let i = ao(n, e);
      return this.memoizedPaths.set(e, i), i;
    }
    previous() {
      if (!this.previousMaps)
        if (this.previousMaps = [], this.root)
          this.root.walk((e) => {
            if (e.source && e.source.input.map) {
              let r = e.source.input.map;
              this.previousMaps.includes(r) || this.previousMaps.push(r);
            }
          });
        else {
          let e = new ed(this.css, this.opts);
          e.map && this.previousMaps.push(e.map);
        }
      return this.previousMaps;
    }
    setSourcesContent() {
      let e = {};
      if (this.root)
        this.root.walk((r) => {
          if (r.source) {
            let n = r.source.input.from;
            if (n && !e[n]) {
              e[n] = true;
              let i = this.usesFileUrls ? this.toFileUrl(n) : this.toUrl(this.path(n));
              this.map.setSourceContent(i, r.source.input.css);
            }
          }
        });
      else if (this.css) {
        let r = this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>";
        this.map.setSourceContent(r, this.css);
      }
    }
    sourcePath(e) {
      return this.mapOpts.from ? this.toUrl(this.mapOpts.from) : this.usesFileUrls ? this.toFileUrl(e.source.input.from) : this.toUrl(this.path(e.source.input.from));
    }
    toBase64(e) {
      return Buffer ? Buffer.from(e).toString("base64") : window.btoa(unescape(encodeURIComponent(e)));
    }
    toFileUrl(e) {
      let r = this.memoizedFileURLs.get(e);
      if (r)
        return r;
      if (io) {
        let n = io(e).toString();
        return this.memoizedFileURLs.set(e, n), n;
      } else
        throw new Error("`map.absolute` option is not available in this PostCSS build");
    }
    toUrl(e) {
      let r = this.memoizedURLs.get(e);
      if (r)
        return r;
      lo === "\\" && (e = e.replace(/\\/g, "/"));
      let n = encodeURI(e).replace(/[#?]/g, encodeURIComponent);
      return this.memoizedURLs.set(e, n), n;
    }
  };
  uo.exports = oi;
});
var At = S((Rb, fo) => {
  var nd = wt(), Ct = class extends nd {
    constructor(e) {
      super(e), this.type = "comment";
    }
  };
  fo.exports = Ct;
  Ct.default = Ct;
});
var _e = S((Db, bo) => {
  var { isClean: co, my: po } = xr(), ho = xt(), mo = At(), id = wt(), go, ui, fi, yo;
  function vo(t) {
    return t.map((e) => (e.nodes && (e.nodes = vo(e.nodes)), delete e.source, e));
  }
  function wo(t) {
    if (t[co] = false, t.proxyOf.nodes)
      for (let e of t.proxyOf.nodes)
        wo(e);
  }
  var ae = class extends id {
    append(...e) {
      for (let r of e) {
        let n = this.normalize(r, this.last);
        for (let i of n)
          this.proxyOf.nodes.push(i);
      }
      return this.markDirty(), this;
    }
    cleanRaws(e) {
      if (super.cleanRaws(e), this.nodes)
        for (let r of this.nodes)
          r.cleanRaws(e);
    }
    each(e) {
      if (!this.proxyOf.nodes)
        return;
      let r = this.getIterator(), n, i;
      for (;this.indexes[r] < this.proxyOf.nodes.length && (n = this.indexes[r], i = e(this.proxyOf.nodes[n], n), i !== false); )
        this.indexes[r] += 1;
      return delete this.indexes[r], i;
    }
    every(e) {
      return this.nodes.every(e);
    }
    getIterator() {
      this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach += 1;
      let e = this.lastEach;
      return this.indexes[e] = 0, e;
    }
    getProxyProcessor() {
      return { get(e, r) {
        return r === "proxyOf" ? e : e[r] ? r === "each" || typeof r == "string" && r.startsWith("walk") ? (...n) => e[r](...n.map((i) => typeof i == "function" ? (a, s) => i(a.toProxy(), s) : i)) : r === "every" || r === "some" ? (n) => e[r]((i, ...a) => n(i.toProxy(), ...a)) : r === "root" ? () => e.root().toProxy() : r === "nodes" ? e.nodes.map((n) => n.toProxy()) : r === "first" || r === "last" ? e[r].toProxy() : e[r] : e[r];
      }, set(e, r, n) {
        return e[r] === n || (e[r] = n, (r === "name" || r === "params" || r === "selector") && e.markDirty()), true;
      } };
    }
    index(e) {
      return typeof e == "number" ? e : (e.proxyOf && (e = e.proxyOf), this.proxyOf.nodes.indexOf(e));
    }
    insertAfter(e, r) {
      let n = this.index(e), i = this.normalize(r, this.proxyOf.nodes[n]).reverse();
      n = this.index(e);
      for (let s of i)
        this.proxyOf.nodes.splice(n + 1, 0, s);
      let a;
      for (let s in this.indexes)
        a = this.indexes[s], n < a && (this.indexes[s] = a + i.length);
      return this.markDirty(), this;
    }
    insertBefore(e, r) {
      let n = this.index(e), i = n === 0 ? "prepend" : false, a = this.normalize(r, this.proxyOf.nodes[n], i).reverse();
      n = this.index(e);
      for (let o2 of a)
        this.proxyOf.nodes.splice(n, 0, o2);
      let s;
      for (let o2 in this.indexes)
        s = this.indexes[o2], n <= s && (this.indexes[o2] = s + a.length);
      return this.markDirty(), this;
    }
    normalize(e, r) {
      if (typeof e == "string")
        e = vo(go(e).nodes);
      else if (Array.isArray(e)) {
        e = e.slice(0);
        for (let i of e)
          i.parent && i.parent.removeChild(i, "ignore");
      } else if (e.type === "root" && this.type !== "document") {
        e = e.nodes.slice(0);
        for (let i of e)
          i.parent && i.parent.removeChild(i, "ignore");
      } else if (e.type)
        e = [e];
      else if (e.prop) {
        if (typeof e.value > "u")
          throw new Error("Value field is missed in node creation");
        typeof e.value != "string" && (e.value = String(e.value)), e = [new ho(e)];
      } else if (e.selector)
        e = [new ui(e)];
      else if (e.name)
        e = [new fi(e)];
      else if (e.text)
        e = [new mo(e)];
      else
        throw new Error("Unknown node type in node creation");
      return e.map((i) => (i[po] || ae.rebuild(i), i = i.proxyOf, i.parent && i.parent.removeChild(i), i[co] && wo(i), typeof i.raws.before > "u" && r && typeof r.raws.before < "u" && (i.raws.before = r.raws.before.replace(/\S/g, "")), i.parent = this.proxyOf, i));
    }
    prepend(...e) {
      e = e.reverse();
      for (let r of e) {
        let n = this.normalize(r, this.first, "prepend").reverse();
        for (let i of n)
          this.proxyOf.nodes.unshift(i);
        for (let i in this.indexes)
          this.indexes[i] = this.indexes[i] + n.length;
      }
      return this.markDirty(), this;
    }
    push(e) {
      return e.parent = this, this.proxyOf.nodes.push(e), this;
    }
    removeAll() {
      for (let e of this.proxyOf.nodes)
        e.parent = undefined;
      return this.proxyOf.nodes = [], this.markDirty(), this;
    }
    removeChild(e) {
      e = this.index(e), this.proxyOf.nodes[e].parent = undefined, this.proxyOf.nodes.splice(e, 1);
      let r;
      for (let n in this.indexes)
        r = this.indexes[n], r >= e && (this.indexes[n] = r - 1);
      return this.markDirty(), this;
    }
    replaceValues(e, r, n) {
      return n || (n = r, r = {}), this.walkDecls((i) => {
        r.props && !r.props.includes(i.prop) || r.fast && !i.value.includes(r.fast) || (i.value = i.value.replace(e, n));
      }), this.markDirty(), this;
    }
    some(e) {
      return this.nodes.some(e);
    }
    walk(e) {
      return this.each((r, n) => {
        let i;
        try {
          i = e(r, n);
        } catch (a) {
          throw r.addToError(a);
        }
        return i !== false && r.walk && (i = r.walk(e)), i;
      });
    }
    walkAtRules(e, r) {
      return r ? e instanceof RegExp ? this.walk((n, i) => {
        if (n.type === "atrule" && e.test(n.name))
          return r(n, i);
      }) : this.walk((n, i) => {
        if (n.type === "atrule" && n.name === e)
          return r(n, i);
      }) : (r = e, this.walk((n, i) => {
        if (n.type === "atrule")
          return r(n, i);
      }));
    }
    walkComments(e) {
      return this.walk((r, n) => {
        if (r.type === "comment")
          return e(r, n);
      });
    }
    walkDecls(e, r) {
      return r ? e instanceof RegExp ? this.walk((n, i) => {
        if (n.type === "decl" && e.test(n.prop))
          return r(n, i);
      }) : this.walk((n, i) => {
        if (n.type === "decl" && n.prop === e)
          return r(n, i);
      }) : (r = e, this.walk((n, i) => {
        if (n.type === "decl")
          return r(n, i);
      }));
    }
    walkRules(e, r) {
      return r ? e instanceof RegExp ? this.walk((n, i) => {
        if (n.type === "rule" && e.test(n.selector))
          return r(n, i);
      }) : this.walk((n, i) => {
        if (n.type === "rule" && n.selector === e)
          return r(n, i);
      }) : (r = e, this.walk((n, i) => {
        if (n.type === "rule")
          return r(n, i);
      }));
    }
    get first() {
      if (!!this.proxyOf.nodes)
        return this.proxyOf.nodes[0];
    }
    get last() {
      if (!!this.proxyOf.nodes)
        return this.proxyOf.nodes[this.proxyOf.nodes.length - 1];
    }
  };
  ae.registerParse = (t) => {
    go = t;
  };
  ae.registerRule = (t) => {
    ui = t;
  };
  ae.registerAtRule = (t) => {
    fi = t;
  };
  ae.registerRoot = (t) => {
    yo = t;
  };
  bo.exports = ae;
  ae.default = ae;
  ae.rebuild = (t) => {
    t.type === "atrule" ? Object.setPrototypeOf(t, fi.prototype) : t.type === "rule" ? Object.setPrototypeOf(t, ui.prototype) : t.type === "decl" ? Object.setPrototypeOf(t, ho.prototype) : t.type === "comment" ? Object.setPrototypeOf(t, mo.prototype) : t.type === "root" && Object.setPrototypeOf(t, yo.prototype), t[po] = true, t.nodes && t.nodes.forEach((e) => {
      ae.rebuild(e);
    });
  };
});
var Ar = S((Mb, ko) => {
  var sd = _e(), xo, So, je = class extends sd {
    constructor(e) {
      super({ type: "document", ...e }), this.nodes || (this.nodes = []);
    }
    toResult(e = {}) {
      return new xo(new So, this, e).stringify();
    }
  };
  je.registerLazyResult = (t) => {
    xo = t;
  };
  je.registerProcessor = (t) => {
    So = t;
  };
  ko.exports = je;
  je.default = je;
});
var ci = S((Fb, Eo) => {
  var Oo = {};
  Eo.exports = function(e) {
    Oo[e] || (Oo[e] = true, typeof console < "u" && console.warn && console.warn(e));
  };
});
var pi = S((Lb, Co) => {
  var _t = class {
    constructor(e, r = {}) {
      if (this.type = "warning", this.text = e, r.node && r.node.source) {
        let n = r.node.rangeBy(r);
        this.line = n.start.line, this.column = n.start.column, this.endLine = n.end.line, this.endColumn = n.end.column;
      }
      for (let n in r)
        this[n] = r[n];
    }
    toString() {
      return this.node ? this.node.error(this.text, { index: this.index, plugin: this.plugin, word: this.word }).message : this.plugin ? this.plugin + ": " + this.text : this.text;
    }
  };
  Co.exports = _t;
  _t.default = _t;
});
var _r = S((Nb, Ao) => {
  var ad = pi(), Tt = class {
    constructor(e, r, n) {
      this.processor = e, this.messages = [], this.root = r, this.opts = n, this.css = undefined, this.map = undefined;
    }
    toString() {
      return this.css;
    }
    warn(e, r = {}) {
      r.plugin || this.lastPlugin && this.lastPlugin.postcssPlugin && (r.plugin = this.lastPlugin.postcssPlugin);
      let n = new ad(e, r);
      return this.messages.push(n), n;
    }
    warnings() {
      return this.messages.filter((e) => e.type === "warning");
    }
    get content() {
      return this.css;
    }
  };
  Ao.exports = Tt;
  Tt.default = Tt;
});
var Ro = S((qb, Io) => {
  var di = "'".charCodeAt(0), _o = '"'.charCodeAt(0), Tr = "\\".charCodeAt(0), To = "/".charCodeAt(0), Pr = `
`.charCodeAt(0), Pt = " ".charCodeAt(0), Ir = "\f".charCodeAt(0), Rr = "	".charCodeAt(0), Dr = "\r".charCodeAt(0), od = "[".charCodeAt(0), ld = "]".charCodeAt(0), ud = "(".charCodeAt(0), fd = ")".charCodeAt(0), cd = "{".charCodeAt(0), pd = "}".charCodeAt(0), dd = ";".charCodeAt(0), hd = "*".charCodeAt(0), md = ":".charCodeAt(0), gd = "@".charCodeAt(0), Mr = /[\t\n\f\r "#'()/;[\\\]{}]/g, Fr = /[\t\n\f\r !"#'():;@[\\\]{}]|\/(?=\*)/g, yd = /.[\r\n"'(/\\]/, Po = /[\da-f]/i;
  Io.exports = function(e, r = {}) {
    let n = e.css.valueOf(), i = r.ignoreErrors, a, s, o2, l, u, f, p, c2, d, h, y = n.length, m = 0, g = [], w = [];
    function b2() {
      return m;
    }
    function v(E) {
      throw e.error("Unclosed " + E, m);
    }
    function O() {
      return w.length === 0 && m >= y;
    }
    function x(E) {
      if (w.length)
        return w.pop();
      if (m >= y)
        return;
      let I = E ? E.ignoreUnclosed : false;
      switch (a = n.charCodeAt(m), a) {
        case Pr:
        case Pt:
        case Rr:
        case Dr:
        case Ir: {
          s = m;
          do
            s += 1, a = n.charCodeAt(s);
          while (a === Pt || a === Pr || a === Rr || a === Dr || a === Ir);
          h = ["space", n.slice(m, s)], m = s - 1;
          break;
        }
        case od:
        case ld:
        case cd:
        case pd:
        case md:
        case dd:
        case fd: {
          let F = String.fromCharCode(a);
          h = [F, F, m];
          break;
        }
        case ud: {
          if (c2 = g.length ? g.pop()[1] : "", d = n.charCodeAt(m + 1), c2 === "url" && d !== di && d !== _o && d !== Pt && d !== Pr && d !== Rr && d !== Ir && d !== Dr) {
            s = m;
            do {
              if (f = false, s = n.indexOf(")", s + 1), s === -1)
                if (i || I) {
                  s = m;
                  break;
                } else
                  v("bracket");
              for (p = s;n.charCodeAt(p - 1) === Tr; )
                p -= 1, f = !f;
            } while (f);
            h = ["brackets", n.slice(m, s + 1), m, s], m = s;
          } else
            s = n.indexOf(")", m + 1), l = n.slice(m, s + 1), s === -1 || yd.test(l) ? h = ["(", "(", m] : (h = ["brackets", l, m, s], m = s);
          break;
        }
        case di:
        case _o: {
          o2 = a === di ? "'" : '"', s = m;
          do {
            if (f = false, s = n.indexOf(o2, s + 1), s === -1)
              if (i || I) {
                s = m + 1;
                break;
              } else
                v("string");
            for (p = s;n.charCodeAt(p - 1) === Tr; )
              p -= 1, f = !f;
          } while (f);
          h = ["string", n.slice(m, s + 1), m, s], m = s;
          break;
        }
        case gd: {
          Mr.lastIndex = m + 1, Mr.test(n), Mr.lastIndex === 0 ? s = n.length - 1 : s = Mr.lastIndex - 2, h = ["at-word", n.slice(m, s + 1), m, s], m = s;
          break;
        }
        case Tr: {
          for (s = m, u = true;n.charCodeAt(s + 1) === Tr; )
            s += 1, u = !u;
          if (a = n.charCodeAt(s + 1), u && a !== To && a !== Pt && a !== Pr && a !== Rr && a !== Dr && a !== Ir && (s += 1, Po.test(n.charAt(s)))) {
            for (;Po.test(n.charAt(s + 1)); )
              s += 1;
            n.charCodeAt(s + 1) === Pt && (s += 1);
          }
          h = ["word", n.slice(m, s + 1), m, s], m = s;
          break;
        }
        default: {
          a === To && n.charCodeAt(m + 1) === hd ? (s = n.indexOf("*/", m + 2) + 1, s === 0 && (i || I ? s = n.length : v("comment")), h = ["comment", n.slice(m, s + 1), m, s], m = s) : (Fr.lastIndex = m + 1, Fr.test(n), Fr.lastIndex === 0 ? s = n.length - 1 : s = Fr.lastIndex - 2, h = ["word", n.slice(m, s + 1), m, s], g.push(h), m = s);
          break;
        }
      }
      return m++, h;
    }
    function A(E) {
      w.push(E);
    }
    return { back: A, endOfFile: O, nextToken: x, position: b2 };
  };
});
var Lr = S(($b, Mo) => {
  var Do = _e(), He = class extends Do {
    constructor(e) {
      super(e), this.type = "atrule";
    }
    append(...e) {
      return this.proxyOf.nodes || (this.nodes = []), super.append(...e);
    }
    prepend(...e) {
      return this.proxyOf.nodes || (this.nodes = []), super.prepend(...e);
    }
  };
  Mo.exports = He;
  He.default = He;
  Do.registerAtRule(He);
});
var Qe = S((Ub, qo) => {
  var Fo = _e(), Lo, No, Te = class extends Fo {
    constructor(e) {
      super(e), this.type = "root", this.nodes || (this.nodes = []);
    }
    normalize(e, r, n) {
      let i = super.normalize(e);
      if (r) {
        if (n === "prepend")
          this.nodes.length > 1 ? r.raws.before = this.nodes[1].raws.before : delete r.raws.before;
        else if (this.first !== r)
          for (let a of i)
            a.raws.before = r.raws.before;
      }
      return i;
    }
    removeChild(e, r) {
      let n = this.index(e);
      return !r && n === 0 && this.nodes.length > 1 && (this.nodes[1].raws.before = this.nodes[n].raws.before), super.removeChild(e);
    }
    toResult(e = {}) {
      return new Lo(new No, this, e).stringify();
    }
  };
  Te.registerLazyResult = (t) => {
    Lo = t;
  };
  Te.registerProcessor = (t) => {
    No = t;
  };
  qo.exports = Te;
  Te.default = Te;
  Fo.registerRoot(Te);
});
var hi = S((jb, $o) => {
  var It = { comma(t) {
    return It.split(t, [","], true);
  }, space(t) {
    let e = [" ", `
`, "	"];
    return It.split(t, e);
  }, split(t, e, r) {
    let n = [], i = "", a = false, s = 0, o2 = false, l = "", u = false;
    for (let f of t)
      u ? u = false : f === "\\" ? u = true : o2 ? f === l && (o2 = false) : f === '"' || f === "'" ? (o2 = true, l = f) : f === "(" ? s += 1 : f === ")" ? s > 0 && (s -= 1) : s === 0 && e.includes(f) && (a = true), a ? (i !== "" && n.push(i.trim()), i = "", a = false) : i += f;
    return (r || i !== "") && n.push(i.trim()), n;
  } };
  $o.exports = It;
  It.default = It;
});
var Nr = S((zb, jo) => {
  var Uo = _e(), vd = hi(), Je = class extends Uo {
    constructor(e) {
      super(e), this.type = "rule", this.nodes || (this.nodes = []);
    }
    get selectors() {
      return vd.comma(this.selector);
    }
    set selectors(e) {
      let r = this.selector ? this.selector.match(/,\s*/) : null, n = r ? r[0] : "," + this.raw("between", "beforeOpen");
      this.selector = e.join(n);
    }
  };
  jo.exports = Je;
  Je.default = Je;
  Uo.registerRule(Je);
});
var Bo = S((Vb, Wo) => {
  var wd = xt(), bd = Ro(), xd = At(), Sd = Lr(), kd = Qe(), zo = Nr(), Vo = { empty: true, space: true };
  function Od(t) {
    for (let e = t.length - 1;e >= 0; e--) {
      let r = t[e], n = r[3] || r[2];
      if (n)
        return n;
    }
  }
  var mi = class {
    constructor(e) {
      this.input = e, this.root = new kd, this.current = this.root, this.spaces = "", this.semicolon = false, this.customProperty = false, this.createTokenizer(), this.root.source = { input: e, start: { column: 1, line: 1, offset: 0 } };
    }
    atrule(e) {
      let r = new Sd;
      r.name = e[1].slice(1), r.name === "" && this.unnamedAtrule(r, e), this.init(r, e[2]);
      let n, i, a, s = false, o2 = false, l = [], u = [];
      for (;!this.tokenizer.endOfFile(); ) {
        if (e = this.tokenizer.nextToken(), n = e[0], n === "(" || n === "[" ? u.push(n === "(" ? ")" : "]") : n === "{" && u.length > 0 ? u.push("}") : n === u[u.length - 1] && u.pop(), u.length === 0)
          if (n === ";") {
            r.source.end = this.getPosition(e[2]), r.source.end.offset++, this.semicolon = true;
            break;
          } else if (n === "{") {
            o2 = true;
            break;
          } else if (n === "}") {
            if (l.length > 0) {
              for (a = l.length - 1, i = l[a];i && i[0] === "space"; )
                i = l[--a];
              i && (r.source.end = this.getPosition(i[3] || i[2]), r.source.end.offset++);
            }
            this.end(e);
            break;
          } else
            l.push(e);
        else
          l.push(e);
        if (this.tokenizer.endOfFile()) {
          s = true;
          break;
        }
      }
      r.raws.between = this.spacesAndCommentsFromEnd(l), l.length ? (r.raws.afterName = this.spacesAndCommentsFromStart(l), this.raw(r, "params", l), s && (e = l[l.length - 1], r.source.end = this.getPosition(e[3] || e[2]), r.source.end.offset++, this.spaces = r.raws.between, r.raws.between = "")) : (r.raws.afterName = "", r.params = ""), o2 && (r.nodes = [], this.current = r);
    }
    checkMissedSemicolon(e) {
      let r = this.colon(e);
      if (r === false)
        return;
      let n = 0, i;
      for (let a = r - 1;a >= 0 && (i = e[a], !(i[0] !== "space" && (n += 1, n === 2))); a--)
        ;
      throw this.input.error("Missed semicolon", i[0] === "word" ? i[3] + 1 : i[2]);
    }
    colon(e) {
      let r = 0, n, i, a;
      for (let [s, o2] of e.entries()) {
        if (n = o2, i = n[0], i === "(" && (r += 1), i === ")" && (r -= 1), r === 0 && i === ":")
          if (!a)
            this.doubleColon(n);
          else {
            if (a[0] === "word" && a[1] === "progid")
              continue;
            return s;
          }
        a = n;
      }
      return false;
    }
    comment(e) {
      let r = new xd;
      this.init(r, e[2]), r.source.end = this.getPosition(e[3] || e[2]), r.source.end.offset++;
      let n = e[1].slice(2, -2);
      if (/^\s*$/.test(n))
        r.text = "", r.raws.left = n, r.raws.right = "";
      else {
        let i = n.match(/^(\s*)([^]*\S)(\s*)$/);
        r.text = i[2], r.raws.left = i[1], r.raws.right = i[3];
      }
    }
    createTokenizer() {
      this.tokenizer = bd(this.input);
    }
    decl(e, r) {
      let n = new wd;
      this.init(n, e[0][2]);
      let i = e[e.length - 1];
      for (i[0] === ";" && (this.semicolon = true, e.pop()), n.source.end = this.getPosition(i[3] || i[2] || Od(e)), n.source.end.offset++;e[0][0] !== "word"; )
        e.length === 1 && this.unknownWord(e), n.raws.before += e.shift()[1];
      for (n.source.start = this.getPosition(e[0][2]), n.prop = "";e.length; ) {
        let u = e[0][0];
        if (u === ":" || u === "space" || u === "comment")
          break;
        n.prop += e.shift()[1];
      }
      n.raws.between = "";
      let a;
      for (;e.length; )
        if (a = e.shift(), a[0] === ":") {
          n.raws.between += a[1];
          break;
        } else
          a[0] === "word" && /\w/.test(a[1]) && this.unknownWord([a]), n.raws.between += a[1];
      (n.prop[0] === "_" || n.prop[0] === "*") && (n.raws.before += n.prop[0], n.prop = n.prop.slice(1));
      let s = [], o2;
      for (;e.length && (o2 = e[0][0], !(o2 !== "space" && o2 !== "comment")); )
        s.push(e.shift());
      this.precheckMissedSemicolon(e);
      for (let u = e.length - 1;u >= 0; u--) {
        if (a = e[u], a[1].toLowerCase() === "!important") {
          n.important = true;
          let f = this.stringFrom(e, u);
          f = this.spacesFromEnd(e) + f, f !== " !important" && (n.raws.important = f);
          break;
        } else if (a[1].toLowerCase() === "important") {
          let f = e.slice(0), p = "";
          for (let c2 = u;c2 > 0; c2--) {
            let d = f[c2][0];
            if (p.trim().indexOf("!") === 0 && d !== "space")
              break;
            p = f.pop()[1] + p;
          }
          p.trim().indexOf("!") === 0 && (n.important = true, n.raws.important = p, e = f);
        }
        if (a[0] !== "space" && a[0] !== "comment")
          break;
      }
      e.some((u) => u[0] !== "space" && u[0] !== "comment") && (n.raws.between += s.map((u) => u[1]).join(""), s = []), this.raw(n, "value", s.concat(e), r), n.value.includes(":") && !r && this.checkMissedSemicolon(e);
    }
    doubleColon(e) {
      throw this.input.error("Double colon", { offset: e[2] }, { offset: e[2] + e[1].length });
    }
    emptyRule(e) {
      let r = new zo;
      this.init(r, e[2]), r.selector = "", r.raws.between = "", this.current = r;
    }
    end(e) {
      this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), this.semicolon = false, this.current.raws.after = (this.current.raws.after || "") + this.spaces, this.spaces = "", this.current.parent ? (this.current.source.end = this.getPosition(e[2]), this.current.source.end.offset++, this.current = this.current.parent) : this.unexpectedClose(e);
    }
    endFile() {
      this.current.parent && this.unclosedBlock(), this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), this.current.raws.after = (this.current.raws.after || "") + this.spaces, this.root.source.end = this.getPosition(this.tokenizer.position());
    }
    freeSemicolon(e) {
      if (this.spaces += e[1], this.current.nodes) {
        let r = this.current.nodes[this.current.nodes.length - 1];
        r && r.type === "rule" && !r.raws.ownSemicolon && (r.raws.ownSemicolon = this.spaces, this.spaces = "");
      }
    }
    getPosition(e) {
      let r = this.input.fromOffset(e);
      return { column: r.col, line: r.line, offset: e };
    }
    init(e, r) {
      this.current.push(e), e.source = { input: this.input, start: this.getPosition(r) }, e.raws.before = this.spaces, this.spaces = "", e.type !== "comment" && (this.semicolon = false);
    }
    other(e) {
      let r = false, n = null, i = false, a = null, s = [], o2 = e[1].startsWith("--"), l = [], u = e;
      for (;u; ) {
        if (n = u[0], l.push(u), n === "(" || n === "[")
          a || (a = u), s.push(n === "(" ? ")" : "]");
        else if (o2 && i && n === "{")
          a || (a = u), s.push("}");
        else if (s.length === 0)
          if (n === ";")
            if (i) {
              this.decl(l, o2);
              return;
            } else
              break;
          else if (n === "{") {
            this.rule(l);
            return;
          } else if (n === "}") {
            this.tokenizer.back(l.pop()), r = true;
            break;
          } else
            n === ":" && (i = true);
        else
          n === s[s.length - 1] && (s.pop(), s.length === 0 && (a = null));
        u = this.tokenizer.nextToken();
      }
      if (this.tokenizer.endOfFile() && (r = true), s.length > 0 && this.unclosedBracket(a), r && i) {
        if (!o2)
          for (;l.length && (u = l[l.length - 1][0], !(u !== "space" && u !== "comment")); )
            this.tokenizer.back(l.pop());
        this.decl(l, o2);
      } else
        this.unknownWord(l);
    }
    parse() {
      let e;
      for (;!this.tokenizer.endOfFile(); )
        switch (e = this.tokenizer.nextToken(), e[0]) {
          case "space":
            this.spaces += e[1];
            break;
          case ";":
            this.freeSemicolon(e);
            break;
          case "}":
            this.end(e);
            break;
          case "comment":
            this.comment(e);
            break;
          case "at-word":
            this.atrule(e);
            break;
          case "{":
            this.emptyRule(e);
            break;
          default:
            this.other(e);
            break;
        }
      this.endFile();
    }
    precheckMissedSemicolon() {
    }
    raw(e, r, n, i) {
      let a, s, o2 = n.length, l = "", u = true, f, p;
      for (let c2 = 0;c2 < o2; c2 += 1)
        a = n[c2], s = a[0], s === "space" && c2 === o2 - 1 && !i ? u = false : s === "comment" ? (p = n[c2 - 1] ? n[c2 - 1][0] : "empty", f = n[c2 + 1] ? n[c2 + 1][0] : "empty", !Vo[p] && !Vo[f] ? l.slice(-1) === "," ? u = false : l += a[1] : u = false) : l += a[1];
      if (!u) {
        let c2 = n.reduce((d, h) => d + h[1], "");
        e.raws[r] = { raw: c2, value: l };
      }
      e[r] = l;
    }
    rule(e) {
      e.pop();
      let r = new zo;
      this.init(r, e[0][2]), r.raws.between = this.spacesAndCommentsFromEnd(e), this.raw(r, "selector", e), this.current = r;
    }
    spacesAndCommentsFromEnd(e) {
      let r, n = "";
      for (;e.length && (r = e[e.length - 1][0], !(r !== "space" && r !== "comment")); )
        n = e.pop()[1] + n;
      return n;
    }
    spacesAndCommentsFromStart(e) {
      let r, n = "";
      for (;e.length && (r = e[0][0], !(r !== "space" && r !== "comment")); )
        n += e.shift()[1];
      return n;
    }
    spacesFromEnd(e) {
      let r, n = "";
      for (;e.length && (r = e[e.length - 1][0], r === "space"); )
        n = e.pop()[1] + n;
      return n;
    }
    stringFrom(e, r) {
      let n = "";
      for (let i = r;i < e.length; i++)
        n += e[i][1];
      return e.splice(r, e.length - r), n;
    }
    unclosedBlock() {
      let e = this.current.source.start;
      throw this.input.error("Unclosed block", e.line, e.column);
    }
    unclosedBracket(e) {
      throw this.input.error("Unclosed bracket", { offset: e[2] }, { offset: e[2] + 1 });
    }
    unexpectedClose(e) {
      throw this.input.error("Unexpected }", { offset: e[2] }, { offset: e[2] + 1 });
    }
    unknownWord(e) {
      throw this.input.error("Unknown word", { offset: e[0][2] }, { offset: e[0][2] + e[0][1].length });
    }
    unnamedAtrule(e, r) {
      throw this.input.error("At-rule without name", { offset: r[2] }, { offset: r[2] + r[1].length });
    }
  };
  Wo.exports = mi;
});
var $r = S((Wb, Go) => {
  var Ed = _e(), Cd = Bo(), Ad = Et();
  function qr(t, e) {
    let r = new Ad(t, e), n = new Cd(r);
    try {
      n.parse();
    } catch (i) {
      throw i;
    }
    return n.root;
  }
  Go.exports = qr;
  qr.default = qr;
  Ed.registerParse(qr);
});
var vi = S((Gb, Jo) => {
  var { isClean: me, my: _d } = xr(), Td = li(), Pd = yt(), Id = _e(), Rd = Ar(), Bb = ci(), Yo = _r(), Dd = $r(), Md = Qe(), Fd = { atrule: "AtRule", comment: "Comment", decl: "Declaration", document: "Document", root: "Root", rule: "Rule" }, Ld = { AtRule: true, AtRuleExit: true, Comment: true, CommentExit: true, Declaration: true, DeclarationExit: true, Document: true, DocumentExit: true, Once: true, OnceExit: true, postcssPlugin: true, prepare: true, Root: true, RootExit: true, Rule: true, RuleExit: true }, Nd = { Once: true, postcssPlugin: true, prepare: true }, Xe = 0;
  function Rt(t) {
    return typeof t == "object" && typeof t.then == "function";
  }
  function Qo(t) {
    let e = false, r = Fd[t.type];
    return t.type === "decl" ? e = t.prop.toLowerCase() : t.type === "atrule" && (e = t.name.toLowerCase()), e && t.append ? [r, r + "-" + e, Xe, r + "Exit", r + "Exit-" + e] : e ? [r, r + "-" + e, r + "Exit", r + "Exit-" + e] : t.append ? [r, Xe, r + "Exit"] : [r, r + "Exit"];
  }
  function Ho(t) {
    let e;
    return t.type === "document" ? e = ["Document", Xe, "DocumentExit"] : t.type === "root" ? e = ["Root", Xe, "RootExit"] : e = Qo(t), { eventIndex: 0, events: e, iterator: 0, node: t, visitorIndex: 0, visitors: [] };
  }
  function gi(t) {
    return t[me] = false, t.nodes && t.nodes.forEach((e) => gi(e)), t;
  }
  var yi = {}, ge = class {
    constructor(e, r, n) {
      this.stringified = false, this.processed = false;
      let i;
      if (typeof r == "object" && r !== null && (r.type === "root" || r.type === "document"))
        i = gi(r);
      else if (r instanceof ge || r instanceof Yo)
        i = gi(r.root), r.map && (typeof n.map > "u" && (n.map = {}), n.map.inline || (n.map.inline = false), n.map.prev = r.map);
      else {
        let a = Dd;
        n.syntax && (a = n.syntax.parse), n.parser && (a = n.parser), a.parse && (a = a.parse);
        try {
          i = a(r, n);
        } catch (s) {
          this.processed = true, this.error = s;
        }
        i && !i[_d] && Id.rebuild(i);
      }
      this.result = new Yo(e, i, n), this.helpers = { ...yi, postcss: yi, result: this.result }, this.plugins = this.processor.plugins.map((a) => typeof a == "object" && a.prepare ? { ...a, ...a.prepare(this.result) } : a);
    }
    async() {
      return this.error ? Promise.reject(this.error) : this.processed ? Promise.resolve(this.result) : (this.processing || (this.processing = this.runAsync()), this.processing);
    }
    catch(e) {
      return this.async().catch(e);
    }
    finally(e) {
      return this.async().then(e, e);
    }
    getAsyncError() {
      throw new Error("Use process(css).then(cb) to work with async plugins");
    }
    handleError(e, r) {
      let n = this.result.lastPlugin;
      try {
        r && r.addToError(e), this.error = e, e.name === "CssSyntaxError" && !e.plugin ? (e.plugin = n.postcssPlugin, e.setMessage()) : n.postcssVersion;
      } catch (i) {
        console && console.error && console.error(i);
      }
      return e;
    }
    prepareVisitors() {
      this.listeners = {};
      let e = (r, n, i) => {
        this.listeners[n] || (this.listeners[n] = []), this.listeners[n].push([r, i]);
      };
      for (let r of this.plugins)
        if (typeof r == "object")
          for (let n in r) {
            if (!Ld[n] && /^[A-Z]/.test(n))
              throw new Error(`Unknown event ${n} in ${r.postcssPlugin}. Try to update PostCSS (${this.processor.version} now).`);
            if (!Nd[n])
              if (typeof r[n] == "object")
                for (let i in r[n])
                  i === "*" ? e(r, n, r[n][i]) : e(r, n + "-" + i.toLowerCase(), r[n][i]);
              else
                typeof r[n] == "function" && e(r, n, r[n]);
          }
      this.hasListener = Object.keys(this.listeners).length > 0;
    }
    async runAsync() {
      this.plugin = 0;
      for (let e = 0;e < this.plugins.length; e++) {
        let r = this.plugins[e], n = this.runOnRoot(r);
        if (Rt(n))
          try {
            await n;
          } catch (i) {
            throw this.handleError(i);
          }
      }
      if (this.prepareVisitors(), this.hasListener) {
        let e = this.result.root;
        for (;!e[me]; ) {
          e[me] = true;
          let r = [Ho(e)];
          for (;r.length > 0; ) {
            let n = this.visitTick(r);
            if (Rt(n))
              try {
                await n;
              } catch (i) {
                let a = r[r.length - 1].node;
                throw this.handleError(i, a);
              }
          }
        }
        if (this.listeners.OnceExit)
          for (let [r, n] of this.listeners.OnceExit) {
            this.result.lastPlugin = r;
            try {
              if (e.type === "document") {
                let i = e.nodes.map((a) => n(a, this.helpers));
                await Promise.all(i);
              } else
                await n(e, this.helpers);
            } catch (i) {
              throw this.handleError(i);
            }
          }
      }
      return this.processed = true, this.stringify();
    }
    runOnRoot(e) {
      this.result.lastPlugin = e;
      try {
        if (typeof e == "object" && e.Once) {
          if (this.result.root.type === "document") {
            let r = this.result.root.nodes.map((n) => e.Once(n, this.helpers));
            return Rt(r[0]) ? Promise.all(r) : r;
          }
          return e.Once(this.result.root, this.helpers);
        } else if (typeof e == "function")
          return e(this.result.root, this.result);
      } catch (r) {
        throw this.handleError(r);
      }
    }
    stringify() {
      if (this.error)
        throw this.error;
      if (this.stringified)
        return this.result;
      this.stringified = true, this.sync();
      let e = this.result.opts, r = Pd;
      e.syntax && (r = e.syntax.stringify), e.stringifier && (r = e.stringifier), r.stringify && (r = r.stringify);
      let i = new Td(r, this.result.root, this.result.opts).generate();
      return this.result.css = i[0], this.result.map = i[1], this.result;
    }
    sync() {
      if (this.error)
        throw this.error;
      if (this.processed)
        return this.result;
      if (this.processed = true, this.processing)
        throw this.getAsyncError();
      for (let e of this.plugins) {
        let r = this.runOnRoot(e);
        if (Rt(r))
          throw this.getAsyncError();
      }
      if (this.prepareVisitors(), this.hasListener) {
        let e = this.result.root;
        for (;!e[me]; )
          e[me] = true, this.walkSync(e);
        if (this.listeners.OnceExit)
          if (e.type === "document")
            for (let r of e.nodes)
              this.visitSync(this.listeners.OnceExit, r);
          else
            this.visitSync(this.listeners.OnceExit, e);
      }
      return this.result;
    }
    then(e, r) {
      return this.async().then(e, r);
    }
    toString() {
      return this.css;
    }
    visitSync(e, r) {
      for (let [n, i] of e) {
        this.result.lastPlugin = n;
        let a;
        try {
          a = i(r, this.helpers);
        } catch (s) {
          throw this.handleError(s, r.proxyOf);
        }
        if (r.type !== "root" && r.type !== "document" && !r.parent)
          return true;
        if (Rt(a))
          throw this.getAsyncError();
      }
    }
    visitTick(e) {
      let r = e[e.length - 1], { node: n, visitors: i } = r;
      if (n.type !== "root" && n.type !== "document" && !n.parent) {
        e.pop();
        return;
      }
      if (i.length > 0 && r.visitorIndex < i.length) {
        let [s, o2] = i[r.visitorIndex];
        r.visitorIndex += 1, r.visitorIndex === i.length && (r.visitors = [], r.visitorIndex = 0), this.result.lastPlugin = s;
        try {
          return o2(n.toProxy(), this.helpers);
        } catch (l) {
          throw this.handleError(l, n);
        }
      }
      if (r.iterator !== 0) {
        let s = r.iterator, o2;
        for (;o2 = n.nodes[n.indexes[s]]; )
          if (n.indexes[s] += 1, !o2[me]) {
            o2[me] = true, e.push(Ho(o2));
            return;
          }
        r.iterator = 0, delete n.indexes[s];
      }
      let a = r.events;
      for (;r.eventIndex < a.length; ) {
        let s = a[r.eventIndex];
        if (r.eventIndex += 1, s === Xe) {
          n.nodes && n.nodes.length && (n[me] = true, r.iterator = n.getIterator());
          return;
        } else if (this.listeners[s]) {
          r.visitors = this.listeners[s];
          return;
        }
      }
      e.pop();
    }
    walkSync(e) {
      e[me] = true;
      let r = Qo(e);
      for (let n of r)
        if (n === Xe)
          e.nodes && e.each((i) => {
            i[me] || this.walkSync(i);
          });
        else {
          let i = this.listeners[n];
          if (i && this.visitSync(i, e.toProxy()))
            return;
        }
    }
    warnings() {
      return this.sync().warnings();
    }
    get content() {
      return this.stringify().content;
    }
    get css() {
      return this.stringify().css;
    }
    get map() {
      return this.stringify().map;
    }
    get messages() {
      return this.sync().messages;
    }
    get opts() {
      return this.result.opts;
    }
    get processor() {
      return this.result.processor;
    }
    get root() {
      return this.sync().root;
    }
    get [Symbol.toStringTag]() {
      return "LazyResult";
    }
  };
  ge.registerPostcss = (t) => {
    yi = t;
  };
  Jo.exports = ge;
  ge.default = ge;
  Md.registerLazyResult(ge);
  Rd.registerLazyResult(ge);
});
var Ko = S((Hb, Xo) => {
  var qd = li(), $d = yt(), Yb = ci(), Ud = $r(), jd = _r(), Dt = class {
    constructor(e, r, n) {
      r = r.toString(), this.stringified = false, this._processor = e, this._css = r, this._opts = n, this._map = undefined;
      let i, a = $d;
      this.result = new jd(this._processor, i, this._opts), this.result.css = r;
      let s = this;
      Object.defineProperty(this.result, "root", { get() {
        return s.root;
      } });
      let o2 = new qd(a, i, this._opts, r);
      if (o2.isMap()) {
        let [l, u] = o2.generate();
        l && (this.result.css = l), u && (this.result.map = u);
      }
    }
    async() {
      return this.error ? Promise.reject(this.error) : Promise.resolve(this.result);
    }
    catch(e) {
      return this.async().catch(e);
    }
    finally(e) {
      return this.async().then(e, e);
    }
    sync() {
      if (this.error)
        throw this.error;
      return this.result;
    }
    then(e, r) {
      return this.async().then(e, r);
    }
    toString() {
      return this._css;
    }
    warnings() {
      return [];
    }
    get content() {
      return this.result.css;
    }
    get css() {
      return this.result.css;
    }
    get map() {
      return this.result.map;
    }
    get messages() {
      return [];
    }
    get opts() {
      return this.result.opts;
    }
    get processor() {
      return this.result.processor;
    }
    get root() {
      if (this._root)
        return this._root;
      let e, r = Ud;
      try {
        e = r(this._css, this._opts);
      } catch (n) {
        this.error = n;
      }
      if (this.error)
        throw this.error;
      return this._root = e, e;
    }
    get [Symbol.toStringTag]() {
      return "NoWorkResult";
    }
  };
  Xo.exports = Dt;
  Dt.default = Dt;
});
var el = S((Qb, Zo) => {
  var zd = Ko(), Vd = vi(), Wd = Ar(), Bd = Qe(), ze = class {
    constructor(e = []) {
      this.version = "8.4.31", this.plugins = this.normalize(e);
    }
    normalize(e) {
      let r = [];
      for (let n of e)
        if (n.postcss === true ? n = n() : n.postcss && (n = n.postcss), typeof n == "object" && Array.isArray(n.plugins))
          r = r.concat(n.plugins);
        else if (typeof n == "object" && n.postcssPlugin)
          r.push(n);
        else if (typeof n == "function")
          r.push(n);
        else if (!(typeof n == "object" && (n.parse || n.stringify)))
          throw new Error(n + " is not a PostCSS plugin");
      return r;
    }
    process(e, r = {}) {
      return this.plugins.length === 0 && typeof r.parser > "u" && typeof r.stringifier > "u" && typeof r.syntax > "u" ? new zd(this, e, r) : new Vd(this, e, r);
    }
    use(e) {
      return this.plugins = this.plugins.concat(this.normalize([e])), this;
    }
  };
  Zo.exports = ze;
  ze.default = ze;
  Bd.registerProcessor(ze);
  Wd.registerProcessor(ze);
});
var rl = S((Jb, tl) => {
  var Gd = xt(), Yd = ri(), Hd = At(), Qd = Lr(), Jd = Et(), Xd = Qe(), Kd = Nr();
  function Mt(t, e) {
    if (Array.isArray(t))
      return t.map((i) => Mt(i));
    let { inputs: r, ...n } = t;
    if (r) {
      e = [];
      for (let i of r) {
        let a = { ...i, __proto__: Jd.prototype };
        a.map && (a.map = { ...a.map, __proto__: Yd.prototype }), e.push(a);
      }
    }
    if (n.nodes && (n.nodes = t.nodes.map((i) => Mt(i, e))), n.source) {
      let { inputId: i, ...a } = n.source;
      n.source = a, i != null && (n.source.input = e[i]);
    }
    if (n.type === "root")
      return new Xd(n);
    if (n.type === "decl")
      return new Gd(n);
    if (n.type === "rule")
      return new Kd(n);
    if (n.type === "comment")
      return new Hd(n);
    if (n.type === "atrule")
      return new Qd(n);
    throw new Error("Unknown node type: " + t.type);
  }
  tl.exports = Mt;
  Mt.default = Mt;
});
var Ke = S((Xb, ul) => {
  var Zd = br(), nl = xt(), eh = vi(), th = _e(), wi = el(), rh = yt(), nh = rl(), il = Ar(), ih = pi(), sl = At(), al = Lr(), sh = _r(), ah = Et(), oh = $r(), lh = hi(), ol = Nr(), ll = Qe(), uh = wt();
  function N(...t) {
    return t.length === 1 && Array.isArray(t[0]) && (t = t[0]), new wi(t);
  }
  N.plugin = function(e, r) {
    let n = false;
    function i(...s) {
      console && console.warn && !n && (n = true, console.warn(e + `: postcss.plugin was deprecated. Migration guide:
https://evilmartians.com/chronicles/postcss-8-plugin-migration`), "en_US.UTF-8".startsWith("cn") && console.warn(e + `: \u91CC\u9762 postcss.plugin \u88AB\u5F03\u7528. \u8FC1\u79FB\u6307\u5357:
https://www.w3ctech.com/topic/2226`));
      let o2 = r(...s);
      return o2.postcssPlugin = e, o2.postcssVersion = new wi().version, o2;
    }
    let a;
    return Object.defineProperty(i, "postcss", { get() {
      return a || (a = i()), a;
    } }), i.process = function(s, o2, l) {
      return N([i(l)]).process(s, o2);
    }, i;
  };
  N.stringify = rh;
  N.parse = oh;
  N.fromJSON = nh;
  N.list = lh;
  N.comment = (t) => new sl(t);
  N.atRule = (t) => new al(t);
  N.decl = (t) => new nl(t);
  N.rule = (t) => new ol(t);
  N.root = (t) => new ll(t);
  N.document = (t) => new il(t);
  N.CssSyntaxError = Zd;
  N.Declaration = nl;
  N.Container = th;
  N.Processor = wi;
  N.Document = il;
  N.Comment = sl;
  N.Warning = ih;
  N.AtRule = al;
  N.Result = sh;
  N.Input = ah;
  N.Rule = ol;
  N.Root = ll;
  N.Node = uh;
  eh.registerPostcss(N);
  ul.exports = N;
  N.default = N;
});
var jr = S((Ur, fl) => {
  Ur.__esModule = true;
  Ur.default = ph;
  function fh(t) {
    for (var e = t.toLowerCase(), r = "", n = false, i = 0;i < 6 && e[i] !== undefined; i++) {
      var a = e.charCodeAt(i), s = a >= 97 && a <= 102 || a >= 48 && a <= 57;
      if (n = a === 32, !s)
        break;
      r += e[i];
    }
    if (r.length !== 0) {
      var o2 = parseInt(r, 16), l = o2 >= 55296 && o2 <= 57343;
      return l || o2 === 0 || o2 > 1114111 ? ["\uFFFD", r.length + (n ? 1 : 0)] : [String.fromCodePoint(o2), r.length + (n ? 1 : 0)];
    }
  }
  var ch = /\\/;
  function ph(t) {
    var e = ch.test(t);
    if (!e)
      return t;
    for (var r = "", n = 0;n < t.length; n++) {
      if (t[n] === "\\") {
        var i = fh(t.slice(n + 1, n + 7));
        if (i !== undefined) {
          r += i[0], n += i[1];
          continue;
        }
        if (t[n + 1] === "\\") {
          r += "\\", n++;
          continue;
        }
        t.length === n + 1 && (r += t[n]);
        continue;
      }
      r += t[n];
    }
    return r;
  }
  fl.exports = Ur.default;
});
var pl = S((zr, cl) => {
  zr.__esModule = true;
  zr.default = dh;
  function dh(t) {
    for (var e = arguments.length, r = new Array(e > 1 ? e - 1 : 0), n = 1;n < e; n++)
      r[n - 1] = arguments[n];
    for (;r.length > 0; ) {
      var i = r.shift();
      if (!t[i])
        return;
      t = t[i];
    }
    return t;
  }
  cl.exports = zr.default;
});
var hl = S((Vr, dl) => {
  Vr.__esModule = true;
  Vr.default = hh;
  function hh(t) {
    for (var e = arguments.length, r = new Array(e > 1 ? e - 1 : 0), n = 1;n < e; n++)
      r[n - 1] = arguments[n];
    for (;r.length > 0; ) {
      var i = r.shift();
      t[i] || (t[i] = {}), t = t[i];
    }
  }
  dl.exports = Vr.default;
});
var gl = S((Wr, ml) => {
  Wr.__esModule = true;
  Wr.default = mh;
  function mh(t) {
    for (var e = "", r = t.indexOf("/*"), n = 0;r >= 0; ) {
      e = e + t.slice(n, r);
      var i = t.indexOf("*/", r + 2);
      if (i < 0)
        return e;
      n = i + 2, r = t.indexOf("/*", n);
    }
    return e = e + t.slice(n), e;
  }
  ml.exports = Wr.default;
});
var Ft = S((ye) => {
  ye.__esModule = true;
  ye.unesc = ye.stripComments = ye.getProp = ye.ensureObject = undefined;
  var gh = Br(jr());
  ye.unesc = gh.default;
  var yh = Br(pl());
  ye.getProp = yh.default;
  var vh = Br(hl());
  ye.ensureObject = vh.default;
  var wh = Br(gl());
  ye.stripComments = wh.default;
  function Br(t) {
    return t && t.__esModule ? t : { default: t };
  }
});
var Oe = S((Lt, wl) => {
  Lt.__esModule = true;
  Lt.default = undefined;
  var yl = Ft();
  function vl(t, e) {
    for (var r = 0;r < e.length; r++) {
      var n = e[r];
      n.enumerable = n.enumerable || false, n.configurable = true, "value" in n && (n.writable = true), Object.defineProperty(t, n.key, n);
    }
  }
  function bh(t, e, r) {
    return e && vl(t.prototype, e), r && vl(t, r), Object.defineProperty(t, "prototype", { writable: false }), t;
  }
  var xh = function t(e, r) {
    if (typeof e != "object" || e === null)
      return e;
    var n = new e.constructor;
    for (var i in e)
      if (!!e.hasOwnProperty(i)) {
        var a = e[i], s = typeof a;
        i === "parent" && s === "object" ? r && (n[i] = r) : a instanceof Array ? n[i] = a.map(function(o2) {
          return t(o2, n);
        }) : n[i] = t(a, n);
      }
    return n;
  }, Sh = function() {
    function t(r) {
      r === undefined && (r = {}), Object.assign(this, r), this.spaces = this.spaces || {}, this.spaces.before = this.spaces.before || "", this.spaces.after = this.spaces.after || "";
    }
    var e = t.prototype;
    return e.remove = function() {
      return this.parent && this.parent.removeChild(this), this.parent = undefined, this;
    }, e.replaceWith = function() {
      if (this.parent) {
        for (var n in arguments)
          this.parent.insertBefore(this, arguments[n]);
        this.remove();
      }
      return this;
    }, e.next = function() {
      return this.parent.at(this.parent.index(this) + 1);
    }, e.prev = function() {
      return this.parent.at(this.parent.index(this) - 1);
    }, e.clone = function(n) {
      n === undefined && (n = {});
      var i = xh(this);
      for (var a in n)
        i[a] = n[a];
      return i;
    }, e.appendToPropertyAndEscape = function(n, i, a) {
      this.raws || (this.raws = {});
      var s = this[n], o2 = this.raws[n];
      this[n] = s + i, o2 || a !== i ? this.raws[n] = (o2 || s) + a : delete this.raws[n];
    }, e.setPropertyAndEscape = function(n, i, a) {
      this.raws || (this.raws = {}), this[n] = i, this.raws[n] = a;
    }, e.setPropertyWithoutEscape = function(n, i) {
      this[n] = i, this.raws && delete this.raws[n];
    }, e.isAtPosition = function(n, i) {
      if (this.source && this.source.start && this.source.end)
        return !(this.source.start.line > n || this.source.end.line < n || this.source.start.line === n && this.source.start.column > i || this.source.end.line === n && this.source.end.column < i);
    }, e.stringifyProperty = function(n) {
      return this.raws && this.raws[n] || this[n];
    }, e.valueToString = function() {
      return String(this.stringifyProperty("value"));
    }, e.toString = function() {
      return [this.rawSpaceBefore, this.valueToString(), this.rawSpaceAfter].join("");
    }, bh(t, [{ key: "rawSpaceBefore", get: function() {
      var n = this.raws && this.raws.spaces && this.raws.spaces.before;
      return n === undefined && (n = this.spaces && this.spaces.before), n || "";
    }, set: function(n) {
      (0, yl.ensureObject)(this, "raws", "spaces"), this.raws.spaces.before = n;
    } }, { key: "rawSpaceAfter", get: function() {
      var n = this.raws && this.raws.spaces && this.raws.spaces.after;
      return n === undefined && (n = this.spaces.after), n || "";
    }, set: function(n) {
      (0, yl.ensureObject)(this, "raws", "spaces"), this.raws.spaces.after = n;
    } }]), t;
  }();
  Lt.default = Sh;
  wl.exports = Lt.default;
});
var J = S((U) => {
  U.__esModule = true;
  U.UNIVERSAL = U.TAG = U.STRING = U.SELECTOR = U.ROOT = U.PSEUDO = U.NESTING = U.ID = U.COMMENT = U.COMBINATOR = U.CLASS = U.ATTRIBUTE = undefined;
  var kh = "tag";
  U.TAG = kh;
  var Oh = "string";
  U.STRING = Oh;
  var Eh = "selector";
  U.SELECTOR = Eh;
  var Ch = "root";
  U.ROOT = Ch;
  var Ah = "pseudo";
  U.PSEUDO = Ah;
  var _h = "nesting";
  U.NESTING = _h;
  var Th = "id";
  U.ID = Th;
  var Ph = "comment";
  U.COMMENT = Ph;
  var Ih = "combinator";
  U.COMBINATOR = Ih;
  var Rh = "class";
  U.CLASS = Rh;
  var Dh = "attribute";
  U.ATTRIBUTE = Dh;
  var Mh = "universal";
  U.UNIVERSAL = Mh;
});
var Gr = S((Nt, kl) => {
  Nt.__esModule = true;
  Nt.default = undefined;
  var Fh = Nh(Oe()), Ee = Lh(J());
  function Sl(t) {
    if (typeof WeakMap != "function")
      return null;
    var e = new WeakMap, r = new WeakMap;
    return (Sl = function(i) {
      return i ? r : e;
    })(t);
  }
  function Lh(t, e) {
    if (!e && t && t.__esModule)
      return t;
    if (t === null || typeof t != "object" && typeof t != "function")
      return { default: t };
    var r = Sl(e);
    if (r && r.has(t))
      return r.get(t);
    var n = {}, i = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var a in t)
      if (a !== "default" && Object.prototype.hasOwnProperty.call(t, a)) {
        var s = i ? Object.getOwnPropertyDescriptor(t, a) : null;
        s && (s.get || s.set) ? Object.defineProperty(n, a, s) : n[a] = t[a];
      }
    return n.default = t, r && r.set(t, n), n;
  }
  function Nh(t) {
    return t && t.__esModule ? t : { default: t };
  }
  function qh(t, e) {
    var r = typeof Symbol < "u" && t[Symbol.iterator] || t["@@iterator"];
    if (r)
      return (r = r.call(t)).next.bind(r);
    if (Array.isArray(t) || (r = $h(t)) || e && t && typeof t.length == "number") {
      r && (t = r);
      var n = 0;
      return function() {
        return n >= t.length ? { done: true } : { done: false, value: t[n++] };
      };
    }
    throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  function $h(t, e) {
    if (!!t) {
      if (typeof t == "string")
        return bl(t, e);
      var r = Object.prototype.toString.call(t).slice(8, -1);
      if (r === "Object" && t.constructor && (r = t.constructor.name), r === "Map" || r === "Set")
        return Array.from(t);
      if (r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r))
        return bl(t, e);
    }
  }
  function bl(t, e) {
    (e == null || e > t.length) && (e = t.length);
    for (var r = 0, n = new Array(e);r < e; r++)
      n[r] = t[r];
    return n;
  }
  function xl(t, e) {
    for (var r = 0;r < e.length; r++) {
      var n = e[r];
      n.enumerable = n.enumerable || false, n.configurable = true, "value" in n && (n.writable = true), Object.defineProperty(t, n.key, n);
    }
  }
  function Uh(t, e, r) {
    return e && xl(t.prototype, e), r && xl(t, r), Object.defineProperty(t, "prototype", { writable: false }), t;
  }
  function jh(t, e) {
    t.prototype = Object.create(e.prototype), t.prototype.constructor = t, bi(t, e);
  }
  function bi(t, e) {
    return bi = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n, i) {
      return n.__proto__ = i, n;
    }, bi(t, e);
  }
  var zh = function(t) {
    jh(e, t);
    function e(n) {
      var i;
      return i = t.call(this, n) || this, i.nodes || (i.nodes = []), i;
    }
    var r = e.prototype;
    return r.append = function(i) {
      return i.parent = this, this.nodes.push(i), this;
    }, r.prepend = function(i) {
      return i.parent = this, this.nodes.unshift(i), this;
    }, r.at = function(i) {
      return this.nodes[i];
    }, r.index = function(i) {
      return typeof i == "number" ? i : this.nodes.indexOf(i);
    }, r.removeChild = function(i) {
      i = this.index(i), this.at(i).parent = undefined, this.nodes.splice(i, 1);
      var a;
      for (var s in this.indexes)
        a = this.indexes[s], a >= i && (this.indexes[s] = a - 1);
      return this;
    }, r.removeAll = function() {
      for (var i = qh(this.nodes), a;!(a = i()).done; ) {
        var s = a.value;
        s.parent = undefined;
      }
      return this.nodes = [], this;
    }, r.empty = function() {
      return this.removeAll();
    }, r.insertAfter = function(i, a) {
      a.parent = this;
      var s = this.index(i);
      this.nodes.splice(s + 1, 0, a), a.parent = this;
      var o2;
      for (var l in this.indexes)
        o2 = this.indexes[l], s <= o2 && (this.indexes[l] = o2 + 1);
      return this;
    }, r.insertBefore = function(i, a) {
      a.parent = this;
      var s = this.index(i);
      this.nodes.splice(s, 0, a), a.parent = this;
      var o2;
      for (var l in this.indexes)
        o2 = this.indexes[l], o2 <= s && (this.indexes[l] = o2 + 1);
      return this;
    }, r._findChildAtPosition = function(i, a) {
      var s = undefined;
      return this.each(function(o2) {
        if (o2.atPosition) {
          var l = o2.atPosition(i, a);
          if (l)
            return s = l, false;
        } else if (o2.isAtPosition(i, a))
          return s = o2, false;
      }), s;
    }, r.atPosition = function(i, a) {
      if (this.isAtPosition(i, a))
        return this._findChildAtPosition(i, a) || this;
    }, r._inferEndPosition = function() {
      this.last && this.last.source && this.last.source.end && (this.source = this.source || {}, this.source.end = this.source.end || {}, Object.assign(this.source.end, this.last.source.end));
    }, r.each = function(i) {
      this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach++;
      var a = this.lastEach;
      if (this.indexes[a] = 0, !!this.length) {
        for (var s, o2;this.indexes[a] < this.length && (s = this.indexes[a], o2 = i(this.at(s), s), o2 !== false); )
          this.indexes[a] += 1;
        if (delete this.indexes[a], o2 === false)
          return false;
      }
    }, r.walk = function(i) {
      return this.each(function(a, s) {
        var o2 = i(a, s);
        if (o2 !== false && a.length && (o2 = a.walk(i)), o2 === false)
          return false;
      });
    }, r.walkAttributes = function(i) {
      var a = this;
      return this.walk(function(s) {
        if (s.type === Ee.ATTRIBUTE)
          return i.call(a, s);
      });
    }, r.walkClasses = function(i) {
      var a = this;
      return this.walk(function(s) {
        if (s.type === Ee.CLASS)
          return i.call(a, s);
      });
    }, r.walkCombinators = function(i) {
      var a = this;
      return this.walk(function(s) {
        if (s.type === Ee.COMBINATOR)
          return i.call(a, s);
      });
    }, r.walkComments = function(i) {
      var a = this;
      return this.walk(function(s) {
        if (s.type === Ee.COMMENT)
          return i.call(a, s);
      });
    }, r.walkIds = function(i) {
      var a = this;
      return this.walk(function(s) {
        if (s.type === Ee.ID)
          return i.call(a, s);
      });
    }, r.walkNesting = function(i) {
      var a = this;
      return this.walk(function(s) {
        if (s.type === Ee.NESTING)
          return i.call(a, s);
      });
    }, r.walkPseudos = function(i) {
      var a = this;
      return this.walk(function(s) {
        if (s.type === Ee.PSEUDO)
          return i.call(a, s);
      });
    }, r.walkTags = function(i) {
      var a = this;
      return this.walk(function(s) {
        if (s.type === Ee.TAG)
          return i.call(a, s);
      });
    }, r.walkUniversals = function(i) {
      var a = this;
      return this.walk(function(s) {
        if (s.type === Ee.UNIVERSAL)
          return i.call(a, s);
      });
    }, r.split = function(i) {
      var a = this, s = [];
      return this.reduce(function(o2, l, u) {
        var f = i.call(a, l);
        return s.push(l), f ? (o2.push(s), s = []) : u === a.length - 1 && o2.push(s), o2;
      }, []);
    }, r.map = function(i) {
      return this.nodes.map(i);
    }, r.reduce = function(i, a) {
      return this.nodes.reduce(i, a);
    }, r.every = function(i) {
      return this.nodes.every(i);
    }, r.some = function(i) {
      return this.nodes.some(i);
    }, r.filter = function(i) {
      return this.nodes.filter(i);
    }, r.sort = function(i) {
      return this.nodes.sort(i);
    }, r.toString = function() {
      return this.map(String).join("");
    }, Uh(e, [{ key: "first", get: function() {
      return this.at(0);
    } }, { key: "last", get: function() {
      return this.at(this.length - 1);
    } }, { key: "length", get: function() {
      return this.nodes.length;
    } }]), e;
  }(Fh.default);
  Nt.default = zh;
  kl.exports = Nt.default;
});
var Si = S((qt, El) => {
  qt.__esModule = true;
  qt.default = undefined;
  var Vh = Bh(Gr()), Wh = J();
  function Bh(t) {
    return t && t.__esModule ? t : { default: t };
  }
  function Ol(t, e) {
    for (var r = 0;r < e.length; r++) {
      var n = e[r];
      n.enumerable = n.enumerable || false, n.configurable = true, "value" in n && (n.writable = true), Object.defineProperty(t, n.key, n);
    }
  }
  function Gh(t, e, r) {
    return e && Ol(t.prototype, e), r && Ol(t, r), Object.defineProperty(t, "prototype", { writable: false }), t;
  }
  function Yh(t, e) {
    t.prototype = Object.create(e.prototype), t.prototype.constructor = t, xi(t, e);
  }
  function xi(t, e) {
    return xi = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n, i) {
      return n.__proto__ = i, n;
    }, xi(t, e);
  }
  var Hh = function(t) {
    Yh(e, t);
    function e(n) {
      var i;
      return i = t.call(this, n) || this, i.type = Wh.ROOT, i;
    }
    var r = e.prototype;
    return r.toString = function() {
      var i = this.reduce(function(a, s) {
        return a.push(String(s)), a;
      }, []).join(",");
      return this.trailingComma ? i + "," : i;
    }, r.error = function(i, a) {
      return this._error ? this._error(i, a) : new Error(i);
    }, Gh(e, [{ key: "errorGenerator", set: function(i) {
      this._error = i;
    } }]), e;
  }(Vh.default);
  qt.default = Hh;
  El.exports = qt.default;
});
var Oi = S(($t, Cl) => {
  $t.__esModule = true;
  $t.default = undefined;
  var Qh = Xh(Gr()), Jh = J();
  function Xh(t) {
    return t && t.__esModule ? t : { default: t };
  }
  function Kh(t, e) {
    t.prototype = Object.create(e.prototype), t.prototype.constructor = t, ki(t, e);
  }
  function ki(t, e) {
    return ki = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n, i) {
      return n.__proto__ = i, n;
    }, ki(t, e);
  }
  var Zh = function(t) {
    Kh(e, t);
    function e(r) {
      var n;
      return n = t.call(this, r) || this, n.type = Jh.SELECTOR, n;
    }
    return e;
  }(Qh.default);
  $t.default = Zh;
  Cl.exports = $t.default;
});
var Yr = S((Ex, Al) => {
  var em = {}, tm = em.hasOwnProperty, rm = function(e, r) {
    if (!e)
      return r;
    var n = {};
    for (var i in r)
      n[i] = tm.call(e, i) ? e[i] : r[i];
    return n;
  }, nm = /[ -,\.\/:-@\[-\^`\{-~]/, im = /[ -,\.\/:-@\[\]\^`\{-~]/, sm = /(^|\\+)?(\\[A-F0-9]{1,6})\x20(?![a-fA-F0-9\x20])/g, Ei = function t(e, r) {
    r = rm(r, t.options), r.quotes != "single" && r.quotes != "double" && (r.quotes = "single");
    for (var n = r.quotes == "double" ? '"' : "'", i = r.isIdentifier, a = e.charAt(0), s = "", o2 = 0, l = e.length;o2 < l; ) {
      var u = e.charAt(o2++), f = u.charCodeAt(), p = undefined;
      if (f < 32 || f > 126) {
        if (f >= 55296 && f <= 56319 && o2 < l) {
          var c2 = e.charCodeAt(o2++);
          (c2 & 64512) == 56320 ? f = ((f & 1023) << 10) + (c2 & 1023) + 65536 : o2--;
        }
        p = "\\" + f.toString(16).toUpperCase() + " ";
      } else
        r.escapeEverything ? nm.test(u) ? p = "\\" + u : p = "\\" + f.toString(16).toUpperCase() + " " : /[\t\n\f\r\x0B]/.test(u) ? p = "\\" + f.toString(16).toUpperCase() + " " : u == "\\" || !i && (u == '"' && n == u || u == "'" && n == u) || i && im.test(u) ? p = "\\" + u : p = u;
      s += p;
    }
    return i && (/^-[-\d]/.test(s) ? s = "\\-" + s.slice(1) : /\d/.test(a) && (s = "\\3" + a + " " + s.slice(1))), s = s.replace(sm, function(d, h, y) {
      return h && h.length % 2 ? d : (h || "") + y;
    }), !i && r.wrap ? n + s + n : s;
  };
  Ei.options = { escapeEverything: false, isIdentifier: false, quotes: "single", wrap: false };
  Ei.version = "3.0.0";
  Al.exports = Ei;
});
var Ai = S((Ut, Pl) => {
  Ut.__esModule = true;
  Ut.default = undefined;
  var am = Tl(Yr()), om = Ft(), lm = Tl(Oe()), um = J();
  function Tl(t) {
    return t && t.__esModule ? t : { default: t };
  }
  function _l(t, e) {
    for (var r = 0;r < e.length; r++) {
      var n = e[r];
      n.enumerable = n.enumerable || false, n.configurable = true, "value" in n && (n.writable = true), Object.defineProperty(t, n.key, n);
    }
  }
  function fm(t, e, r) {
    return e && _l(t.prototype, e), r && _l(t, r), Object.defineProperty(t, "prototype", { writable: false }), t;
  }
  function cm(t, e) {
    t.prototype = Object.create(e.prototype), t.prototype.constructor = t, Ci(t, e);
  }
  function Ci(t, e) {
    return Ci = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n, i) {
      return n.__proto__ = i, n;
    }, Ci(t, e);
  }
  var pm = function(t) {
    cm(e, t);
    function e(n) {
      var i;
      return i = t.call(this, n) || this, i.type = um.CLASS, i._constructed = true, i;
    }
    var r = e.prototype;
    return r.valueToString = function() {
      return "." + t.prototype.valueToString.call(this);
    }, fm(e, [{ key: "value", get: function() {
      return this._value;
    }, set: function(i) {
      if (this._constructed) {
        var a = (0, am.default)(i, { isIdentifier: true });
        a !== i ? ((0, om.ensureObject)(this, "raws"), this.raws.value = a) : this.raws && delete this.raws.value;
      }
      this._value = i;
    } }]), e;
  }(lm.default);
  Ut.default = pm;
  Pl.exports = Ut.default;
});
var Ti = S((jt, Il) => {
  jt.__esModule = true;
  jt.default = undefined;
  var dm = mm(Oe()), hm = J();
  function mm(t) {
    return t && t.__esModule ? t : { default: t };
  }
  function gm(t, e) {
    t.prototype = Object.create(e.prototype), t.prototype.constructor = t, _i(t, e);
  }
  function _i(t, e) {
    return _i = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n, i) {
      return n.__proto__ = i, n;
    }, _i(t, e);
  }
  var ym = function(t) {
    gm(e, t);
    function e(r) {
      var n;
      return n = t.call(this, r) || this, n.type = hm.COMMENT, n;
    }
    return e;
  }(dm.default);
  jt.default = ym;
  Il.exports = jt.default;
});
var Ii = S((zt, Rl) => {
  zt.__esModule = true;
  zt.default = undefined;
  var vm = bm(Oe()), wm = J();
  function bm(t) {
    return t && t.__esModule ? t : { default: t };
  }
  function xm(t, e) {
    t.prototype = Object.create(e.prototype), t.prototype.constructor = t, Pi(t, e);
  }
  function Pi(t, e) {
    return Pi = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n, i) {
      return n.__proto__ = i, n;
    }, Pi(t, e);
  }
  var Sm = function(t) {
    xm(e, t);
    function e(n) {
      var i;
      return i = t.call(this, n) || this, i.type = wm.ID, i;
    }
    var r = e.prototype;
    return r.valueToString = function() {
      return "#" + t.prototype.valueToString.call(this);
    }, e;
  }(vm.default);
  zt.default = Sm;
  Rl.exports = zt.default;
});
var Hr2 = S((Vt, Fl) => {
  Vt.__esModule = true;
  Vt.default = undefined;
  var km = Ml(Yr()), Om = Ft(), Em = Ml(Oe());
  function Ml(t) {
    return t && t.__esModule ? t : { default: t };
  }
  function Dl(t, e) {
    for (var r = 0;r < e.length; r++) {
      var n = e[r];
      n.enumerable = n.enumerable || false, n.configurable = true, "value" in n && (n.writable = true), Object.defineProperty(t, n.key, n);
    }
  }
  function Cm(t, e, r) {
    return e && Dl(t.prototype, e), r && Dl(t, r), Object.defineProperty(t, "prototype", { writable: false }), t;
  }
  function Am(t, e) {
    t.prototype = Object.create(e.prototype), t.prototype.constructor = t, Ri(t, e);
  }
  function Ri(t, e) {
    return Ri = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n, i) {
      return n.__proto__ = i, n;
    }, Ri(t, e);
  }
  var _m = function(t) {
    Am(e, t);
    function e() {
      return t.apply(this, arguments) || this;
    }
    var r = e.prototype;
    return r.qualifiedName = function(i) {
      return this.namespace ? this.namespaceString + "|" + i : i;
    }, r.valueToString = function() {
      return this.qualifiedName(t.prototype.valueToString.call(this));
    }, Cm(e, [{ key: "namespace", get: function() {
      return this._namespace;
    }, set: function(i) {
      if (i === true || i === "*" || i === "&") {
        this._namespace = i, this.raws && delete this.raws.namespace;
        return;
      }
      var a = (0, km.default)(i, { isIdentifier: true });
      this._namespace = i, a !== i ? ((0, Om.ensureObject)(this, "raws"), this.raws.namespace = a) : this.raws && delete this.raws.namespace;
    } }, { key: "ns", get: function() {
      return this._namespace;
    }, set: function(i) {
      this.namespace = i;
    } }, { key: "namespaceString", get: function() {
      if (this.namespace) {
        var i = this.stringifyProperty("namespace");
        return i === true ? "" : i;
      } else
        return "";
    } }]), e;
  }(Em.default);
  Vt.default = _m;
  Fl.exports = Vt.default;
});
var Mi = S((Wt, Ll) => {
  Wt.__esModule = true;
  Wt.default = undefined;
  var Tm = Im(Hr2()), Pm = J();
  function Im(t) {
    return t && t.__esModule ? t : { default: t };
  }
  function Rm(t, e) {
    t.prototype = Object.create(e.prototype), t.prototype.constructor = t, Di(t, e);
  }
  function Di(t, e) {
    return Di = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n, i) {
      return n.__proto__ = i, n;
    }, Di(t, e);
  }
  var Dm = function(t) {
    Rm(e, t);
    function e(r) {
      var n;
      return n = t.call(this, r) || this, n.type = Pm.TAG, n;
    }
    return e;
  }(Tm.default);
  Wt.default = Dm;
  Ll.exports = Wt.default;
});
var Li = S((Bt, Nl) => {
  Bt.__esModule = true;
  Bt.default = undefined;
  var Mm = Lm(Oe()), Fm = J();
  function Lm(t) {
    return t && t.__esModule ? t : { default: t };
  }
  function Nm(t, e) {
    t.prototype = Object.create(e.prototype), t.prototype.constructor = t, Fi(t, e);
  }
  function Fi(t, e) {
    return Fi = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n, i) {
      return n.__proto__ = i, n;
    }, Fi(t, e);
  }
  var qm = function(t) {
    Nm(e, t);
    function e(r) {
      var n;
      return n = t.call(this, r) || this, n.type = Fm.STRING, n;
    }
    return e;
  }(Mm.default);
  Bt.default = qm;
  Nl.exports = Bt.default;
});
var qi = S((Gt, ql) => {
  Gt.__esModule = true;
  Gt.default = undefined;
  var $m = jm(Gr()), Um = J();
  function jm(t) {
    return t && t.__esModule ? t : { default: t };
  }
  function zm(t, e) {
    t.prototype = Object.create(e.prototype), t.prototype.constructor = t, Ni(t, e);
  }
  function Ni(t, e) {
    return Ni = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n, i) {
      return n.__proto__ = i, n;
    }, Ni(t, e);
  }
  var Vm = function(t) {
    zm(e, t);
    function e(n) {
      var i;
      return i = t.call(this, n) || this, i.type = Um.PSEUDO, i;
    }
    var r = e.prototype;
    return r.toString = function() {
      var i = this.length ? "(" + this.map(String).join(",") + ")" : "";
      return [this.rawSpaceBefore, this.stringifyProperty("value"), i, this.rawSpaceAfter].join("");
    }, e;
  }($m.default);
  Gt.default = Vm;
  ql.exports = Gt.default;
});
var Ul = S((Cx, $l) => {
  $l.exports = Wm;
  function Wm(t, e) {
    if ($i("noDeprecation"))
      return t;
    var r = false;
    function n() {
      if (!r) {
        if ($i("throwDeprecation"))
          throw new Error(e);
        $i("traceDeprecation") ? console.trace(e) : console.warn(e), r = true;
      }
      return t.apply(this, arguments);
    }
    return n;
  }
  function $i(t) {
    try {
      if (!global.localStorage)
        return false;
    } catch {
      return false;
    }
    var e = global.localStorage[t];
    return e == null ? false : String(e).toLowerCase() === "true";
  }
});
var Bi = S((Qt) => {
  Qt.__esModule = true;
  Qt.default = undefined;
  Qt.unescapeValue = Wi;
  var Yt = Vi(Yr()), Bm = Vi(jr()), Gm = Vi(Hr2()), Ym = J(), Ui;
  function Vi(t) {
    return t && t.__esModule ? t : { default: t };
  }
  function jl(t, e) {
    for (var r = 0;r < e.length; r++) {
      var n = e[r];
      n.enumerable = n.enumerable || false, n.configurable = true, "value" in n && (n.writable = true), Object.defineProperty(t, n.key, n);
    }
  }
  function Hm(t, e, r) {
    return e && jl(t.prototype, e), r && jl(t, r), Object.defineProperty(t, "prototype", { writable: false }), t;
  }
  function Qm(t, e) {
    t.prototype = Object.create(e.prototype), t.prototype.constructor = t, zi(t, e);
  }
  function zi(t, e) {
    return zi = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n, i) {
      return n.__proto__ = i, n;
    }, zi(t, e);
  }
  var Ht = Ul(), Jm = /^('|")([^]*)\1$/, Xm = Ht(function() {
  }, "Assigning an attribute a value containing characters that might need to be escaped is deprecated. Call attribute.setValue() instead."), Km = Ht(function() {
  }, "Assigning attr.quoted is deprecated and has no effect. Assign to attr.quoteMark instead."), Zm = Ht(function() {
  }, "Constructing an Attribute selector with a value without specifying quoteMark is deprecated. Note: The value should be unescaped now.");
  function Wi(t) {
    var e = false, r = null, n = t, i = n.match(Jm);
    return i && (r = i[1], n = i[2]), n = (0, Bm.default)(n), n !== t && (e = true), { deprecatedUsage: e, unescaped: n, quoteMark: r };
  }
  function eg(t) {
    if (t.quoteMark !== undefined || t.value === undefined)
      return t;
    Zm();
    var e = Wi(t.value), r = e.quoteMark, n = e.unescaped;
    return t.raws || (t.raws = {}), t.raws.value === undefined && (t.raws.value = t.value), t.value = n, t.quoteMark = r, t;
  }
  var Qr = function(t) {
    Qm(e, t);
    function e(n) {
      var i;
      return n === undefined && (n = {}), i = t.call(this, eg(n)) || this, i.type = Ym.ATTRIBUTE, i.raws = i.raws || {}, Object.defineProperty(i.raws, "unquoted", { get: Ht(function() {
        return i.value;
      }, "attr.raws.unquoted is deprecated. Call attr.value instead."), set: Ht(function() {
        return i.value;
      }, "Setting attr.raws.unquoted is deprecated and has no effect. attr.value is unescaped by default now.") }), i._constructed = true, i;
    }
    var r = e.prototype;
    return r.getQuotedValue = function(i) {
      i === undefined && (i = {});
      var a = this._determineQuoteMark(i), s = ji[a], o2 = (0, Yt.default)(this._value, s);
      return o2;
    }, r._determineQuoteMark = function(i) {
      return i.smart ? this.smartQuoteMark(i) : this.preferredQuoteMark(i);
    }, r.setValue = function(i, a) {
      a === undefined && (a = {}), this._value = i, this._quoteMark = this._determineQuoteMark(a), this._syncRawValue();
    }, r.smartQuoteMark = function(i) {
      var a = this.value, s = a.replace(/[^']/g, "").length, o2 = a.replace(/[^"]/g, "").length;
      if (s + o2 === 0) {
        var l = (0, Yt.default)(a, { isIdentifier: true });
        if (l === a)
          return e.NO_QUOTE;
        var u = this.preferredQuoteMark(i);
        if (u === e.NO_QUOTE) {
          var f = this.quoteMark || i.quoteMark || e.DOUBLE_QUOTE, p = ji[f], c2 = (0, Yt.default)(a, p);
          if (c2.length < l.length)
            return f;
        }
        return u;
      } else
        return o2 === s ? this.preferredQuoteMark(i) : o2 < s ? e.DOUBLE_QUOTE : e.SINGLE_QUOTE;
    }, r.preferredQuoteMark = function(i) {
      var a = i.preferCurrentQuoteMark ? this.quoteMark : i.quoteMark;
      return a === undefined && (a = i.preferCurrentQuoteMark ? i.quoteMark : this.quoteMark), a === undefined && (a = e.DOUBLE_QUOTE), a;
    }, r._syncRawValue = function() {
      var i = (0, Yt.default)(this._value, ji[this.quoteMark]);
      i === this._value ? this.raws && delete this.raws.value : this.raws.value = i;
    }, r._handleEscapes = function(i, a) {
      if (this._constructed) {
        var s = (0, Yt.default)(a, { isIdentifier: true });
        s !== a ? this.raws[i] = s : delete this.raws[i];
      }
    }, r._spacesFor = function(i) {
      var a = { before: "", after: "" }, s = this.spaces[i] || {}, o2 = this.raws.spaces && this.raws.spaces[i] || {};
      return Object.assign(a, s, o2);
    }, r._stringFor = function(i, a, s) {
      a === undefined && (a = i), s === undefined && (s = zl);
      var o2 = this._spacesFor(a);
      return s(this.stringifyProperty(i), o2);
    }, r.offsetOf = function(i) {
      var a = 1, s = this._spacesFor("attribute");
      if (a += s.before.length, i === "namespace" || i === "ns")
        return this.namespace ? a : -1;
      if (i === "attributeNS" || (a += this.namespaceString.length, this.namespace && (a += 1), i === "attribute"))
        return a;
      a += this.stringifyProperty("attribute").length, a += s.after.length;
      var o2 = this._spacesFor("operator");
      a += o2.before.length;
      var l = this.stringifyProperty("operator");
      if (i === "operator")
        return l ? a : -1;
      a += l.length, a += o2.after.length;
      var u = this._spacesFor("value");
      a += u.before.length;
      var f = this.stringifyProperty("value");
      if (i === "value")
        return f ? a : -1;
      a += f.length, a += u.after.length;
      var p = this._spacesFor("insensitive");
      return a += p.before.length, i === "insensitive" && this.insensitive ? a : -1;
    }, r.toString = function() {
      var i = this, a = [this.rawSpaceBefore, "["];
      return a.push(this._stringFor("qualifiedAttribute", "attribute")), this.operator && (this.value || this.value === "") && (a.push(this._stringFor("operator")), a.push(this._stringFor("value")), a.push(this._stringFor("insensitiveFlag", "insensitive", function(s, o2) {
        return s.length > 0 && !i.quoted && o2.before.length === 0 && !(i.spaces.value && i.spaces.value.after) && (o2.before = " "), zl(s, o2);
      }))), a.push("]"), a.push(this.rawSpaceAfter), a.join("");
    }, Hm(e, [{ key: "quoted", get: function() {
      var i = this.quoteMark;
      return i === "'" || i === '"';
    }, set: function(i) {
      Km();
    } }, { key: "quoteMark", get: function() {
      return this._quoteMark;
    }, set: function(i) {
      if (!this._constructed) {
        this._quoteMark = i;
        return;
      }
      this._quoteMark !== i && (this._quoteMark = i, this._syncRawValue());
    } }, { key: "qualifiedAttribute", get: function() {
      return this.qualifiedName(this.raws.attribute || this.attribute);
    } }, { key: "insensitiveFlag", get: function() {
      return this.insensitive ? "i" : "";
    } }, { key: "value", get: function() {
      return this._value;
    }, set: function(i) {
      if (this._constructed) {
        var a = Wi(i), s = a.deprecatedUsage, o2 = a.unescaped, l = a.quoteMark;
        if (s && Xm(), o2 === this._value && l === this._quoteMark)
          return;
        this._value = o2, this._quoteMark = l, this._syncRawValue();
      } else
        this._value = i;
    } }, { key: "insensitive", get: function() {
      return this._insensitive;
    }, set: function(i) {
      i || (this._insensitive = false, this.raws && (this.raws.insensitiveFlag === "I" || this.raws.insensitiveFlag === "i") && (this.raws.insensitiveFlag = undefined)), this._insensitive = i;
    } }, { key: "attribute", get: function() {
      return this._attribute;
    }, set: function(i) {
      this._handleEscapes("attribute", i), this._attribute = i;
    } }]), e;
  }(Gm.default);
  Qt.default = Qr;
  Qr.NO_QUOTE = null;
  Qr.SINGLE_QUOTE = "'";
  Qr.DOUBLE_QUOTE = '"';
  var ji = (Ui = { "'": { quotes: "single", wrap: true }, '"': { quotes: "double", wrap: true } }, Ui[null] = { isIdentifier: true }, Ui);
  function zl(t, e) {
    return "" + e.before + t + e.after;
  }
});
var Yi = S((Jt, Vl) => {
  Jt.__esModule = true;
  Jt.default = undefined;
  var tg = ng(Hr2()), rg = J();
  function ng(t) {
    return t && t.__esModule ? t : { default: t };
  }
  function ig(t, e) {
    t.prototype = Object.create(e.prototype), t.prototype.constructor = t, Gi(t, e);
  }
  function Gi(t, e) {
    return Gi = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n, i) {
      return n.__proto__ = i, n;
    }, Gi(t, e);
  }
  var sg = function(t) {
    ig(e, t);
    function e(r) {
      var n;
      return n = t.call(this, r) || this, n.type = rg.UNIVERSAL, n.value = "*", n;
    }
    return e;
  }(tg.default);
  Jt.default = sg;
  Vl.exports = Jt.default;
});
var Qi = S((Xt, Wl) => {
  Xt.__esModule = true;
  Xt.default = undefined;
  var ag = lg(Oe()), og = J();
  function lg(t) {
    return t && t.__esModule ? t : { default: t };
  }
  function ug(t, e) {
    t.prototype = Object.create(e.prototype), t.prototype.constructor = t, Hi(t, e);
  }
  function Hi(t, e) {
    return Hi = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n, i) {
      return n.__proto__ = i, n;
    }, Hi(t, e);
  }
  var fg = function(t) {
    ug(e, t);
    function e(r) {
      var n;
      return n = t.call(this, r) || this, n.type = og.COMBINATOR, n;
    }
    return e;
  }(ag.default);
  Xt.default = fg;
  Wl.exports = Xt.default;
});
var Xi = S((Kt, Bl) => {
  Kt.__esModule = true;
  Kt.default = undefined;
  var cg = dg(Oe()), pg = J();
  function dg(t) {
    return t && t.__esModule ? t : { default: t };
  }
  function hg(t, e) {
    t.prototype = Object.create(e.prototype), t.prototype.constructor = t, Ji(t, e);
  }
  function Ji(t, e) {
    return Ji = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n, i) {
      return n.__proto__ = i, n;
    }, Ji(t, e);
  }
  var mg = function(t) {
    hg(e, t);
    function e(r) {
      var n;
      return n = t.call(this, r) || this, n.type = pg.NESTING, n.value = "&", n;
    }
    return e;
  }(cg.default);
  Kt.default = mg;
  Bl.exports = Kt.default;
});
var Yl = S((Jr, Gl) => {
  Jr.__esModule = true;
  Jr.default = gg;
  function gg(t) {
    return t.sort(function(e, r) {
      return e - r;
    });
  }
  Gl.exports = Jr.default;
});
var Ki = S((P) => {
  P.__esModule = true;
  P.word = P.tilde = P.tab = P.str = P.space = P.slash = P.singleQuote = P.semicolon = P.plus = P.pipe = P.openSquare = P.openParenthesis = P.newline = P.greaterThan = P.feed = P.equals = P.doubleQuote = P.dollar = P.cr = P.comment = P.comma = P.combinator = P.colon = P.closeSquare = P.closeParenthesis = P.caret = P.bang = P.backslash = P.at = P.asterisk = P.ampersand = undefined;
  var yg = 38;
  P.ampersand = yg;
  var vg = 42;
  P.asterisk = vg;
  var wg = 64;
  P.at = wg;
  var bg = 44;
  P.comma = bg;
  var xg = 58;
  P.colon = xg;
  var Sg = 59;
  P.semicolon = Sg;
  var kg = 40;
  P.openParenthesis = kg;
  var Og = 41;
  P.closeParenthesis = Og;
  var Eg = 91;
  P.openSquare = Eg;
  var Cg = 93;
  P.closeSquare = Cg;
  var Ag = 36;
  P.dollar = Ag;
  var _g = 126;
  P.tilde = _g;
  var Tg = 94;
  P.caret = Tg;
  var Pg = 43;
  P.plus = Pg;
  var Ig = 61;
  P.equals = Ig;
  var Rg = 124;
  P.pipe = Rg;
  var Dg = 62;
  P.greaterThan = Dg;
  var Mg = 32;
  P.space = Mg;
  var Hl = 39;
  P.singleQuote = Hl;
  var Fg = 34;
  P.doubleQuote = Fg;
  var Lg = 47;
  P.slash = Lg;
  var Ng = 33;
  P.bang = Ng;
  var qg = 92;
  P.backslash = qg;
  var $g = 13;
  P.cr = $g;
  var Ug = 12;
  P.feed = Ug;
  var jg = 10;
  P.newline = jg;
  var zg = 9;
  P.tab = zg;
  var Vg = Hl;
  P.str = Vg;
  var Wg = -1;
  P.comment = Wg;
  var Bg = -2;
  P.word = Bg;
  var Gg = -3;
  P.combinator = Gg;
});
var Xl = S((Zt) => {
  Zt.__esModule = true;
  Zt.FIELDS = undefined;
  Zt.default = Zg;
  var C = Yg(Ki()), Ze, q;
  function Jl(t) {
    if (typeof WeakMap != "function")
      return null;
    var e = new WeakMap, r = new WeakMap;
    return (Jl = function(i) {
      return i ? r : e;
    })(t);
  }
  function Yg(t, e) {
    if (!e && t && t.__esModule)
      return t;
    if (t === null || typeof t != "object" && typeof t != "function")
      return { default: t };
    var r = Jl(e);
    if (r && r.has(t))
      return r.get(t);
    var n = {}, i = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var a in t)
      if (a !== "default" && Object.prototype.hasOwnProperty.call(t, a)) {
        var s = i ? Object.getOwnPropertyDescriptor(t, a) : null;
        s && (s.get || s.set) ? Object.defineProperty(n, a, s) : n[a] = t[a];
      }
    return n.default = t, r && r.set(t, n), n;
  }
  var Hg = (Ze = {}, Ze[C.tab] = true, Ze[C.newline] = true, Ze[C.cr] = true, Ze[C.feed] = true, Ze), Qg = (q = {}, q[C.space] = true, q[C.tab] = true, q[C.newline] = true, q[C.cr] = true, q[C.feed] = true, q[C.ampersand] = true, q[C.asterisk] = true, q[C.bang] = true, q[C.comma] = true, q[C.colon] = true, q[C.semicolon] = true, q[C.openParenthesis] = true, q[C.closeParenthesis] = true, q[C.openSquare] = true, q[C.closeSquare] = true, q[C.singleQuote] = true, q[C.doubleQuote] = true, q[C.plus] = true, q[C.pipe] = true, q[C.tilde] = true, q[C.greaterThan] = true, q[C.equals] = true, q[C.dollar] = true, q[C.caret] = true, q[C.slash] = true, q), Zi = {}, Ql = "0123456789abcdefABCDEF";
  for (Xr = 0;Xr < Ql.length; Xr++)
    Zi[Ql.charCodeAt(Xr)] = true;
  var Xr;
  function Jg(t, e) {
    var r = e, n;
    do {
      if (n = t.charCodeAt(r), Qg[n])
        return r - 1;
      n === C.backslash ? r = Xg(t, r) + 1 : r++;
    } while (r < t.length);
    return r - 1;
  }
  function Xg(t, e) {
    var r = e, n = t.charCodeAt(r + 1);
    if (!Hg[n])
      if (Zi[n]) {
        var i = 0;
        do
          r++, i++, n = t.charCodeAt(r + 1);
        while (Zi[n] && i < 6);
        i < 6 && n === C.space && r++;
      } else
        r++;
    return r;
  }
  var Kg = { TYPE: 0, START_LINE: 1, START_COL: 2, END_LINE: 3, END_COL: 4, START_POS: 5, END_POS: 6 };
  Zt.FIELDS = Kg;
  function Zg(t) {
    var e = [], r = t.css.valueOf(), n = r, i = n.length, a = -1, s = 1, o2 = 0, l = 0, u, f, p, c2, d, h, y, m, g, w, b2, v, O;
    function x(A, E) {
      if (t.safe)
        r += E, g = r.length - 1;
      else
        throw t.error("Unclosed " + A, s, o2 - a, o2);
    }
    for (;o2 < i; ) {
      switch (u = r.charCodeAt(o2), u === C.newline && (a = o2, s += 1), u) {
        case C.space:
        case C.tab:
        case C.newline:
        case C.cr:
        case C.feed:
          g = o2;
          do
            g += 1, u = r.charCodeAt(g), u === C.newline && (a = g, s += 1);
          while (u === C.space || u === C.newline || u === C.tab || u === C.cr || u === C.feed);
          O = C.space, c2 = s, p = g - a - 1, l = g;
          break;
        case C.plus:
        case C.greaterThan:
        case C.tilde:
        case C.pipe:
          g = o2;
          do
            g += 1, u = r.charCodeAt(g);
          while (u === C.plus || u === C.greaterThan || u === C.tilde || u === C.pipe);
          O = C.combinator, c2 = s, p = o2 - a, l = g;
          break;
        case C.asterisk:
        case C.ampersand:
        case C.bang:
        case C.comma:
        case C.equals:
        case C.dollar:
        case C.caret:
        case C.openSquare:
        case C.closeSquare:
        case C.colon:
        case C.semicolon:
        case C.openParenthesis:
        case C.closeParenthesis:
          g = o2, O = u, c2 = s, p = o2 - a, l = g + 1;
          break;
        case C.singleQuote:
        case C.doubleQuote:
          v = u === C.singleQuote ? "'" : '"', g = o2;
          do
            for (d = false, g = r.indexOf(v, g + 1), g === -1 && x("quote", v), h = g;r.charCodeAt(h - 1) === C.backslash; )
              h -= 1, d = !d;
          while (d);
          O = C.str, c2 = s, p = o2 - a, l = g + 1;
          break;
        default:
          u === C.slash && r.charCodeAt(o2 + 1) === C.asterisk ? (g = r.indexOf("*/", o2 + 2) + 1, g === 0 && x("comment", "*/"), f = r.slice(o2, g + 1), m = f.split(`
`), y = m.length - 1, y > 0 ? (w = s + y, b2 = g - m[y].length) : (w = s, b2 = a), O = C.comment, s = w, c2 = w, p = g - b2) : u === C.slash ? (g = o2, O = u, c2 = s, p = o2 - a, l = g + 1) : (g = Jg(r, o2), O = C.word, c2 = s, p = g - a), l = g + 1;
          break;
      }
      e.push([O, s, o2 - a, c2, p, o2, l]), b2 && (a = b2, b2 = null), o2 = l;
    }
    return e;
  }
});
var su = S((er, iu) => {
  er.__esModule = true;
  er.default = undefined;
  var ey = le(Si()), es = le(Oi()), ty = le(Ai()), Kl = le(Ti()), ry = le(Ii()), ny = le(Mi()), ts = le(Li()), iy = le(qi()), Zl = Kr(Bi()), sy = le(Yi()), rs = le(Qi()), ay = le(Xi()), oy = le(Yl()), k = Kr(Xl()), _ = Kr(Ki()), ly = Kr(J()), V = Ft(), Ve, ns;
  function nu(t) {
    if (typeof WeakMap != "function")
      return null;
    var e = new WeakMap, r = new WeakMap;
    return (nu = function(i) {
      return i ? r : e;
    })(t);
  }
  function Kr(t, e) {
    if (!e && t && t.__esModule)
      return t;
    if (t === null || typeof t != "object" && typeof t != "function")
      return { default: t };
    var r = nu(e);
    if (r && r.has(t))
      return r.get(t);
    var n = {}, i = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var a in t)
      if (a !== "default" && Object.prototype.hasOwnProperty.call(t, a)) {
        var s = i ? Object.getOwnPropertyDescriptor(t, a) : null;
        s && (s.get || s.set) ? Object.defineProperty(n, a, s) : n[a] = t[a];
      }
    return n.default = t, r && r.set(t, n), n;
  }
  function le(t) {
    return t && t.__esModule ? t : { default: t };
  }
  function eu(t, e) {
    for (var r = 0;r < e.length; r++) {
      var n = e[r];
      n.enumerable = n.enumerable || false, n.configurable = true, "value" in n && (n.writable = true), Object.defineProperty(t, n.key, n);
    }
  }
  function uy(t, e, r) {
    return e && eu(t.prototype, e), r && eu(t, r), Object.defineProperty(t, "prototype", { writable: false }), t;
  }
  var as = (Ve = {}, Ve[_.space] = true, Ve[_.cr] = true, Ve[_.feed] = true, Ve[_.newline] = true, Ve[_.tab] = true, Ve), fy = Object.assign({}, as, (ns = {}, ns[_.comment] = true, ns));
  function tu(t) {
    return { line: t[k.FIELDS.START_LINE], column: t[k.FIELDS.START_COL] };
  }
  function ru(t) {
    return { line: t[k.FIELDS.END_LINE], column: t[k.FIELDS.END_COL] };
  }
  function We(t, e, r, n) {
    return { start: { line: t, column: e }, end: { line: r, column: n } };
  }
  function et(t) {
    return We(t[k.FIELDS.START_LINE], t[k.FIELDS.START_COL], t[k.FIELDS.END_LINE], t[k.FIELDS.END_COL]);
  }
  function is2(t, e) {
    if (!!t)
      return We(t[k.FIELDS.START_LINE], t[k.FIELDS.START_COL], e[k.FIELDS.END_LINE], e[k.FIELDS.END_COL]);
  }
  function tt(t, e) {
    var r = t[e];
    if (typeof r == "string")
      return r.indexOf("\\") !== -1 && ((0, V.ensureObject)(t, "raws"), t[e] = (0, V.unesc)(r), t.raws[e] === undefined && (t.raws[e] = r)), t;
  }
  function ss(t, e) {
    for (var r = -1, n = [];(r = t.indexOf(e, r + 1)) !== -1; )
      n.push(r);
    return n;
  }
  function cy() {
    var t = Array.prototype.concat.apply([], arguments);
    return t.filter(function(e, r) {
      return r === t.indexOf(e);
    });
  }
  var py = function() {
    function t(r, n) {
      n === undefined && (n = {}), this.rule = r, this.options = Object.assign({ lossy: false, safe: false }, n), this.position = 0, this.css = typeof this.rule == "string" ? this.rule : this.rule.selector, this.tokens = (0, k.default)({ css: this.css, error: this._errorGenerator(), safe: this.options.safe });
      var i = is2(this.tokens[0], this.tokens[this.tokens.length - 1]);
      this.root = new ey.default({ source: i }), this.root.errorGenerator = this._errorGenerator();
      var a = new es.default({ source: { start: { line: 1, column: 1 } } });
      this.root.append(a), this.current = a, this.loop();
    }
    var e = t.prototype;
    return e._errorGenerator = function() {
      var n = this;
      return function(i, a) {
        return typeof n.rule == "string" ? new Error(i) : n.rule.error(i, a);
      };
    }, e.attribute = function() {
      var n = [], i = this.currToken;
      for (this.position++;this.position < this.tokens.length && this.currToken[k.FIELDS.TYPE] !== _.closeSquare; )
        n.push(this.currToken), this.position++;
      if (this.currToken[k.FIELDS.TYPE] !== _.closeSquare)
        return this.expected("closing square bracket", this.currToken[k.FIELDS.START_POS]);
      var a = n.length, s = { source: We(i[1], i[2], this.currToken[3], this.currToken[4]), sourceIndex: i[k.FIELDS.START_POS] };
      if (a === 1 && !~[_.word].indexOf(n[0][k.FIELDS.TYPE]))
        return this.expected("attribute", n[0][k.FIELDS.START_POS]);
      for (var o2 = 0, l = "", u = "", f = null, p = false;o2 < a; ) {
        var c2 = n[o2], d = this.content(c2), h = n[o2 + 1];
        switch (c2[k.FIELDS.TYPE]) {
          case _.space:
            if (p = true, this.options.lossy)
              break;
            if (f) {
              (0, V.ensureObject)(s, "spaces", f);
              var y = s.spaces[f].after || "";
              s.spaces[f].after = y + d;
              var m = (0, V.getProp)(s, "raws", "spaces", f, "after") || null;
              m && (s.raws.spaces[f].after = m + d);
            } else
              l = l + d, u = u + d;
            break;
          case _.asterisk:
            if (h[k.FIELDS.TYPE] === _.equals)
              s.operator = d, f = "operator";
            else if ((!s.namespace || f === "namespace" && !p) && h) {
              l && ((0, V.ensureObject)(s, "spaces", "attribute"), s.spaces.attribute.before = l, l = ""), u && ((0, V.ensureObject)(s, "raws", "spaces", "attribute"), s.raws.spaces.attribute.before = l, u = ""), s.namespace = (s.namespace || "") + d;
              var g = (0, V.getProp)(s, "raws", "namespace") || null;
              g && (s.raws.namespace += d), f = "namespace";
            }
            p = false;
            break;
          case _.dollar:
            if (f === "value") {
              var w = (0, V.getProp)(s, "raws", "value");
              s.value += "$", w && (s.raws.value = w + "$");
              break;
            }
          case _.caret:
            h[k.FIELDS.TYPE] === _.equals && (s.operator = d, f = "operator"), p = false;
            break;
          case _.combinator:
            if (d === "~" && h[k.FIELDS.TYPE] === _.equals && (s.operator = d, f = "operator"), d !== "|") {
              p = false;
              break;
            }
            h[k.FIELDS.TYPE] === _.equals ? (s.operator = d, f = "operator") : !s.namespace && !s.attribute && (s.namespace = true), p = false;
            break;
          case _.word:
            if (h && this.content(h) === "|" && n[o2 + 2] && n[o2 + 2][k.FIELDS.TYPE] !== _.equals && !s.operator && !s.namespace)
              s.namespace = d, f = "namespace";
            else if (!s.attribute || f === "attribute" && !p) {
              l && ((0, V.ensureObject)(s, "spaces", "attribute"), s.spaces.attribute.before = l, l = ""), u && ((0, V.ensureObject)(s, "raws", "spaces", "attribute"), s.raws.spaces.attribute.before = u, u = ""), s.attribute = (s.attribute || "") + d;
              var b2 = (0, V.getProp)(s, "raws", "attribute") || null;
              b2 && (s.raws.attribute += d), f = "attribute";
            } else if (!s.value && s.value !== "" || f === "value" && !(p || s.quoteMark)) {
              var v = (0, V.unesc)(d), O = (0, V.getProp)(s, "raws", "value") || "", x = s.value || "";
              s.value = x + v, s.quoteMark = null, (v !== d || O) && ((0, V.ensureObject)(s, "raws"), s.raws.value = (O || x) + d), f = "value";
            } else {
              var A = d === "i" || d === "I";
              (s.value || s.value === "") && (s.quoteMark || p) ? (s.insensitive = A, (!A || d === "I") && ((0, V.ensureObject)(s, "raws"), s.raws.insensitiveFlag = d), f = "insensitive", l && ((0, V.ensureObject)(s, "spaces", "insensitive"), s.spaces.insensitive.before = l, l = ""), u && ((0, V.ensureObject)(s, "raws", "spaces", "insensitive"), s.raws.spaces.insensitive.before = u, u = "")) : (s.value || s.value === "") && (f = "value", s.value += d, s.raws.value && (s.raws.value += d));
            }
            p = false;
            break;
          case _.str:
            if (!s.attribute || !s.operator)
              return this.error("Expected an attribute followed by an operator preceding the string.", { index: c2[k.FIELDS.START_POS] });
            var E = (0, Zl.unescapeValue)(d), I = E.unescaped, F = E.quoteMark;
            s.value = I, s.quoteMark = F, f = "value", (0, V.ensureObject)(s, "raws"), s.raws.value = d, p = false;
            break;
          case _.equals:
            if (!s.attribute)
              return this.expected("attribute", c2[k.FIELDS.START_POS], d);
            if (s.value)
              return this.error('Unexpected "=" found; an operator was already defined.', { index: c2[k.FIELDS.START_POS] });
            s.operator = s.operator ? s.operator + d : d, f = "operator", p = false;
            break;
          case _.comment:
            if (f)
              if (p || h && h[k.FIELDS.TYPE] === _.space || f === "insensitive") {
                var Y = (0, V.getProp)(s, "spaces", f, "after") || "", K = (0, V.getProp)(s, "raws", "spaces", f, "after") || Y;
                (0, V.ensureObject)(s, "raws", "spaces", f), s.raws.spaces[f].after = K + d;
              } else {
                var B = s[f] || "", qe = (0, V.getProp)(s, "raws", f) || B;
                (0, V.ensureObject)(s, "raws"), s.raws[f] = qe + d;
              }
            else
              u = u + d;
            break;
          default:
            return this.error('Unexpected "' + d + '" found.', { index: c2[k.FIELDS.START_POS] });
        }
        o2++;
      }
      tt(s, "attribute"), tt(s, "namespace"), this.newNode(new Zl.default(s)), this.position++;
    }, e.parseWhitespaceEquivalentTokens = function(n) {
      n < 0 && (n = this.tokens.length);
      var i = this.position, a = [], s = "", o2 = undefined;
      do
        if (as[this.currToken[k.FIELDS.TYPE]])
          this.options.lossy || (s += this.content());
        else if (this.currToken[k.FIELDS.TYPE] === _.comment) {
          var l = {};
          s && (l.before = s, s = ""), o2 = new Kl.default({ value: this.content(), source: et(this.currToken), sourceIndex: this.currToken[k.FIELDS.START_POS], spaces: l }), a.push(o2);
        }
      while (++this.position < n);
      if (s) {
        if (o2)
          o2.spaces.after = s;
        else if (!this.options.lossy) {
          var u = this.tokens[i], f = this.tokens[this.position - 1];
          a.push(new ts.default({ value: "", source: We(u[k.FIELDS.START_LINE], u[k.FIELDS.START_COL], f[k.FIELDS.END_LINE], f[k.FIELDS.END_COL]), sourceIndex: u[k.FIELDS.START_POS], spaces: { before: s, after: "" } }));
        }
      }
      return a;
    }, e.convertWhitespaceNodesToSpace = function(n, i) {
      var a = this;
      i === undefined && (i = false);
      var s = "", o2 = "";
      n.forEach(function(u) {
        var f = a.lossySpace(u.spaces.before, i), p = a.lossySpace(u.rawSpaceBefore, i);
        s += f + a.lossySpace(u.spaces.after, i && f.length === 0), o2 += f + u.value + a.lossySpace(u.rawSpaceAfter, i && p.length === 0);
      }), o2 === s && (o2 = undefined);
      var l = { space: s, rawSpace: o2 };
      return l;
    }, e.isNamedCombinator = function(n) {
      return n === undefined && (n = this.position), this.tokens[n + 0] && this.tokens[n + 0][k.FIELDS.TYPE] === _.slash && this.tokens[n + 1] && this.tokens[n + 1][k.FIELDS.TYPE] === _.word && this.tokens[n + 2] && this.tokens[n + 2][k.FIELDS.TYPE] === _.slash;
    }, e.namedCombinator = function() {
      if (this.isNamedCombinator()) {
        var n = this.content(this.tokens[this.position + 1]), i = (0, V.unesc)(n).toLowerCase(), a = {};
        i !== n && (a.value = "/" + n + "/");
        var s = new rs.default({ value: "/" + i + "/", source: We(this.currToken[k.FIELDS.START_LINE], this.currToken[k.FIELDS.START_COL], this.tokens[this.position + 2][k.FIELDS.END_LINE], this.tokens[this.position + 2][k.FIELDS.END_COL]), sourceIndex: this.currToken[k.FIELDS.START_POS], raws: a });
        return this.position = this.position + 3, s;
      } else
        this.unexpected();
    }, e.combinator = function() {
      var n = this;
      if (this.content() === "|")
        return this.namespace();
      var i = this.locateNextMeaningfulToken(this.position);
      if (i < 0 || this.tokens[i][k.FIELDS.TYPE] === _.comma) {
        var a = this.parseWhitespaceEquivalentTokens(i);
        if (a.length > 0) {
          var s = this.current.last;
          if (s) {
            var o2 = this.convertWhitespaceNodesToSpace(a), l = o2.space, u = o2.rawSpace;
            u !== undefined && (s.rawSpaceAfter += u), s.spaces.after += l;
          } else
            a.forEach(function(O) {
              return n.newNode(O);
            });
        }
        return;
      }
      var f = this.currToken, p = undefined;
      i > this.position && (p = this.parseWhitespaceEquivalentTokens(i));
      var c2;
      if (this.isNamedCombinator() ? c2 = this.namedCombinator() : this.currToken[k.FIELDS.TYPE] === _.combinator ? (c2 = new rs.default({ value: this.content(), source: et(this.currToken), sourceIndex: this.currToken[k.FIELDS.START_POS] }), this.position++) : as[this.currToken[k.FIELDS.TYPE]] || p || this.unexpected(), c2) {
        if (p) {
          var d = this.convertWhitespaceNodesToSpace(p), h = d.space, y = d.rawSpace;
          c2.spaces.before = h, c2.rawSpaceBefore = y;
        }
      } else {
        var m = this.convertWhitespaceNodesToSpace(p, true), g = m.space, w = m.rawSpace;
        w || (w = g);
        var b2 = {}, v = { spaces: {} };
        g.endsWith(" ") && w.endsWith(" ") ? (b2.before = g.slice(0, g.length - 1), v.spaces.before = w.slice(0, w.length - 1)) : g.startsWith(" ") && w.startsWith(" ") ? (b2.after = g.slice(1), v.spaces.after = w.slice(1)) : v.value = w, c2 = new rs.default({ value: " ", source: is2(f, this.tokens[this.position - 1]), sourceIndex: f[k.FIELDS.START_POS], spaces: b2, raws: v });
      }
      return this.currToken && this.currToken[k.FIELDS.TYPE] === _.space && (c2.spaces.after = this.optionalSpace(this.content()), this.position++), this.newNode(c2);
    }, e.comma = function() {
      if (this.position === this.tokens.length - 1) {
        this.root.trailingComma = true, this.position++;
        return;
      }
      this.current._inferEndPosition();
      var n = new es.default({ source: { start: tu(this.tokens[this.position + 1]) } });
      this.current.parent.append(n), this.current = n, this.position++;
    }, e.comment = function() {
      var n = this.currToken;
      this.newNode(new Kl.default({ value: this.content(), source: et(n), sourceIndex: n[k.FIELDS.START_POS] })), this.position++;
    }, e.error = function(n, i) {
      throw this.root.error(n, i);
    }, e.missingBackslash = function() {
      return this.error("Expected a backslash preceding the semicolon.", { index: this.currToken[k.FIELDS.START_POS] });
    }, e.missingParenthesis = function() {
      return this.expected("opening parenthesis", this.currToken[k.FIELDS.START_POS]);
    }, e.missingSquareBracket = function() {
      return this.expected("opening square bracket", this.currToken[k.FIELDS.START_POS]);
    }, e.unexpected = function() {
      return this.error("Unexpected '" + this.content() + "'. Escaping special characters with \\ may help.", this.currToken[k.FIELDS.START_POS]);
    }, e.unexpectedPipe = function() {
      return this.error("Unexpected '|'.", this.currToken[k.FIELDS.START_POS]);
    }, e.namespace = function() {
      var n = this.prevToken && this.content(this.prevToken) || true;
      if (this.nextToken[k.FIELDS.TYPE] === _.word)
        return this.position++, this.word(n);
      if (this.nextToken[k.FIELDS.TYPE] === _.asterisk)
        return this.position++, this.universal(n);
      this.unexpectedPipe();
    }, e.nesting = function() {
      if (this.nextToken) {
        var n = this.content(this.nextToken);
        if (n === "|") {
          this.position++;
          return;
        }
      }
      var i = this.currToken;
      this.newNode(new ay.default({ value: this.content(), source: et(i), sourceIndex: i[k.FIELDS.START_POS] })), this.position++;
    }, e.parentheses = function() {
      var n = this.current.last, i = 1;
      if (this.position++, n && n.type === ly.PSEUDO) {
        var a = new es.default({ source: { start: tu(this.tokens[this.position - 1]) } }), s = this.current;
        for (n.append(a), this.current = a;this.position < this.tokens.length && i; )
          this.currToken[k.FIELDS.TYPE] === _.openParenthesis && i++, this.currToken[k.FIELDS.TYPE] === _.closeParenthesis && i--, i ? this.parse() : (this.current.source.end = ru(this.currToken), this.current.parent.source.end = ru(this.currToken), this.position++);
        this.current = s;
      } else {
        for (var o2 = this.currToken, l = "(", u;this.position < this.tokens.length && i; )
          this.currToken[k.FIELDS.TYPE] === _.openParenthesis && i++, this.currToken[k.FIELDS.TYPE] === _.closeParenthesis && i--, u = this.currToken, l += this.parseParenthesisToken(this.currToken), this.position++;
        n ? n.appendToPropertyAndEscape("value", l, l) : this.newNode(new ts.default({ value: l, source: We(o2[k.FIELDS.START_LINE], o2[k.FIELDS.START_COL], u[k.FIELDS.END_LINE], u[k.FIELDS.END_COL]), sourceIndex: o2[k.FIELDS.START_POS] }));
      }
      if (i)
        return this.expected("closing parenthesis", this.currToken[k.FIELDS.START_POS]);
    }, e.pseudo = function() {
      for (var n = this, i = "", a = this.currToken;this.currToken && this.currToken[k.FIELDS.TYPE] === _.colon; )
        i += this.content(), this.position++;
      if (!this.currToken)
        return this.expected(["pseudo-class", "pseudo-element"], this.position - 1);
      if (this.currToken[k.FIELDS.TYPE] === _.word)
        this.splitWord(false, function(s, o2) {
          i += s, n.newNode(new iy.default({ value: i, source: is2(a, n.currToken), sourceIndex: a[k.FIELDS.START_POS] })), o2 > 1 && n.nextToken && n.nextToken[k.FIELDS.TYPE] === _.openParenthesis && n.error("Misplaced parenthesis.", { index: n.nextToken[k.FIELDS.START_POS] });
        });
      else
        return this.expected(["pseudo-class", "pseudo-element"], this.currToken[k.FIELDS.START_POS]);
    }, e.space = function() {
      var n = this.content();
      this.position === 0 || this.prevToken[k.FIELDS.TYPE] === _.comma || this.prevToken[k.FIELDS.TYPE] === _.openParenthesis || this.current.nodes.every(function(i) {
        return i.type === "comment";
      }) ? (this.spaces = this.optionalSpace(n), this.position++) : this.position === this.tokens.length - 1 || this.nextToken[k.FIELDS.TYPE] === _.comma || this.nextToken[k.FIELDS.TYPE] === _.closeParenthesis ? (this.current.last.spaces.after = this.optionalSpace(n), this.position++) : this.combinator();
    }, e.string = function() {
      var n = this.currToken;
      this.newNode(new ts.default({ value: this.content(), source: et(n), sourceIndex: n[k.FIELDS.START_POS] })), this.position++;
    }, e.universal = function(n) {
      var i = this.nextToken;
      if (i && this.content(i) === "|")
        return this.position++, this.namespace();
      var a = this.currToken;
      this.newNode(new sy.default({ value: this.content(), source: et(a), sourceIndex: a[k.FIELDS.START_POS] }), n), this.position++;
    }, e.splitWord = function(n, i) {
      for (var a = this, s = this.nextToken, o2 = this.content();s && ~[_.dollar, _.caret, _.equals, _.word].indexOf(s[k.FIELDS.TYPE]); ) {
        this.position++;
        var l = this.content();
        if (o2 += l, l.lastIndexOf("\\") === l.length - 1) {
          var u = this.nextToken;
          u && u[k.FIELDS.TYPE] === _.space && (o2 += this.requiredSpace(this.content(u)), this.position++);
        }
        s = this.nextToken;
      }
      var f = ss(o2, ".").filter(function(h) {
        var y = o2[h - 1] === "\\", m = /^\d+\.\d+%$/.test(o2);
        return !y && !m;
      }), p = ss(o2, "#").filter(function(h) {
        return o2[h - 1] !== "\\";
      }), c2 = ss(o2, "#{");
      c2.length && (p = p.filter(function(h) {
        return !~c2.indexOf(h);
      }));
      var d = (0, oy.default)(cy([0].concat(f, p)));
      d.forEach(function(h, y) {
        var m = d[y + 1] || o2.length, g = o2.slice(h, m);
        if (y === 0 && i)
          return i.call(a, g, d.length);
        var w, b2 = a.currToken, v = b2[k.FIELDS.START_POS] + d[y], O = We(b2[1], b2[2] + h, b2[3], b2[2] + (m - 1));
        if (~f.indexOf(h)) {
          var x = { value: g.slice(1), source: O, sourceIndex: v };
          w = new ty.default(tt(x, "value"));
        } else if (~p.indexOf(h)) {
          var A = { value: g.slice(1), source: O, sourceIndex: v };
          w = new ry.default(tt(A, "value"));
        } else {
          var E = { value: g, source: O, sourceIndex: v };
          tt(E, "value"), w = new ny.default(E);
        }
        a.newNode(w, n), n = null;
      }), this.position++;
    }, e.word = function(n) {
      var i = this.nextToken;
      return i && this.content(i) === "|" ? (this.position++, this.namespace()) : this.splitWord(n);
    }, e.loop = function() {
      for (;this.position < this.tokens.length; )
        this.parse(true);
      return this.current._inferEndPosition(), this.root;
    }, e.parse = function(n) {
      switch (this.currToken[k.FIELDS.TYPE]) {
        case _.space:
          this.space();
          break;
        case _.comment:
          this.comment();
          break;
        case _.openParenthesis:
          this.parentheses();
          break;
        case _.closeParenthesis:
          n && this.missingParenthesis();
          break;
        case _.openSquare:
          this.attribute();
          break;
        case _.dollar:
        case _.caret:
        case _.equals:
        case _.word:
          this.word();
          break;
        case _.colon:
          this.pseudo();
          break;
        case _.comma:
          this.comma();
          break;
        case _.asterisk:
          this.universal();
          break;
        case _.ampersand:
          this.nesting();
          break;
        case _.slash:
        case _.combinator:
          this.combinator();
          break;
        case _.str:
          this.string();
          break;
        case _.closeSquare:
          this.missingSquareBracket();
        case _.semicolon:
          this.missingBackslash();
        default:
          this.unexpected();
      }
    }, e.expected = function(n, i, a) {
      if (Array.isArray(n)) {
        var s = n.pop();
        n = n.join(", ") + " or " + s;
      }
      var o2 = /^[aeiou]/.test(n[0]) ? "an" : "a";
      return a ? this.error("Expected " + o2 + " " + n + ', found "' + a + '" instead.', { index: i }) : this.error("Expected " + o2 + " " + n + ".", { index: i });
    }, e.requiredSpace = function(n) {
      return this.options.lossy ? " " : n;
    }, e.optionalSpace = function(n) {
      return this.options.lossy ? "" : n;
    }, e.lossySpace = function(n, i) {
      return this.options.lossy ? i ? " " : "" : n;
    }, e.parseParenthesisToken = function(n) {
      var i = this.content(n);
      return n[k.FIELDS.TYPE] === _.space ? this.requiredSpace(i) : i;
    }, e.newNode = function(n, i) {
      return i && (/^ +$/.test(i) && (this.options.lossy || (this.spaces = (this.spaces || "") + i), i = true), n.namespace = i, tt(n, "namespace")), this.spaces && (n.spaces.before = this.spaces, this.spaces = ""), this.current.append(n);
    }, e.content = function(n) {
      return n === undefined && (n = this.currToken), this.css.slice(n[k.FIELDS.START_POS], n[k.FIELDS.END_POS]);
    }, e.locateNextMeaningfulToken = function(n) {
      n === undefined && (n = this.position + 1);
      for (var i = n;i < this.tokens.length; )
        if (fy[this.tokens[i][k.FIELDS.TYPE]]) {
          i++;
          continue;
        } else
          return i;
      return -1;
    }, uy(t, [{ key: "currToken", get: function() {
      return this.tokens[this.position];
    } }, { key: "nextToken", get: function() {
      return this.tokens[this.position + 1];
    } }, { key: "prevToken", get: function() {
      return this.tokens[this.position - 1];
    } }]), t;
  }();
  er.default = py;
  iu.exports = er.default;
});
var ou = S((tr, au) => {
  tr.__esModule = true;
  tr.default = undefined;
  var dy = hy(su());
  function hy(t) {
    return t && t.__esModule ? t : { default: t };
  }
  var my = function() {
    function t(r, n) {
      this.func = r || function() {
      }, this.funcRes = null, this.options = n;
    }
    var e = t.prototype;
    return e._shouldUpdateSelector = function(n, i) {
      i === undefined && (i = {});
      var a = Object.assign({}, this.options, i);
      return a.updateSelector === false ? false : typeof n != "string";
    }, e._isLossy = function(n) {
      n === undefined && (n = {});
      var i = Object.assign({}, this.options, n);
      return i.lossless === false;
    }, e._root = function(n, i) {
      i === undefined && (i = {});
      var a = new dy.default(n, this._parseOptions(i));
      return a.root;
    }, e._parseOptions = function(n) {
      return { lossy: this._isLossy(n) };
    }, e._run = function(n, i) {
      var a = this;
      return i === undefined && (i = {}), new Promise(function(s, o2) {
        try {
          var l = a._root(n, i);
          Promise.resolve(a.func(l)).then(function(u) {
            var f = undefined;
            return a._shouldUpdateSelector(n, i) && (f = l.toString(), n.selector = f), { transform: u, root: l, string: f };
          }).then(s, o2);
        } catch (u) {
          o2(u);
          return;
        }
      });
    }, e._runSync = function(n, i) {
      i === undefined && (i = {});
      var a = this._root(n, i), s = this.func(a);
      if (s && typeof s.then == "function")
        throw new Error("Selector processor returned a promise to a synchronous call.");
      var o2 = undefined;
      return i.updateSelector && typeof n != "string" && (o2 = a.toString(), n.selector = o2), { transform: s, root: a, string: o2 };
    }, e.ast = function(n, i) {
      return this._run(n, i).then(function(a) {
        return a.root;
      });
    }, e.astSync = function(n, i) {
      return this._runSync(n, i).root;
    }, e.transform = function(n, i) {
      return this._run(n, i).then(function(a) {
        return a.transform;
      });
    }, e.transformSync = function(n, i) {
      return this._runSync(n, i).transform;
    }, e.process = function(n, i) {
      return this._run(n, i).then(function(a) {
        return a.string || a.root.toString();
      });
    }, e.processSync = function(n, i) {
      var a = this._runSync(n, i);
      return a.string || a.root.toString();
    }, t;
  }();
  tr.default = my;
  au.exports = tr.default;
});
var lu = S((j) => {
  j.__esModule = true;
  j.universal = j.tag = j.string = j.selector = j.root = j.pseudo = j.nesting = j.id = j.comment = j.combinator = j.className = j.attribute = undefined;
  var gy = ue(Bi()), yy = ue(Ai()), vy = ue(Qi()), wy = ue(Ti()), by = ue(Ii()), xy = ue(Xi()), Sy = ue(qi()), ky = ue(Si()), Oy = ue(Oi()), Ey = ue(Li()), Cy = ue(Mi()), Ay = ue(Yi());
  function ue(t) {
    return t && t.__esModule ? t : { default: t };
  }
  var _y = function(e) {
    return new gy.default(e);
  };
  j.attribute = _y;
  var Ty = function(e) {
    return new yy.default(e);
  };
  j.className = Ty;
  var Py = function(e) {
    return new vy.default(e);
  };
  j.combinator = Py;
  var Iy = function(e) {
    return new wy.default(e);
  };
  j.comment = Iy;
  var Ry = function(e) {
    return new by.default(e);
  };
  j.id = Ry;
  var Dy = function(e) {
    return new xy.default(e);
  };
  j.nesting = Dy;
  var My = function(e) {
    return new Sy.default(e);
  };
  j.pseudo = My;
  var Fy = function(e) {
    return new ky.default(e);
  };
  j.root = Fy;
  var Ly = function(e) {
    return new Oy.default(e);
  };
  j.selector = Ly;
  var Ny = function(e) {
    return new Ey.default(e);
  };
  j.string = Ny;
  var qy = function(e) {
    return new Cy.default(e);
  };
  j.tag = qy;
  var $y = function(e) {
    return new Ay.default(e);
  };
  j.universal = $y;
});
var pu = S((D) => {
  D.__esModule = true;
  D.isComment = D.isCombinator = D.isClassName = D.isAttribute = undefined;
  D.isContainer = Xy;
  D.isIdentifier = undefined;
  D.isNamespace = Ky;
  D.isNesting = undefined;
  D.isNode = os2;
  D.isPseudo = undefined;
  D.isPseudoClass = Jy;
  D.isPseudoElement = cu;
  D.isUniversal = D.isTag = D.isString = D.isSelector = D.isRoot = undefined;
  var W = J(), te, Uy = (te = {}, te[W.ATTRIBUTE] = true, te[W.CLASS] = true, te[W.COMBINATOR] = true, te[W.COMMENT] = true, te[W.ID] = true, te[W.NESTING] = true, te[W.PSEUDO] = true, te[W.ROOT] = true, te[W.SELECTOR] = true, te[W.STRING] = true, te[W.TAG] = true, te[W.UNIVERSAL] = true, te);
  function os2(t) {
    return typeof t == "object" && Uy[t.type];
  }
  function fe(t, e) {
    return os2(e) && e.type === t;
  }
  var uu = fe.bind(null, W.ATTRIBUTE);
  D.isAttribute = uu;
  var jy = fe.bind(null, W.CLASS);
  D.isClassName = jy;
  var zy = fe.bind(null, W.COMBINATOR);
  D.isCombinator = zy;
  var Vy = fe.bind(null, W.COMMENT);
  D.isComment = Vy;
  var Wy = fe.bind(null, W.ID);
  D.isIdentifier = Wy;
  var By = fe.bind(null, W.NESTING);
  D.isNesting = By;
  var ls = fe.bind(null, W.PSEUDO);
  D.isPseudo = ls;
  var Gy = fe.bind(null, W.ROOT);
  D.isRoot = Gy;
  var Yy = fe.bind(null, W.SELECTOR);
  D.isSelector = Yy;
  var Hy = fe.bind(null, W.STRING);
  D.isString = Hy;
  var fu = fe.bind(null, W.TAG);
  D.isTag = fu;
  var Qy = fe.bind(null, W.UNIVERSAL);
  D.isUniversal = Qy;
  function cu(t) {
    return ls(t) && t.value && (t.value.startsWith("::") || t.value.toLowerCase() === ":before" || t.value.toLowerCase() === ":after" || t.value.toLowerCase() === ":first-letter" || t.value.toLowerCase() === ":first-line");
  }
  function Jy(t) {
    return ls(t) && !cu(t);
  }
  function Xy(t) {
    return !!(os2(t) && t.walk);
  }
  function Ky(t) {
    return uu(t) || fu(t);
  }
});
var du = S((de) => {
  de.__esModule = true;
  var us = J();
  Object.keys(us).forEach(function(t) {
    t === "default" || t === "__esModule" || t in de && de[t] === us[t] || (de[t] = us[t]);
  });
  var fs2 = lu();
  Object.keys(fs2).forEach(function(t) {
    t === "default" || t === "__esModule" || t in de && de[t] === fs2[t] || (de[t] = fs2[t]);
  });
  var cs = pu();
  Object.keys(cs).forEach(function(t) {
    t === "default" || t === "__esModule" || t in de && de[t] === cs[t] || (de[t] = cs[t]);
  });
});
var ve = S((rr, mu) => {
  rr.__esModule = true;
  rr.default = undefined;
  var Zy = r02(ou()), e02 = t0(du());
  function hu(t) {
    if (typeof WeakMap != "function")
      return null;
    var e = new WeakMap, r = new WeakMap;
    return (hu = function(i) {
      return i ? r : e;
    })(t);
  }
  function t0(t, e) {
    if (!e && t && t.__esModule)
      return t;
    if (t === null || typeof t != "object" && typeof t != "function")
      return { default: t };
    var r = hu(e);
    if (r && r.has(t))
      return r.get(t);
    var n = {}, i = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var a in t)
      if (a !== "default" && Object.prototype.hasOwnProperty.call(t, a)) {
        var s = i ? Object.getOwnPropertyDescriptor(t, a) : null;
        s && (s.get || s.set) ? Object.defineProperty(n, a, s) : n[a] = t[a];
      }
    return n.default = t, r && r.set(t, n), n;
  }
  function r02(t) {
    return t && t.__esModule ? t : { default: t };
  }
  var ps = function(e) {
    return new Zy.default(e);
  };
  Object.assign(ps, e02);
  delete ps.__esModule;
  var n0 = ps;
  rr.default = n0;
  mu.exports = rr.default;
});
var Su = S((Dx, ys) => {
  var { Rule: yu, AtRule: i0 } = Ke(), vu = ve();
  function ms(t, e) {
    let r;
    try {
      vu((n) => {
        r = n;
      }).processSync(t);
    } catch (n) {
      throw t.includes(":") ? e ? e.error("Missed semicolon") : n : e ? e.error(n.message) : n;
    }
    return r.at(0);
  }
  function wu(t, e) {
    let r = false;
    return t.each((n) => {
      if (n.type === "nesting") {
        let i = e.clone({});
        n.value !== "&" ? n.replaceWith(ms(n.value.replace("&", i.toString()))) : n.replaceWith(i), r = true;
      } else
        "nodes" in n && n.nodes && wu(n, e) && (r = true);
    }), r;
  }
  function bu(t, e) {
    let r = [];
    return t.selectors.forEach((n) => {
      let i = ms(n, t);
      e.selectors.forEach((a) => {
        if (!a)
          return;
        let s = ms(a, e);
        wu(s, i) || (s.prepend(vu.combinator({ value: " " })), s.prepend(i.clone({}))), r.push(s.toString());
      });
    }), r;
  }
  function Zr(t, e) {
    let r = t.prev();
    for (e.after(t);r && r.type === "comment"; ) {
      let n = r.prev();
      e.after(r), r = n;
    }
    return t;
  }
  function s0(t) {
    return function e(r, n, i, a = i) {
      let s = [];
      if (n.each((o2) => {
        o2.type === "rule" && i ? a && (o2.selectors = bu(r, o2)) : o2.type === "atrule" && o2.nodes ? t[o2.name] ? e(r, o2, a) : n[gs] !== false && s.push(o2) : s.push(o2);
      }), i && s.length) {
        let o2 = r.clone({ nodes: [] });
        for (let l of s)
          o2.append(l);
        n.prepend(o2);
      }
    };
  }
  function ds(t, e, r) {
    let n = new yu({ selector: t, nodes: [] });
    return n.append(e), r.after(n), n;
  }
  function gu(t, e) {
    let r = {};
    for (let n of t)
      r[n] = true;
    if (e)
      for (let n of e)
        r[n.replace(/^@/, "")] = true;
    return r;
  }
  function a02(t) {
    t = t.trim();
    let e = t.match(/^\((.*)\)$/);
    if (!e)
      return { type: "basic", selector: t };
    let r = e[1].match(/^(with(?:out)?):(.+)$/);
    if (r) {
      let n = r[1] === "with", i = Object.fromEntries(r[2].trim().split(/\s+/).map((s) => [s, true]));
      if (n && i.all)
        return { type: "noop" };
      let a = (s) => !!i[s];
      return i.all ? a = () => true : n && (a = (s) => s === "all" ? false : !i[s]), { type: "withrules", escapes: a };
    }
    return { type: "unknown" };
  }
  function o0(t) {
    let e = [], r = t.parent;
    for (;r && r instanceof i0; )
      e.push(r), r = r.parent;
    return e;
  }
  function l0(t) {
    let e = t[xu];
    if (!e)
      t.after(t.nodes);
    else {
      let r = t.nodes, n, i = -1, a, s, o2, l = o0(t);
      if (l.forEach((u, f) => {
        if (e(u.name))
          n = u, i = f, s = o2;
        else {
          let p = o2;
          o2 = u.clone({ nodes: [] }), p && o2.append(p), a = a || o2;
        }
      }), n ? s ? (a.append(r), n.after(s)) : n.after(r) : t.after(r), t.next() && n) {
        let u;
        l.slice(0, i + 1).forEach((f, p, c2) => {
          let d = u;
          u = f.clone({ nodes: [] }), d && u.append(d);
          let h = [], m = (c2[p - 1] || t).next();
          for (;m; )
            h.push(m), m = m.next();
          u.append(h);
        }), u && (s || r[r.length - 1]).after(u);
      }
    }
    t.remove();
  }
  var gs = Symbol("rootRuleMergeSel"), xu = Symbol("rootRuleEscapes");
  function u0(t) {
    let { params: e } = t, { type: r, selector: n, escapes: i } = a02(e);
    if (r === "unknown")
      throw t.error(`Unknown @${t.name} parameter ${JSON.stringify(e)}`);
    if (r === "basic" && n) {
      let a = new yu({ selector: n, nodes: t.nodes });
      t.removeAll(), t.append(a);
    }
    t[xu] = i, t[gs] = i ? !i("all") : r === "noop";
  }
  var hs = Symbol("hasRootRule");
  ys.exports = (t = {}) => {
    let e = gu(["media", "supports", "layer", "container"], t.bubble), r = s0(e), n = gu(["document", "font-face", "keyframes", "-webkit-keyframes", "-moz-keyframes"], t.unwrap), i = (t.rootRuleName || "at-root").replace(/^@/, ""), a = t.preserveEmpty;
    return { postcssPlugin: "postcss-nested", Once(s) {
      s.walkAtRules(i, (o2) => {
        u0(o2), s[hs] = true;
      });
    }, Rule(s) {
      let o2 = false, l = s, u = false, f = [];
      s.each((p) => {
        p.type === "rule" ? (f.length && (l = ds(s.selector, f, l), f = []), u = true, o2 = true, p.selectors = bu(s, p), l = Zr(p, l)) : p.type === "atrule" ? (f.length && (l = ds(s.selector, f, l), f = []), p.name === i ? (o2 = true, r(s, p, true, p[gs]), l = Zr(p, l)) : e[p.name] ? (u = true, o2 = true, r(s, p, true), l = Zr(p, l)) : n[p.name] ? (u = true, o2 = true, r(s, p, false), l = Zr(p, l)) : u && f.push(p)) : p.type === "decl" && u && f.push(p);
      }), f.length && (l = ds(s.selector, f, l)), o2 && a !== true && (s.raws.semicolon = true, s.nodes.length === 0 && s.remove());
    }, RootExit(s) {
      s[hs] && (s.walkAtRules(i, l0), s[hs] = false);
    } };
  };
  ys.exports.postcss = true;
});
var Cu = S((Mx, Eu) => {
  var ku = /-(\w|$)/g, Ou = function(e, r) {
    return r.toUpperCase();
  }, f0 = function(e) {
    return e = e.toLowerCase(), e === "float" ? "cssFloat" : e.charCodeAt(0) === 45 && e.charCodeAt(1) === 109 && e.charCodeAt(2) === 115 && e.charCodeAt(3) === 45 ? e.substr(1).replace(ku, Ou) : e.replace(ku, Ou);
  };
  Eu.exports = f0;
});
var bs = S((Fx, Au) => {
  var c0 = Cu(), p0 = { boxFlex: true, boxFlexGroup: true, columnCount: true, flex: true, flexGrow: true, flexPositive: true, flexShrink: true, flexNegative: true, fontWeight: true, lineClamp: true, lineHeight: true, opacity: true, order: true, orphans: true, tabSize: true, widows: true, zIndex: true, zoom: true, fillOpacity: true, strokeDashoffset: true, strokeOpacity: true, strokeWidth: true };
  function vs(t) {
    return typeof t.nodes > "u" ? true : ws(t);
  }
  function ws(t) {
    let e, r = {};
    return t.each((n) => {
      if (n.type === "atrule")
        e = "@" + n.name, n.params && (e += " " + n.params), typeof r[e] > "u" ? r[e] = vs(n) : Array.isArray(r[e]) ? r[e].push(vs(n)) : r[e] = [r[e], vs(n)];
      else if (n.type === "rule") {
        let i = ws(n);
        if (r[n.selector])
          for (let a in i)
            r[n.selector][a] = i[a];
        else
          r[n.selector] = i;
      } else if (n.type === "decl") {
        n.prop[0] === "-" && n.prop[1] === "-" || n.parent && n.parent.selector === ":export" ? e = n.prop : e = c0(n.prop);
        let i = n.value;
        !isNaN(n.value) && p0[e] && (i = parseFloat(n.value)), n.important && (i += " !important"), typeof r[e] > "u" ? r[e] = i : Array.isArray(r[e]) ? r[e].push(i) : r[e] = [r[e], i];
      }
    }), r;
  }
  Au.exports = ws;
});
var en = S((Lx, Iu) => {
  var nr = Ke(), _u = /\s*!important\s*$/i, d0 = { "box-flex": true, "box-flex-group": true, "column-count": true, flex: true, "flex-grow": true, "flex-positive": true, "flex-shrink": true, "flex-negative": true, "font-weight": true, "line-clamp": true, "line-height": true, opacity: true, order: true, orphans: true, "tab-size": true, widows: true, "z-index": true, zoom: true, "fill-opacity": true, "stroke-dashoffset": true, "stroke-opacity": true, "stroke-width": true };
  function h0(t) {
    return t.replace(/([A-Z])/g, "-$1").replace(/^ms-/, "-ms-").toLowerCase();
  }
  function Tu(t, e, r) {
    r === false || r === null || (e.startsWith("--") || (e = h0(e)), typeof r == "number" && (r === 0 || d0[e] ? r = r.toString() : r += "px"), e === "css-float" && (e = "float"), _u.test(r) ? (r = r.replace(_u, ""), t.push(nr.decl({ prop: e, value: r, important: true }))) : t.push(nr.decl({ prop: e, value: r })));
  }
  function Pu(t, e, r) {
    let n = nr.atRule({ name: e[1], params: e[3] || "" });
    typeof r == "object" && (n.nodes = [], xs(r, n)), t.push(n);
  }
  function xs(t, e) {
    let r, n, i;
    for (r in t)
      if (n = t[r], !(n === null || typeof n > "u"))
        if (r[0] === "@") {
          let a = r.match(/@(\S+)(\s+([\W\w]*)\s*)?/);
          if (Array.isArray(n))
            for (let s of n)
              Pu(e, a, s);
          else
            Pu(e, a, n);
        } else if (Array.isArray(n))
          for (let a of n)
            Tu(e, r, a);
        else
          typeof n == "object" ? (i = nr.rule({ selector: r }), xs(n, i), e.push(i)) : Tu(e, r, n);
  }
  Iu.exports = function(t) {
    let e = nr.root();
    return xs(t, e), e;
  };
});
var Ss = S((Nx, Ru) => {
  var m0 = bs();
  Ru.exports = function(e) {
    return console && console.warn && e.warnings().forEach((r) => {
      let n = r.plugin || "PostCSS";
      console.warn(n + ": " + r.text);
    }), m0(e.root);
  };
});
var Mu = S((qx, Du) => {
  var g02 = Ke(), y0 = Ss(), v02 = en();
  Du.exports = function(e) {
    let r = g02(e);
    return async (n) => {
      let i = await r.process(n, { parser: v02, from: undefined });
      return y0(i);
    };
  };
});
var Lu = S(($x, Fu) => {
  var w0 = Ke(), b0 = Ss(), x02 = en();
  Fu.exports = function(t) {
    let e = w0(t);
    return (r) => {
      let n = e.process(r, { parser: x02, from: undefined });
      return b0(n);
    };
  };
});
var qu = S((Ux, Nu) => {
  var S0 = bs(), k0 = en(), O02 = Mu(), E0 = Lu();
  Nu.exports = { objectify: S0, parse: k0, async: O02, sync: E0 };
});
var qs = S((Ls, Ns) => {
  (function(t, e) {
    typeof Ls == "object" && typeof Ns < "u" ? Ns.exports = function(r, n, i, a, s) {
      for (n = n.split ? n.split(".") : n, a = 0;a < n.length; a++)
        r = r ? r[n[a]] : s;
      return r === s ? i : r;
    } : typeof define == "function" && define.amd ? define(function() {
      return function(r, n, i, a, s) {
        for (n = n.split ? n.split(".") : n, a = 0;a < n.length; a++)
          r = r ? r[n[a]] : s;
        return r === s ? i : r;
      };
    }) : t.dlv = function(r, n, i, a, s) {
      for (n = n.split ? n.split(".") : n, a = 0;a < n.length; a++)
        r = r ? r[n[a]] : s;
      return r === s ? i : r;
    };
  })(Ls);
});
var Bf = S((bk, On) => {
  (function() {
    function t(n, i, a) {
      if (!n)
        return null;
      t.caseSensitive || (n = n.toLowerCase());
      var s = t.threshold === null ? null : t.threshold * n.length, o2 = t.thresholdAbsolute, l;
      s !== null && o2 !== null ? l = Math.min(s, o2) : s !== null ? l = s : o2 !== null ? l = o2 : l = null;
      var u, f, p, c2, d, h = i.length;
      for (d = 0;d < h; d++)
        if (f = i[d], a && (f = f[a]), !!f && (t.caseSensitive ? p = f : p = f.toLowerCase(), c2 = r(n, p, l), (l === null || c2 < l) && (l = c2, a && t.returnWinningObject ? u = i[d] : u = f, t.returnFirstMatch)))
          return u;
      return u || t.nullResultValue;
    }
    t.threshold = 0.4, t.thresholdAbsolute = 20, t.caseSensitive = false, t.nullResultValue = null, t.returnWinningObject = null, t.returnFirstMatch = false, typeof On < "u" && On.exports ? On.exports = t : window.didYouMean = t;
    var e = Math.pow(2, 32) - 1;
    function r(n, i, a) {
      a = a || a === 0 ? a : e;
      var s = n.length, o2 = i.length;
      if (s === 0)
        return Math.min(a + 1, o2);
      if (o2 === 0)
        return Math.min(a + 1, s);
      if (Math.abs(s - o2) > a)
        return a + 1;
      var l = [], u, f, p, c2, d;
      for (u = 0;u <= o2; u++)
        l[u] = [u];
      for (f = 0;f <= s; f++)
        l[0][f] = f;
      for (u = 1;u <= o2; u++) {
        for (p = e, c2 = 1, u > a && (c2 = u - a), d = o2 + 1, d > a + u && (d = a + u), f = 1;f <= s; f++)
          f < c2 || f > d ? l[u][f] = a + 1 : i.charAt(u - 1) === n.charAt(f - 1) ? l[u][f] = l[u - 1][f - 1] : l[u][f] = Math.min(l[u - 1][f - 1] + 1, Math.min(l[u][f - 1] + 1, l[u - 1][f] + 1)), l[u][f] < p && (p = l[u][f]);
        if (p > a)
          return a + 1;
      }
      return l[o2][s];
    }
  })();
});
var Yf = S((xk, Gf) => {
  var Ks = "(".charCodeAt(0), Zs = ")".charCodeAt(0), En = "'".charCodeAt(0), ea = '"'.charCodeAt(0), ta = "\\".charCodeAt(0), ft = "/".charCodeAt(0), ra = ",".charCodeAt(0), na = ":".charCodeAt(0), Cn = "*".charCodeAt(0), Yv = "u".charCodeAt(0), Hv = "U".charCodeAt(0), Qv = "+".charCodeAt(0), Jv = /^[a-f0-9?-]+$/i;
  Gf.exports = function(t) {
    for (var e = [], r = t, n, i, a, s, o2, l, u, f, p = 0, c2 = r.charCodeAt(p), d = r.length, h = [{ nodes: e }], y = 0, m, g = "", w = "", b2 = "";p < d; )
      if (c2 <= 32) {
        n = p;
        do
          n += 1, c2 = r.charCodeAt(n);
        while (c2 <= 32);
        s = r.slice(p, n), a = e[e.length - 1], c2 === Zs && y ? b2 = s : a && a.type === "div" ? (a.after = s, a.sourceEndIndex += s.length) : c2 === ra || c2 === na || c2 === ft && r.charCodeAt(n + 1) !== Cn && (!m || m && m.type === "function" && m.value !== "calc") ? w = s : e.push({ type: "space", sourceIndex: p, sourceEndIndex: n, value: s }), p = n;
      } else if (c2 === En || c2 === ea) {
        n = p, i = c2 === En ? "'" : '"', s = { type: "string", sourceIndex: p, quote: i };
        do
          if (o2 = false, n = r.indexOf(i, n + 1), ~n)
            for (l = n;r.charCodeAt(l - 1) === ta; )
              l -= 1, o2 = !o2;
          else
            r += i, n = r.length - 1, s.unclosed = true;
        while (o2);
        s.value = r.slice(p + 1, n), s.sourceEndIndex = s.unclosed ? n : n + 1, e.push(s), p = n + 1, c2 = r.charCodeAt(p);
      } else if (c2 === ft && r.charCodeAt(p + 1) === Cn)
        n = r.indexOf("*/", p), s = { type: "comment", sourceIndex: p, sourceEndIndex: n + 2 }, n === -1 && (s.unclosed = true, n = r.length, s.sourceEndIndex = n), s.value = r.slice(p + 2, n), e.push(s), p = n + 2, c2 = r.charCodeAt(p);
      else if ((c2 === ft || c2 === Cn) && m && m.type === "function" && m.value === "calc")
        s = r[p], e.push({ type: "word", sourceIndex: p - w.length, sourceEndIndex: p + s.length, value: s }), p += 1, c2 = r.charCodeAt(p);
      else if (c2 === ft || c2 === ra || c2 === na)
        s = r[p], e.push({ type: "div", sourceIndex: p - w.length, sourceEndIndex: p + s.length, value: s, before: w, after: "" }), w = "", p += 1, c2 = r.charCodeAt(p);
      else if (Ks === c2) {
        n = p;
        do
          n += 1, c2 = r.charCodeAt(n);
        while (c2 <= 32);
        if (f = p, s = { type: "function", sourceIndex: p - g.length, value: g, before: r.slice(f + 1, n) }, p = n, g === "url" && c2 !== En && c2 !== ea) {
          n -= 1;
          do
            if (o2 = false, n = r.indexOf(")", n + 1), ~n)
              for (l = n;r.charCodeAt(l - 1) === ta; )
                l -= 1, o2 = !o2;
            else
              r += ")", n = r.length - 1, s.unclosed = true;
          while (o2);
          u = n;
          do
            u -= 1, c2 = r.charCodeAt(u);
          while (c2 <= 32);
          f < u ? (p !== u + 1 ? s.nodes = [{ type: "word", sourceIndex: p, sourceEndIndex: u + 1, value: r.slice(p, u + 1) }] : s.nodes = [], s.unclosed && u + 1 !== n ? (s.after = "", s.nodes.push({ type: "space", sourceIndex: u + 1, sourceEndIndex: n, value: r.slice(u + 1, n) })) : (s.after = r.slice(u + 1, n), s.sourceEndIndex = n)) : (s.after = "", s.nodes = []), p = n + 1, s.sourceEndIndex = s.unclosed ? n : p, c2 = r.charCodeAt(p), e.push(s);
        } else
          y += 1, s.after = "", s.sourceEndIndex = p + 1, e.push(s), h.push(s), e = s.nodes = [], m = s;
        g = "";
      } else if (Zs === c2 && y)
        p += 1, c2 = r.charCodeAt(p), m.after = b2, m.sourceEndIndex += b2.length, b2 = "", y -= 1, h[h.length - 1].sourceEndIndex = p, h.pop(), m = h[y], e = m.nodes;
      else {
        n = p;
        do
          c2 === ta && (n += 1), n += 1, c2 = r.charCodeAt(n);
        while (n < d && !(c2 <= 32 || c2 === En || c2 === ea || c2 === ra || c2 === na || c2 === ft || c2 === Ks || c2 === Cn && m && m.type === "function" && m.value === "calc" || c2 === ft && m.type === "function" && m.value === "calc" || c2 === Zs && y));
        s = r.slice(p, n), Ks === c2 ? g = s : (Yv === s.charCodeAt(0) || Hv === s.charCodeAt(0)) && Qv === s.charCodeAt(1) && Jv.test(s.slice(2)) ? e.push({ type: "unicode-range", sourceIndex: p, sourceEndIndex: n, value: s }) : e.push({ type: "word", sourceIndex: p, sourceEndIndex: n, value: s }), p = n;
      }
    for (p = h.length - 1;p; p -= 1)
      h[p].unclosed = true, h[p].sourceEndIndex = r.length;
    return h[0].nodes;
  };
});
var Qf = S((Sk, Hf) => {
  Hf.exports = function t(e, r, n) {
    var i, a, s, o2;
    for (i = 0, a = e.length;i < a; i += 1)
      s = e[i], n || (o2 = r(s, i, e)), o2 !== false && s.type === "function" && Array.isArray(s.nodes) && t(s.nodes, r, n), n && r(s, i, e);
  };
});
var Zf = S((kk, Kf) => {
  function Jf(t, e) {
    var { type: r, value: n } = t, i, a;
    return e && (a = e(t)) !== undefined ? a : r === "word" || r === "space" ? n : r === "string" ? (i = t.quote || "", i + n + (t.unclosed ? "" : i)) : r === "comment" ? "/*" + n + (t.unclosed ? "" : "*/") : r === "div" ? (t.before || "") + n + (t.after || "") : Array.isArray(t.nodes) ? (i = Xf(t.nodes, e), r !== "function" ? i : n + "(" + (t.before || "") + i + (t.after || "") + (t.unclosed ? "" : ")")) : n;
  }
  function Xf(t, e) {
    var r, n;
    if (Array.isArray(t)) {
      for (r = "", n = t.length - 1;~n; n -= 1)
        r = Jf(t[n], e) + r;
      return r;
    }
    return Jf(t, e);
  }
  Kf.exports = Xf;
});
var tc = S((Ok, ec) => {
  var An = "-".charCodeAt(0), _n = "+".charCodeAt(0), ia = ".".charCodeAt(0), Xv = "e".charCodeAt(0), Kv = "E".charCodeAt(0);
  function Zv(t) {
    var e = t.charCodeAt(0), r;
    if (e === _n || e === An) {
      if (r = t.charCodeAt(1), r >= 48 && r <= 57)
        return true;
      var n = t.charCodeAt(2);
      return r === ia && n >= 48 && n <= 57;
    }
    return e === ia ? (r = t.charCodeAt(1), r >= 48 && r <= 57) : e >= 48 && e <= 57;
  }
  ec.exports = function(t) {
    var e = 0, r = t.length, n, i, a;
    if (r === 0 || !Zv(t))
      return false;
    for (n = t.charCodeAt(e), (n === _n || n === An) && e++;e < r && (n = t.charCodeAt(e), !(n < 48 || n > 57)); )
      e += 1;
    if (n = t.charCodeAt(e), i = t.charCodeAt(e + 1), n === ia && i >= 48 && i <= 57)
      for (e += 2;e < r && (n = t.charCodeAt(e), !(n < 48 || n > 57)); )
        e += 1;
    if (n = t.charCodeAt(e), i = t.charCodeAt(e + 1), a = t.charCodeAt(e + 2), (n === Xv || n === Kv) && (i >= 48 && i <= 57 || (i === _n || i === An) && a >= 48 && a <= 57))
      for (e += i === _n || i === An ? 3 : 2;e < r && (n = t.charCodeAt(e), !(n < 48 || n > 57)); )
        e += 1;
    return { number: t.slice(0, e), unit: t.slice(e) };
  };
});
var sc = S((Ek, ic) => {
  var ew = Yf(), rc = Qf(), nc = Zf();
  function Ne(t) {
    return this instanceof Ne ? (this.nodes = ew(t), this) : new Ne(t);
  }
  Ne.prototype.toString = function() {
    return Array.isArray(this.nodes) ? nc(this.nodes) : "";
  };
  Ne.prototype.walk = function(t, e) {
    return rc(this.nodes, t, e), this;
  };
  Ne.unit = tc();
  Ne.walk = rc;
  Ne.stringify = nc;
  ic.exports = Ne;
});
var Sc = S((CO, xc) => {
  xc.exports = { content: [], presets: [], darkMode: "media", theme: { accentColor: ({ theme: t }) => ({ ...t("colors"), auto: "auto" }), animation: { none: "none", spin: "spin 1s linear infinite", ping: "ping 1s cubic-bezier(0, 0, 0.2, 1) infinite", pulse: "pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite", bounce: "bounce 1s infinite" }, aria: { checked: 'checked="true"', disabled: 'disabled="true"', expanded: 'expanded="true"', hidden: 'hidden="true"', pressed: 'pressed="true"', readonly: 'readonly="true"', required: 'required="true"', selected: 'selected="true"' }, aspectRatio: { auto: "auto", square: "1 / 1", video: "16 / 9" }, backdropBlur: ({ theme: t }) => t("blur"), backdropBrightness: ({ theme: t }) => t("brightness"), backdropContrast: ({ theme: t }) => t("contrast"), backdropGrayscale: ({ theme: t }) => t("grayscale"), backdropHueRotate: ({ theme: t }) => t("hueRotate"), backdropInvert: ({ theme: t }) => t("invert"), backdropOpacity: ({ theme: t }) => t("opacity"), backdropSaturate: ({ theme: t }) => t("saturate"), backdropSepia: ({ theme: t }) => t("sepia"), backgroundColor: ({ theme: t }) => t("colors"), backgroundImage: { none: "none", "gradient-to-t": "linear-gradient(to top, var(--tw-gradient-stops))", "gradient-to-tr": "linear-gradient(to top right, var(--tw-gradient-stops))", "gradient-to-r": "linear-gradient(to right, var(--tw-gradient-stops))", "gradient-to-br": "linear-gradient(to bottom right, var(--tw-gradient-stops))", "gradient-to-b": "linear-gradient(to bottom, var(--tw-gradient-stops))", "gradient-to-bl": "linear-gradient(to bottom left, var(--tw-gradient-stops))", "gradient-to-l": "linear-gradient(to left, var(--tw-gradient-stops))", "gradient-to-tl": "linear-gradient(to top left, var(--tw-gradient-stops))" }, backgroundOpacity: ({ theme: t }) => t("opacity"), backgroundPosition: { bottom: "bottom", center: "center", left: "left", "left-bottom": "left bottom", "left-top": "left top", right: "right", "right-bottom": "right bottom", "right-top": "right top", top: "top" }, backgroundSize: { auto: "auto", cover: "cover", contain: "contain" }, blur: { 0: "0", none: "0", sm: "4px", DEFAULT: "8px", md: "12px", lg: "16px", xl: "24px", "2xl": "40px", "3xl": "64px" }, borderColor: ({ theme: t }) => ({ ...t("colors"), DEFAULT: t("colors.gray.200", "currentColor") }), borderOpacity: ({ theme: t }) => t("opacity"), borderRadius: { none: "0px", sm: "0.125rem", DEFAULT: "0.25rem", md: "0.375rem", lg: "0.5rem", xl: "0.75rem", "2xl": "1rem", "3xl": "1.5rem", full: "9999px" }, borderSpacing: ({ theme: t }) => ({ ...t("spacing") }), borderWidth: { DEFAULT: "1px", 0: "0px", 2: "2px", 4: "4px", 8: "8px" }, boxShadow: { sm: "0 1px 2px 0 rgb(0 0 0 / 0.05)", DEFAULT: "0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1)", md: "0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1)", lg: "0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1)", xl: "0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1)", "2xl": "0 25px 50px -12px rgb(0 0 0 / 0.25)", inner: "inset 0 2px 4px 0 rgb(0 0 0 / 0.05)", none: "none" }, boxShadowColor: ({ theme: t }) => t("colors"), brightness: { 0: "0", 50: ".5", 75: ".75", 90: ".9", 95: ".95", 100: "1", 105: "1.05", 110: "1.1", 125: "1.25", 150: "1.5", 200: "2" }, caretColor: ({ theme: t }) => t("colors"), colors: ({ colors: t }) => ({ inherit: t.inherit, current: t.current, transparent: t.transparent, black: t.black, white: t.white, slate: t.slate, gray: t.gray, zinc: t.zinc, neutral: t.neutral, stone: t.stone, red: t.red, orange: t.orange, amber: t.amber, yellow: t.yellow, lime: t.lime, green: t.green, emerald: t.emerald, teal: t.teal, cyan: t.cyan, sky: t.sky, blue: t.blue, indigo: t.indigo, violet: t.violet, purple: t.purple, fuchsia: t.fuchsia, pink: t.pink, rose: t.rose }), columns: { auto: "auto", 1: "1", 2: "2", 3: "3", 4: "4", 5: "5", 6: "6", 7: "7", 8: "8", 9: "9", 10: "10", 11: "11", 12: "12", "3xs": "16rem", "2xs": "18rem", xs: "20rem", sm: "24rem", md: "28rem", lg: "32rem", xl: "36rem", "2xl": "42rem", "3xl": "48rem", "4xl": "56rem", "5xl": "64rem", "6xl": "72rem", "7xl": "80rem" }, container: {}, content: { none: "none" }, contrast: { 0: "0", 50: ".5", 75: ".75", 100: "1", 125: "1.25", 150: "1.5", 200: "2" }, cursor: { auto: "auto", default: "default", pointer: "pointer", wait: "wait", text: "text", move: "move", help: "help", "not-allowed": "not-allowed", none: "none", "context-menu": "context-menu", progress: "progress", cell: "cell", crosshair: "crosshair", "vertical-text": "vertical-text", alias: "alias", copy: "copy", "no-drop": "no-drop", grab: "grab", grabbing: "grabbing", "all-scroll": "all-scroll", "col-resize": "col-resize", "row-resize": "row-resize", "n-resize": "n-resize", "e-resize": "e-resize", "s-resize": "s-resize", "w-resize": "w-resize", "ne-resize": "ne-resize", "nw-resize": "nw-resize", "se-resize": "se-resize", "sw-resize": "sw-resize", "ew-resize": "ew-resize", "ns-resize": "ns-resize", "nesw-resize": "nesw-resize", "nwse-resize": "nwse-resize", "zoom-in": "zoom-in", "zoom-out": "zoom-out" }, divideColor: ({ theme: t }) => t("borderColor"), divideOpacity: ({ theme: t }) => t("borderOpacity"), divideWidth: ({ theme: t }) => t("borderWidth"), dropShadow: { sm: "0 1px 1px rgb(0 0 0 / 0.05)", DEFAULT: ["0 1px 2px rgb(0 0 0 / 0.1)", "0 1px 1px rgb(0 0 0 / 0.06)"], md: ["0 4px 3px rgb(0 0 0 / 0.07)", "0 2px 2px rgb(0 0 0 / 0.06)"], lg: ["0 10px 8px rgb(0 0 0 / 0.04)", "0 4px 3px rgb(0 0 0 / 0.1)"], xl: ["0 20px 13px rgb(0 0 0 / 0.03)", "0 8px 5px rgb(0 0 0 / 0.08)"], "2xl": "0 25px 25px rgb(0 0 0 / 0.15)", none: "0 0 #0000" }, fill: ({ theme: t }) => ({ none: "none", ...t("colors") }), flex: { 1: "1 1 0%", auto: "1 1 auto", initial: "0 1 auto", none: "none" }, flexBasis: ({ theme: t }) => ({ auto: "auto", ...t("spacing"), "1/2": "50%", "1/3": "33.333333%", "2/3": "66.666667%", "1/4": "25%", "2/4": "50%", "3/4": "75%", "1/5": "20%", "2/5": "40%", "3/5": "60%", "4/5": "80%", "1/6": "16.666667%", "2/6": "33.333333%", "3/6": "50%", "4/6": "66.666667%", "5/6": "83.333333%", "1/12": "8.333333%", "2/12": "16.666667%", "3/12": "25%", "4/12": "33.333333%", "5/12": "41.666667%", "6/12": "50%", "7/12": "58.333333%", "8/12": "66.666667%", "9/12": "75%", "10/12": "83.333333%", "11/12": "91.666667%", full: "100%" }), flexGrow: { 0: "0", DEFAULT: "1" }, flexShrink: { 0: "0", DEFAULT: "1" }, fontFamily: { sans: ["ui-sans-serif", "system-ui", "-apple-system", "BlinkMacSystemFont", '"Segoe UI"', "Roboto", '"Helvetica Neue"', "Arial", '"Noto Sans"', "sans-serif", '"Apple Color Emoji"', '"Segoe UI Emoji"', '"Segoe UI Symbol"', '"Noto Color Emoji"'], serif: ["ui-serif", "Georgia", "Cambria", '"Times New Roman"', "Times", "serif"], mono: ["ui-monospace", "SFMono-Regular", "Menlo", "Monaco", "Consolas", '"Liberation Mono"', '"Courier New"', "monospace"] }, fontSize: { xs: ["0.75rem", { lineHeight: "1rem" }], sm: ["0.875rem", { lineHeight: "1.25rem" }], base: ["1rem", { lineHeight: "1.5rem" }], lg: ["1.125rem", { lineHeight: "1.75rem" }], xl: ["1.25rem", { lineHeight: "1.75rem" }], "2xl": ["1.5rem", { lineHeight: "2rem" }], "3xl": ["1.875rem", { lineHeight: "2.25rem" }], "4xl": ["2.25rem", { lineHeight: "2.5rem" }], "5xl": ["3rem", { lineHeight: "1" }], "6xl": ["3.75rem", { lineHeight: "1" }], "7xl": ["4.5rem", { lineHeight: "1" }], "8xl": ["6rem", { lineHeight: "1" }], "9xl": ["8rem", { lineHeight: "1" }] }, fontWeight: { thin: "100", extralight: "200", light: "300", normal: "400", medium: "500", semibold: "600", bold: "700", extrabold: "800", black: "900" }, gap: ({ theme: t }) => t("spacing"), gradientColorStops: ({ theme: t }) => t("colors"), gradientColorStopPositions: { "0%": "0%", "5%": "5%", "10%": "10%", "15%": "15%", "20%": "20%", "25%": "25%", "30%": "30%", "35%": "35%", "40%": "40%", "45%": "45%", "50%": "50%", "55%": "55%", "60%": "60%", "65%": "65%", "70%": "70%", "75%": "75%", "80%": "80%", "85%": "85%", "90%": "90%", "95%": "95%", "100%": "100%" }, grayscale: { 0: "0", DEFAULT: "100%" }, gridAutoColumns: { auto: "auto", min: "min-content", max: "max-content", fr: "minmax(0, 1fr)" }, gridAutoRows: { auto: "auto", min: "min-content", max: "max-content", fr: "minmax(0, 1fr)" }, gridColumn: { auto: "auto", "span-1": "span 1 / span 1", "span-2": "span 2 / span 2", "span-3": "span 3 / span 3", "span-4": "span 4 / span 4", "span-5": "span 5 / span 5", "span-6": "span 6 / span 6", "span-7": "span 7 / span 7", "span-8": "span 8 / span 8", "span-9": "span 9 / span 9", "span-10": "span 10 / span 10", "span-11": "span 11 / span 11", "span-12": "span 12 / span 12", "span-full": "1 / -1" }, gridColumnEnd: { auto: "auto", 1: "1", 2: "2", 3: "3", 4: "4", 5: "5", 6: "6", 7: "7", 8: "8", 9: "9", 10: "10", 11: "11", 12: "12", 13: "13" }, gridColumnStart: { auto: "auto", 1: "1", 2: "2", 3: "3", 4: "4", 5: "5", 6: "6", 7: "7", 8: "8", 9: "9", 10: "10", 11: "11", 12: "12", 13: "13" }, gridRow: { auto: "auto", "span-1": "span 1 / span 1", "span-2": "span 2 / span 2", "span-3": "span 3 / span 3", "span-4": "span 4 / span 4", "span-5": "span 5 / span 5", "span-6": "span 6 / span 6", "span-full": "1 / -1" }, gridRowEnd: { auto: "auto", 1: "1", 2: "2", 3: "3", 4: "4", 5: "5", 6: "6", 7: "7" }, gridRowStart: { auto: "auto", 1: "1", 2: "2", 3: "3", 4: "4", 5: "5", 6: "6", 7: "7" }, gridTemplateColumns: { none: "none", 1: "repeat(1, minmax(0, 1fr))", 2: "repeat(2, minmax(0, 1fr))", 3: "repeat(3, minmax(0, 1fr))", 4: "repeat(4, minmax(0, 1fr))", 5: "repeat(5, minmax(0, 1fr))", 6: "repeat(6, minmax(0, 1fr))", 7: "repeat(7, minmax(0, 1fr))", 8: "repeat(8, minmax(0, 1fr))", 9: "repeat(9, minmax(0, 1fr))", 10: "repeat(10, minmax(0, 1fr))", 11: "repeat(11, minmax(0, 1fr))", 12: "repeat(12, minmax(0, 1fr))" }, gridTemplateRows: { none: "none", 1: "repeat(1, minmax(0, 1fr))", 2: "repeat(2, minmax(0, 1fr))", 3: "repeat(3, minmax(0, 1fr))", 4: "repeat(4, minmax(0, 1fr))", 5: "repeat(5, minmax(0, 1fr))", 6: "repeat(6, minmax(0, 1fr))" }, height: ({ theme: t }) => ({ auto: "auto", ...t("spacing"), "1/2": "50%", "1/3": "33.333333%", "2/3": "66.666667%", "1/4": "25%", "2/4": "50%", "3/4": "75%", "1/5": "20%", "2/5": "40%", "3/5": "60%", "4/5": "80%", "1/6": "16.666667%", "2/6": "33.333333%", "3/6": "50%", "4/6": "66.666667%", "5/6": "83.333333%", full: "100%", screen: "100vh", min: "min-content", max: "max-content", fit: "fit-content" }), hueRotate: { 0: "0deg", 15: "15deg", 30: "30deg", 60: "60deg", 90: "90deg", 180: "180deg" }, inset: ({ theme: t }) => ({ auto: "auto", ...t("spacing"), "1/2": "50%", "1/3": "33.333333%", "2/3": "66.666667%", "1/4": "25%", "2/4": "50%", "3/4": "75%", full: "100%" }), invert: { 0: "0", DEFAULT: "100%" }, keyframes: { spin: { to: { transform: "rotate(360deg)" } }, ping: { "75%, 100%": { transform: "scale(2)", opacity: "0" } }, pulse: { "50%": { opacity: ".5" } }, bounce: { "0%, 100%": { transform: "translateY(-25%)", animationTimingFunction: "cubic-bezier(0.8,0,1,1)" }, "50%": { transform: "none", animationTimingFunction: "cubic-bezier(0,0,0.2,1)" } } }, letterSpacing: { tighter: "-0.05em", tight: "-0.025em", normal: "0em", wide: "0.025em", wider: "0.05em", widest: "0.1em" }, lineHeight: { none: "1", tight: "1.25", snug: "1.375", normal: "1.5", relaxed: "1.625", loose: "2", 3: ".75rem", 4: "1rem", 5: "1.25rem", 6: "1.5rem", 7: "1.75rem", 8: "2rem", 9: "2.25rem", 10: "2.5rem" }, listStyleType: { none: "none", disc: "disc", decimal: "decimal" }, listStyleImage: { none: "none" }, margin: ({ theme: t }) => ({ auto: "auto", ...t("spacing") }), lineClamp: { 1: "1", 2: "2", 3: "3", 4: "4", 5: "5", 6: "6" }, maxHeight: ({ theme: t }) => ({ ...t("spacing"), none: "none", full: "100%", screen: "100vh", min: "min-content", max: "max-content", fit: "fit-content" }), maxWidth: ({ theme: t, breakpoints: e }) => ({ none: "none", 0: "0rem", xs: "20rem", sm: "24rem", md: "28rem", lg: "32rem", xl: "36rem", "2xl": "42rem", "3xl": "48rem", "4xl": "56rem", "5xl": "64rem", "6xl": "72rem", "7xl": "80rem", full: "100%", min: "min-content", max: "max-content", fit: "fit-content", prose: "65ch", ...e(t("screens")) }), minHeight: { 0: "0px", full: "100%", screen: "100vh", min: "min-content", max: "max-content", fit: "fit-content" }, minWidth: { 0: "0px", full: "100%", min: "min-content", max: "max-content", fit: "fit-content" }, objectPosition: { bottom: "bottom", center: "center", left: "left", "left-bottom": "left bottom", "left-top": "left top", right: "right", "right-bottom": "right bottom", "right-top": "right top", top: "top" }, opacity: { 0: "0", 5: "0.05", 10: "0.1", 20: "0.2", 25: "0.25", 30: "0.3", 40: "0.4", 50: "0.5", 60: "0.6", 70: "0.7", 75: "0.75", 80: "0.8", 90: "0.9", 95: "0.95", 100: "1" }, order: { first: "-9999", last: "9999", none: "0", 1: "1", 2: "2", 3: "3", 4: "4", 5: "5", 6: "6", 7: "7", 8: "8", 9: "9", 10: "10", 11: "11", 12: "12" }, outlineColor: ({ theme: t }) => t("colors"), outlineOffset: { 0: "0px", 1: "1px", 2: "2px", 4: "4px", 8: "8px" }, outlineWidth: { 0: "0px", 1: "1px", 2: "2px", 4: "4px", 8: "8px" }, padding: ({ theme: t }) => t("spacing"), placeholderColor: ({ theme: t }) => t("colors"), placeholderOpacity: ({ theme: t }) => t("opacity"), ringColor: ({ theme: t }) => ({ DEFAULT: t("colors.blue.500", "#3b82f6"), ...t("colors") }), ringOffsetColor: ({ theme: t }) => t("colors"), ringOffsetWidth: { 0: "0px", 1: "1px", 2: "2px", 4: "4px", 8: "8px" }, ringOpacity: ({ theme: t }) => ({ DEFAULT: "0.5", ...t("opacity") }), ringWidth: { DEFAULT: "3px", 0: "0px", 1: "1px", 2: "2px", 4: "4px", 8: "8px" }, rotate: { 0: "0deg", 1: "1deg", 2: "2deg", 3: "3deg", 6: "6deg", 12: "12deg", 45: "45deg", 90: "90deg", 180: "180deg" }, saturate: { 0: "0", 50: ".5", 100: "1", 150: "1.5", 200: "2" }, scale: { 0: "0", 50: ".5", 75: ".75", 90: ".9", 95: ".95", 100: "1", 105: "1.05", 110: "1.1", 125: "1.25", 150: "1.5" }, screens: { sm: "640px", md: "768px", lg: "1024px", xl: "1280px", "2xl": "1536px" }, scrollMargin: ({ theme: t }) => ({ ...t("spacing") }), scrollPadding: ({ theme: t }) => t("spacing"), sepia: { 0: "0", DEFAULT: "100%" }, skew: { 0: "0deg", 1: "1deg", 2: "2deg", 3: "3deg", 6: "6deg", 12: "12deg" }, space: ({ theme: t }) => ({ ...t("spacing") }), spacing: { px: "1px", 0: "0px", 0.5: "0.125rem", 1: "0.25rem", 1.5: "0.375rem", 2: "0.5rem", 2.5: "0.625rem", 3: "0.75rem", 3.5: "0.875rem", 4: "1rem", 5: "1.25rem", 6: "1.5rem", 7: "1.75rem", 8: "2rem", 9: "2.25rem", 10: "2.5rem", 11: "2.75rem", 12: "3rem", 14: "3.5rem", 16: "4rem", 20: "5rem", 24: "6rem", 28: "7rem", 32: "8rem", 36: "9rem", 40: "10rem", 44: "11rem", 48: "12rem", 52: "13rem", 56: "14rem", 60: "15rem", 64: "16rem", 72: "18rem", 80: "20rem", 96: "24rem" }, stroke: ({ theme: t }) => ({ none: "none", ...t("colors") }), strokeWidth: { 0: "0", 1: "1", 2: "2" }, supports: {}, data: {}, textColor: ({ theme: t }) => t("colors"), textDecorationColor: ({ theme: t }) => t("colors"), textDecorationThickness: { auto: "auto", "from-font": "from-font", 0: "0px", 1: "1px", 2: "2px", 4: "4px", 8: "8px" }, textIndent: ({ theme: t }) => ({ ...t("spacing") }), textOpacity: ({ theme: t }) => t("opacity"), textUnderlineOffset: { auto: "auto", 0: "0px", 1: "1px", 2: "2px", 4: "4px", 8: "8px" }, transformOrigin: { center: "center", top: "top", "top-right": "top right", right: "right", "bottom-right": "bottom right", bottom: "bottom", "bottom-left": "bottom left", left: "left", "top-left": "top left" }, transitionDelay: { 0: "0s", 75: "75ms", 100: "100ms", 150: "150ms", 200: "200ms", 300: "300ms", 500: "500ms", 700: "700ms", 1000: "1000ms" }, transitionDuration: { DEFAULT: "150ms", 0: "0s", 75: "75ms", 100: "100ms", 150: "150ms", 200: "200ms", 300: "300ms", 500: "500ms", 700: "700ms", 1000: "1000ms" }, transitionProperty: { none: "none", all: "all", DEFAULT: "color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter", colors: "color, background-color, border-color, text-decoration-color, fill, stroke", opacity: "opacity", shadow: "box-shadow", transform: "transform" }, transitionTimingFunction: { DEFAULT: "cubic-bezier(0.4, 0, 0.2, 1)", linear: "linear", in: "cubic-bezier(0.4, 0, 1, 1)", out: "cubic-bezier(0, 0, 0.2, 1)", "in-out": "cubic-bezier(0.4, 0, 0.2, 1)" }, translate: ({ theme: t }) => ({ ...t("spacing"), "1/2": "50%", "1/3": "33.333333%", "2/3": "66.666667%", "1/4": "25%", "2/4": "50%", "3/4": "75%", full: "100%" }), width: ({ theme: t }) => ({ auto: "auto", ...t("spacing"), "1/2": "50%", "1/3": "33.333333%", "2/3": "66.666667%", "1/4": "25%", "2/4": "50%", "3/4": "75%", "1/5": "20%", "2/5": "40%", "3/5": "60%", "4/5": "80%", "1/6": "16.666667%", "2/6": "33.333333%", "3/6": "50%", "4/6": "66.666667%", "5/6": "83.333333%", "1/12": "8.333333%", "2/12": "16.666667%", "3/12": "25%", "4/12": "33.333333%", "5/12": "41.666667%", "6/12": "50%", "7/12": "58.333333%", "8/12": "66.666667%", "9/12": "75%", "10/12": "83.333333%", "11/12": "91.666667%", full: "100%", screen: "100vw", min: "min-content", max: "max-content", fit: "fit-content" }), willChange: { auto: "auto", scroll: "scroll-position", contents: "contents", transform: "transform" }, zIndex: { auto: "auto", 0: "0", 10: "10", 20: "20", 30: "30", 40: "40", 50: "50" } }, plugins: [] };
});
var Dc = S((FO, Rc) => {
  var Dn = Object.prototype.hasOwnProperty, Ic = Object.prototype.toString, Ec = Object.defineProperty, Cc = Object.getOwnPropertyDescriptor, Ac = function(e) {
    return typeof Array.isArray == "function" ? Array.isArray(e) : Ic.call(e) === "[object Array]";
  }, _c = function(e) {
    if (!e || Ic.call(e) !== "[object Object]")
      return false;
    var r = Dn.call(e, "constructor"), n = e.constructor && e.constructor.prototype && Dn.call(e.constructor.prototype, "isPrototypeOf");
    if (e.constructor && !r && !n)
      return false;
    var i;
    for (i in e)
      ;
    return typeof i > "u" || Dn.call(e, i);
  }, Tc = function(e, r) {
    Ec && r.name === "__proto__" ? Ec(e, r.name, { enumerable: true, configurable: true, value: r.newValue, writable: true }) : e[r.name] = r.newValue;
  }, Pc = function(e, r) {
    if (r === "__proto__")
      if (Dn.call(e, r)) {
        if (Cc)
          return Cc(e, r).value;
      } else
        return;
    return e[r];
  };
  Rc.exports = function t() {
    var e, r, n, i, a, s, o2 = arguments[0], l = 1, u = arguments.length, f = false;
    for (typeof o2 == "boolean" && (f = o2, o2 = arguments[1] || {}, l = 2), (o2 == null || typeof o2 != "object" && typeof o2 != "function") && (o2 = {});l < u; ++l)
      if (e = arguments[l], e != null)
        for (r in e)
          n = Pc(o2, r), i = Pc(e, r), o2 !== i && (f && i && (_c(i) || (a = Ac(i))) ? (a ? (a = false, s = n && Ac(n) ? n : []) : s = n && _c(n) ? n : {}, Tc(o2, { name: r, newValue: t(f, s, i) })) : typeof i < "u" && Tc(o2, { name: r, newValue: i }));
    return o2;
  };
});
var Mn = S((LO, Mc) => {
  var ya = function(t, e) {
    var r = new t.constructor;
    return Object.keys(t).forEach(function(n) {
      if (!!t.hasOwnProperty(n)) {
        var i = t[n], a = typeof i;
        n === "parent" && a === "object" ? e && (r[n] = e) : n === "source" ? r[n] = i : i instanceof Array ? n === "nodes" ? r[n] = [] : r[n] = i.map(function(s) {
          ya(s, r);
        }) : n !== "before" && n !== "after" && n !== "between" && n !== "semicolon" && (a === "object" && (i = ya(i)), r[n] = i);
      }
    }), r;
  };
  Mc.exports = ya;
});
var $c = S((NO, qc) => {
  qc.exports = Lc;
  function Lc(t, e, r) {
    t instanceof RegExp && (t = Fc(t, r)), e instanceof RegExp && (e = Fc(e, r));
    var n = Nc(t, e, r);
    return n && { start: n[0], end: n[1], pre: r.slice(0, n[0]), body: r.slice(n[0] + t.length, n[1]), post: r.slice(n[1] + e.length) };
  }
  function Fc(t, e) {
    var r = e.match(t);
    return r ? r[0] : null;
  }
  Lc.range = Nc;
  function Nc(t, e, r) {
    var n, i, a, s, o2, l = r.indexOf(t), u = r.indexOf(e, l + 1), f = l;
    if (l >= 0 && u > 0) {
      if (t === e)
        return [l, u];
      for (n = [], a = r.length;f >= 0 && !o2; )
        f == l ? (n.push(f), l = r.indexOf(t, f + 1)) : n.length == 1 ? o2 = [n.pop(), u] : (i = n.pop(), i < a && (a = i, s = u), u = r.indexOf(e, f + 1)), f = l < u && l >= 0 ? l : u;
      n.length && (o2 = [a, s]);
    }
    return o2;
  }
});
var jc = S((qO, Uc) => {
  var Ow = /(.*?(?:(?:\([^\)]+\)|\[[^\]]+\]|(?![><+~\s]).)+)(?:(?:(?:\s(?!>>))|(?:\t(?!>>))|(?:\s?>>\s?))(?!\s+))(?![><+~][\s]+?))/, Ew = function(t) {
    return t.split(Ow).filter(function(e) {
      return e.length > 0;
    }).map(function(e) {
      return e.trim().replace(/\s*?>>\s*?/g, "");
    });
  };
  Uc.exports = Ew;
});
var dr = S(($O, zc) => {
  var Cw = jc(), Aw = function(t, e) {
    e = e || false;
    for (var r = [[]], n = e ? t : t.parent;n; ) {
      var i = (n.selectors || []).map(function(s) {
        return { value: s, type: "selector" };
      });
      n.type === "atrule" && (i = [].concat(n.params).map(function(s) {
        return { value: "@" + n.name + " " + s, type: "atrule" };
      }));
      var a = (i.length > 0 ? i : [1]).map(function() {
        return r.map(function(s) {
          return s.slice(0);
        });
      });
      i.forEach(function(s, o2) {
        a[o2] = a[o2].map(function(l) {
          var u = [s.value];
          return s.type === "selector" && (u = Cw(s.value)), l.unshift.apply(l, u), l;
        });
      }), r = [], a.forEach(function(s) {
        r = r.concat(s);
      }), n = n.parent;
    }
    return r;
  };
  zc.exports = Aw;
});
var Wc = S((UO, Vc) => {
  var _w = /[|\\{}()[\]^$+*?.]/g;
  Vc.exports = function(t) {
    if (typeof t != "string")
      throw new TypeError("Expected a string");
    return t.replace(_w, "\\$&");
  };
});
var Gc = S((jO, Bc) => {
  var Tw = { "*": true, ":root": true, html: true }, Pw = function(t) {
    return !!Tw[t];
  };
  Bc.exports = Pw;
});
var Hc = S((zO, Yc) => {
  var Iw = /(.*?(?:(?:\([^\)]+\)|\[[^\]]+\]|(?!>>|<|\+|~|\s).)+)(?:(?:(?:>(?!>))|(?:\s?>(?!>)\s?))(?!\s+))(?!(?:>>|<|\+|~)[\s]+?))/, Rw = function(t) {
    return t.split(Iw).filter(function(e) {
      return e.length > 0;
    }).map(function(e) {
      return e.trim().replace(/\s*?>\s*?/g, "");
    });
  };
  Yc.exports = Rw;
});
var va = S((VO, tp) => {
  var Dw = Wc(), Qc = Gc(), Jc = Hc(), Mw = /^@.*/, Kc = /([^\s:]+)((?::|::)[^\s]*?)(\s+|$)/;
  function Zc(t, e) {
    var r, n, i = e.some(function(a) {
      return t.some(function(s) {
        r = null;
        var o2 = true;
        for (n = 0;n < a.length; n++) {
          for (var l = a[n], u = r || 0, f = -1, p = s.slice(u), c2 = 0;c2 < p.length; c2++) {
            var d = p[c2], h = u + c2;
            if (new RegExp(Dw(l) + "$").test(d)) {
              f = h;
              break;
            }
            if (Qc(l) || Qc(d)) {
              f = h;
              break;
            }
            var y = Jc(d);
            if (y.length > 1) {
              var m = [].concat([y]), g = [].concat([a.slice(n).reduce(function(v, O) {
                return v.concat(Jc(O));
              }, [])]), w = Zc(m, g);
              (w.doesMatchScope || n + 1 < a.length) && (f = h, n += w.scopePieceIndex - 1);
              break;
            }
          }
          var b2 = f >= u;
          if (r = f + 1, o2 = o2 && b2, !o2)
            break;
        }
        return o2;
      });
    });
    return { doesMatchScope: i, nodeScopePieceIndex: r - 1, scopePieceIndex: n };
  }
  var Xc = function(t) {
    return t.map(function(e) {
      return e.map(function(r) {
        return Mw.test(r) ? r : r.replace(new RegExp(Kc.source, "g"), function(n, i, a, s) {
          return i + s;
        });
      });
    });
  }, ep = function(t, e, r) {
    return t = Xc(t), r && (e = Xc(e)), Zc(t, e).doesMatchScope;
  };
  ep.RE_PSEUDO_SELECTOR = Kc;
  tp.exports = ep;
});
var wa = S((WO, np) => {
  var Fw = va(), rp = dr(), Lw = function(t, e, r) {
    var n = rp(t, true), i = rp(e, true);
    return Fw(n, i, r);
  };
  np.exports = Lw;
});
var ba = S((BO, sp) => {
  var ip = function(t, e, r) {
    r = r || [];
    var n = false;
    return t && (r = t.reduce(function(i, a) {
      var s = !!e[a], o2 = s ? i.some(function(l) {
        return e[a].some(function(u) {
          return l === u;
        });
      }) : false;
      return n = n || o2, s && !n && (i = i.concat(e[a]), (e[a] || []).forEach(function(l) {
        var u = ip(l.variablesUsed, e, i);
        i = u.deps, n = n || u.hasCircularOrSelfReference;
      })), i;
    }, r)), { deps: r, hasCircularOrSelfReference: n };
  };
  sp.exports = ip;
});
var xa = S((GO, ap) => {
  var Nw = dr(), qw = function(t, e) {
    for (var r, n = e;n.parent && !r; ) {
      var i = Nw(n.clone(), true);
      i.some(function(a) {
        return a.some(function(s) {
          return s === t ? (r = n, true) : false;
        });
      }), n = n.parent;
    }
    return r;
  };
  ap.exports = qw;
});
var Sa = S((YO, lp) => {
  var op = Mn(), $w = function(t, e, r) {
    r = r || function() {
      return true;
    };
    for (var n = [], i = t, a = false;i && !a; )
      i.type === "decl" ? n.push(i.clone()) : n.push(op(i)), a = r(i), i = i.parent;
    for (var s = [], o2 = e;o2; )
      s.push(op(o2)), o2 = o2.parent;
    return s.forEach(function(l, u, f) {
      u + 1 < f.length && (l.parent = f[u + 1]);
    }), n.forEach(function(l, u, f) {
      u + 1 < f.length ? l.parent = f[u + 1] : (s.slice(-1)[0].parent = i, l.parent = s[0]);
    }), n[0];
  };
  lp.exports = $w;
});
var ka = S((HO, fp) => {
  var Uw = $c(), jw = dr(), up = wa(), zw = ba(), Vw = xa(), Ww = Sa(), Bw = /var\(\s*(--[^,\s)]+)/;
  function Gw(t) {
    return String(t);
  }
  function Fn(t) {
    var e = Uw("(", ")", t);
    if (e) {
      if (/(?:^|[^\w-])var$/.test(e.pre))
        return { pre: e.pre.slice(0, -3), body: e.body, post: e.post };
      var r = Fn(e.body);
      if (r)
        return { pre: e.pre + "(" + r.pre, body: r.body, post: r.post + ")" + e.post };
      var n = Fn(e.post);
      if (n)
        return { pre: e.pre + "(" + e.body + ")" + n.pre, body: n.body, post: n.post };
    }
  }
  var Ln = function(t, e, r, n) {
    for (var i = n ? "	" : "", a = undefined, s = Gw(t.value), o2 = [], l = {}, u = s;a = Fn(u); ) {
      var f = a.body.split(","), p = f[0].trim();
      l[p] = true, u = (a.pre || "") + a.body.replace(p, "") + (a.post || "");
    }
    u = undefined;
    for (var c2 = Object.keys(l), d = false;a = Fn(s); ) {
      var h = undefined, f = a.body.split(","), p = f[0].trim(), y = f.length > 1 ? f.slice(1).join(",").trim() : undefined;
      (e[p] || []).forEach(function(A) {
        var E = A.parent.type === "root" || A.parent.selectors[0] === ":root", I = up(t.parent, A.parent), F = up(t.parent, A.parent, r);
        F && (!(h || {}).isImportant || A.isImportant) && (h = A);
      });
      var m = (h || {}).calculatedInPlaceValue || function() {
        var A = y;
        if (y) {
          var E = t.clone({ parent: t.parent, value: y });
          A = Ln(E, e, false, true).value;
        }
        return A;
      }();
      if (h !== undefined && !zw(c2, e).hasCircularOrSelfReference) {
        var g = jw(t.parent.parent, true), w = g[0].slice(-1)[0], b2 = Vw(w, h.decl.parent), v = Ww(h.decl, t.parent.parent, function(A) {
          return A === b2;
        });
        m = Ln(v, e, false, true).value;
      }
      d = m === undefined, d && o2.push(["variable " + p + " is undefined and used without a fallback", { node: t }]), s = (a.pre || "") + m + (a.post || "");
    }
    return { value: d ? undefined : s, variablesUsed: c2, warnings: o2 };
  };
  Ln.RE_VAR_FUNC = Bw;
  fp.exports = Ln;
});
var hp = S((QO, dp) => {
  var cp = ka(), Yw = dr(), Hw = ba(), pp = va(), Qw = wa(), Nn = Mn(), Jw = xa(), Xw = Sa();
  function Kw(t, e, r, n) {
    t.forEach(function(i) {
      Hw(t, e).deps.forEach(function(a) {
        var s;
        if (a.isUnderAtRule) {
          var o2 = Yw(a.parent, true), l = o2[0].slice(-1)[0], u = Jw(l, r.parent), f = a.parent.parent;
          s = Xw(r, f, function(h) {
            return h === u;
          });
        } else if (pp.RE_PSEUDO_SELECTOR.test(a.parent.selector)) {
          var p = Nn(r.parent);
          p.parent = r.parent.parent, s = r.clone(), p.append(s);
          var c2 = a.parent.selector.match(new RegExp(pp.RE_PSEUDO_SELECTOR.source + "$")), d = c2 ? c2[2] : "";
          p.selector += d;
        }
        s && Qw(s, a.parent, true) && n(s, a);
      });
    });
  }
  function Zw(t, e, r, n, i) {
    r = (typeof r == "function" ? r(t) : r) || false, n = n || false;
    var a = function(l) {
      return i && i(l), l;
    }, s = a(cp(t, e)), o2;
    Kw(s.variablesUsed, e, t, function(l, u) {
      var f = Nn(t.parent), p = t.clone();
      f.append(p);
      let c2;
      if (typeof r == "function" ? c2 = r(t) : c2 = r, c2 === true && p.cloneAfter(), p.value = a(cp(l, e, true)).value, u.isUnderAtRule) {
        var d = Nn(u.parent.parent);
        d.append(f);
        for (var h = d, y = u.parent.parent;y.parent.type === "atrule"; ) {
          var m = Nn(y.parent);
          m.append(h), h = m, y = y.parent;
        }
        t.parent.parent.insertAfter(n && o2 || t.parent, h), o2 = h;
      } else
        f.selector = l.parent.selector, t.parent.parent.insertAfter(n && o2 || t.parent, f);
    }), r === true && t.value !== s.value && t.cloneAfter(), s.value === undefined && (s.value = "undefined"), t.value = s.value;
  }
  dp.exports = Zw;
});
var vp = S((JO, Oa) => {
  var mp = Dc(), eb = Mn(), gp = ka(), tb = hp(), yp = /(--(.+))/;
  function rb(t, e) {
    t.walkDecls(function(r) {
      yp.test(r.prop) && e(r);
    });
  }
  function nb(t) {
    for (var e = t;e && e.nodes.length <= 0; ) {
      var r = e.type !== "root" ? e : null;
      r ? (e = r.parent, r.remove()) : e = null;
    }
  }
  var ib = { preserve: false, variables: {}, preserveInjectedVariables: true, preserveAtRulesOrder: false };
  Oa.exports = (t = {}) => {
    var e = mp({}, ib, t);
    return { postcssPlugin: "postcss-css-variables", Once(r, { decl: n, result: i, rule: a }) {
      var s = [], o2 = [], l = {};
      l = mp(l, Object.keys(e.variables).reduce(function(p, c2) {
        var d = e.variables[c2];
        c2 = c2.slice(0, 2) === "--" ? c2 : "--" + c2;
        var h = (d || {}).value || d, y = (d || {}).isImportant || false, m = a({ selector: ":root" });
        r.root().prepend(m);
        var g = n({ prop: c2, value: h, important: y });
        return m.append(g), e.preserveInjectedVariables || o2.push(g), p[c2] = (p[c2] || []).concat({ decl: g, prop: c2, calculatedInPlaceValue: h, isImportant: y, variablesUsed: [], parent: m, isUnderAtRule: false }), p;
      }, {}));
      var u = function(p) {
        var c2 = [].concat(p.warnings);
        return c2.forEach(function(d) {
          d = [].concat(d), i.warn.apply(i, d);
        }), p;
      };
      rb(r, function(p) {
        var c2 = p.parent, d = u(gp(p, l));
        p.parent.selectors.forEach(function(y) {
          var m = eb(p.parent);
          m.selector = y, m.parent = p.parent.parent;
          var g = p.clone();
          m.append(g);
          var w = p.prop;
          l[w] = (l[w] || []).concat({ decl: g, prop: w, calculatedInPlaceValue: d.value, isImportant: p.important || false, variablesUsed: d.variablesUsed, parent: m, isUnderAtRule: m.parent.type === "atrule" });
        });
        let h;
        typeof e.preserve == "function" ? h = e.preserve(p) : h = e.preserve, h ? h === "computed" && (p.value = d.value) : p.remove(), c2.nodes.length <= 0 && s.push(c2);
      });
      var f = [];
      r.walk(function(p) {
        if (p.nodes !== undefined) {
          var c2 = p.nodes.some(function(d) {
            if (d.type === "decl") {
              var h = d;
              if (gp.RE_VAR_FUNC.test(h.value) && !yp.test(h.prop))
                return true;
            }
            return false;
          });
          c2 && f.push(p);
        }
      }), f.forEach(function(p) {
        var c2 = [].concat(p);
        p.type === "rule" && p.selectors.length > 1 && (c2 = p.selectors.reverse().map(function(d) {
          var h = p.cloneAfter();
          return h.selector = d, h;
        }), p.remove()), c2.forEach(function(d) {
          d.nodes.slice(0).forEach(function(h) {
            if (h.type === "decl") {
              var y = h;
              tb(y, l, e.preserve, e.preserveAtRulesOrder, u);
            }
          });
        });
      }), s.forEach(nb), o2.forEach(function(p) {
        p.remove();
      });
    } };
  };
  Oa.exports.postcss = true;
});
var Ra = (t) => ({ extractCSS(e, r = false) {
  let n = /(?:[\s\r\n]*)?(?<prop>[\w-]+)\s*:\s*(?<value>[^;\r\n]+)/gm, i, a = {};
  for (;(i = n.exec(e)) !== null; ) {
    let { prop: s, value: o2 } = i.groups;
    a[s] = o2;
  }
  return Object.entries(a).reduce((s, [o2, l]) => s + `${r ? "	" : ""}${o2}: ${l}; 
\r`, "");
}, merge() {
  let e = /(?<=\.)[^{]+\s*\{(?<content>[^{}]*(?:(?<=;)\s*\n\r?[^{}]*)*)\s*\}/gm, r, n = "";
  for (;(r = e.exec(t)) !== null; ) {
    let { content: o2 } = r.groups;
    n += o2;
  }
  let i = this.extractCSS(n), a = /(?<media>@media\s*\([^\)]*\))\s*\{(?<content>[^\}]*)\}/gm, s;
  for (;(s = a.exec(t)) !== null; ) {
    let { media: o2, content: l } = s.groups;
    i += `
\r${o2} {
\r${this.extractCSS(l, true)}}
\r`;
  }
  return t = i, this;
}, removeUndefined() {
  let e = /^[^{}]*(?:[.#][a-zA-Z0-9_-]+)[^{]*{[^}]*\b(?:[a-z-]+):\s*undefined\s*;?[^}]*}/gm;
  return t = t.replace(e, ""), this;
}, combineMediaQueries() {
  let e = new RegExp("@media\\s*(?<conditions>\\([^)]+\\))\\s*{(?<content>(?:[^{}]+|{(?:[^{}]+|{[^{}]*})*})+)}", "gs"), r = new Map, n = (a) => a.replace(e, (s, o2, l) => {
    var f;
    let u = (f = r.get(o2)) != null ? f : "";
    return r.set(o2, u + n(l.trim())), n(l), "";
  }), i = [];
  return i.push(n(t)), i.push(...Array.from(r, ([a, s]) => `@media${a}{${s}}`)), t = i.join(""), this;
}, minify() {
  return t = t.replace(/\/\*[\s\S]*?\*\//gm, "").replace(/;\s+/gm, ";").replace(/:\s+/gm, ":").replace(/\)\s*{/gm, "){").replace(/\s+\(/gm, "(").replace(/{\s+/gm, "{").replace(/}\s+/gm, "}").replace(/\s*{/gm, "{").replace(/;?\s*}/gm, "}"), this;
}, fixRGB() {
  let e = /rgb\(\s*(?<red>\d+)\s*(?<green>\d+)\s*(?<blue>\d+)(?:\s*\/\s*(?<alpha>[\d%.]+))?\s*\)/gm, r;
  for (;(r = e.exec(t)) !== null; ) {
    let [n] = r, { red: i, green: a, blue: s, alpha: o2 = 1 } = r.groups;
    t = t.replace(n, `rgb(${i},${a},${s}${o2 === "1" ? "" : `,${o2}`})`);
  }
  return this;
}, removeMediaQueries() {
  return t = t.replace(/@media[^\{]+\{[^@]+\}/g, ""), this;
}, get() {
  return t;
} });
var L = { info: $n, warn: $n, risk: $n };
vr();
var $f = H(Na());
var $a = "3.3.2";
var zn = { name: "tailwindcss", version: $a, description: "A utility-first CSS framework for rapidly building custom user interfaces.", license: "MIT", main: "lib/index.js", types: "types/index.d.ts", repository: "https://github.com/tailwindlabs/tailwindcss.git", bugs: "https://github.com/tailwindlabs/tailwindcss/issues", homepage: "https://tailwindcss.com", bin: { tailwind: "lib/cli.js", tailwindcss: "lib/cli.js" }, tailwindcss: { engine: "stable" }, scripts: { prebuild: "npm run generate && rimraf lib", build: `swc src --out-dir lib --copy-files --config jsc.transform.optimizer.globals.vars.__OXIDE__='"false"'`, postbuild: "esbuild lib/cli-peer-dependencies.js --bundle --platform=node --outfile=peers/index.js --define:process.env.CSS_TRANSFORMER_WASM=false", "rebuild-fixtures": "npm run build && node -r @swc/register scripts/rebuildFixtures.js", style: "eslint .", pretest: "npm run generate", test: "jest", "test:integrations": "npm run test --prefix ./integrations", "install:integrations": "node scripts/install-integrations.js", "generate:plugin-list": "node -r @swc/register scripts/create-plugin-list.js", "generate:types": "node -r @swc/register scripts/generate-types.js", generate: "npm run generate:plugin-list && npm run generate:types", "release-channel": "node ./scripts/release-channel.js", "release-notes": "node ./scripts/release-notes.js", prepublishOnly: "npm install --force && npm run build" }, files: ["src/*", "cli/*", "lib/*", "peers/*", "scripts/*.js", "stubs/*", "nesting/*", "types/**/*", "*.d.ts", "*.css", "*.js"], devDependencies: { "@swc/cli": "^0.1.62", "@swc/core": "^1.3.55", "@swc/jest": "^0.2.26", "@swc/register": "^0.1.10", autoprefixer: "^10.4.14", browserslist: "^4.21.5", concurrently: "^8.0.1", cssnano: "^6.0.0", esbuild: "^0.17.18", eslint: "^8.39.0", "eslint-config-prettier": "^8.8.0", "eslint-plugin-prettier": "^4.2.1", jest: "^29.5.0", "jest-diff": "^29.5.0", lightningcss: "1.18.0", prettier: "^2.8.8", rimraf: "^5.0.0", "source-map-js": "^1.0.2", turbo: "^1.9.3" }, dependencies: { "@alloc/quick-lru": "^5.2.0", arg: "^5.0.2", chokidar: "^3.5.3", didyoumean: "^1.2.2", dlv: "^1.1.3", "fast-glob": "^3.2.12", "glob-parent": "^6.0.2", "is-glob": "^4.0.3", jiti: "^1.18.2", lilconfig: "^2.1.0", micromatch: "^4.0.5", "normalize-path": "^3.0.0", "object-hash": "^3.0.0", picocolors: "^1.0.0", postcss: "^8.4.23", "postcss-import": "^15.1.0", "postcss-js": "^4.0.1", "postcss-load-config": "^4.0.1", "postcss-nested": "^6.0.1", "postcss-selector-parser": "^6.0.11", "postcss-value-parser": "^4.2.0", resolve: "^1.22.2", sucrase: "^3.32.0" }, browserslist: ["> 1%", "not edge <= 18", "not ie 11", "not op_mini all"], jest: { testTimeout: 30000, setupFilesAfterEnv: ["<rootDir>/jest/customMatchers.js"], testPathIgnorePatterns: ["/node_modules/", "/integrations/", "/standalone-cli/", "\\.test\\.skip\\.js$"], transformIgnorePatterns: ["node_modules/(?!lightningcss)"], transform: { "\\.js$": "@swc/jest", "\\.ts$": "@swc/jest" } }, engines: { node: ">=14.0.0" } };
var Vn = typeof process < "u" ? { NODE_ENV: "production", DEBUG: Dp(undefined), ENGINE: zn.tailwindcss.engine } : { NODE_ENV: "production", DEBUG: false, ENGINE: zn.tailwindcss.engine };
var Wn = new Map;
var ke = new String("*");
var mt = Symbol("__NONE__");
var $ = H(Ke(), 1);
var R = $.default;
var Kb = $.default.stringify;
var Zb = $.default.fromJSON;
var ex = $.default.plugin;
var tx = $.default.parse;
var rx = $.default.list;
var nx = $.default.document;
var ix = $.default.comment;
var sx = $.default.atRule;
var ax = $.default.rule;
var ox = $.default.decl;
var lx = $.default.root;
var ux = $.default.CssSyntaxError;
var fx = $.default.Declaration;
var cx = $.default.Container;
var px = $.default.Processor;
var dx = $.default.Document;
var hx = $.default.Comment;
var mx = $.default.Warning;
var gx = $.default.AtRule;
var yx = $.default.Result;
var vx = $.default.Input;
var wx = $.default.Rule;
var bx = $.default.Root;
var xx = $.default.Node;
var wn = H(ve());
var $u = H(Su());
var rt = H(qu(), 1);
var tn = rt.default;
var jx = rt.default.objectify;
var zx = rt.default.parse;
var Vx = rt.default.async;
var Wx = rt.default.sync;
var Uu = H(ve());
var ks = { aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50] };
var C0 = /^#([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})?$/i;
var A0 = /^#([a-f\d])([a-f\d])([a-f\d])([a-f\d])?$/i;
var Pe = /(?:\d+|\d*\.\d+)%?/;
var rn = /(?:\s*,\s*|\s+)/;
var ju = /\s*[,/]\s*/;
var Ie = /var\(--(?:[^ )]*?)\)/;
var _0 = new RegExp(`^(rgba?)\\(\\s*(${Pe.source}|${Ie.source})(?:${rn.source}(${Pe.source}|${Ie.source}))?(?:${rn.source}(${Pe.source}|${Ie.source}))?(?:${ju.source}(${Pe.source}|${Ie.source}))?\\s*\\)\$`);
var T0 = new RegExp(`^(hsla?)\\(\\s*((?:${Pe.source})(?:deg|rad|grad|turn)?|${Ie.source})(?:${rn.source}(${Pe.source}|${Ie.source}))?(?:${rn.source}(${Pe.source}|${Ie.source}))?(?:${ju.source}(${Pe.source}|${Ie.source}))?\\s*\\)\$`);
var P0 = new Set(["inset", "inherit", "initial", "revert", "unset"]);
var I0 = /\ +(?![^(]*\))/g;
var zu = /^-?(\d+|\.\d+)(.*?)$/g;
var R02 = ["min", "max", "clamp", "calc"];
var Wu = "--tw-placeholder";
var D0 = new RegExp(Wu, "g");
var M0 = ["cm", "mm", "Q", "in", "pc", "pt", "px", "em", "ex", "ch", "rem", "lh", "rlh", "vw", "vh", "vmin", "vmax", "vb", "vi", "svw", "svh", "lvw", "lvh", "dvw", "dvh", "cqw", "cqh", "cqi", "cqb", "cqmin", "cqmax"];
var F0 = `(?:${M0.join("|")})`;
var L0 = new Set(["thin", "medium", "thick"]);
var N0 = new Set(["linear-gradient", "radial-gradient", "repeating-linear-gradient", "repeating-radial-gradient", "conic-gradient"]);
var $02 = new Set(["center", "top", "right", "bottom", "left"]);
var U02 = new Set(["serif", "sans-serif", "monospace", "cursive", "fantasy", "system-ui", "ui-serif", "ui-sans-serif", "ui-monospace", "ui-rounded", "math", "emoji", "fangsong"]);
var j0 = new Set(["xx-small", "x-small", "small", "medium", "large", "x-large", "x-large", "xxx-large"]);
var z02 = new Set(["larger", "smaller"]);
Gn();
var tf = { optimizeUniversalDefaults: false, generalizedModifiers: true, get disableColorOpacityUtilitiesByDefault() {
}, get relativeContentPathsByDefault() {
} };
var sn = { future: ["hoverOnlyWhenSupported", "respectDefaultRingColorOpacity", "disableColorOpacityUtilitiesByDefault", "relativeContentPathsByDefault"], experimental: ["optimizeUniversalDefaults", "generalizedModifiers"] };
var _s = { any: an, color: W0, url: oe(Cs), image: oe(Hu), length: oe(ar), percentage: oe(sr), position: oe(Qu), lookup: B02, "generic-name": oe(Xu), "family-name": oe(Ju), number: oe(As), "line-width": oe(Bu), "absolute-size": oe(Ku), "relative-size": oe(Zu), shadow: oe(Gu), size: oe(ef) };
var sf = Object.keys(_s);
var be = H(ve());
var hf = H(jr());
var ff = H(ve());
var Is = { "::after": ["terminal", "jumpable"], "::backdrop": ["terminal"], "::before": ["terminal", "jumpable"], "::cue": ["terminal"], "::cue-region": ["terminal"], "::first-letter": ["terminal", "jumpable"], "::first-line": ["terminal", "jumpable"], "::grammar-error": ["terminal"], "::marker": ["terminal"], "::part": ["terminal", "actionable"], "::placeholder": ["terminal"], "::selection": ["terminal"], "::slotted": ["terminal"], "::spelling-error": ["terminal"], "::target-text": ["terminal"], "::file-selector-button": ["terminal", "actionable"], "::-webkit-progress-bar": ["terminal", "actionable"], "::-webkit-scrollbar": ["terminal", "actionable"], "::-webkit-scrollbar-button": ["terminal", "actionable"], "::-webkit-scrollbar-thumb": ["terminal", "actionable"], "::-webkit-scrollbar-track": ["terminal", "actionable"], "::-webkit-scrollbar-track-piece": ["terminal", "actionable"], "::-webkit-scrollbar-corner": ["terminal", "actionable"], "::-webkit-resizer": ["terminal", "actionable"], ":after": ["terminal", "jumpable"], ":before": ["terminal", "jumpable"], ":first-letter": ["terminal", "jumpable"], ":first-line": ["terminal", "jumpable"], __default__: ["actionable"] };
var Ds = ":merge";
var Cf = H(qs());
var Vs = H(ve());
vr();
kt();
var X0 = new Set(["normal", "reverse", "alternate", "alternate-reverse"]);
var K0 = new Set(["running", "paused"]);
var Z0 = new Set(["none", "forwards", "backwards", "both"]);
var ev = new Set(["infinite"]);
var tv = new Set(["linear", "ease", "ease-in", "ease-out", "ease-in-out", "step-start", "step-end"]);
var rv = ["cubic-bezier", "steps"];
var nv = /\,(?![^(]*\))/g;
var iv = /\ +(?![^(]*\))/g;
var mf = /^(-?[\d.]+m?s)$/;
var sv = /^(\d+)$/;
var gf = (t) => Object.assign({}, ...Object.entries(t != null ? t : {}).flatMap(([e, r]) => typeof r == "object" ? Object.entries(gf(r)).map(([n, i]) => ({ [e + (n === "DEFAULT" ? "" : `-${n}`)]: i })) : [{ [`${e}`]: r }]));
var Q = gf;
var ne2 = { pseudoElementVariants: ({ addVariant: t }) => {
  t("first-letter", "&::first-letter"), t("first-line", "&::first-line"), t("marker", [({ container: e }) => (cn(e, ["--tw-text-opacity"]), "& *::marker"), ({ container: e }) => (cn(e, ["--tw-text-opacity"]), "&::marker")]), t("selection", ["& *::selection", "&::selection"]), t("file", "&::file-selector-button"), t("placeholder", "&::placeholder"), t("backdrop", "&::backdrop"), t("before", ({ container: e }) => (e.walkRules((r) => {
    let n = false;
    r.walkDecls("content", () => {
      n = true;
    }), n || r.prepend(R.decl({ prop: "content", value: "var(--tw-content)" }));
  }), "&::before")), t("after", ({ container: e }) => (e.walkRules((r) => {
    let n = false;
    r.walkDecls("content", () => {
      n = true;
    }), n || r.prepend(R.decl({ prop: "content", value: "var(--tw-content)" }));
  }), "&::after"));
}, pseudoClassVariants: ({ addVariant: t, matchVariant: e, config: r }) => {
  let n = [["first", "&:first-child"], ["last", "&:last-child"], ["only", "&:only-child"], ["odd", "&:nth-child(odd)"], ["even", "&:nth-child(even)"], "first-of-type", "last-of-type", "only-of-type", ["visited", ({ container: a }) => (cn(a, ["--tw-text-opacity", "--tw-border-opacity", "--tw-bg-opacity"]), "&:visited")], "target", ["open", "&[open]"], "default", "checked", "indeterminate", "placeholder-shown", "autofill", "optional", "required", "valid", "invalid", "in-range", "out-of-range", "read-only", "empty", "focus-within", ["hover", G(r(), "hoverOnlyWhenSupported") ? "@media (hover: hover) and (pointer: fine) { &:hover }" : "&:hover"], "focus", "focus-visible", "active", "enabled", "disabled"].map((a) => Array.isArray(a) ? a : [a, `&:${a}`]);
  for (let [a, s] of n)
    t(a, (o2) => typeof s == "function" ? s(o2) : s);
  let i = { group: (a, { modifier: s }) => s ? [`:merge(.group\\/${re(s)})`, " &"] : [":merge(.group)", " &"], peer: (a, { modifier: s }) => s ? [`:merge(.peer\\/${re(s)})`, " ~ &"] : [":merge(.peer)", " ~ &"] };
  for (let [a, s] of Object.entries(i))
    e(a, (o2 = "", l) => {
      let u = z2(typeof o2 == "function" ? o2(l) : o2);
      u.includes("&") || (u = "&" + u);
      let [f, p] = s("", l), c2 = null, d = null, h = 0;
      for (let y = 0;y < u.length; ++y) {
        let m = u[y];
        m === "&" ? c2 = y : m === "'" || m === '"' ? h += 1 : c2 !== null && m === " " && !h && (d = y);
      }
      return c2 !== null && d === null && (d = u.length), u.slice(0, c2) + f + u.slice(c2 + 1, d) + p + u.slice(d);
    }, { values: Object.fromEntries(n) });
}, directionVariants: ({ addVariant: t }) => {
  t("ltr", ':is([dir="ltr"] &)'), t("rtl", ':is([dir="rtl"] &)');
}, reducedMotionVariants: ({ addVariant: t }) => {
  t("motion-safe", "@media (prefers-reduced-motion: no-preference)"), t("motion-reduce", "@media (prefers-reduced-motion: reduce)");
}, darkVariants: ({ config: t, addVariant: e }) => {
  let [r, n = ".dark"] = [].concat(t("darkMode", "media"));
  r === false && (r = "media", L.warn("darkmode-false", ["The `darkMode` option in your Tailwind CSS configuration is set to `false`, which now behaves the same as `media`.", "Change `darkMode` to `media` or remove it entirely.", "https://tailwindcss.com/docs/upgrade-guide#remove-dark-mode-configuration"])), r === "class" ? e("dark", `:is(${n} &)`) : r === "media" && e("dark", "@media (prefers-color-scheme: dark)");
}, printVariant: ({ addVariant: t }) => {
  t("print", "@media print");
}, screenVariants: ({ theme: t, addVariant: e, matchVariant: r }) => {
  var g;
  let n = (g = t("screens")) != null ? g : {}, i = Object.values(n).every((w) => typeof w == "string"), a = Fe(t("screens")), s = new Set([]);
  function o2(w) {
    var b2, v;
    return (v = (b2 = w.match(/(\D+)$/)) == null ? undefined : b2[1]) != null ? v : "(none)";
  }
  function l(w) {
    w !== undefined && s.add(o2(w));
  }
  function u(w) {
    return l(w), s.size === 1;
  }
  for (let w of a)
    for (let b2 of w.values)
      l(b2.min), l(b2.max);
  let f = s.size <= 1;
  function p(w) {
    return Object.fromEntries(a.filter((b2) => un(b2).result).map((b2) => {
      let { min: v, max: O } = b2.values[0];
      if (w === "min" && v !== undefined)
        return b2;
      if (w === "min" && O !== undefined)
        return { ...b2, not: !b2.not };
      if (w === "max" && O !== undefined)
        return b2;
      if (w === "max" && v !== undefined)
        return { ...b2, not: !b2.not };
    }).map((b2) => [b2.name, b2]));
  }
  function c2(w) {
    return (b2, v) => vf(w, b2.value, v.value);
  }
  let d = c2("max"), h = c2("min");
  function y(w) {
    return (b2) => {
      if (i)
        if (f) {
          if (typeof b2 == "string" && !u(b2))
            return L.warn("minmax-have-mixed-units", ["The `min-*` and `max-*` variants are not supported with a `screens` configuration containing mixed units."]), [];
        } else
          return L.warn("mixed-screen-units", ["The `min-*` and `max-*` variants are not supported with a `screens` configuration containing mixed units."]), [];
      else
        return L.warn("complex-screen-config", ["The `min-*` and `max-*` variants are not supported with a `screens` configuration containing objects."]), [];
      return [`@media ${Me(fn(b2, w))}`];
    };
  }
  r("max", y("max"), { sort: d, values: i ? p("max") : {} });
  let m = "min-screens";
  for (let w of a)
    e(w.name, `@media ${Me(w)}`, { id: m, sort: i && f ? h : undefined, value: w });
  r("min", y("min"), { id: m, sort: h });
}, supportsVariants: ({ matchVariant: t, theme: e }) => {
  var r;
  t("supports", (n = "") => {
    let i = z2(n), a = /^\w*\s*\(/.test(i);
    return i = a ? i.replace(/\b(and|or|not)\b/g, " $1 ") : i, a ? `@supports ${i}` : (i.includes(":") || (i = `${i}: var(--tw)`), i.startsWith("(") && i.endsWith(")") || (i = `(${i})`), `@supports ${i}`);
  }, { values: (r = e("supports")) != null ? r : {} });
}, ariaVariants: ({ matchVariant: t, theme: e }) => {
  var r, n, i;
  t("aria", (a) => `&[aria-${z2(a)}]`, { values: (r = e("aria")) != null ? r : {} }), t("group-aria", (a, { modifier: s }) => s ? `:merge(.group\\/${s})[aria-${z2(a)}] &` : `:merge(.group)[aria-${z2(a)}] &`, { values: (n = e("aria")) != null ? n : {} }), t("peer-aria", (a, { modifier: s }) => s ? `:merge(.peer\\/${s})[aria-${z2(a)}] ~ &` : `:merge(.peer)[aria-${z2(a)}] ~ &`, { values: (i = e("aria")) != null ? i : {} });
}, dataVariants: ({ matchVariant: t, theme: e }) => {
  var r, n, i;
  t("data", (a) => `&[data-${z2(a)}]`, { values: (r = e("data")) != null ? r : {} }), t("group-data", (a, { modifier: s }) => s ? `:merge(.group\\/${s})[data-${z2(a)}] &` : `:merge(.group)[data-${z2(a)}] &`, { values: (n = e("data")) != null ? n : {} }), t("peer-data", (a, { modifier: s }) => s ? `:merge(.peer\\/${s})[data-${z2(a)}] ~ &` : `:merge(.peer)[data-${z2(a)}] ~ &`, { values: (i = e("data")) != null ? i : {} });
}, orientationVariants: ({ addVariant: t }) => {
  t("portrait", "@media (orientation: portrait)"), t("landscape", "@media (orientation: landscape)");
}, prefersContrastVariants: ({ addVariant: t }) => {
  t("contrast-more", "@media (prefers-contrast: more)"), t("contrast-less", "@media (prefers-contrast: less)");
} };
var he = ["translate(var(--tw-translate-x), var(--tw-translate-y))", "rotate(var(--tw-rotate))", "skewX(var(--tw-skew-x))", "skewY(var(--tw-skew-y))", "scaleX(var(--tw-scale-x))", "scaleY(var(--tw-scale-y))"].join(" ");
var xe = ["var(--tw-blur)", "var(--tw-brightness)", "var(--tw-contrast)", "var(--tw-grayscale)", "var(--tw-hue-rotate)", "var(--tw-invert)", "var(--tw-saturate)", "var(--tw-sepia)", "var(--tw-drop-shadow)"].join(" ");
var Se = ["var(--tw-backdrop-blur)", "var(--tw-backdrop-brightness)", "var(--tw-backdrop-contrast)", "var(--tw-backdrop-grayscale)", "var(--tw-backdrop-hue-rotate)", "var(--tw-backdrop-invert)", "var(--tw-backdrop-opacity)", "var(--tw-backdrop-saturate)", "var(--tw-backdrop-sepia)"].join(" ");
var wf = { preflight: ({ addBase: t }) => {
  let e = R.parse(ht.readFileSync(Kn("/", "./css/preflight.css"), "utf8"));
  t([R.comment({ text: `! tailwindcss v${$a} | MIT License | https://tailwindcss.com` }), ...e.nodes]);
}, container: (() => {
  function t(r = []) {
    return r.flatMap((n) => n.values.map((i) => i.min)).filter((n) => n !== undefined);
  }
  function e(r, n, i) {
    if (typeof i > "u")
      return [];
    if (!(typeof i == "object" && i !== null))
      return [{ screen: "DEFAULT", minWidth: 0, padding: i }];
    let a = [];
    i.DEFAULT && a.push({ screen: "DEFAULT", minWidth: 0, padding: i.DEFAULT });
    for (let s of r)
      for (let o2 of n)
        for (let { min: l } of o2.values)
          l === s && a.push({ minWidth: s, padding: i[o2.name] });
    return a;
  }
  return function({ addComponents: r, theme: n }) {
    let i = Fe(n("container.screens", n("screens"))), a = t(i), s = e(a, i, n("container.padding")), o2 = (u) => {
      let f = s.find((p) => p.minWidth === u);
      return f ? { paddingRight: f.padding, paddingLeft: f.padding } : {};
    }, l = Array.from(new Set(a.slice().sort((u, f) => parseInt(u) - parseInt(f)))).map((u) => ({ [`@media (min-width: ${u})`]: { ".container": { "max-width": u, ...o2(u) } } }));
    r([{ ".container": Object.assign({ width: "100%" }, n("container.center", false) ? { marginRight: "auto", marginLeft: "auto" } : {}, o2(0)) }, ...l]);
  };
})(), accessibility: ({ addUtilities: t }) => {
  t({ ".sr-only": { position: "absolute", width: "1px", height: "1px", padding: "0", margin: "-1px", overflow: "hidden", clip: "rect(0, 0, 0, 0)", whiteSpace: "nowrap", borderWidth: "0" }, ".not-sr-only": { position: "static", width: "auto", height: "auto", padding: "0", margin: "0", overflow: "visible", clip: "auto", whiteSpace: "normal" } });
}, pointerEvents: ({ addUtilities: t }) => {
  t({ ".pointer-events-none": { "pointer-events": "none" }, ".pointer-events-auto": { "pointer-events": "auto" } });
}, visibility: ({ addUtilities: t }) => {
  t({ ".visible": { visibility: "visible" }, ".invisible": { visibility: "hidden" }, ".collapse": { visibility: "collapse" } });
}, position: ({ addUtilities: t }) => {
  t({ ".static": { position: "static" }, ".fixed": { position: "fixed" }, ".absolute": { position: "absolute" }, ".relative": { position: "relative" }, ".sticky": { position: "sticky" } });
}, inset: T("inset", [["inset", ["inset"]], [["inset-x", ["left", "right"]], ["inset-y", ["top", "bottom"]]], [["start", ["inset-inline-start"]], ["end", ["inset-inline-end"]], ["top", ["top"]], ["right", ["right"]], ["bottom", ["bottom"]], ["left", ["left"]]]], { supportsNegativeValues: true }), isolation: ({ addUtilities: t }) => {
  t({ ".isolate": { isolation: "isolate" }, ".isolation-auto": { isolation: "auto" } });
}, zIndex: T("zIndex", [["z", ["zIndex"]]], { supportsNegativeValues: true }), order: T("order", undefined, { supportsNegativeValues: true }), gridColumn: T("gridColumn", [["col", ["gridColumn"]]]), gridColumnStart: T("gridColumnStart", [["col-start", ["gridColumnStart"]]]), gridColumnEnd: T("gridColumnEnd", [["col-end", ["gridColumnEnd"]]]), gridRow: T("gridRow", [["row", ["gridRow"]]]), gridRowStart: T("gridRowStart", [["row-start", ["gridRowStart"]]]), gridRowEnd: T("gridRowEnd", [["row-end", ["gridRowEnd"]]]), float: ({ addUtilities: t }) => {
  t({ ".float-right": { float: "right" }, ".float-left": { float: "left" }, ".float-none": { float: "none" } });
}, clear: ({ addUtilities: t }) => {
  t({ ".clear-left": { clear: "left" }, ".clear-right": { clear: "right" }, ".clear-both": { clear: "both" }, ".clear-none": { clear: "none" } });
}, margin: T("margin", [["m", ["margin"]], [["mx", ["margin-left", "margin-right"]], ["my", ["margin-top", "margin-bottom"]]], [["ms", ["margin-inline-start"]], ["me", ["margin-inline-end"]], ["mt", ["margin-top"]], ["mr", ["margin-right"]], ["mb", ["margin-bottom"]], ["ml", ["margin-left"]]]], { supportsNegativeValues: true }), boxSizing: ({ addUtilities: t }) => {
  t({ ".box-border": { "box-sizing": "border-box" }, ".box-content": { "box-sizing": "content-box" } });
}, lineClamp: ({ matchUtilities: t, addUtilities: e, theme: r }) => {
  t({ "line-clamp": (n) => ({ overflow: "hidden", display: "-webkit-box", "-webkit-box-orient": "vertical", "-webkit-line-clamp": `${n}` }) }, { values: r("lineClamp") }), e({ ".line-clamp-none": { overflow: "visible", display: "block", "-webkit-box-orient": "horizontal", "-webkit-line-clamp": "none" } });
}, display: ({ addUtilities: t }) => {
  t({ ".block": { display: "block" }, ".inline-block": { display: "inline-block" }, ".inline": { display: "inline" }, ".flex": { display: "flex" }, ".inline-flex": { display: "inline-flex" }, ".table": { display: "table" }, ".inline-table": { display: "inline-table" }, ".table-caption": { display: "table-caption" }, ".table-cell": { display: "table-cell" }, ".table-column": { display: "table-column" }, ".table-column-group": { display: "table-column-group" }, ".table-footer-group": { display: "table-footer-group" }, ".table-header-group": { display: "table-header-group" }, ".table-row-group": { display: "table-row-group" }, ".table-row": { display: "table-row" }, ".flow-root": { display: "flow-root" }, ".grid": { display: "grid" }, ".inline-grid": { display: "inline-grid" }, ".contents": { display: "contents" }, ".list-item": { display: "list-item" }, ".hidden": { display: "none" } });
}, aspectRatio: T("aspectRatio", [["aspect", ["aspect-ratio"]]]), height: T("height", [["h", ["height"]]]), maxHeight: T("maxHeight", [["max-h", ["maxHeight"]]]), minHeight: T("minHeight", [["min-h", ["minHeight"]]]), width: T("width", [["w", ["width"]]]), minWidth: T("minWidth", [["min-w", ["minWidth"]]]), maxWidth: T("maxWidth", [["max-w", ["maxWidth"]]]), flex: T("flex"), flexShrink: T("flexShrink", [["flex-shrink", ["flex-shrink"]], ["shrink", ["flex-shrink"]]]), flexGrow: T("flexGrow", [["flex-grow", ["flex-grow"]], ["grow", ["flex-grow"]]]), flexBasis: T("flexBasis", [["basis", ["flex-basis"]]]), tableLayout: ({ addUtilities: t }) => {
  t({ ".table-auto": { "table-layout": "auto" }, ".table-fixed": { "table-layout": "fixed" } });
}, captionSide: ({ addUtilities: t }) => {
  t({ ".caption-top": { "caption-side": "top" }, ".caption-bottom": { "caption-side": "bottom" } });
}, borderCollapse: ({ addUtilities: t }) => {
  t({ ".border-collapse": { "border-collapse": "collapse" }, ".border-separate": { "border-collapse": "separate" } });
}, borderSpacing: ({ addDefaults: t, matchUtilities: e, theme: r }) => {
  t("border-spacing", { "--tw-border-spacing-x": 0, "--tw-border-spacing-y": 0 }), e({ "border-spacing": (n) => ({ "--tw-border-spacing-x": n, "--tw-border-spacing-y": n, "@defaults border-spacing": {}, "border-spacing": "var(--tw-border-spacing-x) var(--tw-border-spacing-y)" }), "border-spacing-x": (n) => ({ "--tw-border-spacing-x": n, "@defaults border-spacing": {}, "border-spacing": "var(--tw-border-spacing-x) var(--tw-border-spacing-y)" }), "border-spacing-y": (n) => ({ "--tw-border-spacing-y": n, "@defaults border-spacing": {}, "border-spacing": "var(--tw-border-spacing-x) var(--tw-border-spacing-y)" }) }, { values: r("borderSpacing") });
}, transformOrigin: T("transformOrigin", [["origin", ["transformOrigin"]]]), translate: T("translate", [[["translate-x", [["@defaults transform", {}], "--tw-translate-x", ["transform", he]]], ["translate-y", [["@defaults transform", {}], "--tw-translate-y", ["transform", he]]]]], { supportsNegativeValues: true }), rotate: T("rotate", [["rotate", [["@defaults transform", {}], "--tw-rotate", ["transform", he]]]], { supportsNegativeValues: true }), skew: T("skew", [[["skew-x", [["@defaults transform", {}], "--tw-skew-x", ["transform", he]]], ["skew-y", [["@defaults transform", {}], "--tw-skew-y", ["transform", he]]]]], { supportsNegativeValues: true }), scale: T("scale", [["scale", [["@defaults transform", {}], "--tw-scale-x", "--tw-scale-y", ["transform", he]]], [["scale-x", [["@defaults transform", {}], "--tw-scale-x", ["transform", he]]], ["scale-y", [["@defaults transform", {}], "--tw-scale-y", ["transform", he]]]]], { supportsNegativeValues: true }), transform: ({ addDefaults: t, addUtilities: e }) => {
  t("transform", { "--tw-translate-x": "0", "--tw-translate-y": "0", "--tw-rotate": "0", "--tw-skew-x": "0", "--tw-skew-y": "0", "--tw-scale-x": "1", "--tw-scale-y": "1" }), e({ ".transform": { "@defaults transform": {}, transform: he }, ".transform-cpu": { transform: he }, ".transform-gpu": { transform: he.replace("translate(var(--tw-translate-x), var(--tw-translate-y))", "translate3d(var(--tw-translate-x), var(--tw-translate-y), 0)") }, ".transform-none": { transform: "none" } });
}, animation: ({ matchUtilities: t, theme: e, config: r }) => {
  var a;
  let n = (s) => `${r("prefix")}${re(s)}`, i = Object.fromEntries(Object.entries((a = e("keyframes")) != null ? a : {}).map(([s, o2]) => [s, { [`@keyframes ${n(s)}`]: o2 }]));
  t({ animate: (s) => {
    let o2 = $s(s);
    return [...o2.flatMap((l) => i[l.name]), { animation: o2.map(({ name: l, value: u }) => l === undefined || i[l] === undefined ? u : u.replace(l, n(l))).join(", ") }];
  } }, { values: e("animation") });
}, cursor: T("cursor"), touchAction: ({ addDefaults: t, addUtilities: e }) => {
  t("touch-action", { "--tw-pan-x": " ", "--tw-pan-y": " ", "--tw-pinch-zoom": " " });
  let r = "var(--tw-pan-x) var(--tw-pan-y) var(--tw-pinch-zoom)";
  e({ ".touch-auto": { "touch-action": "auto" }, ".touch-none": { "touch-action": "none" }, ".touch-pan-x": { "@defaults touch-action": {}, "--tw-pan-x": "pan-x", "touch-action": r }, ".touch-pan-left": { "@defaults touch-action": {}, "--tw-pan-x": "pan-left", "touch-action": r }, ".touch-pan-right": { "@defaults touch-action": {}, "--tw-pan-x": "pan-right", "touch-action": r }, ".touch-pan-y": { "@defaults touch-action": {}, "--tw-pan-y": "pan-y", "touch-action": r }, ".touch-pan-up": { "@defaults touch-action": {}, "--tw-pan-y": "pan-up", "touch-action": r }, ".touch-pan-down": { "@defaults touch-action": {}, "--tw-pan-y": "pan-down", "touch-action": r }, ".touch-pinch-zoom": { "@defaults touch-action": {}, "--tw-pinch-zoom": "pinch-zoom", "touch-action": r }, ".touch-manipulation": { "touch-action": "manipulation" } });
}, userSelect: ({ addUtilities: t }) => {
  t({ ".select-none": { "user-select": "none" }, ".select-text": { "user-select": "text" }, ".select-all": { "user-select": "all" }, ".select-auto": { "user-select": "auto" } });
}, resize: ({ addUtilities: t }) => {
  t({ ".resize-none": { resize: "none" }, ".resize-y": { resize: "vertical" }, ".resize-x": { resize: "horizontal" }, ".resize": { resize: "both" } });
}, scrollSnapType: ({ addDefaults: t, addUtilities: e }) => {
  t("scroll-snap-type", { "--tw-scroll-snap-strictness": "proximity" }), e({ ".snap-none": { "scroll-snap-type": "none" }, ".snap-x": { "@defaults scroll-snap-type": {}, "scroll-snap-type": "x var(--tw-scroll-snap-strictness)" }, ".snap-y": { "@defaults scroll-snap-type": {}, "scroll-snap-type": "y var(--tw-scroll-snap-strictness)" }, ".snap-both": { "@defaults scroll-snap-type": {}, "scroll-snap-type": "both var(--tw-scroll-snap-strictness)" }, ".snap-mandatory": { "--tw-scroll-snap-strictness": "mandatory" }, ".snap-proximity": { "--tw-scroll-snap-strictness": "proximity" } });
}, scrollSnapAlign: ({ addUtilities: t }) => {
  t({ ".snap-start": { "scroll-snap-align": "start" }, ".snap-end": { "scroll-snap-align": "end" }, ".snap-center": { "scroll-snap-align": "center" }, ".snap-align-none": { "scroll-snap-align": "none" } });
}, scrollSnapStop: ({ addUtilities: t }) => {
  t({ ".snap-normal": { "scroll-snap-stop": "normal" }, ".snap-always": { "scroll-snap-stop": "always" } });
}, scrollMargin: T("scrollMargin", [["scroll-m", ["scroll-margin"]], [["scroll-mx", ["scroll-margin-left", "scroll-margin-right"]], ["scroll-my", ["scroll-margin-top", "scroll-margin-bottom"]]], [["scroll-ms", ["scroll-margin-inline-start"]], ["scroll-me", ["scroll-margin-inline-end"]], ["scroll-mt", ["scroll-margin-top"]], ["scroll-mr", ["scroll-margin-right"]], ["scroll-mb", ["scroll-margin-bottom"]], ["scroll-ml", ["scroll-margin-left"]]]], { supportsNegativeValues: true }), scrollPadding: T("scrollPadding", [["scroll-p", ["scroll-padding"]], [["scroll-px", ["scroll-padding-left", "scroll-padding-right"]], ["scroll-py", ["scroll-padding-top", "scroll-padding-bottom"]]], [["scroll-ps", ["scroll-padding-inline-start"]], ["scroll-pe", ["scroll-padding-inline-end"]], ["scroll-pt", ["scroll-padding-top"]], ["scroll-pr", ["scroll-padding-right"]], ["scroll-pb", ["scroll-padding-bottom"]], ["scroll-pl", ["scroll-padding-left"]]]]), listStylePosition: ({ addUtilities: t }) => {
  t({ ".list-inside": { "list-style-position": "inside" }, ".list-outside": { "list-style-position": "outside" } });
}, listStyleType: T("listStyleType", [["list", ["listStyleType"]]]), listStyleImage: T("listStyleImage", [["list-image", ["listStyleImage"]]]), appearance: ({ addUtilities: t }) => {
  t({ ".appearance-none": { appearance: "none" } });
}, columns: T("columns", [["columns", ["columns"]]]), breakBefore: ({ addUtilities: t }) => {
  t({ ".break-before-auto": { "break-before": "auto" }, ".break-before-avoid": { "break-before": "avoid" }, ".break-before-all": { "break-before": "all" }, ".break-before-avoid-page": { "break-before": "avoid-page" }, ".break-before-page": { "break-before": "page" }, ".break-before-left": { "break-before": "left" }, ".break-before-right": { "break-before": "right" }, ".break-before-column": { "break-before": "column" } });
}, breakInside: ({ addUtilities: t }) => {
  t({ ".break-inside-auto": { "break-inside": "auto" }, ".break-inside-avoid": { "break-inside": "avoid" }, ".break-inside-avoid-page": { "break-inside": "avoid-page" }, ".break-inside-avoid-column": { "break-inside": "avoid-column" } });
}, breakAfter: ({ addUtilities: t }) => {
  t({ ".break-after-auto": { "break-after": "auto" }, ".break-after-avoid": { "break-after": "avoid" }, ".break-after-all": { "break-after": "all" }, ".break-after-avoid-page": { "break-after": "avoid-page" }, ".break-after-page": { "break-after": "page" }, ".break-after-left": { "break-after": "left" }, ".break-after-right": { "break-after": "right" }, ".break-after-column": { "break-after": "column" } });
}, gridAutoColumns: T("gridAutoColumns", [["auto-cols", ["gridAutoColumns"]]]), gridAutoFlow: ({ addUtilities: t }) => {
  t({ ".grid-flow-row": { gridAutoFlow: "row" }, ".grid-flow-col": { gridAutoFlow: "column" }, ".grid-flow-dense": { gridAutoFlow: "dense" }, ".grid-flow-row-dense": { gridAutoFlow: "row dense" }, ".grid-flow-col-dense": { gridAutoFlow: "column dense" } });
}, gridAutoRows: T("gridAutoRows", [["auto-rows", ["gridAutoRows"]]]), gridTemplateColumns: T("gridTemplateColumns", [["grid-cols", ["gridTemplateColumns"]]]), gridTemplateRows: T("gridTemplateRows", [["grid-rows", ["gridTemplateRows"]]]), flexDirection: ({ addUtilities: t }) => {
  t({ ".flex-row": { "flex-direction": "row" }, ".flex-row-reverse": { "flex-direction": "row-reverse" }, ".flex-col": { "flex-direction": "column" }, ".flex-col-reverse": { "flex-direction": "column-reverse" } });
}, flexWrap: ({ addUtilities: t }) => {
  t({ ".flex-wrap": { "flex-wrap": "wrap" }, ".flex-wrap-reverse": { "flex-wrap": "wrap-reverse" }, ".flex-nowrap": { "flex-wrap": "nowrap" } });
}, placeContent: ({ addUtilities: t }) => {
  t({ ".place-content-center": { "place-content": "center" }, ".place-content-start": { "place-content": "start" }, ".place-content-end": { "place-content": "end" }, ".place-content-between": { "place-content": "space-between" }, ".place-content-around": { "place-content": "space-around" }, ".place-content-evenly": { "place-content": "space-evenly" }, ".place-content-baseline": { "place-content": "baseline" }, ".place-content-stretch": { "place-content": "stretch" } });
}, placeItems: ({ addUtilities: t }) => {
  t({ ".place-items-start": { "place-items": "start" }, ".place-items-end": { "place-items": "end" }, ".place-items-center": { "place-items": "center" }, ".place-items-baseline": { "place-items": "baseline" }, ".place-items-stretch": { "place-items": "stretch" } });
}, alignContent: ({ addUtilities: t }) => {
  t({ ".content-normal": { "align-content": "normal" }, ".content-center": { "align-content": "center" }, ".content-start": { "align-content": "flex-start" }, ".content-end": { "align-content": "flex-end" }, ".content-between": { "align-content": "space-between" }, ".content-around": { "align-content": "space-around" }, ".content-evenly": { "align-content": "space-evenly" }, ".content-baseline": { "align-content": "baseline" }, ".content-stretch": { "align-content": "stretch" } });
}, alignItems: ({ addUtilities: t }) => {
  t({ ".items-start": { "align-items": "flex-start" }, ".items-end": { "align-items": "flex-end" }, ".items-center": { "align-items": "center" }, ".items-baseline": { "align-items": "baseline" }, ".items-stretch": { "align-items": "stretch" } });
}, justifyContent: ({ addUtilities: t }) => {
  t({ ".justify-normal": { "justify-content": "normal" }, ".justify-start": { "justify-content": "flex-start" }, ".justify-end": { "justify-content": "flex-end" }, ".justify-center": { "justify-content": "center" }, ".justify-between": { "justify-content": "space-between" }, ".justify-around": { "justify-content": "space-around" }, ".justify-evenly": { "justify-content": "space-evenly" }, ".justify-stretch": { "justify-content": "stretch" } });
}, justifyItems: ({ addUtilities: t }) => {
  t({ ".justify-items-start": { "justify-items": "start" }, ".justify-items-end": { "justify-items": "end" }, ".justify-items-center": { "justify-items": "center" }, ".justify-items-stretch": { "justify-items": "stretch" } });
}, gap: T("gap", [["gap", ["gap"]], [["gap-x", ["columnGap"]], ["gap-y", ["rowGap"]]]]), space: ({ matchUtilities: t, addUtilities: e, theme: r }) => {
  t({ "space-x": (n) => (n = n === "0" ? "0px" : n, { "& > :not([hidden]) ~ :not([hidden])": { "--tw-space-x-reverse": "0", "margin-right": `calc(${n} * var(--tw-space-x-reverse))`, "margin-left": `calc(${n} * calc(1 - var(--tw-space-x-reverse)))` } }), "space-y": (n) => (n = n === "0" ? "0px" : n, { "& > :not([hidden]) ~ :not([hidden])": { "--tw-space-y-reverse": "0", "margin-top": `calc(${n} * calc(1 - var(--tw-space-y-reverse)))`, "margin-bottom": `calc(${n} * var(--tw-space-y-reverse))` } }) }, { values: r("space"), supportsNegativeValues: true }), e({ ".space-y-reverse > :not([hidden]) ~ :not([hidden])": { "--tw-space-y-reverse": "1" }, ".space-x-reverse > :not([hidden]) ~ :not([hidden])": { "--tw-space-x-reverse": "1" } });
}, divideWidth: ({ matchUtilities: t, addUtilities: e, theme: r }) => {
  t({ "divide-x": (n) => (n = n === "0" ? "0px" : n, { "& > :not([hidden]) ~ :not([hidden])": { "@defaults border-width": {}, "--tw-divide-x-reverse": "0", "border-right-width": `calc(${n} * var(--tw-divide-x-reverse))`, "border-left-width": `calc(${n} * calc(1 - var(--tw-divide-x-reverse)))` } }), "divide-y": (n) => (n = n === "0" ? "0px" : n, { "& > :not([hidden]) ~ :not([hidden])": { "@defaults border-width": {}, "--tw-divide-y-reverse": "0", "border-top-width": `calc(${n} * calc(1 - var(--tw-divide-y-reverse)))`, "border-bottom-width": `calc(${n} * var(--tw-divide-y-reverse))` } }) }, { values: r("divideWidth"), type: ["line-width", "length", "any"] }), e({ ".divide-y-reverse > :not([hidden]) ~ :not([hidden])": { "@defaults border-width": {}, "--tw-divide-y-reverse": "1" }, ".divide-x-reverse > :not([hidden]) ~ :not([hidden])": { "@defaults border-width": {}, "--tw-divide-x-reverse": "1" } });
}, divideStyle: ({ addUtilities: t }) => {
  t({ ".divide-solid > :not([hidden]) ~ :not([hidden])": { "border-style": "solid" }, ".divide-dashed > :not([hidden]) ~ :not([hidden])": { "border-style": "dashed" }, ".divide-dotted > :not([hidden]) ~ :not([hidden])": { "border-style": "dotted" }, ".divide-double > :not([hidden]) ~ :not([hidden])": { "border-style": "double" }, ".divide-none > :not([hidden]) ~ :not([hidden])": { "border-style": "none" } });
}, divideColor: ({ matchUtilities: t, theme: e, corePlugins: r }) => {
  t({ divide: (n) => r("divideOpacity") ? { ["& > :not([hidden]) ~ :not([hidden])"]: Z({ color: n, property: "border-color", variable: "--tw-divide-opacity" }) } : { ["& > :not([hidden]) ~ :not([hidden])"]: { "border-color": M(n) } } }, { values: (({ DEFAULT: n, ...i }) => i)(Q(e("divideColor"))), type: ["color", "any"] });
}, divideOpacity: ({ matchUtilities: t, theme: e }) => {
  t({ "divide-opacity": (r) => ({ ["& > :not([hidden]) ~ :not([hidden])"]: { "--tw-divide-opacity": r } }) }, { values: e("divideOpacity") });
}, placeSelf: ({ addUtilities: t }) => {
  t({ ".place-self-auto": { "place-self": "auto" }, ".place-self-start": { "place-self": "start" }, ".place-self-end": { "place-self": "end" }, ".place-self-center": { "place-self": "center" }, ".place-self-stretch": { "place-self": "stretch" } });
}, alignSelf: ({ addUtilities: t }) => {
  t({ ".self-auto": { "align-self": "auto" }, ".self-start": { "align-self": "flex-start" }, ".self-end": { "align-self": "flex-end" }, ".self-center": { "align-self": "center" }, ".self-stretch": { "align-self": "stretch" }, ".self-baseline": { "align-self": "baseline" } });
}, justifySelf: ({ addUtilities: t }) => {
  t({ ".justify-self-auto": { "justify-self": "auto" }, ".justify-self-start": { "justify-self": "start" }, ".justify-self-end": { "justify-self": "end" }, ".justify-self-center": { "justify-self": "center" }, ".justify-self-stretch": { "justify-self": "stretch" } });
}, overflow: ({ addUtilities: t }) => {
  t({ ".overflow-auto": { overflow: "auto" }, ".overflow-hidden": { overflow: "hidden" }, ".overflow-clip": { overflow: "clip" }, ".overflow-visible": { overflow: "visible" }, ".overflow-scroll": { overflow: "scroll" }, ".overflow-x-auto": { "overflow-x": "auto" }, ".overflow-y-auto": { "overflow-y": "auto" }, ".overflow-x-hidden": { "overflow-x": "hidden" }, ".overflow-y-hidden": { "overflow-y": "hidden" }, ".overflow-x-clip": { "overflow-x": "clip" }, ".overflow-y-clip": { "overflow-y": "clip" }, ".overflow-x-visible": { "overflow-x": "visible" }, ".overflow-y-visible": { "overflow-y": "visible" }, ".overflow-x-scroll": { "overflow-x": "scroll" }, ".overflow-y-scroll": { "overflow-y": "scroll" } });
}, overscrollBehavior: ({ addUtilities: t }) => {
  t({ ".overscroll-auto": { "overscroll-behavior": "auto" }, ".overscroll-contain": { "overscroll-behavior": "contain" }, ".overscroll-none": { "overscroll-behavior": "none" }, ".overscroll-y-auto": { "overscroll-behavior-y": "auto" }, ".overscroll-y-contain": { "overscroll-behavior-y": "contain" }, ".overscroll-y-none": { "overscroll-behavior-y": "none" }, ".overscroll-x-auto": { "overscroll-behavior-x": "auto" }, ".overscroll-x-contain": { "overscroll-behavior-x": "contain" }, ".overscroll-x-none": { "overscroll-behavior-x": "none" } });
}, scrollBehavior: ({ addUtilities: t }) => {
  t({ ".scroll-auto": { "scroll-behavior": "auto" }, ".scroll-smooth": { "scroll-behavior": "smooth" } });
}, textOverflow: ({ addUtilities: t }) => {
  t({ ".truncate": { overflow: "hidden", "text-overflow": "ellipsis", "white-space": "nowrap" }, ".overflow-ellipsis": { "text-overflow": "ellipsis" }, ".text-ellipsis": { "text-overflow": "ellipsis" }, ".text-clip": { "text-overflow": "clip" } });
}, hyphens: ({ addUtilities: t }) => {
  t({ ".hyphens-none": { hyphens: "none" }, ".hyphens-manual": { hyphens: "manual" }, ".hyphens-auto": { hyphens: "auto" } });
}, whitespace: ({ addUtilities: t }) => {
  t({ ".whitespace-normal": { "white-space": "normal" }, ".whitespace-nowrap": { "white-space": "nowrap" }, ".whitespace-pre": { "white-space": "pre" }, ".whitespace-pre-line": { "white-space": "pre-line" }, ".whitespace-pre-wrap": { "white-space": "pre-wrap" }, ".whitespace-break-spaces": { "white-space": "break-spaces" } });
}, wordBreak: ({ addUtilities: t }) => {
  t({ ".break-normal": { "overflow-wrap": "normal", "word-break": "normal" }, ".break-words": { "overflow-wrap": "break-word" }, ".break-all": { "word-break": "break-all" }, ".break-keep": { "word-break": "keep-all" } });
}, borderRadius: T("borderRadius", [["rounded", ["border-radius"]], [["rounded-s", ["border-start-start-radius", "border-end-start-radius"]], ["rounded-e", ["border-start-end-radius", "border-end-end-radius"]], ["rounded-t", ["border-top-left-radius", "border-top-right-radius"]], ["rounded-r", ["border-top-right-radius", "border-bottom-right-radius"]], ["rounded-b", ["border-bottom-right-radius", "border-bottom-left-radius"]], ["rounded-l", ["border-top-left-radius", "border-bottom-left-radius"]]], [["rounded-ss", ["border-start-start-radius"]], ["rounded-se", ["border-start-end-radius"]], ["rounded-ee", ["border-end-end-radius"]], ["rounded-es", ["border-end-start-radius"]], ["rounded-tl", ["border-top-left-radius"]], ["rounded-tr", ["border-top-right-radius"]], ["rounded-br", ["border-bottom-right-radius"]], ["rounded-bl", ["border-bottom-left-radius"]]]]), borderWidth: T("borderWidth", [["border", [["@defaults border-width", {}], "border-width"]], [["border-x", [["@defaults border-width", {}], "border-left-width", "border-right-width"]], ["border-y", [["@defaults border-width", {}], "border-top-width", "border-bottom-width"]]], [["border-s", [["@defaults border-width", {}], "border-inline-start-width"]], ["border-e", [["@defaults border-width", {}], "border-inline-end-width"]], ["border-t", [["@defaults border-width", {}], "border-top-width"]], ["border-r", [["@defaults border-width", {}], "border-right-width"]], ["border-b", [["@defaults border-width", {}], "border-bottom-width"]], ["border-l", [["@defaults border-width", {}], "border-left-width"]]]], { type: ["line-width", "length"] }), borderStyle: ({ addUtilities: t }) => {
  t({ ".border-solid": { "border-style": "solid" }, ".border-dashed": { "border-style": "dashed" }, ".border-dotted": { "border-style": "dotted" }, ".border-double": { "border-style": "double" }, ".border-hidden": { "border-style": "hidden" }, ".border-none": { "border-style": "none" } });
}, borderColor: ({ matchUtilities: t, theme: e, corePlugins: r }) => {
  t({ border: (n) => r("borderOpacity") ? Z({ color: n, property: "border-color", variable: "--tw-border-opacity" }) : { "border-color": M(n) } }, { values: (({ DEFAULT: n, ...i }) => i)(Q(e("borderColor"))), type: ["color", "any"] }), t({ "border-x": (n) => r("borderOpacity") ? Z({ color: n, property: ["border-left-color", "border-right-color"], variable: "--tw-border-opacity" }) : { "border-left-color": M(n), "border-right-color": M(n) }, "border-y": (n) => r("borderOpacity") ? Z({ color: n, property: ["border-top-color", "border-bottom-color"], variable: "--tw-border-opacity" }) : { "border-top-color": M(n), "border-bottom-color": M(n) } }, { values: (({ DEFAULT: n, ...i }) => i)(Q(e("borderColor"))), type: ["color", "any"] }), t({ "border-s": (n) => r("borderOpacity") ? Z({ color: n, property: "border-inline-start-color", variable: "--tw-border-opacity" }) : { "border-inline-start-color": M(n) }, "border-e": (n) => r("borderOpacity") ? Z({ color: n, property: "border-inline-end-color", variable: "--tw-border-opacity" }) : { "border-inline-end-color": M(n) }, "border-t": (n) => r("borderOpacity") ? Z({ color: n, property: "border-top-color", variable: "--tw-border-opacity" }) : { "border-top-color": M(n) }, "border-r": (n) => r("borderOpacity") ? Z({ color: n, property: "border-right-color", variable: "--tw-border-opacity" }) : { "border-right-color": M(n) }, "border-b": (n) => r("borderOpacity") ? Z({ color: n, property: "border-bottom-color", variable: "--tw-border-opacity" }) : { "border-bottom-color": M(n) }, "border-l": (n) => r("borderOpacity") ? Z({ color: n, property: "border-left-color", variable: "--tw-border-opacity" }) : { "border-left-color": M(n) } }, { values: (({ DEFAULT: n, ...i }) => i)(Q(e("borderColor"))), type: ["color", "any"] });
}, borderOpacity: T("borderOpacity", [["border-opacity", ["--tw-border-opacity"]]]), backgroundColor: ({ matchUtilities: t, theme: e, corePlugins: r }) => {
  t({ bg: (n) => r("backgroundOpacity") ? Z({ color: n, property: "background-color", variable: "--tw-bg-opacity" }) : { "background-color": M(n) } }, { values: Q(e("backgroundColor")), type: ["color", "any"] });
}, backgroundOpacity: T("backgroundOpacity", [["bg-opacity", ["--tw-bg-opacity"]]]), backgroundImage: T("backgroundImage", [["bg", ["background-image"]]], { type: ["lookup", "image", "url"] }), gradientColorStops: (() => {
  function t(e) {
    return we(e, 0, "rgb(255 255 255 / 0)");
  }
  return function({ matchUtilities: e, theme: r, addDefaults: n }) {
    n("gradient-color-stops", { "--tw-gradient-from-position": " ", "--tw-gradient-via-position": " ", "--tw-gradient-to-position": " " });
    let i = { values: Q(r("gradientColorStops")), type: ["color", "any"] }, a = { values: r("gradientColorStopPositions"), type: ["length", "percentage"] };
    e({ from: (s) => {
      let o2 = t(s);
      return { "@defaults gradient-color-stops": {}, "--tw-gradient-from": `${M(s)} var(--tw-gradient-from-position)`, "--tw-gradient-to": `${o2} var(--tw-gradient-to-position)`, "--tw-gradient-stops": "var(--tw-gradient-from), var(--tw-gradient-to)" };
    } }, i), e({ from: (s) => ({ "--tw-gradient-from-position": s }) }, a), e({ via: (s) => {
      let o2 = t(s);
      return { "@defaults gradient-color-stops": {}, "--tw-gradient-to": `${o2}  var(--tw-gradient-to-position)`, "--tw-gradient-stops": `var(--tw-gradient-from), ${M(s)} var(--tw-gradient-via-position), var(--tw-gradient-to)` };
    } }, i), e({ via: (s) => ({ "--tw-gradient-via-position": s }) }, a), e({ to: (s) => ({ "@defaults gradient-color-stops": {}, "--tw-gradient-to": `${M(s)} var(--tw-gradient-to-position)` }) }, i), e({ to: (s) => ({ "--tw-gradient-to-position": s }) }, a);
  };
})(), boxDecorationBreak: ({ addUtilities: t }) => {
  t({ ".decoration-slice": { "box-decoration-break": "slice" }, ".decoration-clone": { "box-decoration-break": "clone" }, ".box-decoration-slice": { "box-decoration-break": "slice" }, ".box-decoration-clone": { "box-decoration-break": "clone" } });
}, backgroundSize: T("backgroundSize", [["bg", ["background-size"]]], { type: ["lookup", "length", "percentage", "size"] }), backgroundAttachment: ({ addUtilities: t }) => {
  t({ ".bg-fixed": { "background-attachment": "fixed" }, ".bg-local": { "background-attachment": "local" }, ".bg-scroll": { "background-attachment": "scroll" } });
}, backgroundClip: ({ addUtilities: t }) => {
  t({ ".bg-clip-border": { "background-clip": "border-box" }, ".bg-clip-padding": { "background-clip": "padding-box" }, ".bg-clip-content": { "background-clip": "content-box" }, ".bg-clip-text": { "background-clip": "text" } });
}, backgroundPosition: T("backgroundPosition", [["bg", ["background-position"]]], { type: ["lookup", ["position", { preferOnConflict: true }]] }), backgroundRepeat: ({ addUtilities: t }) => {
  t({ ".bg-repeat": { "background-repeat": "repeat" }, ".bg-no-repeat": { "background-repeat": "no-repeat" }, ".bg-repeat-x": { "background-repeat": "repeat-x" }, ".bg-repeat-y": { "background-repeat": "repeat-y" }, ".bg-repeat-round": { "background-repeat": "round" }, ".bg-repeat-space": { "background-repeat": "space" } });
}, backgroundOrigin: ({ addUtilities: t }) => {
  t({ ".bg-origin-border": { "background-origin": "border-box" }, ".bg-origin-padding": { "background-origin": "padding-box" }, ".bg-origin-content": { "background-origin": "content-box" } });
}, fill: ({ matchUtilities: t, theme: e }) => {
  t({ fill: (r) => ({ fill: M(r) }) }, { values: Q(e("fill")), type: ["color", "any"] });
}, stroke: ({ matchUtilities: t, theme: e }) => {
  t({ stroke: (r) => ({ stroke: M(r) }) }, { values: Q(e("stroke")), type: ["color", "url", "any"] });
}, strokeWidth: T("strokeWidth", [["stroke", ["stroke-width"]]], { type: ["length", "number", "percentage"] }), objectFit: ({ addUtilities: t }) => {
  t({ ".object-contain": { "object-fit": "contain" }, ".object-cover": { "object-fit": "cover" }, ".object-fill": { "object-fit": "fill" }, ".object-none": { "object-fit": "none" }, ".object-scale-down": { "object-fit": "scale-down" } });
}, objectPosition: T("objectPosition", [["object", ["object-position"]]]), padding: T("padding", [["p", ["padding"]], [["px", ["padding-left", "padding-right"]], ["py", ["padding-top", "padding-bottom"]]], [["ps", ["padding-inline-start"]], ["pe", ["padding-inline-end"]], ["pt", ["padding-top"]], ["pr", ["padding-right"]], ["pb", ["padding-bottom"]], ["pl", ["padding-left"]]]]), textAlign: ({ addUtilities: t }) => {
  t({ ".text-left": { "text-align": "left" }, ".text-center": { "text-align": "center" }, ".text-right": { "text-align": "right" }, ".text-justify": { "text-align": "justify" }, ".text-start": { "text-align": "start" }, ".text-end": { "text-align": "end" } });
}, textIndent: T("textIndent", [["indent", ["text-indent"]]], { supportsNegativeValues: true }), verticalAlign: ({ addUtilities: t, matchUtilities: e }) => {
  t({ ".align-baseline": { "vertical-align": "baseline" }, ".align-top": { "vertical-align": "top" }, ".align-middle": { "vertical-align": "middle" }, ".align-bottom": { "vertical-align": "bottom" }, ".align-text-top": { "vertical-align": "text-top" }, ".align-text-bottom": { "vertical-align": "text-bottom" }, ".align-sub": { "vertical-align": "sub" }, ".align-super": { "vertical-align": "super" } }), e({ align: (r) => ({ "vertical-align": r }) });
}, fontFamily: ({ matchUtilities: t, theme: e }) => {
  t({ font: (r) => {
    let [n, i = {}] = Array.isArray(r) && X(r[1]) ? r : [r], { fontFeatureSettings: a, fontVariationSettings: s } = i;
    return { "font-family": Array.isArray(n) ? n.join(", ") : n, ...a === undefined ? {} : { "font-feature-settings": a }, ...s === undefined ? {} : { "font-variation-settings": s } };
  } }, { values: e("fontFamily"), type: ["lookup", "generic-name", "family-name"] });
}, fontSize: ({ matchUtilities: t, theme: e }) => {
  t({ text: (r, { modifier: n }) => {
    let [i, a] = Array.isArray(r) ? r : [r];
    if (n)
      return { "font-size": i, "line-height": n };
    let { lineHeight: s, letterSpacing: o2, fontWeight: l } = X(a) ? a : { lineHeight: a };
    return { "font-size": i, ...s === undefined ? {} : { "line-height": s }, ...o2 === undefined ? {} : { "letter-spacing": o2 }, ...l === undefined ? {} : { "font-weight": l } };
  } }, { values: e("fontSize"), modifiers: e("lineHeight"), type: ["absolute-size", "relative-size", "length", "percentage"] });
}, fontWeight: T("fontWeight", [["font", ["fontWeight"]]], { type: ["lookup", "number", "any"] }), textTransform: ({ addUtilities: t }) => {
  t({ ".uppercase": { "text-transform": "uppercase" }, ".lowercase": { "text-transform": "lowercase" }, ".capitalize": { "text-transform": "capitalize" }, ".normal-case": { "text-transform": "none" } });
}, fontStyle: ({ addUtilities: t }) => {
  t({ ".italic": { "font-style": "italic" }, ".not-italic": { "font-style": "normal" } });
}, fontVariantNumeric: ({ addDefaults: t, addUtilities: e }) => {
  let r = "var(--tw-ordinal) var(--tw-slashed-zero) var(--tw-numeric-figure) var(--tw-numeric-spacing) var(--tw-numeric-fraction)";
  t("font-variant-numeric", { "--tw-ordinal": " ", "--tw-slashed-zero": " ", "--tw-numeric-figure": " ", "--tw-numeric-spacing": " ", "--tw-numeric-fraction": " " }), e({ ".normal-nums": { "font-variant-numeric": "normal" }, ".ordinal": { "@defaults font-variant-numeric": {}, "--tw-ordinal": "ordinal", "font-variant-numeric": r }, ".slashed-zero": { "@defaults font-variant-numeric": {}, "--tw-slashed-zero": "slashed-zero", "font-variant-numeric": r }, ".lining-nums": { "@defaults font-variant-numeric": {}, "--tw-numeric-figure": "lining-nums", "font-variant-numeric": r }, ".oldstyle-nums": { "@defaults font-variant-numeric": {}, "--tw-numeric-figure": "oldstyle-nums", "font-variant-numeric": r }, ".proportional-nums": { "@defaults font-variant-numeric": {}, "--tw-numeric-spacing": "proportional-nums", "font-variant-numeric": r }, ".tabular-nums": { "@defaults font-variant-numeric": {}, "--tw-numeric-spacing": "tabular-nums", "font-variant-numeric": r }, ".diagonal-fractions": { "@defaults font-variant-numeric": {}, "--tw-numeric-fraction": "diagonal-fractions", "font-variant-numeric": r }, ".stacked-fractions": { "@defaults font-variant-numeric": {}, "--tw-numeric-fraction": "stacked-fractions", "font-variant-numeric": r } });
}, lineHeight: T("lineHeight", [["leading", ["lineHeight"]]]), letterSpacing: T("letterSpacing", [["tracking", ["letterSpacing"]]], { supportsNegativeValues: true }), textColor: ({ matchUtilities: t, theme: e, corePlugins: r }) => {
  t({ text: (n) => r("textOpacity") ? Z({ color: n, property: "color", variable: "--tw-text-opacity" }) : { color: M(n) } }, { values: Q(e("textColor")), type: ["color", "any"] });
}, textOpacity: T("textOpacity", [["text-opacity", ["--tw-text-opacity"]]]), textDecoration: ({ addUtilities: t }) => {
  t({ ".underline": { "text-decoration-line": "underline" }, ".overline": { "text-decoration-line": "overline" }, ".line-through": { "text-decoration-line": "line-through" }, ".no-underline": { "text-decoration-line": "none" } });
}, textDecorationColor: ({ matchUtilities: t, theme: e }) => {
  t({ decoration: (r) => ({ "text-decoration-color": M(r) }) }, { values: Q(e("textDecorationColor")), type: ["color", "any"] });
}, textDecorationStyle: ({ addUtilities: t }) => {
  t({ ".decoration-solid": { "text-decoration-style": "solid" }, ".decoration-double": { "text-decoration-style": "double" }, ".decoration-dotted": { "text-decoration-style": "dotted" }, ".decoration-dashed": { "text-decoration-style": "dashed" }, ".decoration-wavy": { "text-decoration-style": "wavy" } });
}, textDecorationThickness: T("textDecorationThickness", [["decoration", ["text-decoration-thickness"]]], { type: ["length", "percentage"] }), textUnderlineOffset: T("textUnderlineOffset", [["underline-offset", ["text-underline-offset"]]], { type: ["length", "percentage", "any"] }), fontSmoothing: ({ addUtilities: t }) => {
  t({ ".antialiased": { "-webkit-font-smoothing": "antialiased", "-moz-osx-font-smoothing": "grayscale" }, ".subpixel-antialiased": { "-webkit-font-smoothing": "auto", "-moz-osx-font-smoothing": "auto" } });
}, placeholderColor: ({ matchUtilities: t, theme: e, corePlugins: r }) => {
  t({ placeholder: (n) => r("placeholderOpacity") ? { "&::placeholder": Z({ color: n, property: "color", variable: "--tw-placeholder-opacity" }) } : { "&::placeholder": { color: M(n) } } }, { values: Q(e("placeholderColor")), type: ["color", "any"] });
}, placeholderOpacity: ({ matchUtilities: t, theme: e }) => {
  t({ "placeholder-opacity": (r) => ({ ["&::placeholder"]: { "--tw-placeholder-opacity": r } }) }, { values: e("placeholderOpacity") });
}, caretColor: ({ matchUtilities: t, theme: e }) => {
  t({ caret: (r) => ({ "caret-color": M(r) }) }, { values: Q(e("caretColor")), type: ["color", "any"] });
}, accentColor: ({ matchUtilities: t, theme: e }) => {
  t({ accent: (r) => ({ "accent-color": M(r) }) }, { values: Q(e("accentColor")), type: ["color", "any"] });
}, opacity: T("opacity", [["opacity", ["opacity"]]]), backgroundBlendMode: ({ addUtilities: t }) => {
  t({ ".bg-blend-normal": { "background-blend-mode": "normal" }, ".bg-blend-multiply": { "background-blend-mode": "multiply" }, ".bg-blend-screen": { "background-blend-mode": "screen" }, ".bg-blend-overlay": { "background-blend-mode": "overlay" }, ".bg-blend-darken": { "background-blend-mode": "darken" }, ".bg-blend-lighten": { "background-blend-mode": "lighten" }, ".bg-blend-color-dodge": { "background-blend-mode": "color-dodge" }, ".bg-blend-color-burn": { "background-blend-mode": "color-burn" }, ".bg-blend-hard-light": { "background-blend-mode": "hard-light" }, ".bg-blend-soft-light": { "background-blend-mode": "soft-light" }, ".bg-blend-difference": { "background-blend-mode": "difference" }, ".bg-blend-exclusion": { "background-blend-mode": "exclusion" }, ".bg-blend-hue": { "background-blend-mode": "hue" }, ".bg-blend-saturation": { "background-blend-mode": "saturation" }, ".bg-blend-color": { "background-blend-mode": "color" }, ".bg-blend-luminosity": { "background-blend-mode": "luminosity" } });
}, mixBlendMode: ({ addUtilities: t }) => {
  t({ ".mix-blend-normal": { "mix-blend-mode": "normal" }, ".mix-blend-multiply": { "mix-blend-mode": "multiply" }, ".mix-blend-screen": { "mix-blend-mode": "screen" }, ".mix-blend-overlay": { "mix-blend-mode": "overlay" }, ".mix-blend-darken": { "mix-blend-mode": "darken" }, ".mix-blend-lighten": { "mix-blend-mode": "lighten" }, ".mix-blend-color-dodge": { "mix-blend-mode": "color-dodge" }, ".mix-blend-color-burn": { "mix-blend-mode": "color-burn" }, ".mix-blend-hard-light": { "mix-blend-mode": "hard-light" }, ".mix-blend-soft-light": { "mix-blend-mode": "soft-light" }, ".mix-blend-difference": { "mix-blend-mode": "difference" }, ".mix-blend-exclusion": { "mix-blend-mode": "exclusion" }, ".mix-blend-hue": { "mix-blend-mode": "hue" }, ".mix-blend-saturation": { "mix-blend-mode": "saturation" }, ".mix-blend-color": { "mix-blend-mode": "color" }, ".mix-blend-luminosity": { "mix-blend-mode": "luminosity" }, ".mix-blend-plus-lighter": { "mix-blend-mode": "plus-lighter" } });
}, boxShadow: (() => {
  let t = Ce("boxShadow"), e = ["var(--tw-ring-offset-shadow, 0 0 #0000)", "var(--tw-ring-shadow, 0 0 #0000)", "var(--tw-shadow)"].join(", ");
  return function({ matchUtilities: r, addDefaults: n, theme: i }) {
    n(" box-shadow", { "--tw-ring-offset-shadow": "0 0 #0000", "--tw-ring-shadow": "0 0 #0000", "--tw-shadow": "0 0 #0000", "--tw-shadow-colored": "0 0 #0000" }), r({ shadow: (a) => {
      a = t(a);
      let s = nn(a);
      for (let o2 of s)
        !o2.valid || (o2.color = "var(--tw-shadow-color)");
      return { "@defaults box-shadow": {}, "--tw-shadow": a === "none" ? "0 0 #0000" : a, "--tw-shadow-colored": a === "none" ? "0 0 #0000" : Vu(s), "box-shadow": e };
    } }, { values: i("boxShadow"), type: ["shadow"] });
  };
})(), boxShadowColor: ({ matchUtilities: t, theme: e }) => {
  t({ shadow: (r) => ({ "--tw-shadow-color": M(r), "--tw-shadow": "var(--tw-shadow-colored)" }) }, { values: Q(e("boxShadowColor")), type: ["color", "any"] });
}, outlineStyle: ({ addUtilities: t }) => {
  t({ ".outline-none": { outline: "2px solid transparent", "outline-offset": "2px" }, ".outline": { "outline-style": "solid" }, ".outline-dashed": { "outline-style": "dashed" }, ".outline-dotted": { "outline-style": "dotted" }, ".outline-double": { "outline-style": "double" } });
}, outlineWidth: T("outlineWidth", [["outline", ["outline-width"]]], { type: ["length", "number", "percentage"] }), outlineOffset: T("outlineOffset", [["outline-offset", ["outline-offset"]]], { type: ["length", "number", "percentage", "any"], supportsNegativeValues: true }), outlineColor: ({ matchUtilities: t, theme: e }) => {
  t({ outline: (r) => ({ "outline-color": M(r) }) }, { values: Q(e("outlineColor")), type: ["color", "any"] });
}, ringWidth: ({ matchUtilities: t, addDefaults: e, addUtilities: r, theme: n, config: i }) => {
  let a = (() => {
    var o2, l;
    if (G(i(), "respectDefaultRingColorOpacity"))
      return n("ringColor.DEFAULT");
    let s = n("ringOpacity.DEFAULT", "0.5");
    return (o2 = n("ringColor")) != null && o2.DEFAULT ? we((l = n("ringColor")) == null ? undefined : l.DEFAULT, s, `rgb(147 197 253 / ${s})`) : `rgb(147 197 253 / ${s})`;
  })();
  e("ring-width", { "--tw-ring-inset": " ", "--tw-ring-offset-width": n("ringOffsetWidth.DEFAULT", "0px"), "--tw-ring-offset-color": n("ringOffsetColor.DEFAULT", "#fff"), "--tw-ring-color": a, "--tw-ring-offset-shadow": "0 0 #0000", "--tw-ring-shadow": "0 0 #0000", "--tw-shadow": "0 0 #0000", "--tw-shadow-colored": "0 0 #0000" }), t({ ring: (s) => ({ "@defaults ring-width": {}, "--tw-ring-offset-shadow": "var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color)", "--tw-ring-shadow": `var(--tw-ring-inset) 0 0 0 calc(${s} + var(--tw-ring-offset-width)) var(--tw-ring-color)`, "box-shadow": ["var(--tw-ring-offset-shadow)", "var(--tw-ring-shadow)", "var(--tw-shadow, 0 0 #0000)"].join(", ") }) }, { values: n("ringWidth"), type: "length" }), r({ ".ring-inset": { "@defaults ring-width": {}, "--tw-ring-inset": "inset" } });
}, ringColor: ({ matchUtilities: t, theme: e, corePlugins: r }) => {
  t({ ring: (n) => r("ringOpacity") ? Z({ color: n, property: "--tw-ring-color", variable: "--tw-ring-opacity" }) : { "--tw-ring-color": M(n) } }, { values: Object.fromEntries(Object.entries(Q(e("ringColor"))).filter(([n]) => n !== "DEFAULT")), type: ["color", "any"] });
}, ringOpacity: (t) => {
  let { config: e } = t;
  return T("ringOpacity", [["ring-opacity", ["--tw-ring-opacity"]]], { filterDefault: !G(e(), "respectDefaultRingColorOpacity") })(t);
}, ringOffsetWidth: T("ringOffsetWidth", [["ring-offset", ["--tw-ring-offset-width"]]], { type: "length" }), ringOffsetColor: ({ matchUtilities: t, theme: e }) => {
  t({ "ring-offset": (r) => ({ "--tw-ring-offset-color": M(r) }) }, { values: Q(e("ringOffsetColor")), type: ["color", "any"] });
}, blur: ({ matchUtilities: t, theme: e }) => {
  t({ blur: (r) => ({ "--tw-blur": `blur(${r})`, "@defaults filter": {}, filter: xe }) }, { values: e("blur") });
}, brightness: ({ matchUtilities: t, theme: e }) => {
  t({ brightness: (r) => ({ "--tw-brightness": `brightness(${r})`, "@defaults filter": {}, filter: xe }) }, { values: e("brightness") });
}, contrast: ({ matchUtilities: t, theme: e }) => {
  t({ contrast: (r) => ({ "--tw-contrast": `contrast(${r})`, "@defaults filter": {}, filter: xe }) }, { values: e("contrast") });
}, dropShadow: ({ matchUtilities: t, theme: e }) => {
  t({ "drop-shadow": (r) => ({ "--tw-drop-shadow": Array.isArray(r) ? r.map((n) => `drop-shadow(${n})`).join(" ") : `drop-shadow(${r})`, "@defaults filter": {}, filter: xe }) }, { values: e("dropShadow") });
}, grayscale: ({ matchUtilities: t, theme: e }) => {
  t({ grayscale: (r) => ({ "--tw-grayscale": `grayscale(${r})`, "@defaults filter": {}, filter: xe }) }, { values: e("grayscale") });
}, hueRotate: ({ matchUtilities: t, theme: e }) => {
  t({ "hue-rotate": (r) => ({ "--tw-hue-rotate": `hue-rotate(${r})`, "@defaults filter": {}, filter: xe }) }, { values: e("hueRotate"), supportsNegativeValues: true });
}, invert: ({ matchUtilities: t, theme: e }) => {
  t({ invert: (r) => ({ "--tw-invert": `invert(${r})`, "@defaults filter": {}, filter: xe }) }, { values: e("invert") });
}, saturate: ({ matchUtilities: t, theme: e }) => {
  t({ saturate: (r) => ({ "--tw-saturate": `saturate(${r})`, "@defaults filter": {}, filter: xe }) }, { values: e("saturate") });
}, sepia: ({ matchUtilities: t, theme: e }) => {
  t({ sepia: (r) => ({ "--tw-sepia": `sepia(${r})`, "@defaults filter": {}, filter: xe }) }, { values: e("sepia") });
}, filter: ({ addDefaults: t, addUtilities: e }) => {
  t("filter", { "--tw-blur": " ", "--tw-brightness": " ", "--tw-contrast": " ", "--tw-grayscale": " ", "--tw-hue-rotate": " ", "--tw-invert": " ", "--tw-saturate": " ", "--tw-sepia": " ", "--tw-drop-shadow": " " }), e({ ".filter": { "@defaults filter": {}, filter: xe }, ".filter-none": { filter: "none" } });
}, backdropBlur: ({ matchUtilities: t, theme: e }) => {
  t({ "backdrop-blur": (r) => ({ "--tw-backdrop-blur": `blur(${r})`, "@defaults backdrop-filter": {}, "backdrop-filter": Se }) }, { values: e("backdropBlur") });
}, backdropBrightness: ({ matchUtilities: t, theme: e }) => {
  t({ "backdrop-brightness": (r) => ({ "--tw-backdrop-brightness": `brightness(${r})`, "@defaults backdrop-filter": {}, "backdrop-filter": Se }) }, { values: e("backdropBrightness") });
}, backdropContrast: ({ matchUtilities: t, theme: e }) => {
  t({ "backdrop-contrast": (r) => ({ "--tw-backdrop-contrast": `contrast(${r})`, "@defaults backdrop-filter": {}, "backdrop-filter": Se }) }, { values: e("backdropContrast") });
}, backdropGrayscale: ({ matchUtilities: t, theme: e }) => {
  t({ "backdrop-grayscale": (r) => ({ "--tw-backdrop-grayscale": `grayscale(${r})`, "@defaults backdrop-filter": {}, "backdrop-filter": Se }) }, { values: e("backdropGrayscale") });
}, backdropHueRotate: ({ matchUtilities: t, theme: e }) => {
  t({ "backdrop-hue-rotate": (r) => ({ "--tw-backdrop-hue-rotate": `hue-rotate(${r})`, "@defaults backdrop-filter": {}, "backdrop-filter": Se }) }, { values: e("backdropHueRotate"), supportsNegativeValues: true });
}, backdropInvert: ({ matchUtilities: t, theme: e }) => {
  t({ "backdrop-invert": (r) => ({ "--tw-backdrop-invert": `invert(${r})`, "@defaults backdrop-filter": {}, "backdrop-filter": Se }) }, { values: e("backdropInvert") });
}, backdropOpacity: ({ matchUtilities: t, theme: e }) => {
  t({ "backdrop-opacity": (r) => ({ "--tw-backdrop-opacity": `opacity(${r})`, "@defaults backdrop-filter": {}, "backdrop-filter": Se }) }, { values: e("backdropOpacity") });
}, backdropSaturate: ({ matchUtilities: t, theme: e }) => {
  t({ "backdrop-saturate": (r) => ({ "--tw-backdrop-saturate": `saturate(${r})`, "@defaults backdrop-filter": {}, "backdrop-filter": Se }) }, { values: e("backdropSaturate") });
}, backdropSepia: ({ matchUtilities: t, theme: e }) => {
  t({ "backdrop-sepia": (r) => ({ "--tw-backdrop-sepia": `sepia(${r})`, "@defaults backdrop-filter": {}, "backdrop-filter": Se }) }, { values: e("backdropSepia") });
}, backdropFilter: ({ addDefaults: t, addUtilities: e }) => {
  t("backdrop-filter", { "--tw-backdrop-blur": " ", "--tw-backdrop-brightness": " ", "--tw-backdrop-contrast": " ", "--tw-backdrop-grayscale": " ", "--tw-backdrop-hue-rotate": " ", "--tw-backdrop-invert": " ", "--tw-backdrop-opacity": " ", "--tw-backdrop-saturate": " ", "--tw-backdrop-sepia": " " }), e({ ".backdrop-filter": { "@defaults backdrop-filter": {}, "backdrop-filter": Se }, ".backdrop-filter-none": { "backdrop-filter": "none" } });
}, transitionProperty: ({ matchUtilities: t, theme: e }) => {
  let r = e("transitionTimingFunction.DEFAULT"), n = e("transitionDuration.DEFAULT");
  t({ transition: (i) => ({ "transition-property": i, ...i === "none" ? {} : { "transition-timing-function": r, "transition-duration": n } }) }, { values: e("transitionProperty") });
}, transitionDelay: T("transitionDelay", [["delay", ["transitionDelay"]]]), transitionDuration: T("transitionDuration", [["duration", ["transitionDuration"]]], { filterDefault: true }), transitionTimingFunction: T("transitionTimingFunction", [["ease", ["transitionTimingFunction"]]], { filterDefault: true }), willChange: T("willChange", [["will-change", ["will-change"]]]), content: T("content", [["content", ["--tw-content", ["content", "var(--tw-content)"]]]]) };
var xf = new Map([["{", "}"], ["[", "]"], ["(", ")"]]);
var bf = new Map(Array.from(xf.entries()).map(([t, e]) => [e, t]));
var av = new Set(['"', "'", "`"]);
var dn = class {
  constructor() {
    this.offsets = { defaults: 0n, base: 0n, components: 0n, utilities: 0n, variants: 0n, user: 0n }, this.layerPositions = { defaults: 0n, base: 1n, components: 2n, utilities: 3n, user: 4n, variants: 5n }, this.reservedVariantBits = 0n, this.variantOffsets = new Map;
  }
  create(e) {
    return { layer: e, parentLayer: e, arbitrary: 0n, variants: 0n, parallelIndex: 0n, index: this.offsets[e]++, options: [] };
  }
  arbitraryProperty() {
    return { ...this.create("utilities"), arbitrary: 1n };
  }
  forVariant(e, r = 0) {
    let n = this.variantOffsets.get(e);
    if (n === undefined)
      throw new Error(`Cannot find offset for unknown variant ${e}`);
    return { ...this.create("variants"), variants: n << BigInt(r) };
  }
  applyVariantOffset(e, r, n) {
    return n.variant = r.variants, { ...e, layer: "variants", parentLayer: e.layer === "variants" ? e.parentLayer : e.layer, variants: e.variants | r.variants, options: n.sort ? [].concat(n, e.options) : e.options, parallelIndex: kf([e.parallelIndex, r.parallelIndex]) };
  }
  applyParallelOffset(e, r) {
    return { ...e, parallelIndex: BigInt(r) };
  }
  recordVariants(e, r) {
    for (let n of e)
      this.recordVariant(n, r(n));
  }
  recordVariant(e, r = 1) {
    return this.variantOffsets.set(e, 1n << this.reservedVariantBits), this.reservedVariantBits += BigInt(r), { ...this.create("variants"), variants: this.variantOffsets.get(e) };
  }
  compare(e, r) {
    var n;
    if (e.layer !== r.layer)
      return this.layerPositions[e.layer] - this.layerPositions[r.layer];
    if (e.parentLayer !== r.parentLayer)
      return this.layerPositions[e.parentLayer] - this.layerPositions[r.parentLayer];
    for (let i of e.options)
      for (let a of r.options) {
        if (i.id !== a.id || !i.sort || !a.sort)
          continue;
        let s = (n = kf([i.variant, a.variant])) != null ? n : 0n, o2 = ~(s | s - 1n), l = e.variants & o2, u = r.variants & o2;
        if (l !== u)
          continue;
        let f = i.sort({ value: i.value, modifier: i.modifier }, { value: a.value, modifier: a.modifier });
        if (f !== 0)
          return f;
      }
    return e.variants !== r.variants ? e.variants - r.variants : e.parallelIndex !== r.parallelIndex ? e.parallelIndex - r.parallelIndex : e.arbitrary !== r.arbitrary ? e.arbitrary - r.arbitrary : e.index - r.index;
  }
  recalculateVariantOffsets() {
    let e = Array.from(this.variantOffsets.entries()).filter(([i]) => i.startsWith("[")).sort(([i], [a]) => ov(i, a)), r = e.map(([, i]) => i).sort((i, a) => pn(i - a));
    return e.map(([, i], a) => [i, r[a]]).filter(([i, a]) => i !== a);
  }
  remapArbitraryVariantOffsets(e) {
    let r = this.recalculateVariantOffsets();
    return r.length === 0 ? e : e.map((n) => {
      let [i, a] = n;
      return i = { ...i, variants: Sf(i.variants, r) }, [i, a];
    });
  }
  sort(e) {
    return e = this.remapArbitraryVariantOffsets(e), e.sort(([r], [n]) => pn(this.compare(r, n)));
  }
};
var Us = { AddVariant: Symbol.for("ADD_VARIANT"), MatchVariant: Symbol.for("MATCH_VARIANT") };
var zs = { Base: 1 << 0, Dynamic: 1 << 1 };
var Bs = H(ve());
var gv = (0, wn.default)((t) => t.first.filter(({ type: e }) => e === "class").pop().value);
var xv = /^[a-z_-]/;
var Df = /[\\^$.*+?()[\]{}|]/g;
var Pv = RegExp(Df.source);
var Dv = /([\[\]'"`])([^\[\]'"`])?/g;
var Mv = /[^"'`\s<>\]]+/;
var Ae = Vn;
var Nf = { DEFAULT: Lf };
var qf = { DEFAULT: (t) => t, svelte: (t) => t.replace(/(?:^|\s)class:/g, " ") };
var ur = new WeakMap;
var kn = H(ve());
var Uv = (0, kn.default)();
var fr = H(qs());
var oc = H(Bf());
var oa = H(sc());
var iw = { atrule: "params", decl: "value" };
var Tn = H(ve());
var pc = { id(t) {
  return Tn.default.attribute({ attribute: "id", operator: "=", value: t.value, quoteMark: '"' });
} };
var lw = (0, Tn.default)((t) => t.map((e) => {
  let r = e.split((n) => n.type === "combinator" && n.value === " ").pop();
  return ow(r);
}));
var la = new Map;
var dc = { atrule: ["name", "params"], rule: ["selector"] };
var fw = new Set(Object.keys(dc));
var cw = Symbol("unitless-number");
var mc = ["preflight", "container", "accessibility", "pointerEvents", "visibility", "position", "inset", "isolation", "zIndex", "order", "gridColumn", "gridColumnStart", "gridColumnEnd", "gridRow", "gridRowStart", "gridRowEnd", "float", "clear", "margin", "boxSizing", "lineClamp", "display", "aspectRatio", "height", "maxHeight", "minHeight", "width", "minWidth", "maxWidth", "flex", "flexShrink", "flexGrow", "flexBasis", "tableLayout", "captionSide", "borderCollapse", "borderSpacing", "transformOrigin", "translate", "rotate", "skew", "scale", "transform", "animation", "cursor", "touchAction", "userSelect", "resize", "scrollSnapType", "scrollSnapAlign", "scrollSnapStop", "scrollMargin", "scrollPadding", "listStylePosition", "listStyleType", "listStyleImage", "appearance", "columns", "breakBefore", "breakInside", "breakAfter", "gridAutoColumns", "gridAutoFlow", "gridAutoRows", "gridTemplateColumns", "gridTemplateRows", "flexDirection", "flexWrap", "placeContent", "placeItems", "alignContent", "alignItems", "justifyContent", "justifyItems", "gap", "space", "divideWidth", "divideStyle", "divideColor", "divideOpacity", "placeSelf", "alignSelf", "justifySelf", "overflow", "overscrollBehavior", "scrollBehavior", "textOverflow", "hyphens", "whitespace", "wordBreak", "borderRadius", "borderWidth", "borderStyle", "borderColor", "borderOpacity", "backgroundColor", "backgroundOpacity", "backgroundImage", "gradientColorStops", "boxDecorationBreak", "backgroundSize", "backgroundAttachment", "backgroundClip", "backgroundPosition", "backgroundRepeat", "backgroundOrigin", "fill", "stroke", "strokeWidth", "objectFit", "objectPosition", "padding", "textAlign", "textIndent", "verticalAlign", "fontFamily", "fontSize", "fontWeight", "textTransform", "fontStyle", "fontVariantNumeric", "lineHeight", "letterSpacing", "textColor", "textOpacity", "textDecoration", "textDecorationColor", "textDecorationStyle", "textDecorationThickness", "textUnderlineOffset", "fontSmoothing", "placeholderColor", "placeholderOpacity", "caretColor", "accentColor", "opacity", "backgroundBlendMode", "mixBlendMode", "boxShadow", "boxShadowColor", "outlineStyle", "outlineWidth", "outlineOffset", "outlineColor", "ringWidth", "ringColor", "ringOpacity", "ringOffsetWidth", "ringOffsetColor", "blur", "brightness", "contrast", "dropShadow", "grayscale", "hueRotate", "invert", "saturate", "sepia", "filter", "backdropBlur", "backdropBrightness", "backdropContrast", "backdropGrayscale", "backdropHueRotate", "backdropInvert", "backdropOpacity", "backdropSaturate", "backdropSepia", "backdropFilter", "transitionProperty", "transitionDelay", "transitionDuration", "transitionTimingFunction", "willChange", "content"];
var yc = { inherit: "inherit", current: "currentColor", transparent: "transparent", black: "#000", white: "#fff", slate: { 50: "#f8fafc", 100: "#f1f5f9", 200: "#e2e8f0", 300: "#cbd5e1", 400: "#94a3b8", 500: "#64748b", 600: "#475569", 700: "#334155", 800: "#1e293b", 900: "#0f172a", 950: "#020617" }, gray: { 50: "#f9fafb", 100: "#f3f4f6", 200: "#e5e7eb", 300: "#d1d5db", 400: "#9ca3af", 500: "#6b7280", 600: "#4b5563", 700: "#374151", 800: "#1f2937", 900: "#111827", 950: "#030712" }, zinc: { 50: "#fafafa", 100: "#f4f4f5", 200: "#e4e4e7", 300: "#d4d4d8", 400: "#a1a1aa", 500: "#71717a", 600: "#52525b", 700: "#3f3f46", 800: "#27272a", 900: "#18181b", 950: "#09090b" }, neutral: { 50: "#fafafa", 100: "#f5f5f5", 200: "#e5e5e5", 300: "#d4d4d4", 400: "#a3a3a3", 500: "#737373", 600: "#525252", 700: "#404040", 800: "#262626", 900: "#171717", 950: "#0a0a0a" }, stone: { 50: "#fafaf9", 100: "#f5f5f4", 200: "#e7e5e4", 300: "#d6d3d1", 400: "#a8a29e", 500: "#78716c", 600: "#57534e", 700: "#44403c", 800: "#292524", 900: "#1c1917", 950: "#0c0a09" }, red: { 50: "#fef2f2", 100: "#fee2e2", 200: "#fecaca", 300: "#fca5a5", 400: "#f87171", 500: "#ef4444", 600: "#dc2626", 700: "#b91c1c", 800: "#991b1b", 900: "#7f1d1d", 950: "#450a0a" }, orange: { 50: "#fff7ed", 100: "#ffedd5", 200: "#fed7aa", 300: "#fdba74", 400: "#fb923c", 500: "#f97316", 600: "#ea580c", 700: "#c2410c", 800: "#9a3412", 900: "#7c2d12", 950: "#431407" }, amber: { 50: "#fffbeb", 100: "#fef3c7", 200: "#fde68a", 300: "#fcd34d", 400: "#fbbf24", 500: "#f59e0b", 600: "#d97706", 700: "#b45309", 800: "#92400e", 900: "#78350f", 950: "#451a03" }, yellow: { 50: "#fefce8", 100: "#fef9c3", 200: "#fef08a", 300: "#fde047", 400: "#facc15", 500: "#eab308", 600: "#ca8a04", 700: "#a16207", 800: "#854d0e", 900: "#713f12", 950: "#422006" }, lime: { 50: "#f7fee7", 100: "#ecfccb", 200: "#d9f99d", 300: "#bef264", 400: "#a3e635", 500: "#84cc16", 600: "#65a30d", 700: "#4d7c0f", 800: "#3f6212", 900: "#365314", 950: "#1a2e05" }, green: { 50: "#f0fdf4", 100: "#dcfce7", 200: "#bbf7d0", 300: "#86efac", 400: "#4ade80", 500: "#22c55e", 600: "#16a34a", 700: "#15803d", 800: "#166534", 900: "#14532d", 950: "#052e16" }, emerald: { 50: "#ecfdf5", 100: "#d1fae5", 200: "#a7f3d0", 300: "#6ee7b7", 400: "#34d399", 500: "#10b981", 600: "#059669", 700: "#047857", 800: "#065f46", 900: "#064e3b", 950: "#022c22" }, teal: { 50: "#f0fdfa", 100: "#ccfbf1", 200: "#99f6e4", 300: "#5eead4", 400: "#2dd4bf", 500: "#14b8a6", 600: "#0d9488", 700: "#0f766e", 800: "#115e59", 900: "#134e4a", 950: "#042f2e" }, cyan: { 50: "#ecfeff", 100: "#cffafe", 200: "#a5f3fc", 300: "#67e8f9", 400: "#22d3ee", 500: "#06b6d4", 600: "#0891b2", 700: "#0e7490", 800: "#155e75", 900: "#164e63", 950: "#083344" }, sky: { 50: "#f0f9ff", 100: "#e0f2fe", 200: "#bae6fd", 300: "#7dd3fc", 400: "#38bdf8", 500: "#0ea5e9", 600: "#0284c7", 700: "#0369a1", 800: "#075985", 900: "#0c4a6e", 950: "#082f49" }, blue: { 50: "#eff6ff", 100: "#dbeafe", 200: "#bfdbfe", 300: "#93c5fd", 400: "#60a5fa", 500: "#3b82f6", 600: "#2563eb", 700: "#1d4ed8", 800: "#1e40af", 900: "#1e3a8a", 950: "#172554" }, indigo: { 50: "#eef2ff", 100: "#e0e7ff", 200: "#c7d2fe", 300: "#a5b4fc", 400: "#818cf8", 500: "#6366f1", 600: "#4f46e5", 700: "#4338ca", 800: "#3730a3", 900: "#312e81", 950: "#1e1b4b" }, violet: { 50: "#f5f3ff", 100: "#ede9fe", 200: "#ddd6fe", 300: "#c4b5fd", 400: "#a78bfa", 500: "#8b5cf6", 600: "#7c3aed", 700: "#6d28d9", 800: "#5b21b6", 900: "#4c1d95", 950: "#2e1065" }, purple: { 50: "#faf5ff", 100: "#f3e8ff", 200: "#e9d5ff", 300: "#d8b4fe", 400: "#c084fc", 500: "#a855f7", 600: "#9333ea", 700: "#7e22ce", 800: "#6b21a8", 900: "#581c87", 950: "#3b0764" }, fuchsia: { 50: "#fdf4ff", 100: "#fae8ff", 200: "#f5d0fe", 300: "#f0abfc", 400: "#e879f9", 500: "#d946ef", 600: "#c026d3", 700: "#a21caf", 800: "#86198f", 900: "#701a75", 950: "#4a044e" }, pink: { 50: "#fdf2f8", 100: "#fce7f3", 200: "#fbcfe8", 300: "#f9a8d4", 400: "#f472b6", 500: "#ec4899", 600: "#db2777", 700: "#be185d", 800: "#9d174d", 900: "#831843", 950: "#500724" }, rose: { 50: "#fff1f2", 100: "#ffe4e6", 200: "#fecdd3", 300: "#fda4af", 400: "#fb7185", 500: "#f43f5e", 600: "#e11d48", 700: "#be123c", 800: "#9f1239", 900: "#881337", 950: "#4c0519" }, get lightBlue() {
  return cr({ version: "v2.2", from: "lightBlue", to: "sky" }), this.sky;
}, get warmGray() {
  return cr({ version: "v3.0", from: "warmGray", to: "stone" }), this.stone;
}, get trueGray() {
  return cr({ version: "v3.0", from: "trueGray", to: "neutral" }), this.neutral;
}, get coolGray() {
  return cr({ version: "v3.0", from: "coolGray", to: "gray" }), this.gray;
}, get blueGray() {
  return cr({ version: "v3.0", from: "blueGray", to: "slate" }), this.slate;
} };
var ha = { colors: yc, negative(t) {
  return Object.keys(t).filter((e) => t[e] !== "0").reduce((e, r) => {
    let n = Re(t[r]);
    return n !== undefined && (e[`-${r}`] = n), e;
  }, {});
}, breakpoints(t) {
  return Object.keys(t).filter((e) => typeof t[e] == "string").reduce((e, r) => ({ ...e, [`screen-${r}`]: t[r] }), {});
} };
var kc = H(Sc());
var Oc = (t) => {
  var n;
  let e = ga((n = t.config) != null ? n : {});
  return pa((i) => () => i.createContext(e, [{ content: t.content }]));
};
var wp = H(vp(), 1);
var bp = (t) => {
  let e = Oc({ config: t.config, content: t.content });
  return R([e, (0, wp.default)()]).process(xp, { from: undefined }).css;
};
var xp = String.raw`
  @tailwind base;
  @tailwind components;
  @tailwind utilities;
`;
var sb = (t, e) => {
  var i, a;
  let r = (a = (i = e == null ? undefined : e.corePlugins) == null ? undefined : i.preflight) != null ? a : false, n = (e == null ? undefined : e.corePlugins) || {};
  return bp({ config: { ...e, corePlugins: { ...n, preflight: r } }, content: t });
};
var Op = ({ config: t, options: e }) => ({ twi: Ea(t, e), twj: Cp(t, e) });
var Ep = (...t) => {
  let e = "";
  return typeof t[0] == "string" ? e = t[0] : Array.isArray(t[0]) ? e = t.flat(1 / 0).map((r) => Ep(r)).join(" ") : typeof t[0] == "object" && (e = Object.entries(t[0]).filter((r) => !!r[1]).map((r) => r[0]).join(" ")), e = e.replace(/\s+/g, " "), e;
};
var Ea = (t, e) => (...r) => {
  let n = Ep(r), { 1: i } = r || {}, s = { ...{ merge: true, minify: true, ignoreMediaQueries: true }, ...e, ...i }, o2 = Ra(sb(n, t));
  return s != null && s.ignoreMediaQueries ? o2.removeMediaQueries() : (o2.removeUndefined(), o2.combineMediaQueries()), o2.fixRGB(), s != null && s.merge && o2.merge(), s != null && s.minify && o2.minify(), o2.get();
};
var Cp = (t, e) => (...r) => kp(Ea(t, e)(r));
var Sp = Ea();
var ab = Cp();
/*! https://mths.be/cssesc v3.0.0 by @mathias */

// node_modules/@react-email/tailwind/dist/index.mjs
var jsx_runtime11 = __toESM(require_jsx_runtime(), 1);
var processElement = function(element, headStyles, twi) {
  let modifiedElement = element;
  if (modifiedElement.props.className) {
    const convertedStyles = [];
    const responsiveStyles = [];
    const classNames = modifiedElement.props.className.split(" ");
    const customClassNames = classNames.filter((className) => {
      const tailwindClassName = twi(className, { ignoreMediaQueries: true });
      if (tailwindClassName) {
        convertedStyles.push(tailwindClassName);
        return false;
      } else if (twi(className, { ignoreMediaQueries: false })) {
        responsiveStyles.push(className);
        return false;
      }
      return true;
    });
    const convertedResponsiveStyles = twi(responsiveStyles, {
      ignoreMediaQueries: false,
      merge: false
    });
    headStyles.push(convertedResponsiveStyles.replace(/^\n+/, "").replace(/\n+$/, ""));
    modifiedElement = React2.cloneElement(modifiedElement, __spreadProps11(__spreadValues11({}, modifiedElement.props), {
      className: customClassNames.length ? customClassNames.join(" ") : undefined,
      style: __spreadValues11(__spreadValues11({}, modifiedElement.props.style), cssToJsxStyle(convertedStyles.join(" ")))
    }));
  }
  if (modifiedElement.props.children) {
    const children = React2.Children.toArray(modifiedElement.props.children);
    const processedChildren = children.map((child) => {
      if (React2.isValidElement(child)) {
        return processElement(child, headStyles, twi);
      }
      return child;
    });
    modifiedElement = React2.cloneElement(modifiedElement, modifiedElement.props, ...processedChildren);
  }
  return modifiedElement;
};
var processHead = function(child, responsiveStyles) {
  let modifiedChild = child;
  if (modifiedChild.type === "head" || modifiedChild.type.displayName === "Head") {
    const styleElement = jsx_runtime11.jsx("style", { children: responsiveStyles });
    const headChildren = React2.Children.toArray(modifiedChild.props.children);
    headChildren.push(styleElement);
    modifiedChild = React2.cloneElement(modifiedChild, modifiedChild.props, ...headChildren);
  }
  if (modifiedChild.props.children) {
    const children = React2.Children.toArray(modifiedChild.props.children);
    const processedChildren = children.map((processedChild) => {
      if (React2.isValidElement(processedChild)) {
        return processHead(processedChild, responsiveStyles);
      }
      return processedChild;
    });
    modifiedChild = React2.cloneElement(modifiedChild, modifiedChild.props, ...processedChildren);
  }
  return modifiedChild;
};
var __defProp12 = Object.defineProperty;
var __defProps11 = Object.defineProperties;
var __getOwnPropDescs11 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols11 = Object.getOwnPropertySymbols;
var __hasOwnProp12 = Object.prototype.hasOwnProperty;
var __propIsEnum11 = Object.prototype.propertyIsEnumerable;
var __defNormalProp11 = (obj, key, value) => (key in obj) ? __defProp12(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues11 = (a, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp12.call(b2, prop))
      __defNormalProp11(a, prop, b2[prop]);
  if (__getOwnPropSymbols11)
    for (var prop of __getOwnPropSymbols11(b2)) {
      if (__propIsEnum11.call(b2, prop))
        __defNormalProp11(a, prop, b2[prop]);
    }
  return a;
};
var __spreadProps11 = (a, b2) => __defProps11(a, __getOwnPropDescs11(b2));
var camelCase = (string) => string.replace(/-(\w|$)/g, (_, p1) => p1.toUpperCase());
var convertPropertyName = (prop) => {
  let modifiedProp = prop;
  modifiedProp = modifiedProp.toLowerCase();
  if (modifiedProp === "float") {
    return "cssFloat";
  }
  if (modifiedProp.startsWith("--")) {
    return modifiedProp;
  }
  if (modifiedProp.startsWith("-ms-")) {
    modifiedProp = modifiedProp.substr(1);
  }
  return camelCase(modifiedProp);
};
var splitDeclarations = (cssText) => {
  const declarations = [];
  let capturing;
  let i = cssText.length;
  let last = i;
  while (i-- > -1) {
    if ((cssText[i] === '"' || cssText[i] === "'") && cssText[i - 1] !== "\\") {
      if (!capturing) {
        capturing = cssText[i];
      } else if (cssText[i] === capturing) {
        capturing = false;
      }
    }
    if (!capturing && cssText[i] === ")") {
      capturing = cssText[i];
    }
    if (cssText[i] === "(" && capturing === ")") {
      capturing = false;
    }
    if (i < 0 || !capturing && cssText[i] === ";") {
      declarations.unshift(cssText.slice(i + 1, last));
      last = i;
    }
  }
  return declarations;
};
var splitDeclaration = (declaration) => {
  const i = declaration.indexOf(":");
  return [declaration.substr(0, i).trim(), declaration.substr(i + 1).trim()];
};
var cssToJsxStyle = (cssText) => splitDeclarations(cssText).map(splitDeclaration).reduce((styles, [name, value]) => {
  if (name && value) {
    styles[convertPropertyName(name)] = value;
  }
  return styles;
}, {});
var Tailwind = ({ children, config }) => {
  const headStyles = [];
  const { twi } = Op({
    config
  });
  const childrenWithInlineStyles = React2.Children.map(children, (child) => {
    if (React2.isValidElement(child)) {
      return processElement(child, headStyles, twi);
    }
    return child;
  });
  if (!childrenWithInlineStyles)
    return jsx_runtime11.jsx(jsx_runtime11.Fragment, { children });
  const fullHTML = server.renderToStaticMarkup(jsx_runtime11.jsx(jsx_runtime11.Fragment, { children: childrenWithInlineStyles }));
  const hasResponsiveStyles = new RegExp("@media[^{]+\\{(?<content>[\\s\\S]+?)\\}\\s*\\}", "gm").test(headStyles.join(" "));
  const hasHTMLAndHead = /<html[^>]*>(?=[\s\S]*<head[^>]*>)/gm.test(fullHTML);
  if (hasResponsiveStyles && !hasHTMLAndHead) {
    throw new Error("Tailwind: To use responsive styles you must have a <html> and <head> element in your template.");
  }
  const childrenWithInlineAndResponsiveStyles = React2.Children.map(childrenWithInlineStyles, (child) => {
    if (React2.isValidElement(child)) {
      return processHead(child, headStyles);
    }
    return child;
  });
  return jsx_runtime11.jsx(jsx_runtime11.Fragment, { children: childrenWithInlineAndResponsiveStyles });
};

// node_modules/@react-email/text/dist/index.mjs
var jsx_runtime12 = __toESM(require_jsx_runtime(), 1);
var __defProp13 = Object.defineProperty;
var __defProps12 = Object.defineProperties;
var __getOwnPropDescs12 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols12 = Object.getOwnPropertySymbols;
var __hasOwnProp13 = Object.prototype.hasOwnProperty;
var __propIsEnum12 = Object.prototype.propertyIsEnumerable;
var __defNormalProp12 = (obj, key, value) => (key in obj) ? __defProp13(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues12 = (a, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp13.call(b2, prop))
      __defNormalProp12(a, prop, b2[prop]);
  if (__getOwnPropSymbols12)
    for (var prop of __getOwnPropSymbols12(b2)) {
      if (__propIsEnum12.call(b2, prop))
        __defNormalProp12(a, prop, b2[prop]);
    }
  return a;
};
var __spreadProps12 = (a, b2) => __defProps12(a, __getOwnPropDescs12(b2));
var __objRest11 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp13.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols12)
    for (var prop of __getOwnPropSymbols12(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum12.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var Text = (_a) => {
  var _b = _a, { style } = _b, props = __objRest11(_b, ["style"]);
  return jsx_runtime12.jsx("p", __spreadProps12(__spreadValues12({}, props), {
    style: __spreadValues12({
      fontSize: "14px",
      lineHeight: "24px",
      margin: "16px 0"
    }, style)
  }));
};

// src/mail/templates/authentication-magic-link.tsx
var jsx_dev_runtime = __toESM(require_jsx_dev_runtime(), 1);
function AuthenticationMagicLinkTemplate({
  userEmail,
  authLink
}) {
  const previewText = `Fa\xE7a login na OrderFlow`;
  return jsx_dev_runtime.jsxDEV(Html, {
    children: [
      jsx_dev_runtime.jsxDEV(Head, {}, undefined, false, undefined, this),
      jsx_dev_runtime.jsxDEV(Preview, {
        children: previewText
      }, undefined, false, undefined, this),
      jsx_dev_runtime.jsxDEV(Tailwind, {
        children: jsx_dev_runtime.jsxDEV(Body, {
          className: "bg-white my-auto mx-auto font-sans",
          children: jsx_dev_runtime.jsxDEV(Container, {
            className: "border border-solid border-[#eaeaea] rounded my-[40px] mx-auto p-[20px] w-[465px]",
            children: [
              jsx_dev_runtime.jsxDEV(Section, {
                className: "mt-[32px] text-center",
                children: jsx_dev_runtime.jsxDEV("span", {
                  className: "text-2xl",
                  children: "\uD83C\uDF55"
                }, undefined, false, undefined, this)
              }, undefined, false, undefined, this),
              jsx_dev_runtime.jsxDEV(Heading, {
                className: "text-black text-[24px] font-normal text-center p-0 my-[30px] mx-0",
                children: "Fa\xE7a login na OrderFlow"
              }, undefined, false, undefined, this),
              jsx_dev_runtime.jsxDEV(Text, {
                className: "text-black text-[14px] leading-[24px]",
                children: [
                  "Voc\xEA solicitou um link para login na OrderFlow atrav\xE9s do email",
                  " ",
                  userEmail,
                  "."
                ]
              }, undefined, true, undefined, this),
              jsx_dev_runtime.jsxDEV(Section, {
                className: "text-center mt-[32px] mb-[32px]",
                children: jsx_dev_runtime.jsxDEV(Button, {
                  className: "bg-sky-500 rounded text-white px-5 py-3 text-[12px] font-semibold no-underline text-center",
                  href: authLink,
                  children: "Entrar agora"
                }, undefined, false, undefined, this)
              }, undefined, false, undefined, this),
              jsx_dev_runtime.jsxDEV(Text, {
                className: "text-black text-[14px] leading-[24px]",
                children: [
                  "ou copie a URL abaixo e cole em seu browser:",
                  " ",
                  jsx_dev_runtime.jsxDEV(Link, {
                    href: authLink,
                    className: "text-sky-500 no-underline",
                    children: authLink
                  }, undefined, false, undefined, this)
                ]
              }, undefined, true, undefined, this),
              jsx_dev_runtime.jsxDEV(Hr, {
                className: "border border-solid border-[#eaeaea] my-[26px] mx-0 w-full"
              }, undefined, false, undefined, this),
              jsx_dev_runtime.jsxDEV(Text, {
                className: "text-[#666666] text-[12px] leading-[24px]",
                children: "Se voc\xEA n\xE3o solicitou esse link de autentica\xE7\xE3o, apenas descarte esse e-mail."
              }, undefined, false, undefined, this)
            ]
          }, undefined, true, undefined, this)
        }, undefined, false, undefined, this)
      }, undefined, false, undefined, this)
    ]
  }, undefined, true, undefined, this);
}

// src/http/routes/errors/unauthorized-error.ts
class UnauthorizedError extends Error {
  constructor() {
    super("Unauthorized.");
  }
}

// src/http/routes/send-authentication-link.ts
var sendAuthenticationLink = new I$().post("/authenticate", async ({ body }) => {
  const { email } = body;
  const userFromEmail = await db3.query.users.findFirst({
    where(fields, { eq: eq2 }) {
      return eq2(fields.email, email);
    }
  });
  if (!userFromEmail) {
    throw new UnauthorizedError;
  }
  const authLinkCode = $createId();
  await db3.insert(authLinks).values({
    userId: userFromEmail.id,
    code: authLinkCode
  });
  const authLink = new URL("/auth-links/authenticate", env.API_BASE_URL);
  authLink.searchParams.set("code", authLinkCode);
  authLink.searchParams.set("redirect", env.AUTH_REDIRECT_URL);
  console.log(authLink.toString());
  await resend.emails.send({
    from: "OrderFlow <naoresponda@enzomoita.pro>",
    to: email,
    subject: "[OrderFlow] Link para login",
    react: AuthenticationMagicLinkTemplate({
      userEmail: email,
      authLink: authLink.toString()
    })
  });
}, {
  body: export_t.Object({
    email: export_t.String({ format: "email" })
  })
});

// node_modules/cookie/index.js
var parse2 = function(str, options) {
  if (typeof str !== "string") {
    throw new TypeError("argument str must be a string");
  }
  var obj = {};
  var opt = options || {};
  var dec = opt.decode || decode;
  var index = 0;
  while (index < str.length) {
    var eqIdx = str.indexOf("=", index);
    if (eqIdx === -1) {
      break;
    }
    var endIdx = str.indexOf(";", index);
    if (endIdx === -1) {
      endIdx = str.length;
    } else if (endIdx < eqIdx) {
      index = str.lastIndexOf(";", eqIdx - 1) + 1;
      continue;
    }
    var key = str.slice(index, eqIdx).trim();
    if (obj[key] === undefined) {
      var val = str.slice(eqIdx + 1, endIdx).trim();
      if (val.charCodeAt(0) === 34) {
        val = val.slice(1, -1);
      }
      obj[key] = tryDecode(val, dec);
    }
    index = endIdx + 1;
  }
  return obj;
};
var serialize = function(name, val, options) {
  var opt = options || {};
  var enc = opt.encode || encode;
  if (typeof enc !== "function") {
    throw new TypeError("option encode is invalid");
  }
  if (!fieldContentRegExp.test(name)) {
    throw new TypeError("argument name is invalid");
  }
  var value = enc(val);
  if (value && !fieldContentRegExp.test(value)) {
    throw new TypeError("argument val is invalid");
  }
  var str = name + "=" + value;
  if (opt.maxAge != null) {
    var maxAge = opt.maxAge - 0;
    if (isNaN(maxAge) || !isFinite(maxAge)) {
      throw new TypeError("option maxAge is invalid");
    }
    str += "; Max-Age=" + Math.floor(maxAge);
  }
  if (opt.domain) {
    if (!fieldContentRegExp.test(opt.domain)) {
      throw new TypeError("option domain is invalid");
    }
    str += "; Domain=" + opt.domain;
  }
  if (opt.path) {
    if (!fieldContentRegExp.test(opt.path)) {
      throw new TypeError("option path is invalid");
    }
    str += "; Path=" + opt.path;
  }
  if (opt.expires) {
    var expires = opt.expires;
    if (!isDate(expires) || isNaN(expires.valueOf())) {
      throw new TypeError("option expires is invalid");
    }
    str += "; Expires=" + expires.toUTCString();
  }
  if (opt.httpOnly) {
    str += "; HttpOnly";
  }
  if (opt.secure) {
    str += "; Secure";
  }
  if (opt.priority) {
    var priority = typeof opt.priority === "string" ? opt.priority.toLowerCase() : opt.priority;
    switch (priority) {
      case "low":
        str += "; Priority=Low";
        break;
      case "medium":
        str += "; Priority=Medium";
        break;
      case "high":
        str += "; Priority=High";
        break;
      default:
        throw new TypeError("option priority is invalid");
    }
  }
  if (opt.sameSite) {
    var sameSite = typeof opt.sameSite === "string" ? opt.sameSite.toLowerCase() : opt.sameSite;
    switch (sameSite) {
      case true:
        str += "; SameSite=Strict";
        break;
      case "lax":
        str += "; SameSite=Lax";
        break;
      case "strict":
        str += "; SameSite=Strict";
        break;
      case "none":
        str += "; SameSite=None";
        break;
      default:
        throw new TypeError("option sameSite is invalid");
    }
  }
  return str;
};
var decode = function(str) {
  return str.indexOf("%") !== -1 ? decodeURIComponent(str) : str;
};
var encode = function(val) {
  return encodeURIComponent(val);
};
var isDate = function(val) {
  return __toString.call(val) === "[object Date]" || val instanceof Date;
};
var tryDecode = function(str, decode2) {
  try {
    return decode2(str);
  } catch (e) {
    return str;
  }
};
/*!
 * cookie
 * Copyright(c) 2012-2014 Roman Shtylman
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var $parse = parse2;
var $serialize = serialize;
var __toString = Object.prototype.toString;
var fieldContentRegExp = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;

// node_modules/cookie-signature/index.js
var crypto3 = import.meta.require("crypto");
var $sign = function(val, secret) {
  if (typeof val != "string")
    throw new TypeError("Cookie value must be provided as a string.");
  if (secret == null)
    throw new TypeError("Secret key must be provided.");
  return val + "." + crypto3.createHmac("sha256", secret).update(val).digest("base64").replace(/\=+$/, "");
};
var $unsign = function(input, secret) {
  if (typeof input != "string")
    throw new TypeError("Signed cookie string must be provided.");
  if (secret == null)
    throw new TypeError("Secret key must be provided.");
  var tentativeValue = input.slice(0, input.lastIndexOf(".")), expectedInput = $sign(tentativeValue, secret), expectedBuffer = Buffer.from(expectedInput), inputBuffer = Buffer.from(input);
  return expectedBuffer.length === inputBuffer.length && crypto3.timingSafeEqual(expectedBuffer, inputBuffer) ? tentativeValue : false;
};

// node_modules/@elysiajs/cookie/dist/index.js
var cookie = (options = {}) => {
  const { signed, secret: secretKey, ...defaultOptions } = options;
  const secret = !secretKey ? undefined : typeof secretKey === "string" ? secretKey : secretKey[0];
  const isStringKey = typeof secret === "string";
  return new I$({
    name: "@elysiajs/cookie",
    seed: options
  }).decorate("unsignCookie", (value) => {
    if (!secret)
      throw new Error("No secret is provided to cookie plugin");
    let unsigned = isStringKey ? $unsign(value, secret) : false;
    if (isStringKey === false)
      for (let i = 0;i < secret.length; i++) {
        const temp = $unsign(value, secret[i]);
        if (temp) {
          unsigned = temp;
          break;
        }
      }
    return {
      valid: unsigned !== false,
      value: unsigned || undefined
    };
  }).derive((context) => {
    let _cookie;
    const getCookie = () => {
      if (_cookie)
        return _cookie;
      try {
        const headerCookie = context.request.headers.get("cookie");
        _cookie = headerCookie ? $parse(headerCookie) : {};
      } catch (error) {
        _cookie = {};
      }
      return _cookie;
    };
    return {
      get cookie() {
        return getCookie();
      },
      setCookie(name, value, { signed: signed2 = false, ...options2 } = {}) {
        if (signed2) {
          if (!secret)
            throw new Error("No secret is provided to cookie plugin");
          value = $sign(value, secret);
        }
        if (!Array.isArray(context.set.headers["Set-Cookie"]))
          context.set.headers["Set-Cookie"] = [];
        context.set.headers["Set-Cookie"].push($serialize(name, value, {
          path: "/",
          ...defaultOptions,
          ...options2
        }));
        if (!_cookie)
          getCookie();
        _cookie[name] = value;
      },
      removeCookie(name) {
        if (!getCookie()[name])
          return;
        context.set.headers["Set-Cookie"] = $serialize(name, "", {
          expires: new Date("Thu, Jan 01 1970 00:00:00 UTC")
        });
        delete _cookie[name];
      }
    };
  });
};
var dist_default = cookie;

// node_modules/jose/dist/browser/runtime/webcrypto.js
var webcrypto_default = crypto;
var isCryptoKey = (key) => key instanceof CryptoKey;

// node_modules/jose/dist/browser/lib/buffer_utils.js
function concat(...buffers) {
  const size2 = buffers.reduce((acc, { length }) => acc + length, 0);
  const buf = new Uint8Array(size2);
  let i = 0;
  buffers.forEach((buffer2) => {
    buf.set(buffer2, i);
    i += buffer2.length;
  });
  return buf;
}
var encoder = new TextEncoder;
var decoder = new TextDecoder;
var MAX_INT32 = 2 ** 32;

// node_modules/jose/dist/browser/runtime/base64url.js
var encodeBase64 = (input) => {
  let unencoded = input;
  if (typeof unencoded === "string") {
    unencoded = encoder.encode(unencoded);
  }
  const CHUNK_SIZE = 32768;
  const arr = [];
  for (let i = 0;i < unencoded.length; i += CHUNK_SIZE) {
    arr.push(String.fromCharCode.apply(null, unencoded.subarray(i, i + CHUNK_SIZE)));
  }
  return btoa(arr.join(""));
};
var encode2 = (input) => {
  return encodeBase64(input).replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
};
var decodeBase64 = (encoded) => {
  const binary = atob(encoded);
  const bytes2 = new Uint8Array(binary.length);
  for (let i = 0;i < binary.length; i++) {
    bytes2[i] = binary.charCodeAt(i);
  }
  return bytes2;
};
var decode2 = (input) => {
  let encoded = input;
  if (encoded instanceof Uint8Array) {
    encoded = decoder.decode(encoded);
  }
  encoded = encoded.replace(/-/g, "+").replace(/_/g, "/").replace(/\s/g, "");
  try {
    return decodeBase64(encoded);
  } catch (_a) {
    throw new TypeError("The input to be decoded is not correctly encoded.");
  }
};

// node_modules/jose/dist/browser/util/errors.js
class JOSEError extends Error {
  static get code() {
    return "ERR_JOSE_GENERIC";
  }
  constructor(message) {
    var _a;
    super(message);
    this.code = "ERR_JOSE_GENERIC";
    this.name = this.constructor.name;
    (_a = Error.captureStackTrace) === null || _a === undefined || _a.call(Error, this, this.constructor);
  }
}

class JWTClaimValidationFailed extends JOSEError {
  static get code() {
    return "ERR_JWT_CLAIM_VALIDATION_FAILED";
  }
  constructor(message, claim = "unspecified", reason = "unspecified") {
    super(message);
    this.code = "ERR_JWT_CLAIM_VALIDATION_FAILED";
    this.claim = claim;
    this.reason = reason;
  }
}

class JWTExpired extends JOSEError {
  static get code() {
    return "ERR_JWT_EXPIRED";
  }
  constructor(message, claim = "unspecified", reason = "unspecified") {
    super(message);
    this.code = "ERR_JWT_EXPIRED";
    this.claim = claim;
    this.reason = reason;
  }
}

class JOSEAlgNotAllowed extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = "ERR_JOSE_ALG_NOT_ALLOWED";
  }
  static get code() {
    return "ERR_JOSE_ALG_NOT_ALLOWED";
  }
}

class JOSENotSupported extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = "ERR_JOSE_NOT_SUPPORTED";
  }
  static get code() {
    return "ERR_JOSE_NOT_SUPPORTED";
  }
}
class JWSInvalid extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = "ERR_JWS_INVALID";
  }
  static get code() {
    return "ERR_JWS_INVALID";
  }
}

class JWTInvalid extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = "ERR_JWT_INVALID";
  }
  static get code() {
    return "ERR_JWT_INVALID";
  }
}
class JWSSignatureVerificationFailed extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = "ERR_JWS_SIGNATURE_VERIFICATION_FAILED";
    this.message = "signature verification failed";
  }
  static get code() {
    return "ERR_JWS_SIGNATURE_VERIFICATION_FAILED";
  }
}

// node_modules/jose/dist/browser/lib/crypto_key.js
var unusable = function(name, prop = "algorithm.name") {
  return new TypeError(`CryptoKey does not support this operation, its ${prop} must be ${name}`);
};
var isAlgorithm = function(algorithm, name) {
  return algorithm.name === name;
};
var getHashLength = function(hash) {
  return parseInt(hash.name.slice(4), 10);
};
var getNamedCurve = function(alg) {
  switch (alg) {
    case "ES256":
      return "P-256";
    case "ES384":
      return "P-384";
    case "ES512":
      return "P-521";
    default:
      throw new Error("unreachable");
  }
};
var checkUsage = function(key, usages) {
  if (usages.length && !usages.some((expected) => key.usages.includes(expected))) {
    let msg = "CryptoKey does not support this operation, its usages must include ";
    if (usages.length > 2) {
      const last = usages.pop();
      msg += `one of ${usages.join(", ")}, or ${last}.`;
    } else if (usages.length === 2) {
      msg += `one of ${usages[0]} or ${usages[1]}.`;
    } else {
      msg += `${usages[0]}.`;
    }
    throw new TypeError(msg);
  }
};
function checkSigCryptoKey(key, alg, ...usages) {
  switch (alg) {
    case "HS256":
    case "HS384":
    case "HS512": {
      if (!isAlgorithm(key.algorithm, "HMAC"))
        throw unusable("HMAC");
      const expected = parseInt(alg.slice(2), 10);
      const actual = getHashLength(key.algorithm.hash);
      if (actual !== expected)
        throw unusable(`SHA-${expected}`, "algorithm.hash");
      break;
    }
    case "RS256":
    case "RS384":
    case "RS512": {
      if (!isAlgorithm(key.algorithm, "RSASSA-PKCS1-v1_5"))
        throw unusable("RSASSA-PKCS1-v1_5");
      const expected = parseInt(alg.slice(2), 10);
      const actual = getHashLength(key.algorithm.hash);
      if (actual !== expected)
        throw unusable(`SHA-${expected}`, "algorithm.hash");
      break;
    }
    case "PS256":
    case "PS384":
    case "PS512": {
      if (!isAlgorithm(key.algorithm, "RSA-PSS"))
        throw unusable("RSA-PSS");
      const expected = parseInt(alg.slice(2), 10);
      const actual = getHashLength(key.algorithm.hash);
      if (actual !== expected)
        throw unusable(`SHA-${expected}`, "algorithm.hash");
      break;
    }
    case "EdDSA": {
      if (key.algorithm.name !== "Ed25519" && key.algorithm.name !== "Ed448") {
        throw unusable("Ed25519 or Ed448");
      }
      break;
    }
    case "ES256":
    case "ES384":
    case "ES512": {
      if (!isAlgorithm(key.algorithm, "ECDSA"))
        throw unusable("ECDSA");
      const expected = getNamedCurve(alg);
      const actual = key.algorithm.namedCurve;
      if (actual !== expected)
        throw unusable(expected, "algorithm.namedCurve");
      break;
    }
    default:
      throw new TypeError("CryptoKey does not support this operation");
  }
  checkUsage(key, usages);
}

// node_modules/jose/dist/browser/lib/invalid_key_input.js
var message = function(msg, actual, ...types4) {
  if (types4.length > 2) {
    const last = types4.pop();
    msg += `one of type ${types4.join(", ")}, or ${last}.`;
  } else if (types4.length === 2) {
    msg += `one of type ${types4[0]} or ${types4[1]}.`;
  } else {
    msg += `of type ${types4[0]}.`;
  }
  if (actual == null) {
    msg += ` Received ${actual}`;
  } else if (typeof actual === "function" && actual.name) {
    msg += ` Received function ${actual.name}`;
  } else if (typeof actual === "object" && actual != null) {
    if (actual.constructor && actual.constructor.name) {
      msg += ` Received an instance of ${actual.constructor.name}`;
    }
  }
  return msg;
};
function withAlg(alg, actual, ...types4) {
  return message(`Key for the ${alg} algorithm must be `, actual, ...types4);
}
var invalid_key_input_default = (actual, ...types4) => {
  return message("Key must be ", actual, ...types4);
};

// node_modules/jose/dist/browser/runtime/is_key_like.js
var is_key_like_default = (key) => {
  return isCryptoKey(key);
};
var types4 = ["CryptoKey"];

// node_modules/jose/dist/browser/lib/is_disjoint.js
var isDisjoint = (...headers) => {
  const sources = headers.filter(Boolean);
  if (sources.length === 0 || sources.length === 1) {
    return true;
  }
  let acc;
  for (const header of sources) {
    const parameters = Object.keys(header);
    if (!acc || acc.size === 0) {
      acc = new Set(parameters);
      continue;
    }
    for (const parameter of parameters) {
      if (acc.has(parameter)) {
        return false;
      }
      acc.add(parameter);
    }
  }
  return true;
};
var is_disjoint_default = isDisjoint;

// node_modules/jose/dist/browser/lib/is_object.js
var isObjectLike = function(value) {
  return typeof value === "object" && value !== null;
};
function isObject(input) {
  if (!isObjectLike(input) || Object.prototype.toString.call(input) !== "[object Object]") {
    return false;
  }
  if (Object.getPrototypeOf(input) === null) {
    return true;
  }
  let proto = input;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(input) === proto;
}

// node_modules/jose/dist/browser/runtime/check_key_length.js
var check_key_length_default = (alg, key) => {
  if (alg.startsWith("RS") || alg.startsWith("PS")) {
    const { modulusLength } = key.algorithm;
    if (typeof modulusLength !== "number" || modulusLength < 2048) {
      throw new TypeError(`${alg} requires key modulusLength to be 2048 bits or larger`);
    }
  }
};

// node_modules/jose/dist/browser/lib/check_key_type.js
var symmetricTypeCheck = (alg, key) => {
  if (key instanceof Uint8Array)
    return;
  if (!is_key_like_default(key)) {
    throw new TypeError(withAlg(alg, key, ...types4, "Uint8Array"));
  }
  if (key.type !== "secret") {
    throw new TypeError(`${types4.join(" or ")} instances for symmetric algorithms must be of type "secret"`);
  }
};
var asymmetricTypeCheck = (alg, key, usage) => {
  if (!is_key_like_default(key)) {
    throw new TypeError(withAlg(alg, key, ...types4));
  }
  if (key.type === "secret") {
    throw new TypeError(`${types4.join(" or ")} instances for asymmetric algorithms must not be of type "secret"`);
  }
  if (usage === "sign" && key.type === "public") {
    throw new TypeError(`${types4.join(" or ")} instances for asymmetric algorithm signing must be of type "private"`);
  }
  if (usage === "decrypt" && key.type === "public") {
    throw new TypeError(`${types4.join(" or ")} instances for asymmetric algorithm decryption must be of type "private"`);
  }
  if (key.algorithm && usage === "verify" && key.type === "private") {
    throw new TypeError(`${types4.join(" or ")} instances for asymmetric algorithm verifying must be of type "public"`);
  }
  if (key.algorithm && usage === "encrypt" && key.type === "private") {
    throw new TypeError(`${types4.join(" or ")} instances for asymmetric algorithm encryption must be of type "public"`);
  }
};
var checkKeyType = (alg, key, usage) => {
  const symmetric = alg.startsWith("HS") || alg === "dir" || alg.startsWith("PBES2") || /^A\d{3}(?:GCM)?KW$/.test(alg);
  if (symmetric) {
    symmetricTypeCheck(alg, key);
  } else {
    asymmetricTypeCheck(alg, key, usage);
  }
};
var check_key_type_default = checkKeyType;

// node_modules/jose/dist/browser/lib/validate_crit.js
var validateCrit = function(Err, recognizedDefault, recognizedOption, protectedHeader, joseHeader) {
  if (joseHeader.crit !== undefined && protectedHeader.crit === undefined) {
    throw new Err('"crit" (Critical) Header Parameter MUST be integrity protected');
  }
  if (!protectedHeader || protectedHeader.crit === undefined) {
    return new Set;
  }
  if (!Array.isArray(protectedHeader.crit) || protectedHeader.crit.length === 0 || protectedHeader.crit.some((input) => typeof input !== "string" || input.length === 0)) {
    throw new Err('"crit" (Critical) Header Parameter MUST be an array of non-empty strings when present');
  }
  let recognized;
  if (recognizedOption !== undefined) {
    recognized = new Map([...Object.entries(recognizedOption), ...recognizedDefault.entries()]);
  } else {
    recognized = recognizedDefault;
  }
  for (const parameter of protectedHeader.crit) {
    if (!recognized.has(parameter)) {
      throw new JOSENotSupported(`Extension Header Parameter "${parameter}" is not recognized`);
    }
    if (joseHeader[parameter] === undefined) {
      throw new Err(`Extension Header Parameter "${parameter}" is missing`);
    } else if (recognized.get(parameter) && protectedHeader[parameter] === undefined) {
      throw new Err(`Extension Header Parameter "${parameter}" MUST be integrity protected`);
    }
  }
  return new Set(protectedHeader.crit);
};
var validate_crit_default = validateCrit;

// node_modules/jose/dist/browser/lib/validate_algorithms.js
var validateAlgorithms = (option, algorithms) => {
  if (algorithms !== undefined && (!Array.isArray(algorithms) || algorithms.some((s) => typeof s !== "string"))) {
    throw new TypeError(`"${option}" option must be an array of strings`);
  }
  if (!algorithms) {
    return;
  }
  return new Set(algorithms);
};
var validate_algorithms_default = validateAlgorithms;

// node_modules/jose/dist/browser/runtime/subtle_dsa.js
function subtleDsa(alg, algorithm) {
  const hash = `SHA-${alg.slice(-3)}`;
  switch (alg) {
    case "HS256":
    case "HS384":
    case "HS512":
      return { hash, name: "HMAC" };
    case "PS256":
    case "PS384":
    case "PS512":
      return { hash, name: "RSA-PSS", saltLength: alg.slice(-3) >> 3 };
    case "RS256":
    case "RS384":
    case "RS512":
      return { hash, name: "RSASSA-PKCS1-v1_5" };
    case "ES256":
    case "ES384":
    case "ES512":
      return { hash, name: "ECDSA", namedCurve: algorithm.namedCurve };
    case "EdDSA":
      return { name: algorithm.name };
    default:
      throw new JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);
  }
}

// node_modules/jose/dist/browser/runtime/get_sign_verify_key.js
function getCryptoKey(alg, key, usage) {
  if (isCryptoKey(key)) {
    checkSigCryptoKey(key, alg, usage);
    return key;
  }
  if (key instanceof Uint8Array) {
    if (!alg.startsWith("HS")) {
      throw new TypeError(invalid_key_input_default(key, ...types4));
    }
    return webcrypto_default.subtle.importKey("raw", key, { hash: `SHA-${alg.slice(-3)}`, name: "HMAC" }, false, [usage]);
  }
  throw new TypeError(invalid_key_input_default(key, ...types4, "Uint8Array"));
}

// node_modules/jose/dist/browser/runtime/verify.js
var verify = async (alg, key, signature, data) => {
  const cryptoKey = await getCryptoKey(alg, key, "verify");
  check_key_length_default(alg, cryptoKey);
  const algorithm = subtleDsa(alg, cryptoKey.algorithm);
  try {
    return await webcrypto_default.subtle.verify(algorithm, cryptoKey, signature, data);
  } catch (_a) {
    return false;
  }
};
var verify_default = verify;

// node_modules/jose/dist/browser/jws/flattened/verify.js
async function flattenedVerify(jws, key, options) {
  var _a;
  if (!isObject(jws)) {
    throw new JWSInvalid("Flattened JWS must be an object");
  }
  if (jws.protected === undefined && jws.header === undefined) {
    throw new JWSInvalid('Flattened JWS must have either of the "protected" or "header" members');
  }
  if (jws.protected !== undefined && typeof jws.protected !== "string") {
    throw new JWSInvalid("JWS Protected Header incorrect type");
  }
  if (jws.payload === undefined) {
    throw new JWSInvalid("JWS Payload missing");
  }
  if (typeof jws.signature !== "string") {
    throw new JWSInvalid("JWS Signature missing or incorrect type");
  }
  if (jws.header !== undefined && !isObject(jws.header)) {
    throw new JWSInvalid("JWS Unprotected Header incorrect type");
  }
  let parsedProt = {};
  if (jws.protected) {
    try {
      const protectedHeader = decode2(jws.protected);
      parsedProt = JSON.parse(decoder.decode(protectedHeader));
    } catch (_b) {
      throw new JWSInvalid("JWS Protected Header is invalid");
    }
  }
  if (!is_disjoint_default(parsedProt, jws.header)) {
    throw new JWSInvalid("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");
  }
  const joseHeader = {
    ...parsedProt,
    ...jws.header
  };
  const extensions = validate_crit_default(JWSInvalid, new Map([["b64", true]]), options === null || options === undefined ? undefined : options.crit, parsedProt, joseHeader);
  let b64 = true;
  if (extensions.has("b64")) {
    b64 = parsedProt.b64;
    if (typeof b64 !== "boolean") {
      throw new JWSInvalid('The "b64" (base64url-encode payload) Header Parameter must be a boolean');
    }
  }
  const { alg } = joseHeader;
  if (typeof alg !== "string" || !alg) {
    throw new JWSInvalid('JWS "alg" (Algorithm) Header Parameter missing or invalid');
  }
  const algorithms = options && validate_algorithms_default("algorithms", options.algorithms);
  if (algorithms && !algorithms.has(alg)) {
    throw new JOSEAlgNotAllowed('"alg" (Algorithm) Header Parameter not allowed');
  }
  if (b64) {
    if (typeof jws.payload !== "string") {
      throw new JWSInvalid("JWS Payload must be a string");
    }
  } else if (typeof jws.payload !== "string" && !(jws.payload instanceof Uint8Array)) {
    throw new JWSInvalid("JWS Payload must be a string or an Uint8Array instance");
  }
  let resolvedKey = false;
  if (typeof key === "function") {
    key = await key(parsedProt, jws);
    resolvedKey = true;
  }
  check_key_type_default(alg, key, "verify");
  const data = concat(encoder.encode((_a = jws.protected) !== null && _a !== undefined ? _a : ""), encoder.encode("."), typeof jws.payload === "string" ? encoder.encode(jws.payload) : jws.payload);
  let signature;
  try {
    signature = decode2(jws.signature);
  } catch (_c) {
    throw new JWSInvalid("Failed to base64url decode the signature");
  }
  const verified = await verify_default(alg, key, signature, data);
  if (!verified) {
    throw new JWSSignatureVerificationFailed;
  }
  let payload;
  if (b64) {
    try {
      payload = decode2(jws.payload);
    } catch (_d) {
      throw new JWSInvalid("Failed to base64url decode the payload");
    }
  } else if (typeof jws.payload === "string") {
    payload = encoder.encode(jws.payload);
  } else {
    payload = jws.payload;
  }
  const result2 = { payload };
  if (jws.protected !== undefined) {
    result2.protectedHeader = parsedProt;
  }
  if (jws.header !== undefined) {
    result2.unprotectedHeader = jws.header;
  }
  if (resolvedKey) {
    return { ...result2, key };
  }
  return result2;
}

// node_modules/jose/dist/browser/jws/compact/verify.js
async function compactVerify(jws, key, options) {
  if (jws instanceof Uint8Array) {
    jws = decoder.decode(jws);
  }
  if (typeof jws !== "string") {
    throw new JWSInvalid("Compact JWS must be a string or Uint8Array");
  }
  const { 0: protectedHeader, 1: payload, 2: signature, length } = jws.split(".");
  if (length !== 3) {
    throw new JWSInvalid("Invalid Compact JWS");
  }
  const verified = await flattenedVerify({ payload, protected: protectedHeader, signature }, key, options);
  const result2 = { payload: verified.payload, protectedHeader: verified.protectedHeader };
  if (typeof key === "function") {
    return { ...result2, key: verified.key };
  }
  return result2;
}

// node_modules/jose/dist/browser/lib/epoch.js
var epoch_default = (date) => Math.floor(date.getTime() / 1000);

// node_modules/jose/dist/browser/lib/secs.js
var minute = 60;
var hour = minute * 60;
var day = hour * 24;
var week = day * 7;
var year = day * 365.25;
var REGEX = /^(\d+|\d+\.\d+) ?(seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)$/i;
var secs_default = (str) => {
  const matched = REGEX.exec(str);
  if (!matched) {
    throw new TypeError("Invalid time period format");
  }
  const value = parseFloat(matched[1]);
  const unit = matched[2].toLowerCase();
  switch (unit) {
    case "sec":
    case "secs":
    case "second":
    case "seconds":
    case "s":
      return Math.round(value);
    case "minute":
    case "minutes":
    case "min":
    case "mins":
    case "m":
      return Math.round(value * minute);
    case "hour":
    case "hours":
    case "hr":
    case "hrs":
    case "h":
      return Math.round(value * hour);
    case "day":
    case "days":
    case "d":
      return Math.round(value * day);
    case "week":
    case "weeks":
    case "w":
      return Math.round(value * week);
    default:
      return Math.round(value * year);
  }
};

// node_modules/jose/dist/browser/lib/jwt_claims_set.js
var normalizeTyp = (value) => value.toLowerCase().replace(/^application\//, "");
var checkAudiencePresence = (audPayload, audOption) => {
  if (typeof audPayload === "string") {
    return audOption.includes(audPayload);
  }
  if (Array.isArray(audPayload)) {
    return audOption.some(Set.prototype.has.bind(new Set(audPayload)));
  }
  return false;
};
var jwt_claims_set_default = (protectedHeader, encodedPayload, options = {}) => {
  const { typ } = options;
  if (typ && (typeof protectedHeader.typ !== "string" || normalizeTyp(protectedHeader.typ) !== normalizeTyp(typ))) {
    throw new JWTClaimValidationFailed('unexpected "typ" JWT header value', "typ", "check_failed");
  }
  let payload;
  try {
    payload = JSON.parse(decoder.decode(encodedPayload));
  } catch (_a) {
  }
  if (!isObject(payload)) {
    throw new JWTInvalid("JWT Claims Set must be a top-level JSON object");
  }
  const { requiredClaims = [], issuer, subject, audience, maxTokenAge } = options;
  if (maxTokenAge !== undefined)
    requiredClaims.push("iat");
  if (audience !== undefined)
    requiredClaims.push("aud");
  if (subject !== undefined)
    requiredClaims.push("sub");
  if (issuer !== undefined)
    requiredClaims.push("iss");
  for (const claim of new Set(requiredClaims.reverse())) {
    if (!(claim in payload)) {
      throw new JWTClaimValidationFailed(`missing required "${claim}" claim`, claim, "missing");
    }
  }
  if (issuer && !(Array.isArray(issuer) ? issuer : [issuer]).includes(payload.iss)) {
    throw new JWTClaimValidationFailed('unexpected "iss" claim value', "iss", "check_failed");
  }
  if (subject && payload.sub !== subject) {
    throw new JWTClaimValidationFailed('unexpected "sub" claim value', "sub", "check_failed");
  }
  if (audience && !checkAudiencePresence(payload.aud, typeof audience === "string" ? [audience] : audience)) {
    throw new JWTClaimValidationFailed('unexpected "aud" claim value', "aud", "check_failed");
  }
  let tolerance;
  switch (typeof options.clockTolerance) {
    case "string":
      tolerance = secs_default(options.clockTolerance);
      break;
    case "number":
      tolerance = options.clockTolerance;
      break;
    case "undefined":
      tolerance = 0;
      break;
    default:
      throw new TypeError("Invalid clockTolerance option type");
  }
  const { currentDate } = options;
  const now = epoch_default(currentDate || new Date);
  if ((payload.iat !== undefined || maxTokenAge) && typeof payload.iat !== "number") {
    throw new JWTClaimValidationFailed('"iat" claim must be a number', "iat", "invalid");
  }
  if (payload.nbf !== undefined) {
    if (typeof payload.nbf !== "number") {
      throw new JWTClaimValidationFailed('"nbf" claim must be a number', "nbf", "invalid");
    }
    if (payload.nbf > now + tolerance) {
      throw new JWTClaimValidationFailed('"nbf" claim timestamp check failed', "nbf", "check_failed");
    }
  }
  if (payload.exp !== undefined) {
    if (typeof payload.exp !== "number") {
      throw new JWTClaimValidationFailed('"exp" claim must be a number', "exp", "invalid");
    }
    if (payload.exp <= now - tolerance) {
      throw new JWTExpired('"exp" claim timestamp check failed', "exp", "check_failed");
    }
  }
  if (maxTokenAge) {
    const age = now - payload.iat;
    const max = typeof maxTokenAge === "number" ? maxTokenAge : secs_default(maxTokenAge);
    if (age - tolerance > max) {
      throw new JWTExpired('"iat" claim timestamp check failed (too far in the past)', "iat", "check_failed");
    }
    if (age < 0 - tolerance) {
      throw new JWTClaimValidationFailed('"iat" claim timestamp check failed (it should be in the past)', "iat", "check_failed");
    }
  }
  return payload;
};

// node_modules/jose/dist/browser/jwt/verify.js
async function jwtVerify(jwt, key, options) {
  var _a;
  const verified = await compactVerify(jwt, key, options);
  if (((_a = verified.protectedHeader.crit) === null || _a === undefined ? undefined : _a.includes("b64")) && verified.protectedHeader.b64 === false) {
    throw new JWTInvalid("JWTs MUST NOT use unencoded payload");
  }
  const payload = jwt_claims_set_default(verified.protectedHeader, verified.payload, options);
  const result2 = { payload, protectedHeader: verified.protectedHeader };
  if (typeof key === "function") {
    return { ...result2, key: verified.key };
  }
  return result2;
}
// node_modules/jose/dist/browser/runtime/sign.js
var sign = async (alg, key, data) => {
  const cryptoKey = await getCryptoKey(alg, key, "sign");
  check_key_length_default(alg, cryptoKey);
  const signature = await webcrypto_default.subtle.sign(subtleDsa(alg, cryptoKey.algorithm), cryptoKey, data);
  return new Uint8Array(signature);
};
var sign_default = sign;

// node_modules/jose/dist/browser/jws/flattened/sign.js
class FlattenedSign {
  constructor(payload) {
    if (!(payload instanceof Uint8Array)) {
      throw new TypeError("payload must be an instance of Uint8Array");
    }
    this._payload = payload;
  }
  setProtectedHeader(protectedHeader) {
    if (this._protectedHeader) {
      throw new TypeError("setProtectedHeader can only be called once");
    }
    this._protectedHeader = protectedHeader;
    return this;
  }
  setUnprotectedHeader(unprotectedHeader) {
    if (this._unprotectedHeader) {
      throw new TypeError("setUnprotectedHeader can only be called once");
    }
    this._unprotectedHeader = unprotectedHeader;
    return this;
  }
  async sign(key, options) {
    if (!this._protectedHeader && !this._unprotectedHeader) {
      throw new JWSInvalid("either setProtectedHeader or setUnprotectedHeader must be called before #sign()");
    }
    if (!is_disjoint_default(this._protectedHeader, this._unprotectedHeader)) {
      throw new JWSInvalid("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");
    }
    const joseHeader = {
      ...this._protectedHeader,
      ...this._unprotectedHeader
    };
    const extensions = validate_crit_default(JWSInvalid, new Map([["b64", true]]), options === null || options === undefined ? undefined : options.crit, this._protectedHeader, joseHeader);
    let b64 = true;
    if (extensions.has("b64")) {
      b64 = this._protectedHeader.b64;
      if (typeof b64 !== "boolean") {
        throw new JWSInvalid('The "b64" (base64url-encode payload) Header Parameter must be a boolean');
      }
    }
    const { alg } = joseHeader;
    if (typeof alg !== "string" || !alg) {
      throw new JWSInvalid('JWS "alg" (Algorithm) Header Parameter missing or invalid');
    }
    check_key_type_default(alg, key, "sign");
    let payload = this._payload;
    if (b64) {
      payload = encoder.encode(encode2(payload));
    }
    let protectedHeader;
    if (this._protectedHeader) {
      protectedHeader = encoder.encode(encode2(JSON.stringify(this._protectedHeader)));
    } else {
      protectedHeader = encoder.encode("");
    }
    const data = concat(protectedHeader, encoder.encode("."), payload);
    const signature = await sign_default(alg, key, data);
    const jws = {
      signature: encode2(signature),
      payload: ""
    };
    if (b64) {
      jws.payload = decoder.decode(payload);
    }
    if (this._unprotectedHeader) {
      jws.header = this._unprotectedHeader;
    }
    if (this._protectedHeader) {
      jws.protected = decoder.decode(protectedHeader);
    }
    return jws;
  }
}

// node_modules/jose/dist/browser/jws/compact/sign.js
class CompactSign {
  constructor(payload) {
    this._flattened = new FlattenedSign(payload);
  }
  setProtectedHeader(protectedHeader) {
    this._flattened.setProtectedHeader(protectedHeader);
    return this;
  }
  async sign(key, options) {
    const jws = await this._flattened.sign(key, options);
    if (jws.payload === undefined) {
      throw new TypeError("use the flattened module for creating JWS with b64: false");
    }
    return `${jws.protected}.${jws.payload}.${jws.signature}`;
  }
}

// node_modules/jose/dist/browser/jwt/produce.js
class ProduceJWT {
  constructor(payload) {
    if (!isObject(payload)) {
      throw new TypeError("JWT Claims Set MUST be an object");
    }
    this._payload = payload;
  }
  setIssuer(issuer) {
    this._payload = { ...this._payload, iss: issuer };
    return this;
  }
  setSubject(subject) {
    this._payload = { ...this._payload, sub: subject };
    return this;
  }
  setAudience(audience) {
    this._payload = { ...this._payload, aud: audience };
    return this;
  }
  setJti(jwtId) {
    this._payload = { ...this._payload, jti: jwtId };
    return this;
  }
  setNotBefore(input) {
    if (typeof input === "number") {
      this._payload = { ...this._payload, nbf: input };
    } else {
      this._payload = { ...this._payload, nbf: epoch_default(new Date) + secs_default(input) };
    }
    return this;
  }
  setExpirationTime(input) {
    if (typeof input === "number") {
      this._payload = { ...this._payload, exp: input };
    } else {
      this._payload = { ...this._payload, exp: epoch_default(new Date) + secs_default(input) };
    }
    return this;
  }
  setIssuedAt(input) {
    if (typeof input === "undefined") {
      this._payload = { ...this._payload, iat: epoch_default(new Date) };
    } else {
      this._payload = { ...this._payload, iat: input };
    }
    return this;
  }
}

// node_modules/jose/dist/browser/jwt/sign.js
class SignJWT extends ProduceJWT {
  setProtectedHeader(protectedHeader) {
    this._protectedHeader = protectedHeader;
    return this;
  }
  async sign(key, options) {
    var _a;
    const sig = new CompactSign(encoder.encode(JSON.stringify(this._payload)));
    sig.setProtectedHeader(this._protectedHeader);
    if (Array.isArray((_a = this._protectedHeader) === null || _a === undefined ? undefined : _a.crit) && this._protectedHeader.crit.includes("b64") && this._protectedHeader.b64 === false) {
      throw new JWTInvalid("JWTs MUST NOT use unencoded payload");
    }
    return sig.sign(key, options);
  }
}
// node_modules/@elysiajs/jwt/dist/index.js
var typebox = __toESM(require_typebox(), 1);
var jwt = ({ name = "jwt", secret, alg = "HS256", crit, schema: schema4, nbf, exp, ...payload }) => {
  if (!secret)
    throw new Error("Secret can't be empty");
  const key = typeof secret === "string" ? new TextEncoder().encode(secret) : secret;
  const validator = schema4 ? Q1(typebox.Type.Intersect([
    schema4,
    typebox.Type.Object({
      iss: typebox.Type.Optional(typebox.Type.String()),
      sub: typebox.Type.Optional(typebox.Type.String()),
      aud: typebox.Type.Optional(typebox.Type.Union([typebox.Type.String(), typebox.Type.Array(typebox.Type.String())])),
      jti: typebox.Type.Optional(typebox.Type.String()),
      nbf: typebox.Type.Optional(typebox.Type.Union([typebox.Type.String(), typebox.Type.Number()])),
      exp: typebox.Type.Optional(typebox.Type.Union([typebox.Type.String(), typebox.Type.Number()])),
      iat: typebox.Type.Optional(typebox.Type.String())
    })
  ]), {}) : undefined;
  return new I$({
    name: "@elysiajs/jwt",
    seed: {
      name,
      secret,
      alg,
      crit,
      schema: schema4,
      nbf,
      exp,
      ...payload
    }
  }).decorate(name, {
    sign: (morePayload) => {
      let jwt2 = new SignJWT({
        ...payload,
        ...morePayload,
        nbf: undefined,
        exp: undefined
      }).setProtectedHeader({
        alg,
        crit
      });
      if (nbf)
        jwt2 = jwt2.setNotBefore(nbf);
      if (exp)
        jwt2 = jwt2.setExpirationTime(exp);
      return jwt2.sign(key);
    },
    verify: async (jwt2) => {
      if (!jwt2)
        return false;
      try {
        const data = (await jwtVerify(jwt2, key)).payload;
        if (validator && !validator.Check(data))
          throw new U0("JWT", validator, data);
        return data;
      } catch (_) {
        return false;
      }
    }
  });
};
var dist_default2 = jwt;

// src/http/routes/errors/not-a-manager-error.ts
class NotAManagerError extends Error {
  constructor() {
    super("User is not a restaurant manager.");
  }
}

// src/http/authentication.ts
var jwtPayloadSchema = export_t.Object({
  sub: export_t.String(),
  restaurantId: export_t.Optional(export_t.String())
});
var authentication = new I$().error({
  UNAUTHORIZED: UnauthorizedError,
  NOT_A_MANAGER: NotAManagerError
}).onError(({ code, error, set }) => {
  switch (code) {
    case "UNAUTHORIZED":
      set.status = 401;
      return { code, message: error.message };
    case "NOT_A_MANAGER":
      set.status = 401;
      return { code, message: error.message };
  }
}).use(dist_default2({
  name: "jwt",
  secret: env.JWT_SECRET_KEY,
  schema: jwtPayloadSchema
})).use(dist_default()).derive(({ jwt: jwt3, cookie: cookie3, setCookie, removeCookie }) => {
  return {
    getCurrentUser: async () => {
      const payload = await jwt3.verify(cookie3.auth);
      if (!payload) {
        throw new UnauthorizedError;
      }
      return payload;
    },
    signUser: async (payload) => {
      setCookie("auth", await jwt3.sign(payload), {
        httpOnly: true,
        maxAge: 604800,
        path: "/"
      });
    },
    signOut: () => {
      removeCookie("auth");
    }
  };
}).derive(({ getCurrentUser }) => {
  return {
    getManagedRestaurantId: async () => {
      const { restaurantId } = await getCurrentUser();
      if (!restaurantId) {
        throw new NotAManagerError;
      }
      return restaurantId;
    }
  };
});

// src/http/routes/create-order.ts
var createOrder = new I$().use(authentication).post("/restaurants/:restaurantId/orders", async ({ params, body, getCurrentUser, set }) => {
  const { sub: customerId } = await getCurrentUser();
  const { restaurantId } = params;
  const { items } = body;
  const productsIds = items.map((item) => item.productId);
  const products3 = await db3.query.products.findMany({
    where(fields, { eq: eq2, and: and2, inArray: inArray2 }) {
      return and2(eq2(fields.restaurantId, restaurantId), inArray2(fields.id, productsIds));
    }
  });
  const orderProducts = items.map((item) => {
    const product = products3.find((product2) => product2.id === item.productId);
    if (!product) {
      throw new Error("Not all products are available in this restaurant.");
    }
    return {
      productId: item.productId,
      unitPriceInCents: product.priceInCents,
      quantity: item.quantity,
      subtotalInCents: item.quantity * product.priceInCents
    };
  });
  const totalInCents = orderProducts.reduce((total, orderItem) => {
    return total + orderItem.subtotalInCents;
  }, 0);
  await db3.transaction(async (tx2) => {
    const [order] = await tx2.insert(orders).values({
      totalInCents,
      customerId,
      restaurantId
    }).returning({
      id: orders.id
    });
    await tx2.insert(orderItems).values(orderProducts.map((orderProduct) => {
      return {
        orderId: order.id,
        productId: orderProduct.productId,
        priceInCents: orderProduct.unitPriceInCents,
        quantity: orderProduct.quantity
      };
    }));
  });
  set.status = 201;
}, {
  body: export_t.Object({
    items: export_t.Array(export_t.Object({
      productId: export_t.String(),
      quantity: export_t.Integer()
    }))
  }),
  params: export_t.Object({
    restaurantId: export_t.String()
  })
});

// src/http/routes/approve-order.ts
var approveOrder = new I$().use(authentication).patch("/orders/:id/approve", async ({ getManagedRestaurantId, set, params }) => {
  const { id: orderId } = params;
  const restaurantId = await getManagedRestaurantId();
  const order = await db3.query.orders.findFirst({
    where(fields, { eq: eq2, and: and2 }) {
      return and2(eq2(fields.id, orderId), eq2(fields.restaurantId, restaurantId));
    }
  });
  if (!order) {
    throw new UnauthorizedError;
  }
  if (order.status !== "pending") {
    set.status = 400;
    return { message: "Order was already approved before." };
  }
  await db3.update(orders).set({
    status: "processing"
  }).where(eq(orders.id, orderId));
  set.status = 204;
}, {
  params: export_t.Object({
    id: export_t.String()
  })
});

// src/http/routes/cancel-order.ts
var cancelOrder = new I$().use(authentication).patch("/orders/:id/cancel", async ({ getCurrentUser, set, params }) => {
  const { id: orderId } = params;
  const { restaurantId } = await getCurrentUser();
  if (!restaurantId) {
    set.status = 401;
    throw new Error("User is not a restaurant manager.");
  }
  const order = await db3.query.orders.findFirst({
    where(fields, { eq: eq2, and: and2 }) {
      return and2(eq2(fields.id, orderId), eq2(fields.restaurantId, restaurantId));
    }
  });
  if (!order) {
    set.status = 401;
    throw new Error("Order not found under the user managed restaurant.");
  }
  if (!["pending", "processing"].includes(order.status)) {
    set.status = 400;
    return {
      code: "STATUS_NOT_VALID",
      message: "O pedido n\xE3o pode ser cancelado depois de ser enviado."
    };
  }
  await db3.update(orders).set({
    status: "canceled"
  }).where(eq(orders.id, orderId));
  set.status = 204;
}, {
  params: export_t.Object({
    id: export_t.String()
  })
});

// node_modules/drizzle-typebox/index.mjs
var typebox2 = __toESM(require_typebox(), 1);

// node_modules/drizzle-orm/mysql-core/table.js
var InlineForeignKeys2 = Symbol.for("drizzle:MySqlInlineForeignKeys");

class MySqlTable extends Table {
  static [entityKind] = "MySqlTable";
  static Symbol = Object.assign({}, Table.Symbol, {
    InlineForeignKeys: InlineForeignKeys2
  });
  [Table.Symbol.Columns];
  [InlineForeignKeys2] = [];
  [Table.Symbol.ExtraConfigBuilder] = undefined;
}

// node_modules/drizzle-orm/mysql-core/unique-constraint.js
var uniqueKeyName2 = function(table18, columns2) {
  return `${table18[MySqlTable.Symbol.Name]}_${columns2.join("_")}_unique`;
};

// node_modules/drizzle-orm/mysql-core/columns/common.js
class MySqlColumn extends Column {
  constructor(table18, config) {
    if (!config.uniqueName) {
      config.uniqueName = uniqueKeyName2(table18, [config.name]);
    }
    super(table18, config);
    this.table = table18;
  }
  static [entityKind] = "MySqlColumn";
}
class MySqlColumnWithAutoIncrement extends MySqlColumn {
  static [entityKind] = "MySqlColumnWithAutoIncrement";
  autoIncrement = this.config.autoIncrement;
}

// node_modules/drizzle-orm/mysql-core/columns/char.js
class MySqlChar extends MySqlColumn {
  static [entityKind] = "MySqlChar";
  length = this.config.length;
  enumValues = this.config.enum;
  getSQLType() {
    return this.length === undefined ? `char` : `char(${this.length})`;
  }
}

// node_modules/drizzle-orm/mysql-core/columns/varbinary.js
class MySqlVarBinary extends MySqlColumn {
  static [entityKind] = "MySqlVarBinary";
  length = this.config.length;
  getSQLType() {
    return this.length === undefined ? `varbinary` : `varbinary(${this.length})`;
  }
}

// node_modules/drizzle-orm/mysql-core/columns/varchar.js
class MySqlVarChar extends MySqlColumn {
  static [entityKind] = "MySqlVarChar";
  length = this.config.length;
  enumValues = this.config.enum;
  getSQLType() {
    return this.length === undefined ? `varchar` : `varchar(${this.length})`;
  }
}

// node_modules/drizzle-orm/sqlite-core/table.js
var InlineForeignKeys3 = Symbol.for("drizzle:SQLiteInlineForeignKeys");

class SQLiteTable extends Table {
  static [entityKind] = "SQLiteTable";
  static Symbol = Object.assign({}, Table.Symbol, {
    InlineForeignKeys: InlineForeignKeys3
  });
  [Table.Symbol.Columns];
  [InlineForeignKeys3] = [];
  [Table.Symbol.ExtraConfigBuilder] = undefined;
}

// node_modules/drizzle-orm/sqlite-core/unique-constraint.js
var uniqueKeyName3 = function(table20, columns2) {
  return `${table20[SQLiteTable.Symbol.Name]}_${columns2.join("_")}_unique`;
};

// node_modules/drizzle-orm/sqlite-core/columns/common.js
class SQLiteColumn extends Column {
  constructor(table20, config) {
    if (!config.uniqueName) {
      config.uniqueName = uniqueKeyName3(table20, [config.name]);
    }
    super(table20, config);
    this.table = table20;
  }
  static [entityKind] = "SQLiteColumn";
}

// node_modules/drizzle-orm/sqlite-core/columns/text.js
class SQLiteText extends SQLiteColumn {
  static [entityKind] = "SQLiteText";
  enumValues = this.config.enumValues;
  length = this.config.length;
  constructor(table20, config) {
    super(table20, config);
  }
  getSQLType() {
    return `text${this.config.length ? `(${this.config.length})` : ""}`;
  }
}

// node_modules/drizzle-typebox/index.mjs
var y = function(n, r) {
  const o2 = getTableColumns(n), i = Object.entries(o2);
  let a = Object.fromEntries(i.map(([e2, t2]) => [e2, d(t2)]));
  r && (a = Object.assign(a, Object.fromEntries(Object.entries(r).map(([e2, t2]) => [e2, typeof t2 == "function" ? t2(a) : t2]))));
  for (const [e2, t2] of i)
    t2.notNull || (a[e2] = u(a[e2]));
  return typebox2.Type.Object(a);
};
var d = function(t2) {
  let f;
  if (function(e2) {
    return "enumValues" in e2 && Array.isArray(e2.enumValues) && e2.enumValues.length > 0;
  }(t2) && (f = t2.enumValues?.length ? typebox2.Type.Union(t2.enumValues.map((t3) => typebox2.Type.Literal(t3))) : typebox2.Type.String()), !f)
    if (t2.dataType === "custom")
      f = typebox2.Type.Any();
    else if (t2.dataType === "json")
      f = c2;
    else if (t2.dataType === "array")
      f = typebox2.Type.Array(d(t2.baseColumn));
    else if (t2.dataType === "number")
      f = typebox2.Type.Number();
    else if (t2.dataType === "bigint")
      f = typebox2.Type.BigInt();
    else if (t2.dataType === "boolean")
      f = typebox2.Type.Boolean();
    else if (t2.dataType === "date")
      f = typebox2.Type.Date();
    else if (t2.dataType === "string") {
      const s = typebox2.Type.String();
      (is(t2, PgChar) || is(t2, PgVarchar) || is(t2, MySqlVarChar) || is(t2, MySqlVarBinary) || is(t2, MySqlChar) || is(t2, SQLiteText)) && typeof t2.length == "number" && (s.maxLength = t2.length), f = s;
    } else
      is(t2, PgUUID) && (f = typebox2.Type.RegEx(b2));
  return f || (f = typebox2.Type.Any()), f;
};
var f = typebox2.Type.Union([typebox2.Type.String(), typebox2.Type.Number(), typebox2.Type.Boolean(), typebox2.Type.Null()]);
var c2 = typebox2.Type.Union([f, typebox2.Type.Array(typebox2.Type.Any()), typebox2.Type.Record(typebox2.Type.String(), typebox2.Type.Any())]);
var u = (t2) => typebox2.Type.Union([t2, typebox2.Type.Null()]);
var b2 = /^[\dA-Fa-f]{8}(?:-[\dA-Fa-f]{4}){3}-[\dA-Fa-f]{12}$/;

// src/http/routes/get-orders.ts
var getOrders = new I$().use(authentication).get("/orders", async ({ query: query5, getCurrentUser, set }) => {
  const { pageIndex, orderId, customerName, status } = query5;
  const { restaurantId } = await getCurrentUser();
  if (!restaurantId) {
    set.status = 401;
    throw new Error("User is not a restaurant manager.");
  }
  const baseQuery = db3.select({
    orderId: orders.id,
    createdAt: orders.createdAt,
    status: orders.status,
    customerName: users.name,
    total: orders.totalInCents
  }).from(orders).innerJoin(users, eq(users.id, orders.customerId)).where(and(eq(orders.restaurantId, restaurantId), orderId ? ilike(orders.id, `%${orderId}%`) : undefined, status ? eq(orders.status, status) : undefined, customerName ? ilike(users.name, `%${customerName}%`) : undefined));
  const [ordersCount] = await db3.select({ count: count() }).from(baseQuery.as("baseQuery"));
  const allOrders = await baseQuery.offset(pageIndex * 10).limit(10).orderBy((fields) => {
    return [
      sql2`CASE ${fields.status} 
            WHEN 'pending' THEN 1
            WHEN 'processing' THEN 2
            WHEN 'delivering' THEN 3
            WHEN 'delivered' THEN 4
            WHEN 'canceled' THEN 99
          END`,
      desc(fields.createdAt)
    ];
  });
  const result2 = {
    orders: allOrders,
    meta: {
      pageIndex,
      perPage: 10,
      totalCount: ordersCount.count
    }
  };
  return result2;
}, {
  query: export_t.Object({
    customerName: export_t.Optional(export_t.String()),
    orderId: export_t.Optional(export_t.String()),
    status: export_t.Optional(y(orders).properties.status),
    pageIndex: export_t.Numeric({ minimum: 0 })
  })
});

// src/http/routes/create-evaluation.ts
var createEvaluation = new I$().use(authentication).post("/evaluations", async ({ body, getCurrentUser, set }) => {
  const { sub: userId } = await getCurrentUser();
  const { restaurantId, rate, comment } = body;
  await db3.insert(evaluations).values({
    restaurantId,
    customerId: userId,
    rate,
    comment
  });
  set.status = 201;
}, {
  body: export_t.Object({
    restaurantId: export_t.String(),
    rate: export_t.Integer({ minimum: 1, maximum: 5 }),
    comment: export_t.Optional(export_t.String())
  })
});

// src/http/routes/get-evaluations.ts
var getEvaluations = new I$().use(authentication).get("/evaluations", async ({ query: query5, set, getCurrentUser }) => {
  const { restaurantId } = await getCurrentUser();
  if (!restaurantId) {
    set.status = 401;
    throw new Error("User is not a restaurant manager.");
  }
  const { pageIndex } = z.object({
    pageIndex: z.coerce.number().default(0)
  }).parse(query5);
  const evaluations3 = await db3.query.evaluations.findMany({
    offset: pageIndex * 10,
    limit: 10,
    orderBy: (evaluations4, { desc: desc2 }) => desc2(evaluations4.createdAt)
  });
  return evaluations3;
}, {
  query: export_t.Object({
    pageIndex: export_t.Numeric({ minimum: 0 })
  })
});

// src/http/routes/update-menu.ts
var productSchema = export_t.Object({
  id: export_t.Optional(export_t.String()),
  name: export_t.String(),
  description: export_t.Optional(export_t.String()),
  price: export_t.Number({ minimum: 0 })
});
var updateMenu = new I$().use(authentication).put("/menu", async ({ getManagedRestaurantId, set, body }) => {
  const restaurantId = await getManagedRestaurantId();
  const {
    products: { deletedProductIds, newOrUpdatedProducts }
  } = body;
  if (deletedProductIds.length > 0) {
    await db3.delete(products).where(and(inArray(products.id, deletedProductIds), eq(products.restaurantId, restaurantId)));
  }
  const updatedProducts = newOrUpdatedProducts.filter((product) => {
    return !!product.id;
  });
  if (updatedProducts.length > 0) {
    await Promise.all(updatedProducts.map((product) => {
      return db3.update(products).set({
        name: product.name,
        description: product.description,
        priceInCents: product.price * 100
      }).where(and(eq(products.id, product.id), eq(products.restaurantId, restaurantId)));
    }));
  }
  const newProducts = newOrUpdatedProducts.filter((product) => {
    return !product.id;
  });
  if (newProducts.length) {
    await db3.insert(products).values(newProducts.map((product) => {
      return {
        name: product.name,
        description: product.description,
        priceInCents: product.price * 100,
        restaurantId
      };
    }));
  }
  set.status = 204;
}, {
  body: export_t.Object({
    products: export_t.Object({
      newOrUpdatedProducts: export_t.Array(productSchema),
      deletedProductIds: export_t.Array(export_t.String())
    })
  })
});

// src/http/routes/update-profile.ts
var updateProfile = new I$().use(authentication).put("/profile", async ({ getManagedRestaurantId, set, body }) => {
  const restaurantId = await getManagedRestaurantId();
  const { name, description } = body;
  await db3.update(restaurants).set({
    name,
    description
  }).where(eq(restaurants.id, restaurantId));
  set.status = 204;
}, {
  body: export_t.Object({
    name: export_t.String(),
    description: export_t.Optional(export_t.String())
  })
});

// src/http/routes/get-profile.ts
var getProfile = new I$().use(authentication).get("/me", async ({ getCurrentUser }) => {
  const { sub: userId } = await getCurrentUser();
  const user = await db3.query.users.findFirst({
    where(fields, { eq: eq2 }) {
      return eq2(fields.id, userId);
    }
  });
  if (!user) {
    throw new Error("User not found.");
  }
  return user;
});

// src/http/routes/authenticate-from-link.ts
var import_dayjs = __toESM(require_dayjs_min(), 1);
var authenticateFromLink = new I$().use(authentication).get("/auth-links/authenticate", async ({ signUser, query: query5, set }) => {
  const { code, redirect } = query5;
  const authLinkFromCode = await db3.query.authLinks.findFirst({
    where(fields, { eq: eq2 }) {
      return eq2(fields.code, code);
    }
  });
  if (!authLinkFromCode) {
    throw new UnauthorizedError;
  }
  if (import_dayjs.default().diff(authLinkFromCode.createdAt, "days") > 7) {
    throw new UnauthorizedError;
  }
  const managedRestaurant = await db3.query.restaurants.findFirst({
    where(fields, { eq: eq2 }) {
      return eq2(fields.managerId, authLinkFromCode.userId);
    }
  });
  await signUser({
    sub: authLinkFromCode.userId,
    restaurantId: managedRestaurant?.id
  });
  await db3.delete(authLinks).where(eq(authLinks.code, code));
  set.redirect = redirect;
}, {
  query: export_t.Object({
    code: export_t.String(),
    redirect: export_t.String()
  })
});

// src/http/routes/get-managed-restaurant.ts
var getManagedRestaurant = new I$().use(authentication).get("/managed-restaurant", async ({ getManagedRestaurantId }) => {
  const restaurantId = await getManagedRestaurantId();
  const restaurant = await db3.query.restaurants.findFirst({
    where(fields, { eq: eq2 }) {
      return eq2(fields.id, restaurantId);
    }
  });
  if (!restaurant) {
    throw new Error("Restaurant not found.");
  }
  return restaurant;
});

// src/http/routes/sign-out.ts
var signOut = new I$().use(authentication).post("/sign-out", async ({ signOut: signOut2 }) => {
  signOut2();
});

// src/http/routes/get-order-details.ts
var getOrderDetails = new I$().use(authentication).get("/orders/:id", async ({ getCurrentUser, params }) => {
  const { id: orderId } = params;
  const { restaurantId } = await getCurrentUser();
  if (!restaurantId) {
    throw new NotAManagerError;
  }
  const order = await db3.query.orders.findFirst({
    columns: {
      id: true,
      createdAt: true,
      status: true,
      totalInCents: true
    },
    with: {
      customer: {
        columns: {
          name: true,
          phone: true,
          email: true
        }
      },
      orderItems: {
        columns: {
          id: true,
          priceInCents: true,
          quantity: true
        },
        with: {
          product: {
            columns: {
              name: true
            }
          }
        }
      }
    },
    where(fields, { eq: eq2, and: and2 }) {
      return and2(eq2(fields.id, orderId), eq2(fields.restaurantId, restaurantId));
    }
  });
  if (!order) {
    throw new UnauthorizedError;
  }
  return order;
}, {
  params: export_t.Object({
    id: export_t.String()
  })
});

// src/http/routes/get-month-receipt.ts
var import_dayjs2 = __toESM(require_dayjs_min(), 1);
var getMonthReceipt = new I$().use(authentication).get("/metrics/month-receipt", async ({ getManagedRestaurantId }) => {
  const restaurantId = await getManagedRestaurantId();
  const today = import_dayjs2.default();
  const lastMonth = today.subtract(1, "month");
  const startOfLastMonth = lastMonth.startOf("month");
  const lastMonthWithYear = lastMonth.format("YYYY-MM");
  const currentMonthWithYear = today.format("YYYY-MM");
  const monthsReceipts = await db3.select({
    monthWithYear: sql2`TO_CHAR(${orders.createdAt}, 'YYYY-MM')`,
    receipt: sum(orders.totalInCents).mapWith(Number)
  }).from(orders).where(and(eq(orders.restaurantId, restaurantId), gte(orders.createdAt, startOfLastMonth.toDate()))).groupBy(sql2`TO_CHAR(${orders.createdAt}, 'YYYY-MM')`).having(({ receipt }) => gte(receipt, 1));
  const currentMonthReceipt = monthsReceipts.find((monthReceipt) => {
    return monthReceipt.monthWithYear === currentMonthWithYear;
  });
  const lastMonthReceipt = monthsReceipts.find((monthReceipt) => {
    return monthReceipt.monthWithYear === lastMonthWithYear;
  });
  const diffFromLastMonth = lastMonthReceipt && currentMonthReceipt ? currentMonthReceipt.receipt * 100 / lastMonthReceipt.receipt : null;
  return {
    receipt: currentMonthReceipt?.receipt ?? 0,
    diffFromLastMonth: diffFromLastMonth ? Number((diffFromLastMonth - 100).toFixed(2)) : 0
  };
});

// src/http/routes/get-month-orders-amount.ts
var import_dayjs3 = __toESM(require_dayjs_min(), 1);
var getMonthOrdersAmount = new I$().use(authentication).get("/metrics/month-orders-amount", async ({ getManagedRestaurantId }) => {
  const restaurantId = await getManagedRestaurantId();
  const today = import_dayjs3.default();
  const lastMonth = today.subtract(1, "month");
  const startOfLastMonth = lastMonth.startOf("month");
  const lastMonthWithYear = lastMonth.format("YYYY-MM");
  const currentMonthWithYear = today.format("YYYY-MM");
  const ordersPerMonth = await db3.select({
    monthWithYear: sql2`TO_CHAR(${orders.createdAt}, 'YYYY-MM')`,
    amount: count(orders.id)
  }).from(orders).where(and(eq(orders.restaurantId, restaurantId), gte(orders.createdAt, startOfLastMonth.toDate()))).groupBy(sql2`TO_CHAR(${orders.createdAt}, 'YYYY-MM')`).having(({ amount }) => gte(amount, 1));
  const currentMonthOrdersAmount = ordersPerMonth.find((ordersInMonth) => {
    return ordersInMonth.monthWithYear === currentMonthWithYear;
  });
  const lastMonthOrdersAmount = ordersPerMonth.find((ordersInMonth) => {
    return ordersInMonth.monthWithYear === lastMonthWithYear;
  });
  const diffFromLastMonth = lastMonthOrdersAmount && currentMonthOrdersAmount ? currentMonthOrdersAmount.amount * 100 / lastMonthOrdersAmount.amount : null;
  return {
    amount: currentMonthOrdersAmount?.amount ?? 0,
    diffFromLastMonth: diffFromLastMonth ? Number((diffFromLastMonth - 100).toFixed(2)) : 0
  };
});

// src/http/routes/get-day-orders-amount.ts
var import_dayjs4 = __toESM(require_dayjs_min(), 1);
var getDayOrdersAmount = new I$().use(authentication).get("/metrics/day-orders-amount", async ({ getManagedRestaurantId }) => {
  const restaurantId = await getManagedRestaurantId();
  const today = import_dayjs4.default();
  const yesterday = today.subtract(1, "day");
  const startOfYesterday = yesterday.startOf("day");
  const yesterdayWithMonthAndYear = yesterday.format("YYYY-MM-DD");
  const todayWithMonthAndYear = today.format("YYYY-MM-DD");
  const ordersPerDay = await db3.select({
    dayWithMonthAndYear: sql2`TO_CHAR(${orders.createdAt}, 'YYYY-MM-DD')`,
    amount: count(orders.id)
  }).from(orders).where(and(eq(orders.restaurantId, restaurantId), gte(orders.createdAt, startOfYesterday.toDate()))).groupBy(sql2`TO_CHAR(${orders.createdAt}, 'YYYY-MM-DD')`).having(({ amount }) => gte(amount, 1));
  const todayOrdersAmount = ordersPerDay.find((orderInDay) => {
    return orderInDay.dayWithMonthAndYear === todayWithMonthAndYear;
  });
  const yesterdayOrdersAmount = ordersPerDay.find((orderInDay) => {
    return orderInDay.dayWithMonthAndYear === yesterdayWithMonthAndYear;
  });
  const diffFromYesterday = yesterdayOrdersAmount && todayOrdersAmount ? todayOrdersAmount.amount * 100 / yesterdayOrdersAmount.amount : null;
  return {
    amount: todayOrdersAmount?.amount ?? 0,
    diffFromYesterday: diffFromYesterday ? Number((diffFromYesterday - 100).toFixed(2)) : 0
  };
});

// src/http/routes/get-month-canceled-orders-amount.ts
var import_dayjs5 = __toESM(require_dayjs_min(), 1);
var getMonthCanceledOrdersAmount = new I$().use(authentication).get("/metrics/month-canceled-orders-amount", async ({ getManagedRestaurantId }) => {
  const restaurantId = await getManagedRestaurantId();
  const today = import_dayjs5.default();
  const lastMonth = today.subtract(1, "month");
  const startOfLastMonth = lastMonth.startOf("month");
  const lastMonthWithYear = lastMonth.format("YYYY-MM");
  const currentMonthWithYear = today.format("YYYY-MM");
  const ordersPerMonth = await db3.select({
    monthWithYear: sql2`TO_CHAR(${orders.createdAt}, 'YYYY-MM')`,
    amount: count(orders.id)
  }).from(orders).where(and(eq(orders.restaurantId, restaurantId), eq(orders.status, "canceled"), gte(orders.createdAt, startOfLastMonth.toDate()))).groupBy(sql2`TO_CHAR(${orders.createdAt}, 'YYYY-MM')`).having(({ amount }) => gte(amount, 1));
  const currentMonthOrdersAmount = ordersPerMonth.find((ordersInMonth) => {
    return ordersInMonth.monthWithYear === currentMonthWithYear;
  });
  const lastMonthOrdersAmount = ordersPerMonth.find((ordersInMonth) => {
    return ordersInMonth.monthWithYear === lastMonthWithYear;
  });
  const diffFromLastMonth = lastMonthOrdersAmount && currentMonthOrdersAmount ? currentMonthOrdersAmount.amount * 100 / lastMonthOrdersAmount.amount : null;
  return {
    amount: currentMonthOrdersAmount?.amount ?? 0,
    diffFromLastMonth: diffFromLastMonth ? Number((diffFromLastMonth - 100).toFixed(2)) : 0
  };
});

// src/http/routes/get-daily-receipt-in-period.ts
var import_dayjs6 = __toESM(require_dayjs_min(), 1);
var getDailyReceiptInPeriod = new I$().use(authentication).get("/metrics/daily-receipt-in-period", async ({ getManagedRestaurantId, query: query5, set }) => {
  const restaurantId = await getManagedRestaurantId();
  const { from, to } = query5;
  const startDate = from ? import_dayjs6.default(from) : import_dayjs6.default().subtract(7, "d");
  const endDate = to ? import_dayjs6.default(to) : from ? startDate.add(7, "days") : import_dayjs6.default();
  if (endDate.diff(startDate, "days") > 7) {
    set.status = 400;
    return {
      code: "INVALID_PERIOD",
      message: "O intervalo das datas n\xE3o pode ser superior a 7 dias."
    };
  }
  const receiptPerDay = await db3.select({
    date: sql2`TO_CHAR(${orders.createdAt}, 'DD/MM')`,
    receipt: sum(orders.totalInCents).mapWith(Number)
  }).from(orders).where(and(eq(orders.restaurantId, restaurantId), gte(orders.createdAt, startDate.startOf("day").add(startDate.utcOffset(), "minutes").toDate()), lte(orders.createdAt, endDate.endOf("day").add(endDate.utcOffset(), "minutes").toDate()))).groupBy(sql2`TO_CHAR(${orders.createdAt}, 'DD/MM')`).having(({ receipt }) => gte(receipt, 1));
  const orderedReceiptPerDay = receiptPerDay.sort((a, b3) => {
    const [dayA, monthA] = a.date.split("/").map(Number);
    const [dayB, monthB] = b3.date.split("/").map(Number);
    if (monthA === monthB) {
      return dayA - dayB;
    } else {
      const dateA = new Date(2023, monthA - 1);
      const dateB = new Date(2023, monthB - 1);
      return dateA.getTime() - dateB.getTime();
    }
  });
  return orderedReceiptPerDay;
}, {
  query: export_t.Object({
    from: export_t.Optional(export_t.String()),
    to: export_t.Optional(export_t.String())
  })
});

// src/http/routes/get-popular-products.ts
var getPopularProducts = new I$().use(authentication).get("/metrics/popular-products", async ({ getManagedRestaurantId }) => {
  const restaurantId = await getManagedRestaurantId();
  try {
    const popularProducts = await db3.select({
      product: products.name,
      amount: count(orderItems.id)
    }).from(orderItems).leftJoin(orders, eq(orders.id, orderItems.orderId)).leftJoin(products, eq(products.id, orderItems.productId)).where(and(eq(orders.restaurantId, restaurantId))).groupBy(products.name).limit(5);
    return popularProducts;
  } catch (err) {
    console.log(err);
  }
});

// src/http/routes/dispatch-order.ts
var dispatchOrder = new I$().use(authentication).patch("/orders/:id/dispatch", async ({ getManagedRestaurantId, set, params }) => {
  const { id: orderId } = params;
  const restaurantId = await getManagedRestaurantId();
  const order = await db3.query.orders.findFirst({
    where(fields, { eq: eq2, and: and2 }) {
      return and2(eq2(fields.id, orderId), eq2(fields.restaurantId, restaurantId));
    }
  });
  if (!order) {
    throw new UnauthorizedError;
  }
  if (order.status !== "processing") {
    set.status = 400;
    return { message: "O pedido j\xE1 foi enviado ao cliente." };
  }
  await db3.update(orders).set({
    status: "delivering"
  }).where(eq(orders.id, orderId));
  set.status = 204;
}, {
  params: export_t.Object({
    id: export_t.String()
  })
});

// src/http/routes/deliver-order.ts
var deliverOrder = new I$().use(authentication).patch("/orders/:id/deliver", async ({ getManagedRestaurantId, set, params }) => {
  const { id: orderId } = params;
  const restaurantId = await getManagedRestaurantId();
  const order = await db3.query.orders.findFirst({
    where(fields, { eq: eq2, and: and2 }) {
      return and2(eq2(fields.id, orderId), eq2(fields.restaurantId, restaurantId));
    }
  });
  if (!order) {
    throw new UnauthorizedError;
  }
  if (order.status !== "delivering") {
    set.status = 400;
    return { message: "O pedido j\xE1 foi entregue." };
  }
  await db3.update(orders).set({
    status: "delivered"
  }).where(eq(orders.id, orderId));
  set.status = 204;
}, {
  params: export_t.Object({
    id: export_t.String()
  })
});

// src/http/server.ts
var app = new I$().use(cors({
  credentials: true,
  allowedHeaders: ["content-type"],
  methods: ["GET", "POST", "PUT", "DELETE", "PATCH", "HEAD", "OPTIONS"],
  origin: (request) => {
    const origin = request.headers.get("origin");
    if (!origin) {
      return false;
    }
    return true;
  }
})).use(authentication).use(signOut).use(getProfile).use(getManagedRestaurant).use(registerRestaurant).use(registerCustomer).use(sendAuthenticationLink).use(authenticateFromLink).use(createOrder).use(approveOrder).use(cancelOrder).use(dispatchOrder).use(deliverOrder).use(getOrders).use(getOrderDetails).use(createEvaluation).use(getEvaluations).use(updateMenu).use(updateProfile).use(getMonthReceipt).use(getMonthOrdersAmount).use(getDayOrdersAmount).use(getMonthCanceledOrdersAmount).use(getDailyReceiptInPeriod).use(getPopularProducts).onError(({ code, error, set }) => {
  switch (code) {
    case "VALIDATION": {
      set.status = error.status;
      return error.toResponse();
    }
    case "NOT_FOUND": {
      return new Response(null, { status: 404 });
    }
    default: {
      console.error(error);
      return new Response(null, { status: 500 });
    }
  }
});
app.listen(3333);
console.log(`\uD83D\uDD25 HTTP server running at ${app.server?.hostname}:${app.server?.port}`);
